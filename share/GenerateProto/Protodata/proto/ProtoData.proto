syntax = "proto2";
package fantasybit;
import "StaticData.proto";
import "StatusData.proto";
import "ExData.proto";
enum MyNameStatus
{
    none=1;
    notavil=2;
    requested=5;
    transaction_sent=15;
    confirmed=20;
}

message MyFantasyName
{
    optional string name=1;
    optional MyNameStatus status=2;
}

message FantasyPlayer {
    optional string name = 10;
    optional uint64 bits = 20;
}

message Secret
{
    required string private_key = 1;
    optional MyFantasyName myfantasyname=2;
    optional NameTrans nametran = 10;
}

message Secret2
{
    optional string private_key = 1;
    optional string fantasy_name = 20;
    optional string public_key = 30;
}

message Secret3
{
    optional string private_key = 1;
    optional string mnemonic_key = 3;
    optional string fantasy_name = 20;
    optional string public_key = 30;
}


message OutData {
    enum Type { MYFANTASYNAME = 1; SNAPSHOT = 2; HEARTBEAT=3; }
    required Type type = 1;

    optional MyFantasyName myfantasyname = 2;
    extensions 100 to max;
}

// Elsewhere...
//extend OutData {
//	optional int32 test = 100;
//}

message InData {
    enum Type { MINENAME = 1; QUIT=2; HEARTBEAT=3; CONNECT=4; MAKE_BLOCK=5; NEWNAME=6; PROJ=7;DATA=8;}
    required Type type = 1;

    optional string data = 2;
    optional string data2 = 3;
    optional int32 num = 4;
        optional DataTransition data_trans=5;
    extensions 100 to max;
}

// Elsewhere...
//extend InData {
//	optional int32 test = 100;
//}


message NameProof
{
        enum Type { POW=1; TWEET=2; ORACLE=3; MASTER=4; }
    optional Type type = 1;
    extensions 200 to max;
}

message TweetProof
{
    extend NameProof {
        optional TweetProof tweet_proof = 201;
    }

    optional string tweet = 10;
}

message MasterProof {
    extend NameProof {
            optional MasterProof  master_proof = 401;
    }

    optional string season = 10;
    optional int32 week = 20;
    optional int32 timestamp = 21;
    optional SignedTransaction new_oracle_name =66;
}

enum TransType {
    NAME = 0;
    PROJECTION = 1;
    RESULT = 2;
    DATA = 3;
    PROJECTION_BLOCK = 4;
    MASTER_NAME = 5;
    TIME = 6;
    STAMPED = 7;
    EXCHANGE = 8;
    EXCHANGE_BLOCK = 9;
    TRANSFER = 10;
    SWAPASK = 11;
    SWAPBID = 12;
    SWAPFIL = 13;
    SWAPSENT = 14;
    PODP = 15;
    SWAPSENTACK = 16;
}

message Transaction {
    optional int32 version = 1;
    optional TransType type = 2;
    optional uint64 nonce = 10;  //required since version 4
    extensions 100 to max;
}

message NameTrans {
    extend Transaction {
        optional NameTrans name_trans = 200;
    }

    optional string fantasy_name = 10;
    optional bytes public_key=20;
    optional NameProof proof = 30;
    optional bytes recovery_key=40;
    optional bool am_agent = 50;
    optional string my_agent = 60;

}

// Units
//
// Point            100 = Fantasypoint   =         100 Fantasybit
// Coin               1 = Fantasybitcoin =           1 Fantasybit
// Cent            0.01 = Fantasycent    =         100 Fantasybit
// Yard           0.001 = Fantasyyard    =       1,000 Fantasybit
// Hash        0.000001 = Fantasyhash    =   1,000,000 Fantasybit
// Satoshi   0.00000001 = Fantasysatoshi = 100,000,000 Fantasybit

message TransferTrans {
    extend Transaction {
        optional TransferTrans transfer_tran = 400;
    }

    optional string from = 10;
    optional string to = 20;
    optional uint64 amount = 30;  //fantasysatoshi
}

message SignedTransaction {
    optional Transaction trans = 10;
    optional bytes id = 20;
    optional bytes sig = 30;
    optional string fantasy_name = 40;
}

//message BlockHeader {
//	optional int32 num = 10;
//	optional bytes prev_id = 20;
//}

message BlockHeader {
        enum Type { NORMAL=1; DATA=2; }

    optional int32 version = 1;
    optional int32 num = 10;
    optional bytes prev_id = 20;
    optional int32 timestamp = 21;
    optional bytes generator_pk=30;
    optional bytes generating_sig=40; //hash(prev(generating_sig) + generator_pk)
    optional uint64 basetarget=50;
    optional Type blocktype = 60;
    optional bytes transaction_id = 70;
}

message SignedBlockHeader {
    optional BlockHeader head = 10;
    optional string sig = 30;
}

message Block {
    optional SignedBlockHeader signedhead = 10;
    repeated SignedTransaction signed_transactions = 20;


    extensions 1000 to max;
}

message NodeRequest
{
    enum Type { HANDSHAKE=1; BLOCK_REQUEST=2; HIGHT_REQUEST=3; NAT_TEST=4;}
    optional Type type = 10;
    optional string myip=20;
    optional int32 num=30;
    optional string myhost=40;
}

message NodeReply
{
    optional int32 hight=10;
    repeated string ips=20;
}

////////////////////////////////////////////////////////////
// FantasyPlayerPoints used for projections and results   //
// does not contain team                                  //
// player + week is enough                                //
////////////////////////////////////////////////////////////
message FantasyPlayerPoints {
    optional uint32 season = 10;
    optional uint32 week = 20;
    optional string playerid = 30;
        optional int32 points = 40;
        optional float result = 50;
}

////////////////////////////////////////////////////////////
// ProjectionTrans used to make projections
////////////////////////////////////////////////////////////
message ProjectionTrans {
    extend Transaction {
        optional ProjectionTrans proj_trans = 201;
    }

    optional uint32 season = 10;
    optional uint32 week = 20;
    optional string playerid = 30;
    optional int32 points = 40;
}

message PlayerPoints {
    optional string playerid = 30;
    optional int32 points = 40;
}

message ProjectionTransBlock {
    extend Transaction {
        optional ProjectionTransBlock proj_trans_block = 211;
    }

    optional uint32 season = 10;
    optional uint32 week = 20;
    repeated PlayerPoints player_points = 30;
}



message Data {
    enum Type {
        SCHEDULE = 0;
        PLAYER = 1;
        GAME = 2;
        RESULT = 3;
        MESSAGE = 4;
    }

    optional int32 version = 10;
    optional Type type = 20;

    extensions 100 to max;
}


message PlayerData {
    extend Data {
        optional PlayerData player_data = 101;
    }

    optional string playerid = 10;
    optional PlayerBase player_base = 20;
    optional PlayerStatus player_status = 30;
    optional PlayerGameStatus player_game_status = 40;
}

message GameData {
    extend Data {
        optional GameData game_data = 111;
    }

    optional string gameid=10;
    optional GameStatus status=20;
}

message ResultData {
    extend Data {
        optional ResultData result_data = 202;
    }

    optional GameResult game_result = 10;
}

message ScheduleData {
    extend Data {
        optional ScheduleData schedule_data = 302;
    }

    optional int32 week = 1;
    optional WeeklySchedule weekly = 10;
}

enum TrType {
    SEASONSTART=2; // before week1 - week1 projection can start
    SEASONEND=3; //after last week of season
    HEARTBEAT=5; //anytime
    GAMESTART=6; //list of teamids to cut off projections for week
    WEEKOVER=7; //clear all projections
    TRADESESSIONSTART=8;
    TRADESESSIONCLOSEANDPREOPEN=9;
    PLAYOFFSTART=10; //LISTOFPLAYOFFTEAMS
    SUPERBOWLEND=12;
}

message DataTransition {
    extend Transaction {
        optional DataTransition data_trans = 203;
    }


    optional TrType type =1;
    optional uint32 season =10;
    optional uint32 week = 20;
    repeated GameData gamedata = 30;
    repeated Data data = 40;
}

message TeamState {
    enum State {
        PREGAME = 1;
        INGAME = 2;
    }

    optional State state =1;
    optional uint32 week =10;
    optional string teamid = 20;
}

message DeltaData {
    enum Type { SNAPSHOT = 2; HEARTBEAT=3; }
    optional Type type=1;
    repeated MyFantasyName myfantasyname = 2;
    optional GlobalState globalstate = 10;
    repeated TeamState teamstates = 20;
    repeated Data datas = 30;
    repeated FantasyPlayer players = 40;

    extensions 1000 to max;
}

message MessageData {
    extend Data {
        optional MessageData message_data = 404;
    }

    optional string msg = 10;
    optional int32 gt  = 20;
    optional int32 lt = 30;
}


message StampedTrans {
    extend Transaction {
        optional StampedTrans stamped_trans = 300;
    }

    optional uint64 timestamp = 10;
    optional int32 seqnum = 20;
    optional int32 prevseq  = 21;
    optional SignedTransaction signed_orig = 30;
}

message ExchangeOrder {
    extend Transaction {
        optional ExchangeOrder exchange_order = 310;
    }

    enum Type { NEW=1; CANCEL=2; REPLACE=3; }

    optional Type type = 10;
    optional string playerid = 40;
    optional OrderCore core = 50;
    optional int32 cancel_oref = 100;
    optional FutContract futcontract = 110;
    optional string symbol = 120;
    extensions 500 to max;
}

message OrderUnique {
    optional string public_key = 10;
    optional uint32 season =20;
    optional uint32 week = 30;
    optional bool buyside = 40;
    optional string playerid = 50;
    optional int32 price = 70;
}

message OrderDeets {
    optional bytes oid = 10;
    optional OrderUnique order = 20;
    optional int32 size  = 30;
}

message InsideUnique {
    optional string playerid = 50;
    optional string public_key = 10;
    optional bool buyside = 40;
    optional int32 price = 70;

    optional bytes oid = 11;
    optional OrderUnique order = 20;
    optional int32 size  = 30;
}


message TimeTransition {
    extend Transaction {
        optional TimeTransition time_trans = 303;
    }

    enum Type {
        TRADEOPEN=2; // trading session opened
        TRADECLOSE=3; // trading session closed
    }

    optional Type type =1;
    optional uint32 season =10;
    optional uint32 week = 20;
}


// Step 0: BOB says I want to offer 1000 FB for Btcoin
// at a rate of .00001 BTC per FB
// 1000 SAT per FB
// so bob wants .01 BTC (1,000,000 SAT) for 1000 FB
// lock 1000 FB


// Step 1: Alice says I will SWAP .01 BTC for 1000 FB with BOB
// to  1000 SAT per FB for 1000
// and Here is by Bitcoin UTXOs that I will use


// Step 2: Bob says here sign this hash and you get my 1000 FB
//  1 - create a bitcoin transaction
//      tells system that if Alice signs this tx - send he FB


// Step 3: Alice sends message with signature to Protoblock blockchain
//     by consensus 1000 FB are now transfered from BOB to alice

// Step 4: Bob takes signature creates a complete bitcoin tx - sends it to bitcoin
// Alt Step 4: Alice sens tx to bitcoin
// * FB are locked for 48 hours

// Step 5 good: Bob say - all good unlock
// Step 5 bad: Bob provides Proof Of Double Spend within 48 hours



//  2. alices send bitcoin - and shows signed hash

// 4. proof of doube spend

// protoc --cpp_out d:/work/protoblock-open/share/generated --proto_path d:/work/protoblock-open/share/GenerateProto/Protodata/proto/ d:/work/protoblock-open/share/GenerateProto/Protodata/proto/ProtoData.proto

// 100,000,000 satoshi per Bitcoin
// 20 BTC = 1,000,000,000

// JayToDo: cancel?

message Bitcoin_UTXO {
    optional bytes txid = 10;
    optional uint32 tx_output_n = 20; //output number
    optional uint64 in_value = 30;
    optional bytes locking_script = 40; // PubkeyScript
}

message Bitcoin_UTXOS {
    optional uint64 total_value = 10;
    repeated Bitcoin_UTXO utxo = 20;
}

//Bob broadcast intent to sell Fantasybit
message SwapAsk {
    extend Transaction {
        optional SwapAsk swapask_tran = 450;
    }

    optional uint64 satoshi_min = 10;
    optional uint64 satoshi_max = 11;
    optional uint64 rate = 20; //satoshis per fb
    optional uint64 fb_qty = 30;

}

//Alice has bitcoin - wants fantasybit
message SwapBid {
    extend Transaction {
        optional SwapBid swapbid_tran = 500;
    }

    optional uint64 satoshi_min = 10;
    optional uint64 satoshi_max = 11;
    optional uint64 rate = 20; //satoshis per fb
    optional Bitcoin_UTXOS utxos = 30;
    optional bytes change_addr = 40;

    optional SwapAsk this_offer = 50;
    optional string counteroffer = 60;

}

//Bob has fantasybit - wants bitcoin
message SwapFill {
    extend Transaction {
        optional SwapFill swapfil_tran = 600;
    }

    optional SwapBid swapbid = 10;
    optional bytes hash_to_sign = 20;
    optional uint64 satoshi_fee = 30;
    optional uint64 fb_qty = 40;
    optional string counterparty = 50;

    //actual bitcoin tx structure○
}

//Proves Alice paid bob - system sends alice FB (locked for 48 hours)
message SwapSent {
    extend Transaction {
        optional SwapSent swapsent_tran = 700;
    }

    optional SwapFill swapfill = 10;
    optional bytes sig = 20;
}

//Proof of Double Spend (gives FB back to Bob)
message ProofOfDoubleSpend {
    extend Transaction {
        optional ProofOfDoubleSpend podp_tran = 800;
    }

    optional SwapSent swapsent = 10;
    optional Bitcoin_UTXO utxo = 20;
    optional bytes pre = 30;
    optional bytes post = 40;
    optional bytes sig = 50;
}

//bob ACK swapsent - dont wait x hous to relese fantasybit
message SwapSentAck {
    extend Transaction {
        optional SwapSentAck swapsentack_tran = 810;
    }

    optional SwapSent swapsent = 10;
}
