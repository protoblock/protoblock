// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: StateData.proto

#ifndef PROTOBUF_StateData_2eproto__INCLUDED
#define PROTOBUF_StateData_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "ProtoData.pb.h"
#include "NameData.pb.h"
#include "StaticData.pb.h"
#include "StatusData.pb.h"
#include "ExData.pb.h"
// @@protoc_insertion_point(includes)

namespace fantasybit {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_StateData_2eproto();
void protobuf_AssignDesc_StateData_2eproto();
void protobuf_ShutdownFile_StateData_2eproto();

class BlockMeta;
class TxMeta;
class TrMeta;
class GameMeta;
class DataMeta;
class LeaderBoardMeta;
class FantasyNameBalMeta;
class FantasyNameState;
class WeekGameStatusMeta;
class InGameProjMeta;
class GameResultsMeta;
class GameStatusMeta;
class TeamProjMeta;
class TeamResultMeta;
class GamePlayerProjMeta;
class ProjMeta;
class PosMeta;
class PlayerResultMeta;
class PlayerGameStats;
class AwardMeta;
class PnlMeta;
class PlayerMarketState;
class LimitBookMeta;
class MarketTicMeta;
class OrderMeta;
class OrderFillMeta;
class GlobalStateMeta;
class PlayerMeta;
class TeamMeta;
class pbstate;
class MerkleTree;
class NewPlayerModel;
class WsReq;
class WSReply;
class GetGlobalStateRep;
class GetScheduleRep;
class CheckNameReq;
class CheckNameRep;
class Pk2FnameReq;
class Pk2FnameRep;
class SubscribeReq;
class NameStatusReq;
class NameStatusRep;
class GetAllNamesRep;
class TeamRoster;
class GameDataRoster;
class GetCurrRostersRep;
class ROWMarket;
class GetROWMarketRep;
class GetDepthReq;
class GetDepthRep;
class AllOdersSymbol;
class AllOdersFname;
class GetOrdersRep;
class GetOrdersReq;
class GetProjectionReq;
class PlayerProj;
class ProjByName;
class GetProjectionRep;
class KeyValue;
class Bootstrap;

enum CType {
  NONE = 0,
  CHECKNAME = 1,
  NEWTX = 2,
  PK2FNAME = 3,
  GETSTATUS = 4,
  GETALLNAMES = 5,
  GETROWMARKET = 6,
  GETDEPTH = 7,
  GETORDERS = 8,
  GETPOSITIONS = 9,
  SUBSCRIBEFNAME = 10,
  GETGLOBALSTATE = 11,
  GETSCHEDULE = 12,
  GETGAMEROSTER = 13,
  GETPROJECTIONS = 15,
  GETGAMESTART = 16
};
bool CType_IsValid(int value);
const CType CType_MIN = NONE;
const CType CType_MAX = GETGAMESTART;
const int CType_ARRAYSIZE = CType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CType_descriptor();
inline const ::std::string& CType_Name(CType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CType_descriptor(), value);
}
inline bool CType_Parse(
    const ::std::string& name, CType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CType>(
    CType_descriptor(), name, value);
}
// ===================================================================

class BlockMeta : public ::google::protobuf::Message {
 public:
  BlockMeta();
  virtual ~BlockMeta();

  BlockMeta(const BlockMeta& from);

  inline BlockMeta& operator=(const BlockMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlockMeta& default_instance();

  void Swap(BlockMeta* other);

  // implements Message ----------------------------------------------

  BlockMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlockMeta& from);
  void MergeFrom(const BlockMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 blocknum = 40;
  inline bool has_blocknum() const;
  inline void clear_blocknum();
  static const int kBlocknumFieldNumber = 40;
  inline ::google::protobuf::int32 blocknum() const;
  inline void set_blocknum(::google::protobuf::int32 value);

  // optional bytes trmetaid = 50;
  inline bool has_trmetaid() const;
  inline void clear_trmetaid();
  static const int kTrmetaidFieldNumber = 50;
  inline const ::std::string& trmetaid() const;
  inline void set_trmetaid(const ::std::string& value);
  inline void set_trmetaid(const char* value);
  inline void set_trmetaid(const void* value, size_t size);
  inline ::std::string* mutable_trmetaid();
  inline ::std::string* release_trmetaid();
  inline void set_allocated_trmetaid(::std::string* trmetaid);

  // optional bytes txmetaroot = 10;
  inline bool has_txmetaroot() const;
  inline void clear_txmetaroot();
  static const int kTxmetarootFieldNumber = 10;
  inline const ::std::string& txmetaroot() const;
  inline void set_txmetaroot(const ::std::string& value);
  inline void set_txmetaroot(const char* value);
  inline void set_txmetaroot(const void* value, size_t size);
  inline ::std::string* mutable_txmetaroot();
  inline ::std::string* release_txmetaroot();
  inline void set_allocated_txmetaroot(::std::string* txmetaroot);

  // optional bytes pbstateid = 60;
  inline bool has_pbstateid() const;
  inline void clear_pbstateid();
  static const int kPbstateidFieldNumber = 60;
  inline const ::std::string& pbstateid() const;
  inline void set_pbstateid(const ::std::string& value);
  inline void set_pbstateid(const char* value);
  inline void set_pbstateid(const void* value, size_t size);
  inline ::std::string* mutable_pbstateid();
  inline ::std::string* release_pbstateid();
  inline void set_allocated_pbstateid(::std::string* pbstateid);

  // optional bytes prev = 20;
  inline bool has_prev() const;
  inline void clear_prev();
  static const int kPrevFieldNumber = 20;
  inline const ::std::string& prev() const;
  inline void set_prev(const ::std::string& value);
  inline void set_prev(const char* value);
  inline void set_prev(const void* value, size_t size);
  inline ::std::string* mutable_prev();
  inline ::std::string* release_prev();
  inline void set_allocated_prev(::std::string* prev);

  // optional bytes next = 30;
  inline bool has_next() const;
  inline void clear_next();
  static const int kNextFieldNumber = 30;
  inline const ::std::string& next() const;
  inline void set_next(const ::std::string& value);
  inline void set_next(const char* value);
  inline void set_next(const void* value, size_t size);
  inline ::std::string* mutable_next();
  inline ::std::string* release_next();
  inline void set_allocated_next(::std::string* next);

  // @@protoc_insertion_point(class_scope:fantasybit.BlockMeta)
 private:
  inline void set_has_blocknum();
  inline void clear_has_blocknum();
  inline void set_has_trmetaid();
  inline void clear_has_trmetaid();
  inline void set_has_txmetaroot();
  inline void clear_has_txmetaroot();
  inline void set_has_pbstateid();
  inline void clear_has_pbstateid();
  inline void set_has_prev();
  inline void clear_has_prev();
  inline void set_has_next();
  inline void clear_has_next();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* trmetaid_;
  ::std::string* txmetaroot_;
  ::std::string* pbstateid_;
  ::std::string* prev_;
  ::std::string* next_;
  ::google::protobuf::int32 blocknum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static BlockMeta* default_instance_;
};
// -------------------------------------------------------------------

class TxMeta : public ::google::protobuf::Message {
 public:
  TxMeta();
  virtual ~TxMeta();

  TxMeta(const TxMeta& from);

  inline TxMeta& operator=(const TxMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TxMeta& default_instance();

  void Swap(TxMeta* other);

  // implements Message ----------------------------------------------

  TxMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TxMeta& from);
  void MergeFrom(const TxMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 blocknum = 10;
  inline bool has_blocknum() const;
  inline void clear_blocknum();
  static const int kBlocknumFieldNumber = 10;
  inline ::google::protobuf::int32 blocknum() const;
  inline void set_blocknum(::google::protobuf::int32 value);

  // optional int32 txnum = 20;
  inline bool has_txnum() const;
  inline void clear_txnum();
  static const int kTxnumFieldNumber = 20;
  inline ::google::protobuf::int32 txnum() const;
  inline void set_txnum(::google::protobuf::int32 value);

  // optional .fantasybit.TransType txtype = 40;
  inline bool has_txtype() const;
  inline void clear_txtype();
  static const int kTxtypeFieldNumber = 40;
  inline ::fantasybit::TransType txtype() const;
  inline void set_txtype(::fantasybit::TransType value);

  // optional .fantasybit.Transaction tx = 50;
  inline bool has_tx() const;
  inline void clear_tx();
  static const int kTxFieldNumber = 50;
  inline const ::fantasybit::Transaction& tx() const;
  inline ::fantasybit::Transaction* mutable_tx();
  inline ::fantasybit::Transaction* release_tx();
  inline void set_allocated_tx(::fantasybit::Transaction* tx);

  // optional string fantasy_name = 60;
  inline bool has_fantasy_name() const;
  inline void clear_fantasy_name();
  static const int kFantasyNameFieldNumber = 60;
  inline const ::std::string& fantasy_name() const;
  inline void set_fantasy_name(const ::std::string& value);
  inline void set_fantasy_name(const char* value);
  inline void set_fantasy_name(const char* value, size_t size);
  inline ::std::string* mutable_fantasy_name();
  inline ::std::string* release_fantasy_name();
  inline void set_allocated_fantasy_name(::std::string* fantasy_name);

  // optional bytes id = 70;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 70;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const void* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:fantasybit.TxMeta)
 private:
  inline void set_has_blocknum();
  inline void clear_has_blocknum();
  inline void set_has_txnum();
  inline void clear_has_txnum();
  inline void set_has_txtype();
  inline void clear_has_txtype();
  inline void set_has_tx();
  inline void clear_has_tx();
  inline void set_has_fantasy_name();
  inline void clear_has_fantasy_name();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 blocknum_;
  ::google::protobuf::int32 txnum_;
  ::fantasybit::Transaction* tx_;
  ::std::string* fantasy_name_;
  ::std::string* id_;
  int txtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static TxMeta* default_instance_;
};
// -------------------------------------------------------------------

class TrMeta : public ::google::protobuf::Message {
 public:
  TrMeta();
  virtual ~TrMeta();

  TrMeta(const TrMeta& from);

  inline TrMeta& operator=(const TrMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrMeta& default_instance();

  void Swap(TrMeta* other);

  // implements Message ----------------------------------------------

  TrMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TrMeta& from);
  void MergeFrom(const TrMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 blocknum = 10;
  inline bool has_blocknum() const;
  inline void clear_blocknum();
  static const int kBlocknumFieldNumber = 10;
  inline ::google::protobuf::int32 blocknum() const;
  inline void set_blocknum(::google::protobuf::int32 value);

  // optional .fantasybit.TrType type = 40;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 40;
  inline ::fantasybit::TrType type() const;
  inline void set_type(::fantasybit::TrType value);

  // optional uint32 season = 50;
  inline bool has_season() const;
  inline void clear_season();
  static const int kSeasonFieldNumber = 50;
  inline ::google::protobuf::uint32 season() const;
  inline void set_season(::google::protobuf::uint32 value);

  // optional uint32 week = 60;
  inline bool has_week() const;
  inline void clear_week();
  static const int kWeekFieldNumber = 60;
  inline ::google::protobuf::uint32 week() const;
  inline void set_week(::google::protobuf::uint32 value);

  // optional bytes gamemetaroot = 70;
  inline bool has_gamemetaroot() const;
  inline void clear_gamemetaroot();
  static const int kGamemetarootFieldNumber = 70;
  inline const ::std::string& gamemetaroot() const;
  inline void set_gamemetaroot(const ::std::string& value);
  inline void set_gamemetaroot(const char* value);
  inline void set_gamemetaroot(const void* value, size_t size);
  inline ::std::string* mutable_gamemetaroot();
  inline ::std::string* release_gamemetaroot();
  inline void set_allocated_gamemetaroot(::std::string* gamemetaroot);

  // optional bytes datametaroot = 80;
  inline bool has_datametaroot() const;
  inline void clear_datametaroot();
  static const int kDatametarootFieldNumber = 80;
  inline const ::std::string& datametaroot() const;
  inline void set_datametaroot(const ::std::string& value);
  inline void set_datametaroot(const char* value);
  inline void set_datametaroot(const void* value, size_t size);
  inline ::std::string* mutable_datametaroot();
  inline ::std::string* release_datametaroot();
  inline void set_allocated_datametaroot(::std::string* datametaroot);

  // optional bytes txmetaid = 100;
  inline bool has_txmetaid() const;
  inline void clear_txmetaid();
  static const int kTxmetaidFieldNumber = 100;
  inline const ::std::string& txmetaid() const;
  inline void set_txmetaid(const ::std::string& value);
  inline void set_txmetaid(const char* value);
  inline void set_txmetaid(const void* value, size_t size);
  inline ::std::string* mutable_txmetaid();
  inline ::std::string* release_txmetaid();
  inline void set_allocated_txmetaid(::std::string* txmetaid);

  // @@protoc_insertion_point(class_scope:fantasybit.TrMeta)
 private:
  inline void set_has_blocknum();
  inline void clear_has_blocknum();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_season();
  inline void clear_has_season();
  inline void set_has_week();
  inline void clear_has_week();
  inline void set_has_gamemetaroot();
  inline void clear_has_gamemetaroot();
  inline void set_has_datametaroot();
  inline void clear_has_datametaroot();
  inline void set_has_txmetaid();
  inline void clear_has_txmetaid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 blocknum_;
  int type_;
  ::google::protobuf::uint32 season_;
  ::google::protobuf::uint32 week_;
  ::std::string* gamemetaroot_;
  ::std::string* datametaroot_;
  ::std::string* txmetaid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static TrMeta* default_instance_;
};
// -------------------------------------------------------------------

class GameMeta : public ::google::protobuf::Message {
 public:
  GameMeta();
  virtual ~GameMeta();

  GameMeta(const GameMeta& from);

  inline GameMeta& operator=(const GameMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameMeta& default_instance();

  void Swap(GameMeta* other);

  // implements Message ----------------------------------------------

  GameMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameMeta& from);
  void MergeFrom(const GameMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes txmetaid = 10;
  inline bool has_txmetaid() const;
  inline void clear_txmetaid();
  static const int kTxmetaidFieldNumber = 10;
  inline const ::std::string& txmetaid() const;
  inline void set_txmetaid(const ::std::string& value);
  inline void set_txmetaid(const char* value);
  inline void set_txmetaid(const void* value, size_t size);
  inline ::std::string* mutable_txmetaid();
  inline ::std::string* release_txmetaid();
  inline void set_allocated_txmetaid(::std::string* txmetaid);

  // optional .fantasybit.GameData gamedata = 20;
  inline bool has_gamedata() const;
  inline void clear_gamedata();
  static const int kGamedataFieldNumber = 20;
  inline const ::fantasybit::GameData& gamedata() const;
  inline ::fantasybit::GameData* mutable_gamedata();
  inline ::fantasybit::GameData* release_gamedata();
  inline void set_allocated_gamedata(::fantasybit::GameData* gamedata);

  // @@protoc_insertion_point(class_scope:fantasybit.GameMeta)
 private:
  inline void set_has_txmetaid();
  inline void clear_has_txmetaid();
  inline void set_has_gamedata();
  inline void clear_has_gamedata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* txmetaid_;
  ::fantasybit::GameData* gamedata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static GameMeta* default_instance_;
};
// -------------------------------------------------------------------

class DataMeta : public ::google::protobuf::Message {
 public:
  DataMeta();
  virtual ~DataMeta();

  DataMeta(const DataMeta& from);

  inline DataMeta& operator=(const DataMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataMeta& default_instance();

  void Swap(DataMeta* other);

  // implements Message ----------------------------------------------

  DataMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataMeta& from);
  void MergeFrom(const DataMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes txmetaid = 10;
  inline bool has_txmetaid() const;
  inline void clear_txmetaid();
  static const int kTxmetaidFieldNumber = 10;
  inline const ::std::string& txmetaid() const;
  inline void set_txmetaid(const ::std::string& value);
  inline void set_txmetaid(const char* value);
  inline void set_txmetaid(const void* value, size_t size);
  inline ::std::string* mutable_txmetaid();
  inline ::std::string* release_txmetaid();
  inline void set_allocated_txmetaid(::std::string* txmetaid);

  // optional .fantasybit.Data data = 20;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 20;
  inline const ::fantasybit::Data& data() const;
  inline ::fantasybit::Data* mutable_data();
  inline ::fantasybit::Data* release_data();
  inline void set_allocated_data(::fantasybit::Data* data);

  // @@protoc_insertion_point(class_scope:fantasybit.DataMeta)
 private:
  inline void set_has_txmetaid();
  inline void clear_has_txmetaid();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* txmetaid_;
  ::fantasybit::Data* data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static DataMeta* default_instance_;
};
// -------------------------------------------------------------------

class LeaderBoardMeta : public ::google::protobuf::Message {
 public:
  LeaderBoardMeta();
  virtual ~LeaderBoardMeta();

  LeaderBoardMeta(const LeaderBoardMeta& from);

  inline LeaderBoardMeta& operator=(const LeaderBoardMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LeaderBoardMeta& default_instance();

  void Swap(LeaderBoardMeta* other);

  // implements Message ----------------------------------------------

  LeaderBoardMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LeaderBoardMeta& from);
  void MergeFrom(const LeaderBoardMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 week = 10;
  inline bool has_week() const;
  inline void clear_week();
  static const int kWeekFieldNumber = 10;
  inline ::google::protobuf::uint32 week() const;
  inline void set_week(::google::protobuf::uint32 value);

  // optional bytes fnbalmetaroot = 20;
  inline bool has_fnbalmetaroot() const;
  inline void clear_fnbalmetaroot();
  static const int kFnbalmetarootFieldNumber = 20;
  inline const ::std::string& fnbalmetaroot() const;
  inline void set_fnbalmetaroot(const ::std::string& value);
  inline void set_fnbalmetaroot(const char* value);
  inline void set_fnbalmetaroot(const void* value, size_t size);
  inline ::std::string* mutable_fnbalmetaroot();
  inline ::std::string* release_fnbalmetaroot();
  inline void set_allocated_fnbalmetaroot(::std::string* fnbalmetaroot);

  // optional bytes prev = 30;
  inline bool has_prev() const;
  inline void clear_prev();
  static const int kPrevFieldNumber = 30;
  inline const ::std::string& prev() const;
  inline void set_prev(const ::std::string& value);
  inline void set_prev(const char* value);
  inline void set_prev(const void* value, size_t size);
  inline ::std::string* mutable_prev();
  inline ::std::string* release_prev();
  inline void set_allocated_prev(::std::string* prev);

  // optional bytes next = 40;
  inline bool has_next() const;
  inline void clear_next();
  static const int kNextFieldNumber = 40;
  inline const ::std::string& next() const;
  inline void set_next(const ::std::string& value);
  inline void set_next(const char* value);
  inline void set_next(const void* value, size_t size);
  inline ::std::string* mutable_next();
  inline ::std::string* release_next();
  inline void set_allocated_next(::std::string* next);

  // @@protoc_insertion_point(class_scope:fantasybit.LeaderBoardMeta)
 private:
  inline void set_has_week();
  inline void clear_has_week();
  inline void set_has_fnbalmetaroot();
  inline void clear_has_fnbalmetaroot();
  inline void set_has_prev();
  inline void clear_has_prev();
  inline void set_has_next();
  inline void clear_has_next();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* fnbalmetaroot_;
  ::std::string* prev_;
  ::std::string* next_;
  ::google::protobuf::uint32 week_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static LeaderBoardMeta* default_instance_;
};
// -------------------------------------------------------------------

class FantasyNameBalMeta : public ::google::protobuf::Message {
 public:
  FantasyNameBalMeta();
  virtual ~FantasyNameBalMeta();

  FantasyNameBalMeta(const FantasyNameBalMeta& from);

  inline FantasyNameBalMeta& operator=(const FantasyNameBalMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FantasyNameBalMeta& default_instance();

  void Swap(FantasyNameBalMeta* other);

  // implements Message ----------------------------------------------

  FantasyNameBalMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FantasyNameBalMeta& from);
  void MergeFrom(const FantasyNameBalMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes txmetaid = 10;
  inline bool has_txmetaid() const;
  inline void clear_txmetaid();
  static const int kTxmetaidFieldNumber = 10;
  inline const ::std::string& txmetaid() const;
  inline void set_txmetaid(const ::std::string& value);
  inline void set_txmetaid(const char* value);
  inline void set_txmetaid(const void* value, size_t size);
  inline ::std::string* mutable_txmetaid();
  inline ::std::string* release_txmetaid();
  inline void set_allocated_txmetaid(::std::string* txmetaid);

  // optional bytes trmetaid = 20;
  inline bool has_trmetaid() const;
  inline void clear_trmetaid();
  static const int kTrmetaidFieldNumber = 20;
  inline const ::std::string& trmetaid() const;
  inline void set_trmetaid(const ::std::string& value);
  inline void set_trmetaid(const char* value);
  inline void set_trmetaid(const void* value, size_t size);
  inline ::std::string* mutable_trmetaid();
  inline ::std::string* release_trmetaid();
  inline void set_allocated_trmetaid(::std::string* trmetaid);

  // optional string name = 25;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 25;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string public_key = 30;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 30;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const char* value, size_t size);
  inline ::std::string* mutable_public_key();
  inline ::std::string* release_public_key();
  inline void set_allocated_public_key(::std::string* public_key);

  // optional uint64 bits = 35;
  inline bool has_bits() const;
  inline void clear_bits();
  static const int kBitsFieldNumber = 35;
  inline ::google::protobuf::uint64 bits() const;
  inline void set_bits(::google::protobuf::uint64 value);

  // optional int64 stake = 40;
  inline bool has_stake() const;
  inline void clear_stake();
  static const int kStakeFieldNumber = 40;
  inline ::google::protobuf::int64 stake() const;
  inline void set_stake(::google::protobuf::int64 value);

  // optional int32 block = 41;
  inline bool has_block() const;
  inline void clear_block();
  static const int kBlockFieldNumber = 41;
  inline ::google::protobuf::int32 block() const;
  inline void set_block(::google::protobuf::int32 value);

  // optional int32 count = 42;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 42;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // optional uint64 nonce = 45;
  inline bool has_nonce() const;
  inline void clear_nonce();
  static const int kNonceFieldNumber = 45;
  inline ::google::protobuf::uint64 nonce() const;
  inline void set_nonce(::google::protobuf::uint64 value);

  // optional bytes awardmetaroot = 50;
  inline bool has_awardmetaroot() const;
  inline void clear_awardmetaroot();
  static const int kAwardmetarootFieldNumber = 50;
  inline const ::std::string& awardmetaroot() const;
  inline void set_awardmetaroot(const ::std::string& value);
  inline void set_awardmetaroot(const char* value);
  inline void set_awardmetaroot(const void* value, size_t size);
  inline ::std::string* mutable_awardmetaroot();
  inline ::std::string* release_awardmetaroot();
  inline void set_allocated_awardmetaroot(::std::string* awardmetaroot);

  // optional bytes pnlmetaroot = 60;
  inline bool has_pnlmetaroot() const;
  inline void clear_pnlmetaroot();
  static const int kPnlmetarootFieldNumber = 60;
  inline const ::std::string& pnlmetaroot() const;
  inline void set_pnlmetaroot(const ::std::string& value);
  inline void set_pnlmetaroot(const char* value);
  inline void set_pnlmetaroot(const void* value, size_t size);
  inline ::std::string* mutable_pnlmetaroot();
  inline ::std::string* release_pnlmetaroot();
  inline void set_allocated_pnlmetaroot(::std::string* pnlmetaroot);

  // optional bytes prev = 70;
  inline bool has_prev() const;
  inline void clear_prev();
  static const int kPrevFieldNumber = 70;
  inline const ::std::string& prev() const;
  inline void set_prev(const ::std::string& value);
  inline void set_prev(const char* value);
  inline void set_prev(const void* value, size_t size);
  inline ::std::string* mutable_prev();
  inline ::std::string* release_prev();
  inline void set_allocated_prev(::std::string* prev);

  // optional bytes next = 80;
  inline bool has_next() const;
  inline void clear_next();
  static const int kNextFieldNumber = 80;
  inline const ::std::string& next() const;
  inline void set_next(const ::std::string& value);
  inline void set_next(const char* value);
  inline void set_next(const void* value, size_t size);
  inline ::std::string* mutable_next();
  inline ::std::string* release_next();
  inline void set_allocated_next(::std::string* next);

  // @@protoc_insertion_point(class_scope:fantasybit.FantasyNameBalMeta)
 private:
  inline void set_has_txmetaid();
  inline void clear_has_txmetaid();
  inline void set_has_trmetaid();
  inline void clear_has_trmetaid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_public_key();
  inline void clear_has_public_key();
  inline void set_has_bits();
  inline void clear_has_bits();
  inline void set_has_stake();
  inline void clear_has_stake();
  inline void set_has_block();
  inline void clear_has_block();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_nonce();
  inline void clear_has_nonce();
  inline void set_has_awardmetaroot();
  inline void clear_has_awardmetaroot();
  inline void set_has_pnlmetaroot();
  inline void clear_has_pnlmetaroot();
  inline void set_has_prev();
  inline void clear_has_prev();
  inline void set_has_next();
  inline void clear_has_next();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* txmetaid_;
  ::std::string* trmetaid_;
  ::std::string* name_;
  ::std::string* public_key_;
  ::google::protobuf::uint64 bits_;
  ::google::protobuf::int64 stake_;
  ::google::protobuf::int32 block_;
  ::google::protobuf::int32 count_;
  ::google::protobuf::uint64 nonce_;
  ::std::string* awardmetaroot_;
  ::std::string* pnlmetaroot_;
  ::std::string* prev_;
  ::std::string* next_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static FantasyNameBalMeta* default_instance_;
};
// -------------------------------------------------------------------

class FantasyNameState : public ::google::protobuf::Message {
 public:
  FantasyNameState();
  virtual ~FantasyNameState();

  FantasyNameState(const FantasyNameState& from);

  inline FantasyNameState& operator=(const FantasyNameState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FantasyNameState& default_instance();

  void Swap(FantasyNameState* other);

  // implements Message ----------------------------------------------

  FantasyNameState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FantasyNameState& from);
  void MergeFrom(const FantasyNameState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bytes fantasynamebalmetaid = 10;
  inline bool has_fantasynamebalmetaid() const;
  inline void clear_fantasynamebalmetaid();
  static const int kFantasynamebalmetaidFieldNumber = 10;
  inline const ::std::string& fantasynamebalmetaid() const;
  inline void set_fantasynamebalmetaid(const ::std::string& value);
  inline void set_fantasynamebalmetaid(const char* value);
  inline void set_fantasynamebalmetaid(const void* value, size_t size);
  inline ::std::string* mutable_fantasynamebalmetaid();
  inline ::std::string* release_fantasynamebalmetaid();
  inline void set_allocated_fantasynamebalmetaid(::std::string* fantasynamebalmetaid);

  // optional bytes posmetaroot = 20;
  inline bool has_posmetaroot() const;
  inline void clear_posmetaroot();
  static const int kPosmetarootFieldNumber = 20;
  inline const ::std::string& posmetaroot() const;
  inline void set_posmetaroot(const ::std::string& value);
  inline void set_posmetaroot(const char* value);
  inline void set_posmetaroot(const void* value, size_t size);
  inline ::std::string* mutable_posmetaroot();
  inline ::std::string* release_posmetaroot();
  inline void set_allocated_posmetaroot(::std::string* posmetaroot);

  // optional bytes ordersmetaroot = 30;
  inline bool has_ordersmetaroot() const;
  inline void clear_ordersmetaroot();
  static const int kOrdersmetarootFieldNumber = 30;
  inline const ::std::string& ordersmetaroot() const;
  inline void set_ordersmetaroot(const ::std::string& value);
  inline void set_ordersmetaroot(const char* value);
  inline void set_ordersmetaroot(const void* value, size_t size);
  inline ::std::string* mutable_ordersmetaroot();
  inline ::std::string* release_ordersmetaroot();
  inline void set_allocated_ordersmetaroot(::std::string* ordersmetaroot);

  // optional bytes projmetaroot = 40;
  inline bool has_projmetaroot() const;
  inline void clear_projmetaroot();
  static const int kProjmetarootFieldNumber = 40;
  inline const ::std::string& projmetaroot() const;
  inline void set_projmetaroot(const ::std::string& value);
  inline void set_projmetaroot(const char* value);
  inline void set_projmetaroot(const void* value, size_t size);
  inline ::std::string* mutable_projmetaroot();
  inline ::std::string* release_projmetaroot();
  inline void set_allocated_projmetaroot(::std::string* projmetaroot);

  // optional bytes prev = 70;
  inline bool has_prev() const;
  inline void clear_prev();
  static const int kPrevFieldNumber = 70;
  inline const ::std::string& prev() const;
  inline void set_prev(const ::std::string& value);
  inline void set_prev(const char* value);
  inline void set_prev(const void* value, size_t size);
  inline ::std::string* mutable_prev();
  inline ::std::string* release_prev();
  inline void set_allocated_prev(::std::string* prev);

  // optional bytes next = 80;
  inline bool has_next() const;
  inline void clear_next();
  static const int kNextFieldNumber = 80;
  inline const ::std::string& next() const;
  inline void set_next(const ::std::string& value);
  inline void set_next(const char* value);
  inline void set_next(const void* value, size_t size);
  inline ::std::string* mutable_next();
  inline ::std::string* release_next();
  inline void set_allocated_next(::std::string* next);

  // optional bytes txmetaid = 50;
  inline bool has_txmetaid() const;
  inline void clear_txmetaid();
  static const int kTxmetaidFieldNumber = 50;
  inline const ::std::string& txmetaid() const;
  inline void set_txmetaid(const ::std::string& value);
  inline void set_txmetaid(const char* value);
  inline void set_txmetaid(const void* value, size_t size);
  inline ::std::string* mutable_txmetaid();
  inline ::std::string* release_txmetaid();
  inline void set_allocated_txmetaid(::std::string* txmetaid);

  // @@protoc_insertion_point(class_scope:fantasybit.FantasyNameState)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_fantasynamebalmetaid();
  inline void clear_has_fantasynamebalmetaid();
  inline void set_has_posmetaroot();
  inline void clear_has_posmetaroot();
  inline void set_has_ordersmetaroot();
  inline void clear_has_ordersmetaroot();
  inline void set_has_projmetaroot();
  inline void clear_has_projmetaroot();
  inline void set_has_prev();
  inline void clear_has_prev();
  inline void set_has_next();
  inline void clear_has_next();
  inline void set_has_txmetaid();
  inline void clear_has_txmetaid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* fantasynamebalmetaid_;
  ::std::string* posmetaroot_;
  ::std::string* ordersmetaroot_;
  ::std::string* projmetaroot_;
  ::std::string* prev_;
  ::std::string* next_;
  ::std::string* txmetaid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static FantasyNameState* default_instance_;
};
// -------------------------------------------------------------------

class WeekGameStatusMeta : public ::google::protobuf::Message {
 public:
  WeekGameStatusMeta();
  virtual ~WeekGameStatusMeta();

  WeekGameStatusMeta(const WeekGameStatusMeta& from);

  inline WeekGameStatusMeta& operator=(const WeekGameStatusMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WeekGameStatusMeta& default_instance();

  void Swap(WeekGameStatusMeta* other);

  // implements Message ----------------------------------------------

  WeekGameStatusMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WeekGameStatusMeta& from);
  void MergeFrom(const WeekGameStatusMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 week = 10;
  inline bool has_week() const;
  inline void clear_week();
  static const int kWeekFieldNumber = 10;
  inline ::google::protobuf::uint32 week() const;
  inline void set_week(::google::protobuf::uint32 value);

  // optional bytes gameresultmetaroot = 20;
  inline bool has_gameresultmetaroot() const;
  inline void clear_gameresultmetaroot();
  static const int kGameresultmetarootFieldNumber = 20;
  inline const ::std::string& gameresultmetaroot() const;
  inline void set_gameresultmetaroot(const ::std::string& value);
  inline void set_gameresultmetaroot(const char* value);
  inline void set_gameresultmetaroot(const void* value, size_t size);
  inline ::std::string* mutable_gameresultmetaroot();
  inline ::std::string* release_gameresultmetaroot();
  inline void set_allocated_gameresultmetaroot(::std::string* gameresultmetaroot);

  // optional bytes ingameprojmetaroot = 30;
  inline bool has_ingameprojmetaroot() const;
  inline void clear_ingameprojmetaroot();
  static const int kIngameprojmetarootFieldNumber = 30;
  inline const ::std::string& ingameprojmetaroot() const;
  inline void set_ingameprojmetaroot(const ::std::string& value);
  inline void set_ingameprojmetaroot(const char* value);
  inline void set_ingameprojmetaroot(const void* value, size_t size);
  inline ::std::string* mutable_ingameprojmetaroot();
  inline ::std::string* release_ingameprojmetaroot();
  inline void set_allocated_ingameprojmetaroot(::std::string* ingameprojmetaroot);

  // optional bytes opengamestatusroot = 40;
  inline bool has_opengamestatusroot() const;
  inline void clear_opengamestatusroot();
  static const int kOpengamestatusrootFieldNumber = 40;
  inline const ::std::string& opengamestatusroot() const;
  inline void set_opengamestatusroot(const ::std::string& value);
  inline void set_opengamestatusroot(const char* value);
  inline void set_opengamestatusroot(const void* value, size_t size);
  inline ::std::string* mutable_opengamestatusroot();
  inline ::std::string* release_opengamestatusroot();
  inline void set_allocated_opengamestatusroot(::std::string* opengamestatusroot);

  // optional bytes prev = 50;
  inline bool has_prev() const;
  inline void clear_prev();
  static const int kPrevFieldNumber = 50;
  inline const ::std::string& prev() const;
  inline void set_prev(const ::std::string& value);
  inline void set_prev(const char* value);
  inline void set_prev(const void* value, size_t size);
  inline ::std::string* mutable_prev();
  inline ::std::string* release_prev();
  inline void set_allocated_prev(::std::string* prev);

  // optional bytes next = 60;
  inline bool has_next() const;
  inline void clear_next();
  static const int kNextFieldNumber = 60;
  inline const ::std::string& next() const;
  inline void set_next(const ::std::string& value);
  inline void set_next(const char* value);
  inline void set_next(const void* value, size_t size);
  inline ::std::string* mutable_next();
  inline ::std::string* release_next();
  inline void set_allocated_next(::std::string* next);

  // @@protoc_insertion_point(class_scope:fantasybit.WeekGameStatusMeta)
 private:
  inline void set_has_week();
  inline void clear_has_week();
  inline void set_has_gameresultmetaroot();
  inline void clear_has_gameresultmetaroot();
  inline void set_has_ingameprojmetaroot();
  inline void clear_has_ingameprojmetaroot();
  inline void set_has_opengamestatusroot();
  inline void clear_has_opengamestatusroot();
  inline void set_has_prev();
  inline void clear_has_prev();
  inline void set_has_next();
  inline void clear_has_next();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* gameresultmetaroot_;
  ::std::string* ingameprojmetaroot_;
  ::std::string* opengamestatusroot_;
  ::std::string* prev_;
  ::std::string* next_;
  ::google::protobuf::uint32 week_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static WeekGameStatusMeta* default_instance_;
};
// -------------------------------------------------------------------

class InGameProjMeta : public ::google::protobuf::Message {
 public:
  InGameProjMeta();
  virtual ~InGameProjMeta();

  InGameProjMeta(const InGameProjMeta& from);

  inline InGameProjMeta& operator=(const InGameProjMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InGameProjMeta& default_instance();

  void Swap(InGameProjMeta* other);

  // implements Message ----------------------------------------------

  InGameProjMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InGameProjMeta& from);
  void MergeFrom(const InGameProjMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string gameid = 20;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameidFieldNumber = 20;
  inline const ::std::string& gameid() const;
  inline void set_gameid(const ::std::string& value);
  inline void set_gameid(const char* value);
  inline void set_gameid(const char* value, size_t size);
  inline ::std::string* mutable_gameid();
  inline ::std::string* release_gameid();
  inline void set_allocated_gameid(::std::string* gameid);

  // optional bytes gamestatusmetaid = 40;
  inline bool has_gamestatusmetaid() const;
  inline void clear_gamestatusmetaid();
  static const int kGamestatusmetaidFieldNumber = 40;
  inline const ::std::string& gamestatusmetaid() const;
  inline void set_gamestatusmetaid(const ::std::string& value);
  inline void set_gamestatusmetaid(const char* value);
  inline void set_gamestatusmetaid(const void* value, size_t size);
  inline ::std::string* mutable_gamestatusmetaid();
  inline ::std::string* release_gamestatusmetaid();
  inline void set_allocated_gamestatusmetaid(::std::string* gamestatusmetaid);

  // optional bytes homeprojmeta = 60;
  inline bool has_homeprojmeta() const;
  inline void clear_homeprojmeta();
  static const int kHomeprojmetaFieldNumber = 60;
  inline const ::std::string& homeprojmeta() const;
  inline void set_homeprojmeta(const ::std::string& value);
  inline void set_homeprojmeta(const char* value);
  inline void set_homeprojmeta(const void* value, size_t size);
  inline ::std::string* mutable_homeprojmeta();
  inline ::std::string* release_homeprojmeta();
  inline void set_allocated_homeprojmeta(::std::string* homeprojmeta);

  // optional bytes awayprojmeta = 70;
  inline bool has_awayprojmeta() const;
  inline void clear_awayprojmeta();
  static const int kAwayprojmetaFieldNumber = 70;
  inline const ::std::string& awayprojmeta() const;
  inline void set_awayprojmeta(const ::std::string& value);
  inline void set_awayprojmeta(const char* value);
  inline void set_awayprojmeta(const void* value, size_t size);
  inline ::std::string* mutable_awayprojmeta();
  inline ::std::string* release_awayprojmeta();
  inline void set_allocated_awayprojmeta(::std::string* awayprojmeta);

  // optional bytes gamedatametaid = 50;
  inline bool has_gamedatametaid() const;
  inline void clear_gamedatametaid();
  static const int kGamedatametaidFieldNumber = 50;
  inline const ::std::string& gamedatametaid() const;
  inline void set_gamedatametaid(const ::std::string& value);
  inline void set_gamedatametaid(const char* value);
  inline void set_gamedatametaid(const void* value, size_t size);
  inline ::std::string* mutable_gamedatametaid();
  inline ::std::string* release_gamedatametaid();
  inline void set_allocated_gamedatametaid(::std::string* gamedatametaid);

  // @@protoc_insertion_point(class_scope:fantasybit.InGameProjMeta)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gamestatusmetaid();
  inline void clear_has_gamestatusmetaid();
  inline void set_has_homeprojmeta();
  inline void clear_has_homeprojmeta();
  inline void set_has_awayprojmeta();
  inline void clear_has_awayprojmeta();
  inline void set_has_gamedatametaid();
  inline void clear_has_gamedatametaid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* gameid_;
  ::std::string* gamestatusmetaid_;
  ::std::string* homeprojmeta_;
  ::std::string* awayprojmeta_;
  ::std::string* gamedatametaid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static InGameProjMeta* default_instance_;
};
// -------------------------------------------------------------------

class GameResultsMeta : public ::google::protobuf::Message {
 public:
  GameResultsMeta();
  virtual ~GameResultsMeta();

  GameResultsMeta(const GameResultsMeta& from);

  inline GameResultsMeta& operator=(const GameResultsMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameResultsMeta& default_instance();

  void Swap(GameResultsMeta* other);

  // implements Message ----------------------------------------------

  GameResultsMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameResultsMeta& from);
  void MergeFrom(const GameResultsMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string gameid = 20;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameidFieldNumber = 20;
  inline const ::std::string& gameid() const;
  inline void set_gameid(const ::std::string& value);
  inline void set_gameid(const char* value);
  inline void set_gameid(const char* value, size_t size);
  inline ::std::string* mutable_gameid();
  inline ::std::string* release_gameid();
  inline void set_allocated_gameid(::std::string* gameid);

  // optional bytes gamestatusmetaid = 40;
  inline bool has_gamestatusmetaid() const;
  inline void clear_gamestatusmetaid();
  static const int kGamestatusmetaidFieldNumber = 40;
  inline const ::std::string& gamestatusmetaid() const;
  inline void set_gamestatusmetaid(const ::std::string& value);
  inline void set_gamestatusmetaid(const char* value);
  inline void set_gamestatusmetaid(const void* value, size_t size);
  inline ::std::string* mutable_gamestatusmetaid();
  inline ::std::string* release_gamestatusmetaid();
  inline void set_allocated_gamestatusmetaid(::std::string* gamestatusmetaid);

  // optional bytes homeresultmeta = 60;
  inline bool has_homeresultmeta() const;
  inline void clear_homeresultmeta();
  static const int kHomeresultmetaFieldNumber = 60;
  inline const ::std::string& homeresultmeta() const;
  inline void set_homeresultmeta(const ::std::string& value);
  inline void set_homeresultmeta(const char* value);
  inline void set_homeresultmeta(const void* value, size_t size);
  inline ::std::string* mutable_homeresultmeta();
  inline ::std::string* release_homeresultmeta();
  inline void set_allocated_homeresultmeta(::std::string* homeresultmeta);

  // optional bytes awayresultmeta = 70;
  inline bool has_awayresultmeta() const;
  inline void clear_awayresultmeta();
  static const int kAwayresultmetaFieldNumber = 70;
  inline const ::std::string& awayresultmeta() const;
  inline void set_awayresultmeta(const ::std::string& value);
  inline void set_awayresultmeta(const char* value);
  inline void set_awayresultmeta(const void* value, size_t size);
  inline ::std::string* mutable_awayresultmeta();
  inline ::std::string* release_awayresultmeta();
  inline void set_allocated_awayresultmeta(::std::string* awayresultmeta);

  // optional bytes resultdatametaid = 50;
  inline bool has_resultdatametaid() const;
  inline void clear_resultdatametaid();
  static const int kResultdatametaidFieldNumber = 50;
  inline const ::std::string& resultdatametaid() const;
  inline void set_resultdatametaid(const ::std::string& value);
  inline void set_resultdatametaid(const char* value);
  inline void set_resultdatametaid(const void* value, size_t size);
  inline ::std::string* mutable_resultdatametaid();
  inline ::std::string* release_resultdatametaid();
  inline void set_allocated_resultdatametaid(::std::string* resultdatametaid);

  // @@protoc_insertion_point(class_scope:fantasybit.GameResultsMeta)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gamestatusmetaid();
  inline void clear_has_gamestatusmetaid();
  inline void set_has_homeresultmeta();
  inline void clear_has_homeresultmeta();
  inline void set_has_awayresultmeta();
  inline void clear_has_awayresultmeta();
  inline void set_has_resultdatametaid();
  inline void clear_has_resultdatametaid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* gameid_;
  ::std::string* gamestatusmetaid_;
  ::std::string* homeresultmeta_;
  ::std::string* awayresultmeta_;
  ::std::string* resultdatametaid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static GameResultsMeta* default_instance_;
};
// -------------------------------------------------------------------

class GameStatusMeta : public ::google::protobuf::Message {
 public:
  GameStatusMeta();
  virtual ~GameStatusMeta();

  GameStatusMeta(const GameStatusMeta& from);

  inline GameStatusMeta& operator=(const GameStatusMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameStatusMeta& default_instance();

  void Swap(GameStatusMeta* other);

  // implements Message ----------------------------------------------

  GameStatusMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameStatusMeta& from);
  void MergeFrom(const GameStatusMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional int32 week = 2;
  inline bool has_week() const;
  inline void clear_week();
  static const int kWeekFieldNumber = 2;
  inline ::google::protobuf::int32 week() const;
  inline void set_week(::google::protobuf::int32 value);

  // optional .fantasybit.GameInfo gameinfo = 10;
  inline bool has_gameinfo() const;
  inline void clear_gameinfo();
  static const int kGameinfoFieldNumber = 10;
  inline const ::fantasybit::GameInfo& gameinfo() const;
  inline ::fantasybit::GameInfo* mutable_gameinfo();
  inline ::fantasybit::GameInfo* release_gameinfo();
  inline void set_allocated_gameinfo(::fantasybit::GameInfo* gameinfo);

  // optional .fantasybit.GameStatus gamesatus = 20;
  inline bool has_gamesatus() const;
  inline void clear_gamesatus();
  static const int kGamesatusFieldNumber = 20;
  inline const ::fantasybit::GameStatus& gamesatus() const;
  inline ::fantasybit::GameStatus* mutable_gamesatus();
  inline ::fantasybit::GameStatus* release_gamesatus();
  inline void set_allocated_gamesatus(::fantasybit::GameStatus* gamesatus);

  // optional bytes gamemetaid = 30;
  inline bool has_gamemetaid() const;
  inline void clear_gamemetaid();
  static const int kGamemetaidFieldNumber = 30;
  inline const ::std::string& gamemetaid() const;
  inline void set_gamemetaid(const ::std::string& value);
  inline void set_gamemetaid(const char* value);
  inline void set_gamemetaid(const void* value, size_t size);
  inline ::std::string* mutable_gamemetaid();
  inline ::std::string* release_gamemetaid();
  inline void set_allocated_gamemetaid(::std::string* gamemetaid);

  // optional bytes datametaid = 40;
  inline bool has_datametaid() const;
  inline void clear_datametaid();
  static const int kDatametaidFieldNumber = 40;
  inline const ::std::string& datametaid() const;
  inline void set_datametaid(const ::std::string& value);
  inline void set_datametaid(const char* value);
  inline void set_datametaid(const void* value, size_t size);
  inline ::std::string* mutable_datametaid();
  inline ::std::string* release_datametaid();
  inline void set_allocated_datametaid(::std::string* datametaid);

  // optional bytes prev = 50;
  inline bool has_prev() const;
  inline void clear_prev();
  static const int kPrevFieldNumber = 50;
  inline const ::std::string& prev() const;
  inline void set_prev(const ::std::string& value);
  inline void set_prev(const char* value);
  inline void set_prev(const void* value, size_t size);
  inline ::std::string* mutable_prev();
  inline ::std::string* release_prev();
  inline void set_allocated_prev(::std::string* prev);

  // optional bytes next = 60;
  inline bool has_next() const;
  inline void clear_next();
  static const int kNextFieldNumber = 60;
  inline const ::std::string& next() const;
  inline void set_next(const ::std::string& value);
  inline void set_next(const char* value);
  inline void set_next(const void* value, size_t size);
  inline ::std::string* mutable_next();
  inline ::std::string* release_next();
  inline void set_allocated_next(::std::string* next);

  // optional int32 season = 70;
  inline bool has_season() const;
  inline void clear_season();
  static const int kSeasonFieldNumber = 70;
  inline ::google::protobuf::int32 season() const;
  inline void set_season(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fantasybit.GameStatusMeta)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_week();
  inline void clear_has_week();
  inline void set_has_gameinfo();
  inline void clear_has_gameinfo();
  inline void set_has_gamesatus();
  inline void clear_has_gamesatus();
  inline void set_has_gamemetaid();
  inline void clear_has_gamemetaid();
  inline void set_has_datametaid();
  inline void clear_has_datametaid();
  inline void set_has_prev();
  inline void clear_has_prev();
  inline void set_has_next();
  inline void clear_has_next();
  inline void set_has_season();
  inline void clear_has_season();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::fantasybit::GameInfo* gameinfo_;
  ::fantasybit::GameStatus* gamesatus_;
  ::std::string* gamemetaid_;
  ::google::protobuf::int32 week_;
  ::google::protobuf::int32 season_;
  ::std::string* datametaid_;
  ::std::string* prev_;
  ::std::string* next_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static GameStatusMeta* default_instance_;
};
// -------------------------------------------------------------------

class TeamProjMeta : public ::google::protobuf::Message {
 public:
  TeamProjMeta();
  virtual ~TeamProjMeta();

  TeamProjMeta(const TeamProjMeta& from);

  inline TeamProjMeta& operator=(const TeamProjMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TeamProjMeta& default_instance();

  void Swap(TeamProjMeta* other);

  // implements Message ----------------------------------------------

  TeamProjMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TeamProjMeta& from);
  void MergeFrom(const TeamProjMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string gameid = 20;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameidFieldNumber = 20;
  inline const ::std::string& gameid() const;
  inline void set_gameid(const ::std::string& value);
  inline void set_gameid(const char* value);
  inline void set_gameid(const char* value, size_t size);
  inline ::std::string* mutable_gameid();
  inline ::std::string* release_gameid();
  inline void set_allocated_gameid(::std::string* gameid);

  // optional string team = 30;
  inline bool has_team() const;
  inline void clear_team();
  static const int kTeamFieldNumber = 30;
  inline const ::std::string& team() const;
  inline void set_team(const ::std::string& value);
  inline void set_team(const char* value);
  inline void set_team(const char* value, size_t size);
  inline ::std::string* mutable_team();
  inline ::std::string* release_team();
  inline void set_allocated_team(::std::string* team);

  // optional uint32 kickofftime = 40;
  inline bool has_kickofftime() const;
  inline void clear_kickofftime();
  static const int kKickofftimeFieldNumber = 40;
  inline ::google::protobuf::uint32 kickofftime() const;
  inline void set_kickofftime(::google::protobuf::uint32 value);

  // optional uint32 week = 50;
  inline bool has_week() const;
  inline void clear_week();
  static const int kWeekFieldNumber = 50;
  inline ::google::protobuf::uint32 week() const;
  inline void set_week(::google::protobuf::uint32 value);

  // optional bytes gameplayerprojmetaroot = 60;
  inline bool has_gameplayerprojmetaroot() const;
  inline void clear_gameplayerprojmetaroot();
  static const int kGameplayerprojmetarootFieldNumber = 60;
  inline const ::std::string& gameplayerprojmetaroot() const;
  inline void set_gameplayerprojmetaroot(const ::std::string& value);
  inline void set_gameplayerprojmetaroot(const char* value);
  inline void set_gameplayerprojmetaroot(const void* value, size_t size);
  inline ::std::string* mutable_gameplayerprojmetaroot();
  inline ::std::string* release_gameplayerprojmetaroot();
  inline void set_allocated_gameplayerprojmetaroot(::std::string* gameplayerprojmetaroot);

  // optional bytes gamedatametaid = 70;
  inline bool has_gamedatametaid() const;
  inline void clear_gamedatametaid();
  static const int kGamedatametaidFieldNumber = 70;
  inline const ::std::string& gamedatametaid() const;
  inline void set_gamedatametaid(const ::std::string& value);
  inline void set_gamedatametaid(const char* value);
  inline void set_gamedatametaid(const void* value, size_t size);
  inline ::std::string* mutable_gamedatametaid();
  inline ::std::string* release_gamedatametaid();
  inline void set_allocated_gamedatametaid(::std::string* gamedatametaid);

  // @@protoc_insertion_point(class_scope:fantasybit.TeamProjMeta)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_team();
  inline void clear_has_team();
  inline void set_has_kickofftime();
  inline void clear_has_kickofftime();
  inline void set_has_week();
  inline void clear_has_week();
  inline void set_has_gameplayerprojmetaroot();
  inline void clear_has_gameplayerprojmetaroot();
  inline void set_has_gamedatametaid();
  inline void clear_has_gamedatametaid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* gameid_;
  ::std::string* team_;
  ::google::protobuf::uint32 kickofftime_;
  ::google::protobuf::uint32 week_;
  ::std::string* gameplayerprojmetaroot_;
  ::std::string* gamedatametaid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static TeamProjMeta* default_instance_;
};
// -------------------------------------------------------------------

class TeamResultMeta : public ::google::protobuf::Message {
 public:
  TeamResultMeta();
  virtual ~TeamResultMeta();

  TeamResultMeta(const TeamResultMeta& from);

  inline TeamResultMeta& operator=(const TeamResultMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TeamResultMeta& default_instance();

  void Swap(TeamResultMeta* other);

  // implements Message ----------------------------------------------

  TeamResultMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TeamResultMeta& from);
  void MergeFrom(const TeamResultMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string gameid = 20;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameidFieldNumber = 20;
  inline const ::std::string& gameid() const;
  inline void set_gameid(const ::std::string& value);
  inline void set_gameid(const char* value);
  inline void set_gameid(const char* value, size_t size);
  inline ::std::string* mutable_gameid();
  inline ::std::string* release_gameid();
  inline void set_allocated_gameid(::std::string* gameid);

  // optional string team = 30;
  inline bool has_team() const;
  inline void clear_team();
  static const int kTeamFieldNumber = 30;
  inline const ::std::string& team() const;
  inline void set_team(const ::std::string& value);
  inline void set_team(const char* value);
  inline void set_team(const char* value, size_t size);
  inline ::std::string* mutable_team();
  inline ::std::string* release_team();
  inline void set_allocated_team(::std::string* team);

  // optional uint32 kickofftime = 40;
  inline bool has_kickofftime() const;
  inline void clear_kickofftime();
  static const int kKickofftimeFieldNumber = 40;
  inline ::google::protobuf::uint32 kickofftime() const;
  inline void set_kickofftime(::google::protobuf::uint32 value);

  // optional uint32 week = 50;
  inline bool has_week() const;
  inline void clear_week();
  static const int kWeekFieldNumber = 50;
  inline ::google::protobuf::uint32 week() const;
  inline void set_week(::google::protobuf::uint32 value);

  // optional bytes playerresultmetaroot = 60;
  inline bool has_playerresultmetaroot() const;
  inline void clear_playerresultmetaroot();
  static const int kPlayerresultmetarootFieldNumber = 60;
  inline const ::std::string& playerresultmetaroot() const;
  inline void set_playerresultmetaroot(const ::std::string& value);
  inline void set_playerresultmetaroot(const char* value);
  inline void set_playerresultmetaroot(const void* value, size_t size);
  inline ::std::string* mutable_playerresultmetaroot();
  inline ::std::string* release_playerresultmetaroot();
  inline void set_allocated_playerresultmetaroot(::std::string* playerresultmetaroot);

  // optional bytes resultdatametaid = 70;
  inline bool has_resultdatametaid() const;
  inline void clear_resultdatametaid();
  static const int kResultdatametaidFieldNumber = 70;
  inline const ::std::string& resultdatametaid() const;
  inline void set_resultdatametaid(const ::std::string& value);
  inline void set_resultdatametaid(const char* value);
  inline void set_resultdatametaid(const void* value, size_t size);
  inline ::std::string* mutable_resultdatametaid();
  inline ::std::string* release_resultdatametaid();
  inline void set_allocated_resultdatametaid(::std::string* resultdatametaid);

  // @@protoc_insertion_point(class_scope:fantasybit.TeamResultMeta)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_team();
  inline void clear_has_team();
  inline void set_has_kickofftime();
  inline void clear_has_kickofftime();
  inline void set_has_week();
  inline void clear_has_week();
  inline void set_has_playerresultmetaroot();
  inline void clear_has_playerresultmetaroot();
  inline void set_has_resultdatametaid();
  inline void clear_has_resultdatametaid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* gameid_;
  ::std::string* team_;
  ::google::protobuf::uint32 kickofftime_;
  ::google::protobuf::uint32 week_;
  ::std::string* playerresultmetaroot_;
  ::std::string* resultdatametaid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static TeamResultMeta* default_instance_;
};
// -------------------------------------------------------------------

class GamePlayerProjMeta : public ::google::protobuf::Message {
 public:
  GamePlayerProjMeta();
  virtual ~GamePlayerProjMeta();

  GamePlayerProjMeta(const GamePlayerProjMeta& from);

  inline GamePlayerProjMeta& operator=(const GamePlayerProjMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GamePlayerProjMeta& default_instance();

  void Swap(GamePlayerProjMeta* other);

  // implements Message ----------------------------------------------

  GamePlayerProjMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GamePlayerProjMeta& from);
  void MergeFrom(const GamePlayerProjMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string playerid = 20;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 20;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  inline void set_allocated_playerid(::std::string* playerid);

  // optional bytes gamestatusmetaid = 30;
  inline bool has_gamestatusmetaid() const;
  inline void clear_gamestatusmetaid();
  static const int kGamestatusmetaidFieldNumber = 30;
  inline const ::std::string& gamestatusmetaid() const;
  inline void set_gamestatusmetaid(const ::std::string& value);
  inline void set_gamestatusmetaid(const char* value);
  inline void set_gamestatusmetaid(const void* value, size_t size);
  inline ::std::string* mutable_gamestatusmetaid();
  inline ::std::string* release_gamestatusmetaid();
  inline void set_allocated_gamestatusmetaid(::std::string* gamestatusmetaid);

  // optional bytes projmetaplayerroot = 60;
  inline bool has_projmetaplayerroot() const;
  inline void clear_projmetaplayerroot();
  static const int kProjmetaplayerrootFieldNumber = 60;
  inline const ::std::string& projmetaplayerroot() const;
  inline void set_projmetaplayerroot(const ::std::string& value);
  inline void set_projmetaplayerroot(const char* value);
  inline void set_projmetaplayerroot(const void* value, size_t size);
  inline ::std::string* mutable_projmetaplayerroot();
  inline ::std::string* release_projmetaplayerroot();
  inline void set_allocated_projmetaplayerroot(::std::string* projmetaplayerroot);

  // optional bytes posmetaplayerroot = 70;
  inline bool has_posmetaplayerroot() const;
  inline void clear_posmetaplayerroot();
  static const int kPosmetaplayerrootFieldNumber = 70;
  inline const ::std::string& posmetaplayerroot() const;
  inline void set_posmetaplayerroot(const ::std::string& value);
  inline void set_posmetaplayerroot(const char* value);
  inline void set_posmetaplayerroot(const void* value, size_t size);
  inline ::std::string* mutable_posmetaplayerroot();
  inline ::std::string* release_posmetaplayerroot();
  inline void set_allocated_posmetaplayerroot(::std::string* posmetaplayerroot);

  // optional bytes gamedatametaid = 80;
  inline bool has_gamedatametaid() const;
  inline void clear_gamedatametaid();
  static const int kGamedatametaidFieldNumber = 80;
  inline const ::std::string& gamedatametaid() const;
  inline void set_gamedatametaid(const ::std::string& value);
  inline void set_gamedatametaid(const char* value);
  inline void set_gamedatametaid(const void* value, size_t size);
  inline ::std::string* mutable_gamedatametaid();
  inline ::std::string* release_gamedatametaid();
  inline void set_allocated_gamedatametaid(::std::string* gamedatametaid);

  // @@protoc_insertion_point(class_scope:fantasybit.GamePlayerProjMeta)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_gamestatusmetaid();
  inline void clear_has_gamestatusmetaid();
  inline void set_has_projmetaplayerroot();
  inline void clear_has_projmetaplayerroot();
  inline void set_has_posmetaplayerroot();
  inline void clear_has_posmetaplayerroot();
  inline void set_has_gamedatametaid();
  inline void clear_has_gamedatametaid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* playerid_;
  ::std::string* gamestatusmetaid_;
  ::std::string* projmetaplayerroot_;
  ::std::string* posmetaplayerroot_;
  ::std::string* gamedatametaid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static GamePlayerProjMeta* default_instance_;
};
// -------------------------------------------------------------------

class ProjMeta : public ::google::protobuf::Message {
 public:
  ProjMeta();
  virtual ~ProjMeta();

  ProjMeta(const ProjMeta& from);

  inline ProjMeta& operator=(const ProjMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProjMeta& default_instance();

  void Swap(ProjMeta* other);

  // implements Message ----------------------------------------------

  ProjMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProjMeta& from);
  void MergeFrom(const ProjMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 10;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 10;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 proj = 20;
  inline bool has_proj() const;
  inline void clear_proj();
  static const int kProjFieldNumber = 20;
  inline ::google::protobuf::int32 proj() const;
  inline void set_proj(::google::protobuf::int32 value);

  // optional string playerid = 30;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 30;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  inline void set_allocated_playerid(::std::string* playerid);

  // optional bytes txmetaid = 40;
  inline bool has_txmetaid() const;
  inline void clear_txmetaid();
  static const int kTxmetaidFieldNumber = 40;
  inline const ::std::string& txmetaid() const;
  inline void set_txmetaid(const ::std::string& value);
  inline void set_txmetaid(const char* value);
  inline void set_txmetaid(const void* value, size_t size);
  inline ::std::string* mutable_txmetaid();
  inline ::std::string* release_txmetaid();
  inline void set_allocated_txmetaid(::std::string* txmetaid);

  // optional bytes prev = 50;
  inline bool has_prev() const;
  inline void clear_prev();
  static const int kPrevFieldNumber = 50;
  inline const ::std::string& prev() const;
  inline void set_prev(const ::std::string& value);
  inline void set_prev(const char* value);
  inline void set_prev(const void* value, size_t size);
  inline ::std::string* mutable_prev();
  inline ::std::string* release_prev();
  inline void set_allocated_prev(::std::string* prev);

  // @@protoc_insertion_point(class_scope:fantasybit.ProjMeta)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_proj();
  inline void clear_has_proj();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_txmetaid();
  inline void clear_has_txmetaid();
  inline void set_has_prev();
  inline void clear_has_prev();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* playerid_;
  ::std::string* txmetaid_;
  ::std::string* prev_;
  ::google::protobuf::int32 proj_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static ProjMeta* default_instance_;
};
// -------------------------------------------------------------------

class PosMeta : public ::google::protobuf::Message {
 public:
  PosMeta();
  virtual ~PosMeta();

  PosMeta(const PosMeta& from);

  inline PosMeta& operator=(const PosMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PosMeta& default_instance();

  void Swap(PosMeta* other);

  // implements Message ----------------------------------------------

  PosMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PosMeta& from);
  void MergeFrom(const PosMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 10;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 10;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 qty = 20;
  inline bool has_qty() const;
  inline void clear_qty();
  static const int kQtyFieldNumber = 20;
  inline ::google::protobuf::int32 qty() const;
  inline void set_qty(::google::protobuf::int32 value);

  // optional int32 price = 30;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 30;
  inline ::google::protobuf::int32 price() const;
  inline void set_price(::google::protobuf::int32 value);

  // optional string playerid = 40;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 40;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  inline void set_allocated_playerid(::std::string* playerid);

  // optional bytes txmetaid = 50;
  inline bool has_txmetaid() const;
  inline void clear_txmetaid();
  static const int kTxmetaidFieldNumber = 50;
  inline const ::std::string& txmetaid() const;
  inline void set_txmetaid(const ::std::string& value);
  inline void set_txmetaid(const char* value);
  inline void set_txmetaid(const void* value, size_t size);
  inline ::std::string* mutable_txmetaid();
  inline ::std::string* release_txmetaid();
  inline void set_allocated_txmetaid(::std::string* txmetaid);

  // optional bytes prev = 60;
  inline bool has_prev() const;
  inline void clear_prev();
  static const int kPrevFieldNumber = 60;
  inline const ::std::string& prev() const;
  inline void set_prev(const ::std::string& value);
  inline void set_prev(const char* value);
  inline void set_prev(const void* value, size_t size);
  inline ::std::string* mutable_prev();
  inline ::std::string* release_prev();
  inline void set_allocated_prev(::std::string* prev);

  // @@protoc_insertion_point(class_scope:fantasybit.PosMeta)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_qty();
  inline void clear_has_qty();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_txmetaid();
  inline void clear_has_txmetaid();
  inline void set_has_prev();
  inline void clear_has_prev();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::int32 qty_;
  ::google::protobuf::int32 price_;
  ::std::string* playerid_;
  ::std::string* txmetaid_;
  ::std::string* prev_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static PosMeta* default_instance_;
};
// -------------------------------------------------------------------

class PlayerResultMeta : public ::google::protobuf::Message {
 public:
  PlayerResultMeta();
  virtual ~PlayerResultMeta();

  PlayerResultMeta(const PlayerResultMeta& from);

  inline PlayerResultMeta& operator=(const PlayerResultMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerResultMeta& default_instance();

  void Swap(PlayerResultMeta* other);

  // implements Message ----------------------------------------------

  PlayerResultMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerResultMeta& from);
  void MergeFrom(const PlayerResultMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes playergamestatsid = 10;
  inline bool has_playergamestatsid() const;
  inline void clear_playergamestatsid();
  static const int kPlayergamestatsidFieldNumber = 10;
  inline const ::std::string& playergamestatsid() const;
  inline void set_playergamestatsid(const ::std::string& value);
  inline void set_playergamestatsid(const char* value);
  inline void set_playergamestatsid(const void* value, size_t size);
  inline ::std::string* mutable_playergamestatsid();
  inline ::std::string* release_playergamestatsid();
  inline void set_allocated_playergamestatsid(::std::string* playergamestatsid);

  // optional bytes gamestatusmetaid = 30;
  inline bool has_gamestatusmetaid() const;
  inline void clear_gamestatusmetaid();
  static const int kGamestatusmetaidFieldNumber = 30;
  inline const ::std::string& gamestatusmetaid() const;
  inline void set_gamestatusmetaid(const ::std::string& value);
  inline void set_gamestatusmetaid(const char* value);
  inline void set_gamestatusmetaid(const void* value, size_t size);
  inline ::std::string* mutable_gamestatusmetaid();
  inline ::std::string* release_gamestatusmetaid();
  inline void set_allocated_gamestatusmetaid(::std::string* gamestatusmetaid);

  // optional bytes awardmetaplayerroot = 60;
  inline bool has_awardmetaplayerroot() const;
  inline void clear_awardmetaplayerroot();
  static const int kAwardmetaplayerrootFieldNumber = 60;
  inline const ::std::string& awardmetaplayerroot() const;
  inline void set_awardmetaplayerroot(const ::std::string& value);
  inline void set_awardmetaplayerroot(const char* value);
  inline void set_awardmetaplayerroot(const void* value, size_t size);
  inline ::std::string* mutable_awardmetaplayerroot();
  inline ::std::string* release_awardmetaplayerroot();
  inline void set_allocated_awardmetaplayerroot(::std::string* awardmetaplayerroot);

  // optional bytes pnlmetaplayerroot = 70;
  inline bool has_pnlmetaplayerroot() const;
  inline void clear_pnlmetaplayerroot();
  static const int kPnlmetaplayerrootFieldNumber = 70;
  inline const ::std::string& pnlmetaplayerroot() const;
  inline void set_pnlmetaplayerroot(const ::std::string& value);
  inline void set_pnlmetaplayerroot(const char* value);
  inline void set_pnlmetaplayerroot(const void* value, size_t size);
  inline ::std::string* mutable_pnlmetaplayerroot();
  inline ::std::string* release_pnlmetaplayerroot();
  inline void set_allocated_pnlmetaplayerroot(::std::string* pnlmetaplayerroot);

  // optional bytes resultdatametaid = 80;
  inline bool has_resultdatametaid() const;
  inline void clear_resultdatametaid();
  static const int kResultdatametaidFieldNumber = 80;
  inline const ::std::string& resultdatametaid() const;
  inline void set_resultdatametaid(const ::std::string& value);
  inline void set_resultdatametaid(const char* value);
  inline void set_resultdatametaid(const void* value, size_t size);
  inline ::std::string* mutable_resultdatametaid();
  inline ::std::string* release_resultdatametaid();
  inline void set_allocated_resultdatametaid(::std::string* resultdatametaid);

  // @@protoc_insertion_point(class_scope:fantasybit.PlayerResultMeta)
 private:
  inline void set_has_playergamestatsid();
  inline void clear_has_playergamestatsid();
  inline void set_has_gamestatusmetaid();
  inline void clear_has_gamestatusmetaid();
  inline void set_has_awardmetaplayerroot();
  inline void clear_has_awardmetaplayerroot();
  inline void set_has_pnlmetaplayerroot();
  inline void clear_has_pnlmetaplayerroot();
  inline void set_has_resultdatametaid();
  inline void clear_has_resultdatametaid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* playergamestatsid_;
  ::std::string* gamestatusmetaid_;
  ::std::string* awardmetaplayerroot_;
  ::std::string* pnlmetaplayerroot_;
  ::std::string* resultdatametaid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static PlayerResultMeta* default_instance_;
};
// -------------------------------------------------------------------

class PlayerGameStats : public ::google::protobuf::Message {
 public:
  PlayerGameStats();
  virtual ~PlayerGameStats();

  PlayerGameStats(const PlayerGameStats& from);

  inline PlayerGameStats& operator=(const PlayerGameStats& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerGameStats& default_instance();

  void Swap(PlayerGameStats* other);

  // implements Message ----------------------------------------------

  PlayerGameStats* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerGameStats& from);
  void MergeFrom(const PlayerGameStats& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string playerid = 20;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 20;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  inline void set_allocated_playerid(::std::string* playerid);

  // optional float result = 40;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 40;
  inline float result() const;
  inline void set_result(float value);

  // optional .fantasybit.Stats stats = 50;
  inline bool has_stats() const;
  inline void clear_stats();
  static const int kStatsFieldNumber = 50;
  inline const ::fantasybit::Stats& stats() const;
  inline ::fantasybit::Stats* mutable_stats();
  inline ::fantasybit::Stats* release_stats();
  inline void set_allocated_stats(::fantasybit::Stats* stats);

  // optional string gameid = 60;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameidFieldNumber = 60;
  inline const ::std::string& gameid() const;
  inline void set_gameid(const ::std::string& value);
  inline void set_gameid(const char* value);
  inline void set_gameid(const char* value, size_t size);
  inline ::std::string* mutable_gameid();
  inline ::std::string* release_gameid();
  inline void set_allocated_gameid(::std::string* gameid);

  // @@protoc_insertion_point(class_scope:fantasybit.PlayerGameStats)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_stats();
  inline void clear_has_stats();
  inline void set_has_gameid();
  inline void clear_has_gameid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* playerid_;
  ::fantasybit::Stats* stats_;
  ::std::string* gameid_;
  float result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static PlayerGameStats* default_instance_;
};
// -------------------------------------------------------------------

class AwardMeta : public ::google::protobuf::Message {
 public:
  AwardMeta();
  virtual ~AwardMeta();

  AwardMeta(const AwardMeta& from);

  inline AwardMeta& operator=(const AwardMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AwardMeta& default_instance();

  void Swap(AwardMeta* other);

  // implements Message ----------------------------------------------

  AwardMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AwardMeta& from);
  void MergeFrom(const AwardMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 10;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 10;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 proj = 20;
  inline bool has_proj() const;
  inline void clear_proj();
  static const int kProjFieldNumber = 20;
  inline ::google::protobuf::int32 proj() const;
  inline void set_proj(::google::protobuf::int32 value);

  // optional uint64 award = 30;
  inline bool has_award() const;
  inline void clear_award();
  static const int kAwardFieldNumber = 30;
  inline ::google::protobuf::uint64 award() const;
  inline void set_award(::google::protobuf::uint64 value);

  // optional bytes projmetaid = 40;
  inline bool has_projmetaid() const;
  inline void clear_projmetaid();
  static const int kProjmetaidFieldNumber = 40;
  inline const ::std::string& projmetaid() const;
  inline void set_projmetaid(const ::std::string& value);
  inline void set_projmetaid(const char* value);
  inline void set_projmetaid(const void* value, size_t size);
  inline ::std::string* mutable_projmetaid();
  inline ::std::string* release_projmetaid();
  inline void set_allocated_projmetaid(::std::string* projmetaid);

  // optional bytes playergamestatsid = 50;
  inline bool has_playergamestatsid() const;
  inline void clear_playergamestatsid();
  static const int kPlayergamestatsidFieldNumber = 50;
  inline const ::std::string& playergamestatsid() const;
  inline void set_playergamestatsid(const ::std::string& value);
  inline void set_playergamestatsid(const char* value);
  inline void set_playergamestatsid(const void* value, size_t size);
  inline ::std::string* mutable_playergamestatsid();
  inline ::std::string* release_playergamestatsid();
  inline void set_allocated_playergamestatsid(::std::string* playergamestatsid);

  // @@protoc_insertion_point(class_scope:fantasybit.AwardMeta)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_proj();
  inline void clear_has_proj();
  inline void set_has_award();
  inline void clear_has_award();
  inline void set_has_projmetaid();
  inline void clear_has_projmetaid();
  inline void set_has_playergamestatsid();
  inline void clear_has_playergamestatsid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint64 award_;
  ::std::string* projmetaid_;
  ::std::string* playergamestatsid_;
  ::google::protobuf::int32 proj_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static AwardMeta* default_instance_;
};
// -------------------------------------------------------------------

class PnlMeta : public ::google::protobuf::Message {
 public:
  PnlMeta();
  virtual ~PnlMeta();

  PnlMeta(const PnlMeta& from);

  inline PnlMeta& operator=(const PnlMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PnlMeta& default_instance();

  void Swap(PnlMeta* other);

  // implements Message ----------------------------------------------

  PnlMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PnlMeta& from);
  void MergeFrom(const PnlMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 10;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 10;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 qty = 20;
  inline bool has_qty() const;
  inline void clear_qty();
  static const int kQtyFieldNumber = 20;
  inline ::google::protobuf::int32 qty() const;
  inline void set_qty(::google::protobuf::int32 value);

  // optional int32 price = 30;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 30;
  inline ::google::protobuf::int32 price() const;
  inline void set_price(::google::protobuf::int32 value);

  // optional int64 pnl = 40;
  inline bool has_pnl() const;
  inline void clear_pnl();
  static const int kPnlFieldNumber = 40;
  inline ::google::protobuf::int64 pnl() const;
  inline void set_pnl(::google::protobuf::int64 value);

  // optional bytes posmetaid = 50;
  inline bool has_posmetaid() const;
  inline void clear_posmetaid();
  static const int kPosmetaidFieldNumber = 50;
  inline const ::std::string& posmetaid() const;
  inline void set_posmetaid(const ::std::string& value);
  inline void set_posmetaid(const char* value);
  inline void set_posmetaid(const void* value, size_t size);
  inline ::std::string* mutable_posmetaid();
  inline ::std::string* release_posmetaid();
  inline void set_allocated_posmetaid(::std::string* posmetaid);

  // optional bytes playergamestatsid = 60;
  inline bool has_playergamestatsid() const;
  inline void clear_playergamestatsid();
  static const int kPlayergamestatsidFieldNumber = 60;
  inline const ::std::string& playergamestatsid() const;
  inline void set_playergamestatsid(const ::std::string& value);
  inline void set_playergamestatsid(const char* value);
  inline void set_playergamestatsid(const void* value, size_t size);
  inline ::std::string* mutable_playergamestatsid();
  inline ::std::string* release_playergamestatsid();
  inline void set_allocated_playergamestatsid(::std::string* playergamestatsid);

  // @@protoc_insertion_point(class_scope:fantasybit.PnlMeta)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_qty();
  inline void clear_has_qty();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_pnl();
  inline void clear_has_pnl();
  inline void set_has_posmetaid();
  inline void clear_has_posmetaid();
  inline void set_has_playergamestatsid();
  inline void clear_has_playergamestatsid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::int32 qty_;
  ::google::protobuf::int32 price_;
  ::google::protobuf::int64 pnl_;
  ::std::string* posmetaid_;
  ::std::string* playergamestatsid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static PnlMeta* default_instance_;
};
// -------------------------------------------------------------------

class PlayerMarketState : public ::google::protobuf::Message {
 public:
  PlayerMarketState();
  virtual ~PlayerMarketState();

  PlayerMarketState(const PlayerMarketState& from);

  inline PlayerMarketState& operator=(const PlayerMarketState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerMarketState& default_instance();

  void Swap(PlayerMarketState* other);

  // implements Message ----------------------------------------------

  PlayerMarketState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerMarketState& from);
  void MergeFrom(const PlayerMarketState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes limitbookmetaid = 10;
  inline bool has_limitbookmetaid() const;
  inline void clear_limitbookmetaid();
  static const int kLimitbookmetaidFieldNumber = 10;
  inline const ::std::string& limitbookmetaid() const;
  inline void set_limitbookmetaid(const ::std::string& value);
  inline void set_limitbookmetaid(const char* value);
  inline void set_limitbookmetaid(const void* value, size_t size);
  inline ::std::string* mutable_limitbookmetaid();
  inline ::std::string* release_limitbookmetaid();
  inline void set_allocated_limitbookmetaid(::std::string* limitbookmetaid);

  // optional string playerid = 20;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 20;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  inline void set_allocated_playerid(::std::string* playerid);

  // optional bytes marketticmetaid = 30;
  inline bool has_marketticmetaid() const;
  inline void clear_marketticmetaid();
  static const int kMarketticmetaidFieldNumber = 30;
  inline const ::std::string& marketticmetaid() const;
  inline void set_marketticmetaid(const ::std::string& value);
  inline void set_marketticmetaid(const char* value);
  inline void set_marketticmetaid(const void* value, size_t size);
  inline ::std::string* mutable_marketticmetaid();
  inline ::std::string* release_marketticmetaid();
  inline void set_allocated_marketticmetaid(::std::string* marketticmetaid);

  // optional bool locked = 31;
  inline bool has_locked() const;
  inline void clear_locked();
  static const int kLockedFieldNumber = 31;
  inline bool locked() const;
  inline void set_locked(bool value);

  // optional bytes prev = 40;
  inline bool has_prev() const;
  inline void clear_prev();
  static const int kPrevFieldNumber = 40;
  inline const ::std::string& prev() const;
  inline void set_prev(const ::std::string& value);
  inline void set_prev(const char* value);
  inline void set_prev(const void* value, size_t size);
  inline ::std::string* mutable_prev();
  inline ::std::string* release_prev();
  inline void set_allocated_prev(::std::string* prev);

  // optional bytes next = 50;
  inline bool has_next() const;
  inline void clear_next();
  static const int kNextFieldNumber = 50;
  inline const ::std::string& next() const;
  inline void set_next(const ::std::string& value);
  inline void set_next(const char* value);
  inline void set_next(const void* value, size_t size);
  inline ::std::string* mutable_next();
  inline ::std::string* release_next();
  inline void set_allocated_next(::std::string* next);

  // @@protoc_insertion_point(class_scope:fantasybit.PlayerMarketState)
 private:
  inline void set_has_limitbookmetaid();
  inline void clear_has_limitbookmetaid();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_marketticmetaid();
  inline void clear_has_marketticmetaid();
  inline void set_has_locked();
  inline void clear_has_locked();
  inline void set_has_prev();
  inline void clear_has_prev();
  inline void set_has_next();
  inline void clear_has_next();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* limitbookmetaid_;
  ::std::string* playerid_;
  ::std::string* marketticmetaid_;
  ::std::string* prev_;
  ::std::string* next_;
  bool locked_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static PlayerMarketState* default_instance_;
};
// -------------------------------------------------------------------

class LimitBookMeta : public ::google::protobuf::Message {
 public:
  LimitBookMeta();
  virtual ~LimitBookMeta();

  LimitBookMeta(const LimitBookMeta& from);

  inline LimitBookMeta& operator=(const LimitBookMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LimitBookMeta& default_instance();

  void Swap(LimitBookMeta* other);

  // implements Message ----------------------------------------------

  LimitBookMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LimitBookMeta& from);
  void MergeFrom(const LimitBookMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 bid = 10;
  inline bool has_bid() const;
  inline void clear_bid();
  static const int kBidFieldNumber = 10;
  inline ::google::protobuf::int32 bid() const;
  inline void set_bid(::google::protobuf::int32 value);

  // optional int32 bidsize = 20;
  inline bool has_bidsize() const;
  inline void clear_bidsize();
  static const int kBidsizeFieldNumber = 20;
  inline ::google::protobuf::int32 bidsize() const;
  inline void set_bidsize(::google::protobuf::int32 value);

  // optional int32 asksize = 30;
  inline bool has_asksize() const;
  inline void clear_asksize();
  static const int kAsksizeFieldNumber = 30;
  inline ::google::protobuf::int32 asksize() const;
  inline void set_asksize(::google::protobuf::int32 value);

  // optional int32 ask = 40;
  inline bool has_ask() const;
  inline void clear_ask();
  static const int kAskFieldNumber = 40;
  inline ::google::protobuf::int32 ask() const;
  inline void set_ask(::google::protobuf::int32 value);

  // optional bytes bidordermetaroot = 50;
  inline bool has_bidordermetaroot() const;
  inline void clear_bidordermetaroot();
  static const int kBidordermetarootFieldNumber = 50;
  inline const ::std::string& bidordermetaroot() const;
  inline void set_bidordermetaroot(const ::std::string& value);
  inline void set_bidordermetaroot(const char* value);
  inline void set_bidordermetaroot(const void* value, size_t size);
  inline ::std::string* mutable_bidordermetaroot();
  inline ::std::string* release_bidordermetaroot();
  inline void set_allocated_bidordermetaroot(::std::string* bidordermetaroot);

  // optional bytes askordermetaroot = 60;
  inline bool has_askordermetaroot() const;
  inline void clear_askordermetaroot();
  static const int kAskordermetarootFieldNumber = 60;
  inline const ::std::string& askordermetaroot() const;
  inline void set_askordermetaroot(const ::std::string& value);
  inline void set_askordermetaroot(const char* value);
  inline void set_askordermetaroot(const void* value, size_t size);
  inline ::std::string* mutable_askordermetaroot();
  inline ::std::string* release_askordermetaroot();
  inline void set_allocated_askordermetaroot(::std::string* askordermetaroot);

  // @@protoc_insertion_point(class_scope:fantasybit.LimitBookMeta)
 private:
  inline void set_has_bid();
  inline void clear_has_bid();
  inline void set_has_bidsize();
  inline void clear_has_bidsize();
  inline void set_has_asksize();
  inline void clear_has_asksize();
  inline void set_has_ask();
  inline void clear_has_ask();
  inline void set_has_bidordermetaroot();
  inline void clear_has_bidordermetaroot();
  inline void set_has_askordermetaroot();
  inline void clear_has_askordermetaroot();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 bid_;
  ::google::protobuf::int32 bidsize_;
  ::google::protobuf::int32 asksize_;
  ::google::protobuf::int32 ask_;
  ::std::string* bidordermetaroot_;
  ::std::string* askordermetaroot_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static LimitBookMeta* default_instance_;
};
// -------------------------------------------------------------------

class MarketTicMeta : public ::google::protobuf::Message {
 public:
  MarketTicMeta();
  virtual ~MarketTicMeta();

  MarketTicMeta(const MarketTicMeta& from);

  inline MarketTicMeta& operator=(const MarketTicMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketTicMeta& default_instance();

  void Swap(MarketTicMeta* other);

  // implements Message ----------------------------------------------

  MarketTicMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MarketTicMeta& from);
  void MergeFrom(const MarketTicMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 price = 20;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 20;
  inline ::google::protobuf::int32 price() const;
  inline void set_price(::google::protobuf::int32 value);

  // optional int32 size = 30;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 30;
  inline ::google::protobuf::int32 size() const;
  inline void set_size(::google::protobuf::int32 value);

  // optional bytes orderfillhead = 40;
  inline bool has_orderfillhead() const;
  inline void clear_orderfillhead();
  static const int kOrderfillheadFieldNumber = 40;
  inline const ::std::string& orderfillhead() const;
  inline void set_orderfillhead(const ::std::string& value);
  inline void set_orderfillhead(const char* value);
  inline void set_orderfillhead(const void* value, size_t size);
  inline ::std::string* mutable_orderfillhead();
  inline ::std::string* release_orderfillhead();
  inline void set_allocated_orderfillhead(::std::string* orderfillhead);

  // optional bytes prev = 50;
  inline bool has_prev() const;
  inline void clear_prev();
  static const int kPrevFieldNumber = 50;
  inline const ::std::string& prev() const;
  inline void set_prev(const ::std::string& value);
  inline void set_prev(const char* value);
  inline void set_prev(const void* value, size_t size);
  inline ::std::string* mutable_prev();
  inline ::std::string* release_prev();
  inline void set_allocated_prev(::std::string* prev);

  // @@protoc_insertion_point(class_scope:fantasybit.MarketTicMeta)
 private:
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_orderfillhead();
  inline void clear_has_orderfillhead();
  inline void set_has_prev();
  inline void clear_has_prev();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 price_;
  ::google::protobuf::int32 size_;
  ::std::string* orderfillhead_;
  ::std::string* prev_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static MarketTicMeta* default_instance_;
};
// -------------------------------------------------------------------

class OrderMeta : public ::google::protobuf::Message {
 public:
  OrderMeta();
  virtual ~OrderMeta();

  OrderMeta(const OrderMeta& from);

  inline OrderMeta& operator=(const OrderMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OrderMeta& default_instance();

  void Swap(OrderMeta* other);

  // implements Message ----------------------------------------------

  OrderMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OrderMeta& from);
  void MergeFrom(const OrderMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 refnum = 1;
  inline bool has_refnum() const;
  inline void clear_refnum();
  static const int kRefnumFieldNumber = 1;
  inline ::google::protobuf::int32 refnum() const;
  inline void set_refnum(::google::protobuf::int32 value);

  // optional string fname = 10;
  inline bool has_fname() const;
  inline void clear_fname();
  static const int kFnameFieldNumber = 10;
  inline const ::std::string& fname() const;
  inline void set_fname(const ::std::string& value);
  inline void set_fname(const char* value);
  inline void set_fname(const char* value, size_t size);
  inline ::std::string* mutable_fname();
  inline ::std::string* release_fname();
  inline void set_allocated_fname(::std::string* fname);

  // optional string playerid = 20;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 20;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  inline void set_allocated_playerid(::std::string* playerid);

  // optional bool buyside = 30;
  inline bool has_buyside() const;
  inline void clear_buyside();
  static const int kBuysideFieldNumber = 30;
  inline bool buyside() const;
  inline void set_buyside(bool value);

  // optional int32 size = 40;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 40;
  inline ::google::protobuf::int32 size() const;
  inline void set_size(::google::protobuf::int32 value);

  // optional int32 price = 50;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 50;
  inline ::google::protobuf::int32 price() const;
  inline void set_price(::google::protobuf::int32 value);

  // optional bytes txmetaid = 60;
  inline bool has_txmetaid() const;
  inline void clear_txmetaid();
  static const int kTxmetaidFieldNumber = 60;
  inline const ::std::string& txmetaid() const;
  inline void set_txmetaid(const ::std::string& value);
  inline void set_txmetaid(const char* value);
  inline void set_txmetaid(const void* value, size_t size);
  inline ::std::string* mutable_txmetaid();
  inline ::std::string* release_txmetaid();
  inline void set_allocated_txmetaid(::std::string* txmetaid);

  // optional bytes orderfillmetaid = 70;
  inline bool has_orderfillmetaid() const;
  inline void clear_orderfillmetaid();
  static const int kOrderfillmetaidFieldNumber = 70;
  inline const ::std::string& orderfillmetaid() const;
  inline void set_orderfillmetaid(const ::std::string& value);
  inline void set_orderfillmetaid(const char* value);
  inline void set_orderfillmetaid(const void* value, size_t size);
  inline ::std::string* mutable_orderfillmetaid();
  inline ::std::string* release_orderfillmetaid();
  inline void set_allocated_orderfillmetaid(::std::string* orderfillmetaid);

  // optional int32 timestamp = 75;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 75;
  inline ::google::protobuf::int32 timestamp() const;
  inline void set_timestamp(::google::protobuf::int32 value);

  // optional bytes prev = 80;
  inline bool has_prev() const;
  inline void clear_prev();
  static const int kPrevFieldNumber = 80;
  inline const ::std::string& prev() const;
  inline void set_prev(const ::std::string& value);
  inline void set_prev(const char* value);
  inline void set_prev(const void* value, size_t size);
  inline ::std::string* mutable_prev();
  inline ::std::string* release_prev();
  inline void set_allocated_prev(::std::string* prev);

  // @@protoc_insertion_point(class_scope:fantasybit.OrderMeta)
 private:
  inline void set_has_refnum();
  inline void clear_has_refnum();
  inline void set_has_fname();
  inline void clear_has_fname();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_buyside();
  inline void clear_has_buyside();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_txmetaid();
  inline void clear_has_txmetaid();
  inline void set_has_orderfillmetaid();
  inline void clear_has_orderfillmetaid();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_prev();
  inline void clear_has_prev();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* fname_;
  ::google::protobuf::int32 refnum_;
  bool buyside_;
  ::std::string* playerid_;
  ::google::protobuf::int32 size_;
  ::google::protobuf::int32 price_;
  ::std::string* txmetaid_;
  ::std::string* orderfillmetaid_;
  ::std::string* prev_;
  ::google::protobuf::int32 timestamp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static OrderMeta* default_instance_;
};
// -------------------------------------------------------------------

class OrderFillMeta : public ::google::protobuf::Message {
 public:
  OrderFillMeta();
  virtual ~OrderFillMeta();

  OrderFillMeta(const OrderFillMeta& from);

  inline OrderFillMeta& operator=(const OrderFillMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OrderFillMeta& default_instance();

  void Swap(OrderFillMeta* other);

  // implements Message ----------------------------------------------

  OrderFillMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OrderFillMeta& from);
  void MergeFrom(const OrderFillMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 refnum = 1;
  inline bool has_refnum() const;
  inline void clear_refnum();
  static const int kRefnumFieldNumber = 1;
  inline ::google::protobuf::int32 refnum() const;
  inline void set_refnum(::google::protobuf::int32 value);

  // optional string fname = 10;
  inline bool has_fname() const;
  inline void clear_fname();
  static const int kFnameFieldNumber = 10;
  inline const ::std::string& fname() const;
  inline void set_fname(const ::std::string& value);
  inline void set_fname(const char* value);
  inline void set_fname(const char* value, size_t size);
  inline ::std::string* mutable_fname();
  inline ::std::string* release_fname();
  inline void set_allocated_fname(::std::string* fname);

  // optional string playerid = 15;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 15;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  inline void set_allocated_playerid(::std::string* playerid);

  // optional int32 fillprice = 20;
  inline bool has_fillprice() const;
  inline void clear_fillprice();
  static const int kFillpriceFieldNumber = 20;
  inline ::google::protobuf::int32 fillprice() const;
  inline void set_fillprice(::google::protobuf::int32 value);

  // optional int32 fillsize = 30;
  inline bool has_fillsize() const;
  inline void clear_fillsize();
  static const int kFillsizeFieldNumber = 30;
  inline ::google::protobuf::int32 fillsize() const;
  inline void set_fillsize(::google::protobuf::int32 value);

  // optional bool buyside = 35;
  inline bool has_buyside() const;
  inline void clear_buyside();
  static const int kBuysideFieldNumber = 35;
  inline bool buyside() const;
  inline void set_buyside(bool value);

  // optional uint64 timestamp = 40;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 40;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);

  // optional bytes txmetaid = 60;
  inline bool has_txmetaid() const;
  inline void clear_txmetaid();
  static const int kTxmetaidFieldNumber = 60;
  inline const ::std::string& txmetaid() const;
  inline void set_txmetaid(const ::std::string& value);
  inline void set_txmetaid(const char* value);
  inline void set_txmetaid(const void* value, size_t size);
  inline ::std::string* mutable_txmetaid();
  inline ::std::string* release_txmetaid();
  inline void set_allocated_txmetaid(::std::string* txmetaid);

  // optional bytes prev = 70;
  inline bool has_prev() const;
  inline void clear_prev();
  static const int kPrevFieldNumber = 70;
  inline const ::std::string& prev() const;
  inline void set_prev(const ::std::string& value);
  inline void set_prev(const char* value);
  inline void set_prev(const void* value, size_t size);
  inline ::std::string* mutable_prev();
  inline ::std::string* release_prev();
  inline void set_allocated_prev(::std::string* prev);

  // @@protoc_insertion_point(class_scope:fantasybit.OrderFillMeta)
 private:
  inline void set_has_refnum();
  inline void clear_has_refnum();
  inline void set_has_fname();
  inline void clear_has_fname();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_fillprice();
  inline void clear_has_fillprice();
  inline void set_has_fillsize();
  inline void clear_has_fillsize();
  inline void set_has_buyside();
  inline void clear_has_buyside();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_txmetaid();
  inline void clear_has_txmetaid();
  inline void set_has_prev();
  inline void clear_has_prev();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* fname_;
  ::google::protobuf::int32 refnum_;
  ::google::protobuf::int32 fillprice_;
  ::std::string* playerid_;
  ::google::protobuf::int32 fillsize_;
  bool buyside_;
  ::google::protobuf::uint64 timestamp_;
  ::std::string* txmetaid_;
  ::std::string* prev_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static OrderFillMeta* default_instance_;
};
// -------------------------------------------------------------------

class GlobalStateMeta : public ::google::protobuf::Message {
 public:
  GlobalStateMeta();
  virtual ~GlobalStateMeta();

  GlobalStateMeta(const GlobalStateMeta& from);

  inline GlobalStateMeta& operator=(const GlobalStateMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GlobalStateMeta& default_instance();

  void Swap(GlobalStateMeta* other);

  // implements Message ----------------------------------------------

  GlobalStateMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GlobalStateMeta& from);
  void MergeFrom(const GlobalStateMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .fantasybit.GlobalState globalstate = 10;
  inline bool has_globalstate() const;
  inline void clear_globalstate();
  static const int kGlobalstateFieldNumber = 10;
  inline const ::fantasybit::GlobalState& globalstate() const;
  inline ::fantasybit::GlobalState* mutable_globalstate();
  inline ::fantasybit::GlobalState* release_globalstate();
  inline void set_allocated_globalstate(::fantasybit::GlobalState* globalstate);

  // optional bytes trmetaid = 20;
  inline bool has_trmetaid() const;
  inline void clear_trmetaid();
  static const int kTrmetaidFieldNumber = 20;
  inline const ::std::string& trmetaid() const;
  inline void set_trmetaid(const ::std::string& value);
  inline void set_trmetaid(const char* value);
  inline void set_trmetaid(const void* value, size_t size);
  inline ::std::string* mutable_trmetaid();
  inline ::std::string* release_trmetaid();
  inline void set_allocated_trmetaid(::std::string* trmetaid);

  // optional bytes prev = 30;
  inline bool has_prev() const;
  inline void clear_prev();
  static const int kPrevFieldNumber = 30;
  inline const ::std::string& prev() const;
  inline void set_prev(const ::std::string& value);
  inline void set_prev(const char* value);
  inline void set_prev(const void* value, size_t size);
  inline ::std::string* mutable_prev();
  inline ::std::string* release_prev();
  inline void set_allocated_prev(::std::string* prev);

  // optional bytes next = 40;
  inline bool has_next() const;
  inline void clear_next();
  static const int kNextFieldNumber = 40;
  inline const ::std::string& next() const;
  inline void set_next(const ::std::string& value);
  inline void set_next(const char* value);
  inline void set_next(const void* value, size_t size);
  inline ::std::string* mutable_next();
  inline ::std::string* release_next();
  inline void set_allocated_next(::std::string* next);

  // @@protoc_insertion_point(class_scope:fantasybit.GlobalStateMeta)
 private:
  inline void set_has_globalstate();
  inline void clear_has_globalstate();
  inline void set_has_trmetaid();
  inline void clear_has_trmetaid();
  inline void set_has_prev();
  inline void clear_has_prev();
  inline void set_has_next();
  inline void clear_has_next();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::fantasybit::GlobalState* globalstate_;
  ::std::string* trmetaid_;
  ::std::string* prev_;
  ::std::string* next_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static GlobalStateMeta* default_instance_;
};
// -------------------------------------------------------------------

class PlayerMeta : public ::google::protobuf::Message {
 public:
  PlayerMeta();
  virtual ~PlayerMeta();

  PlayerMeta(const PlayerMeta& from);

  inline PlayerMeta& operator=(const PlayerMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerMeta& default_instance();

  void Swap(PlayerMeta* other);

  // implements Message ----------------------------------------------

  PlayerMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerMeta& from);
  void MergeFrom(const PlayerMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string playerid = 10;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 10;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  inline void set_allocated_playerid(::std::string* playerid);

  // optional .fantasybit.PlayerBase player_base = 20;
  inline bool has_player_base() const;
  inline void clear_player_base();
  static const int kPlayerBaseFieldNumber = 20;
  inline const ::fantasybit::PlayerBase& player_base() const;
  inline ::fantasybit::PlayerBase* mutable_player_base();
  inline ::fantasybit::PlayerBase* release_player_base();
  inline void set_allocated_player_base(::fantasybit::PlayerBase* player_base);

  // optional .fantasybit.PlayerStatus player_status = 30;
  inline bool has_player_status() const;
  inline void clear_player_status();
  static const int kPlayerStatusFieldNumber = 30;
  inline const ::fantasybit::PlayerStatus& player_status() const;
  inline ::fantasybit::PlayerStatus* mutable_player_status();
  inline ::fantasybit::PlayerStatus* release_player_status();
  inline void set_allocated_player_status(::fantasybit::PlayerStatus* player_status);

  // optional bytes datametaid = 40;
  inline bool has_datametaid() const;
  inline void clear_datametaid();
  static const int kDatametaidFieldNumber = 40;
  inline const ::std::string& datametaid() const;
  inline void set_datametaid(const ::std::string& value);
  inline void set_datametaid(const char* value);
  inline void set_datametaid(const void* value, size_t size);
  inline ::std::string* mutable_datametaid();
  inline ::std::string* release_datametaid();
  inline void set_allocated_datametaid(::std::string* datametaid);

  // optional bytes prev = 50;
  inline bool has_prev() const;
  inline void clear_prev();
  static const int kPrevFieldNumber = 50;
  inline const ::std::string& prev() const;
  inline void set_prev(const ::std::string& value);
  inline void set_prev(const char* value);
  inline void set_prev(const void* value, size_t size);
  inline ::std::string* mutable_prev();
  inline ::std::string* release_prev();
  inline void set_allocated_prev(::std::string* prev);

  // @@protoc_insertion_point(class_scope:fantasybit.PlayerMeta)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_player_base();
  inline void clear_has_player_base();
  inline void set_has_player_status();
  inline void clear_has_player_status();
  inline void set_has_datametaid();
  inline void clear_has_datametaid();
  inline void set_has_prev();
  inline void clear_has_prev();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* playerid_;
  ::fantasybit::PlayerBase* player_base_;
  ::fantasybit::PlayerStatus* player_status_;
  ::std::string* datametaid_;
  ::std::string* prev_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static PlayerMeta* default_instance_;
};
// -------------------------------------------------------------------

class TeamMeta : public ::google::protobuf::Message {
 public:
  TeamMeta();
  virtual ~TeamMeta();

  TeamMeta(const TeamMeta& from);

  inline TeamMeta& operator=(const TeamMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TeamMeta& default_instance();

  void Swap(TeamMeta* other);

  // implements Message ----------------------------------------------

  TeamMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TeamMeta& from);
  void MergeFrom(const TeamMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string teamid = 10;
  inline bool has_teamid() const;
  inline void clear_teamid();
  static const int kTeamidFieldNumber = 10;
  inline const ::std::string& teamid() const;
  inline void set_teamid(const ::std::string& value);
  inline void set_teamid(const char* value);
  inline void set_teamid(const char* value, size_t size);
  inline ::std::string* mutable_teamid();
  inline ::std::string* release_teamid();
  inline void set_allocated_teamid(::std::string* teamid);

  // optional bytes playermetaidroot = 20;
  inline bool has_playermetaidroot() const;
  inline void clear_playermetaidroot();
  static const int kPlayermetaidrootFieldNumber = 20;
  inline const ::std::string& playermetaidroot() const;
  inline void set_playermetaidroot(const ::std::string& value);
  inline void set_playermetaidroot(const char* value);
  inline void set_playermetaidroot(const void* value, size_t size);
  inline ::std::string* mutable_playermetaidroot();
  inline ::std::string* release_playermetaidroot();
  inline void set_allocated_playermetaidroot(::std::string* playermetaidroot);

  // optional bytes prev = 30;
  inline bool has_prev() const;
  inline void clear_prev();
  static const int kPrevFieldNumber = 30;
  inline const ::std::string& prev() const;
  inline void set_prev(const ::std::string& value);
  inline void set_prev(const char* value);
  inline void set_prev(const void* value, size_t size);
  inline ::std::string* mutable_prev();
  inline ::std::string* release_prev();
  inline void set_allocated_prev(::std::string* prev);

  // @@protoc_insertion_point(class_scope:fantasybit.TeamMeta)
 private:
  inline void set_has_teamid();
  inline void clear_has_teamid();
  inline void set_has_playermetaidroot();
  inline void clear_has_playermetaidroot();
  inline void set_has_prev();
  inline void clear_has_prev();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* teamid_;
  ::std::string* playermetaidroot_;
  ::std::string* prev_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static TeamMeta* default_instance_;
};
// -------------------------------------------------------------------

class pbstate : public ::google::protobuf::Message {
 public:
  pbstate();
  virtual ~pbstate();

  pbstate(const pbstate& from);

  inline pbstate& operator=(const pbstate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const pbstate& default_instance();

  void Swap(pbstate* other);

  // implements Message ----------------------------------------------

  pbstate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbstate& from);
  void MergeFrom(const pbstate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes schedulestateid = 10;
  inline bool has_schedulestateid() const;
  inline void clear_schedulestateid();
  static const int kSchedulestateidFieldNumber = 10;
  inline const ::std::string& schedulestateid() const;
  inline void set_schedulestateid(const ::std::string& value);
  inline void set_schedulestateid(const char* value);
  inline void set_schedulestateid(const void* value, size_t size);
  inline ::std::string* mutable_schedulestateid();
  inline ::std::string* release_schedulestateid();
  inline void set_allocated_schedulestateid(::std::string* schedulestateid);

  // optional bytes leaderboardstateid = 20;
  inline bool has_leaderboardstateid() const;
  inline void clear_leaderboardstateid();
  static const int kLeaderboardstateidFieldNumber = 20;
  inline const ::std::string& leaderboardstateid() const;
  inline void set_leaderboardstateid(const ::std::string& value);
  inline void set_leaderboardstateid(const char* value);
  inline void set_leaderboardstateid(const void* value, size_t size);
  inline ::std::string* mutable_leaderboardstateid();
  inline ::std::string* release_leaderboardstateid();
  inline void set_allocated_leaderboardstateid(::std::string* leaderboardstateid);

  // optional bytes projstateid = 30;
  inline bool has_projstateid() const;
  inline void clear_projstateid();
  static const int kProjstateidFieldNumber = 30;
  inline const ::std::string& projstateid() const;
  inline void set_projstateid(const ::std::string& value);
  inline void set_projstateid(const char* value);
  inline void set_projstateid(const void* value, size_t size);
  inline ::std::string* mutable_projstateid();
  inline ::std::string* release_projstateid();
  inline void set_allocated_projstateid(::std::string* projstateid);

  // optional bytes posstateid = 35;
  inline bool has_posstateid() const;
  inline void clear_posstateid();
  static const int kPosstateidFieldNumber = 35;
  inline const ::std::string& posstateid() const;
  inline void set_posstateid(const ::std::string& value);
  inline void set_posstateid(const char* value);
  inline void set_posstateid(const void* value, size_t size);
  inline ::std::string* mutable_posstateid();
  inline ::std::string* release_posstateid();
  inline void set_allocated_posstateid(::std::string* posstateid);

  // optional bytes orderstateid = 40;
  inline bool has_orderstateid() const;
  inline void clear_orderstateid();
  static const int kOrderstateidFieldNumber = 40;
  inline const ::std::string& orderstateid() const;
  inline void set_orderstateid(const ::std::string& value);
  inline void set_orderstateid(const char* value);
  inline void set_orderstateid(const void* value, size_t size);
  inline ::std::string* mutable_orderstateid();
  inline ::std::string* release_orderstateid();
  inline void set_allocated_orderstateid(::std::string* orderstateid);

  // optional bytes marketstateid = 50;
  inline bool has_marketstateid() const;
  inline void clear_marketstateid();
  static const int kMarketstateidFieldNumber = 50;
  inline const ::std::string& marketstateid() const;
  inline void set_marketstateid(const ::std::string& value);
  inline void set_marketstateid(const char* value);
  inline void set_marketstateid(const void* value, size_t size);
  inline ::std::string* mutable_marketstateid();
  inline ::std::string* release_marketstateid();
  inline void set_allocated_marketstateid(::std::string* marketstateid);

  // optional bytes globalstateid = 60;
  inline bool has_globalstateid() const;
  inline void clear_globalstateid();
  static const int kGlobalstateidFieldNumber = 60;
  inline const ::std::string& globalstateid() const;
  inline void set_globalstateid(const ::std::string& value);
  inline void set_globalstateid(const char* value);
  inline void set_globalstateid(const void* value, size_t size);
  inline ::std::string* mutable_globalstateid();
  inline ::std::string* release_globalstateid();
  inline void set_allocated_globalstateid(::std::string* globalstateid);

  // optional bytes teamstatemid = 70;
  inline bool has_teamstatemid() const;
  inline void clear_teamstatemid();
  static const int kTeamstatemidFieldNumber = 70;
  inline const ::std::string& teamstatemid() const;
  inline void set_teamstatemid(const ::std::string& value);
  inline void set_teamstatemid(const char* value);
  inline void set_teamstatemid(const void* value, size_t size);
  inline ::std::string* mutable_teamstatemid();
  inline ::std::string* release_teamstatemid();
  inline void set_allocated_teamstatemid(::std::string* teamstatemid);

  // optional bytes fantasynamestateid = 80;
  inline bool has_fantasynamestateid() const;
  inline void clear_fantasynamestateid();
  static const int kFantasynamestateidFieldNumber = 80;
  inline const ::std::string& fantasynamestateid() const;
  inline void set_fantasynamestateid(const ::std::string& value);
  inline void set_fantasynamestateid(const char* value);
  inline void set_fantasynamestateid(const void* value, size_t size);
  inline ::std::string* mutable_fantasynamestateid();
  inline ::std::string* release_fantasynamestateid();
  inline void set_allocated_fantasynamestateid(::std::string* fantasynamestateid);

  // @@protoc_insertion_point(class_scope:fantasybit.pbstate)
 private:
  inline void set_has_schedulestateid();
  inline void clear_has_schedulestateid();
  inline void set_has_leaderboardstateid();
  inline void clear_has_leaderboardstateid();
  inline void set_has_projstateid();
  inline void clear_has_projstateid();
  inline void set_has_posstateid();
  inline void clear_has_posstateid();
  inline void set_has_orderstateid();
  inline void clear_has_orderstateid();
  inline void set_has_marketstateid();
  inline void clear_has_marketstateid();
  inline void set_has_globalstateid();
  inline void clear_has_globalstateid();
  inline void set_has_teamstatemid();
  inline void clear_has_teamstatemid();
  inline void set_has_fantasynamestateid();
  inline void clear_has_fantasynamestateid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* schedulestateid_;
  ::std::string* leaderboardstateid_;
  ::std::string* projstateid_;
  ::std::string* posstateid_;
  ::std::string* orderstateid_;
  ::std::string* marketstateid_;
  ::std::string* globalstateid_;
  ::std::string* teamstatemid_;
  ::std::string* fantasynamestateid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static pbstate* default_instance_;
};
// -------------------------------------------------------------------

class MerkleTree : public ::google::protobuf::Message {
 public:
  MerkleTree();
  virtual ~MerkleTree();

  MerkleTree(const MerkleTree& from);

  inline MerkleTree& operator=(const MerkleTree& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MerkleTree& default_instance();

  void Swap(MerkleTree* other);

  // implements Message ----------------------------------------------

  MerkleTree* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MerkleTree& from);
  void MergeFrom(const MerkleTree& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes root = 10;
  inline bool has_root() const;
  inline void clear_root();
  static const int kRootFieldNumber = 10;
  inline const ::std::string& root() const;
  inline void set_root(const ::std::string& value);
  inline void set_root(const char* value);
  inline void set_root(const void* value, size_t size);
  inline ::std::string* mutable_root();
  inline ::std::string* release_root();
  inline void set_allocated_root(::std::string* root);

  // repeated bytes leaves = 20;
  inline int leaves_size() const;
  inline void clear_leaves();
  static const int kLeavesFieldNumber = 20;
  inline const ::std::string& leaves(int index) const;
  inline ::std::string* mutable_leaves(int index);
  inline void set_leaves(int index, const ::std::string& value);
  inline void set_leaves(int index, const char* value);
  inline void set_leaves(int index, const void* value, size_t size);
  inline ::std::string* add_leaves();
  inline void add_leaves(const ::std::string& value);
  inline void add_leaves(const char* value);
  inline void add_leaves(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& leaves() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_leaves();

  // @@protoc_insertion_point(class_scope:fantasybit.MerkleTree)
 private:
  inline void set_has_root();
  inline void clear_has_root();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* root_;
  ::google::protobuf::RepeatedPtrField< ::std::string> leaves_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static MerkleTree* default_instance_;
};
// -------------------------------------------------------------------

class NewPlayerModel : public ::google::protobuf::Message {
 public:
  NewPlayerModel();
  virtual ~NewPlayerModel();

  NewPlayerModel(const NewPlayerModel& from);

  inline NewPlayerModel& operator=(const NewPlayerModel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewPlayerModel& default_instance();

  void Swap(NewPlayerModel* other);

  // implements Message ----------------------------------------------

  NewPlayerModel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NewPlayerModel& from);
  void MergeFrom(const NewPlayerModel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .fantasybit.PlayerMeta players = 10;
  inline int players_size() const;
  inline void clear_players();
  static const int kPlayersFieldNumber = 10;
  inline const ::fantasybit::PlayerMeta& players(int index) const;
  inline ::fantasybit::PlayerMeta* mutable_players(int index);
  inline ::fantasybit::PlayerMeta* add_players();
  inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::PlayerMeta >&
      players() const;
  inline ::google::protobuf::RepeatedPtrField< ::fantasybit::PlayerMeta >*
      mutable_players();

  // @@protoc_insertion_point(class_scope:fantasybit.NewPlayerModel)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::fantasybit::PlayerMeta > players_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static NewPlayerModel* default_instance_;
};
// -------------------------------------------------------------------

class WsReq : public ::google::protobuf::Message {
 public:
  WsReq();
  virtual ~WsReq();

  WsReq(const WsReq& from);

  inline WsReq& operator=(const WsReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WsReq& default_instance();

  void Swap(WsReq* other);

  // implements Message ----------------------------------------------

  WsReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WsReq& from);
  void MergeFrom(const WsReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);

  // optional .fantasybit.CType ctype = 2;
  inline bool has_ctype() const;
  inline void clear_ctype();
  static const int kCtypeFieldNumber = 2;
  inline ::fantasybit::CType ctype() const;
  inline void set_ctype(::fantasybit::CType value);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(WsReq)
  // @@protoc_insertion_point(class_scope:fantasybit.WsReq)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_ctype();
  inline void clear_has_ctype();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 version_;
  int ctype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static WsReq* default_instance_;
};
// -------------------------------------------------------------------

class WSReply : public ::google::protobuf::Message {
 public:
  WSReply();
  virtual ~WSReply();

  WSReply(const WSReply& from);

  inline WSReply& operator=(const WSReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WSReply& default_instance();

  void Swap(WSReply* other);

  // implements Message ----------------------------------------------

  WSReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WSReply& from);
  void MergeFrom(const WSReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);

  // optional .fantasybit.CType ctype = 2;
  inline bool has_ctype() const;
  inline void clear_ctype();
  static const int kCtypeFieldNumber = 2;
  inline ::fantasybit::CType ctype() const;
  inline void set_ctype(::fantasybit::CType value);

  // optional .fantasybit.WsReq req = 20;
  inline bool has_req() const;
  inline void clear_req();
  static const int kReqFieldNumber = 20;
  inline const ::fantasybit::WsReq& req() const;
  inline ::fantasybit::WsReq* mutable_req();
  inline ::fantasybit::WsReq* release_req();
  inline void set_allocated_req(::fantasybit::WsReq* req);

  // optional string data = 30;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 30;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const char* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(WSReply)
  // @@protoc_insertion_point(class_scope:fantasybit.WSReply)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_ctype();
  inline void clear_has_ctype();
  inline void set_has_req();
  inline void clear_has_req();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 version_;
  int ctype_;
  ::fantasybit::WsReq* req_;
  ::std::string* data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static WSReply* default_instance_;
};
// -------------------------------------------------------------------

class GetGlobalStateRep : public ::google::protobuf::Message {
 public:
  GetGlobalStateRep();
  virtual ~GetGlobalStateRep();

  GetGlobalStateRep(const GetGlobalStateRep& from);

  inline GetGlobalStateRep& operator=(const GetGlobalStateRep& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetGlobalStateRep& default_instance();

  void Swap(GetGlobalStateRep* other);

  // implements Message ----------------------------------------------

  GetGlobalStateRep* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetGlobalStateRep& from);
  void MergeFrom(const GetGlobalStateRep& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .fantasybit.GlobalState globalstate = 10;
  inline bool has_globalstate() const;
  inline void clear_globalstate();
  static const int kGlobalstateFieldNumber = 10;
  inline const ::fantasybit::GlobalState& globalstate() const;
  inline ::fantasybit::GlobalState* mutable_globalstate();
  inline ::fantasybit::GlobalState* release_globalstate();
  inline void set_allocated_globalstate(::fantasybit::GlobalState* globalstate);

  static const int kRepFieldNumber = 900;
  static ::google::protobuf::internal::ExtensionIdentifier< ::fantasybit::WSReply,
      ::google::protobuf::internal::MessageTypeTraits< ::fantasybit::GetGlobalStateRep >, 11, false >
    rep;
  // @@protoc_insertion_point(class_scope:fantasybit.GetGlobalStateRep)
 private:
  inline void set_has_globalstate();
  inline void clear_has_globalstate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::fantasybit::GlobalState* globalstate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static GetGlobalStateRep* default_instance_;
};
// -------------------------------------------------------------------

class GetScheduleRep : public ::google::protobuf::Message {
 public:
  GetScheduleRep();
  virtual ~GetScheduleRep();

  GetScheduleRep(const GetScheduleRep& from);

  inline GetScheduleRep& operator=(const GetScheduleRep& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetScheduleRep& default_instance();

  void Swap(GetScheduleRep* other);

  // implements Message ----------------------------------------------

  GetScheduleRep* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetScheduleRep& from);
  void MergeFrom(const GetScheduleRep& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .fantasybit.ScheduleData scheduledata = 10;
  inline bool has_scheduledata() const;
  inline void clear_scheduledata();
  static const int kScheduledataFieldNumber = 10;
  inline const ::fantasybit::ScheduleData& scheduledata() const;
  inline ::fantasybit::ScheduleData* mutable_scheduledata();
  inline ::fantasybit::ScheduleData* release_scheduledata();
  inline void set_allocated_scheduledata(::fantasybit::ScheduleData* scheduledata);

  static const int kRepFieldNumber = 910;
  static ::google::protobuf::internal::ExtensionIdentifier< ::fantasybit::WSReply,
      ::google::protobuf::internal::MessageTypeTraits< ::fantasybit::GetScheduleRep >, 11, false >
    rep;
  // @@protoc_insertion_point(class_scope:fantasybit.GetScheduleRep)
 private:
  inline void set_has_scheduledata();
  inline void clear_has_scheduledata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::fantasybit::ScheduleData* scheduledata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static GetScheduleRep* default_instance_;
};
// -------------------------------------------------------------------

class CheckNameReq : public ::google::protobuf::Message {
 public:
  CheckNameReq();
  virtual ~CheckNameReq();

  CheckNameReq(const CheckNameReq& from);

  inline CheckNameReq& operator=(const CheckNameReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckNameReq& default_instance();

  void Swap(CheckNameReq* other);

  // implements Message ----------------------------------------------

  CheckNameReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CheckNameReq& from);
  void MergeFrom(const CheckNameReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string fantasy_name = 10;
  inline bool has_fantasy_name() const;
  inline void clear_fantasy_name();
  static const int kFantasyNameFieldNumber = 10;
  inline const ::std::string& fantasy_name() const;
  inline void set_fantasy_name(const ::std::string& value);
  inline void set_fantasy_name(const char* value);
  inline void set_fantasy_name(const char* value, size_t size);
  inline ::std::string* mutable_fantasy_name();
  inline ::std::string* release_fantasy_name();
  inline void set_allocated_fantasy_name(::std::string* fantasy_name);

  static const int kReqFieldNumber = 200;
  static ::google::protobuf::internal::ExtensionIdentifier< ::fantasybit::WsReq,
      ::google::protobuf::internal::MessageTypeTraits< ::fantasybit::CheckNameReq >, 11, false >
    req;
  // @@protoc_insertion_point(class_scope:fantasybit.CheckNameReq)
 private:
  inline void set_has_fantasy_name();
  inline void clear_has_fantasy_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* fantasy_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static CheckNameReq* default_instance_;
};
// -------------------------------------------------------------------

class CheckNameRep : public ::google::protobuf::Message {
 public:
  CheckNameRep();
  virtual ~CheckNameRep();

  CheckNameRep(const CheckNameRep& from);

  inline CheckNameRep& operator=(const CheckNameRep& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckNameRep& default_instance();

  void Swap(CheckNameRep* other);

  // implements Message ----------------------------------------------

  CheckNameRep* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CheckNameRep& from);
  void MergeFrom(const CheckNameRep& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string isavail = 10;
  inline bool has_isavail() const;
  inline void clear_isavail();
  static const int kIsavailFieldNumber = 10;
  inline const ::std::string& isavail() const;
  inline void set_isavail(const ::std::string& value);
  inline void set_isavail(const char* value);
  inline void set_isavail(const char* value, size_t size);
  inline ::std::string* mutable_isavail();
  inline ::std::string* release_isavail();
  inline void set_allocated_isavail(::std::string* isavail);

  // optional .fantasybit.CheckNameReq req = 20;
  inline bool has_req() const;
  inline void clear_req();
  static const int kReqFieldNumber = 20;
  inline const ::fantasybit::CheckNameReq& req() const;
  inline ::fantasybit::CheckNameReq* mutable_req();
  inline ::fantasybit::CheckNameReq* release_req();
  inline void set_allocated_req(::fantasybit::CheckNameReq* req);

  static const int kRepFieldNumber = 200;
  static ::google::protobuf::internal::ExtensionIdentifier< ::fantasybit::WSReply,
      ::google::protobuf::internal::MessageTypeTraits< ::fantasybit::CheckNameRep >, 11, false >
    rep;
  // @@protoc_insertion_point(class_scope:fantasybit.CheckNameRep)
 private:
  inline void set_has_isavail();
  inline void clear_has_isavail();
  inline void set_has_req();
  inline void clear_has_req();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* isavail_;
  ::fantasybit::CheckNameReq* req_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static CheckNameRep* default_instance_;
};
// -------------------------------------------------------------------

class Pk2FnameReq : public ::google::protobuf::Message {
 public:
  Pk2FnameReq();
  virtual ~Pk2FnameReq();

  Pk2FnameReq(const Pk2FnameReq& from);

  inline Pk2FnameReq& operator=(const Pk2FnameReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pk2FnameReq& default_instance();

  void Swap(Pk2FnameReq* other);

  // implements Message ----------------------------------------------

  Pk2FnameReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Pk2FnameReq& from);
  void MergeFrom(const Pk2FnameReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string pk = 10;
  inline bool has_pk() const;
  inline void clear_pk();
  static const int kPkFieldNumber = 10;
  inline const ::std::string& pk() const;
  inline void set_pk(const ::std::string& value);
  inline void set_pk(const char* value);
  inline void set_pk(const char* value, size_t size);
  inline ::std::string* mutable_pk();
  inline ::std::string* release_pk();
  inline void set_allocated_pk(::std::string* pk);

  static const int kReqFieldNumber = 300;
  static ::google::protobuf::internal::ExtensionIdentifier< ::fantasybit::WsReq,
      ::google::protobuf::internal::MessageTypeTraits< ::fantasybit::Pk2FnameReq >, 11, false >
    req;
  // @@protoc_insertion_point(class_scope:fantasybit.Pk2FnameReq)
 private:
  inline void set_has_pk();
  inline void clear_has_pk();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* pk_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static Pk2FnameReq* default_instance_;
};
// -------------------------------------------------------------------

class Pk2FnameRep : public ::google::protobuf::Message {
 public:
  Pk2FnameRep();
  virtual ~Pk2FnameRep();

  Pk2FnameRep(const Pk2FnameRep& from);

  inline Pk2FnameRep& operator=(const Pk2FnameRep& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pk2FnameRep& default_instance();

  void Swap(Pk2FnameRep* other);

  // implements Message ----------------------------------------------

  Pk2FnameRep* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Pk2FnameRep& from);
  void MergeFrom(const Pk2FnameRep& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string fname = 10;
  inline bool has_fname() const;
  inline void clear_fname();
  static const int kFnameFieldNumber = 10;
  inline const ::std::string& fname() const;
  inline void set_fname(const ::std::string& value);
  inline void set_fname(const char* value);
  inline void set_fname(const char* value, size_t size);
  inline ::std::string* mutable_fname();
  inline ::std::string* release_fname();
  inline void set_allocated_fname(::std::string* fname);

  // optional .fantasybit.Pk2FnameReq req = 20;
  inline bool has_req() const;
  inline void clear_req();
  static const int kReqFieldNumber = 20;
  inline const ::fantasybit::Pk2FnameReq& req() const;
  inline ::fantasybit::Pk2FnameReq* mutable_req();
  inline ::fantasybit::Pk2FnameReq* release_req();
  inline void set_allocated_req(::fantasybit::Pk2FnameReq* req);

  // optional .fantasybit.FantasyNameBal fnb = 30;
  inline bool has_fnb() const;
  inline void clear_fnb();
  static const int kFnbFieldNumber = 30;
  inline const ::fantasybit::FantasyNameBal& fnb() const;
  inline ::fantasybit::FantasyNameBal* mutable_fnb();
  inline ::fantasybit::FantasyNameBal* release_fnb();
  inline void set_allocated_fnb(::fantasybit::FantasyNameBal* fnb);

  static const int kRepFieldNumber = 300;
  static ::google::protobuf::internal::ExtensionIdentifier< ::fantasybit::WSReply,
      ::google::protobuf::internal::MessageTypeTraits< ::fantasybit::Pk2FnameRep >, 11, false >
    rep;
  // @@protoc_insertion_point(class_scope:fantasybit.Pk2FnameRep)
 private:
  inline void set_has_fname();
  inline void clear_has_fname();
  inline void set_has_req();
  inline void clear_has_req();
  inline void set_has_fnb();
  inline void clear_has_fnb();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* fname_;
  ::fantasybit::Pk2FnameReq* req_;
  ::fantasybit::FantasyNameBal* fnb_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static Pk2FnameRep* default_instance_;
};
// -------------------------------------------------------------------

class SubscribeReq : public ::google::protobuf::Message {
 public:
  SubscribeReq();
  virtual ~SubscribeReq();

  SubscribeReq(const SubscribeReq& from);

  inline SubscribeReq& operator=(const SubscribeReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubscribeReq& default_instance();

  void Swap(SubscribeReq* other);

  // implements Message ----------------------------------------------

  SubscribeReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubscribeReq& from);
  void MergeFrom(const SubscribeReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 10;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 10;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint64 fchash = 30;
  inline bool has_fchash() const;
  inline void clear_fchash();
  static const int kFchashFieldNumber = 30;
  inline ::google::protobuf::uint64 fchash() const;
  inline void set_fchash(::google::protobuf::uint64 value);

  static const int kReqFieldNumber = 350;
  static ::google::protobuf::internal::ExtensionIdentifier< ::fantasybit::WsReq,
      ::google::protobuf::internal::MessageTypeTraits< ::fantasybit::SubscribeReq >, 11, false >
    req;
  // @@protoc_insertion_point(class_scope:fantasybit.SubscribeReq)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_fchash();
  inline void clear_has_fchash();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint64 fchash_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static SubscribeReq* default_instance_;
};
// -------------------------------------------------------------------

class NameStatusReq : public ::google::protobuf::Message {
 public:
  NameStatusReq();
  virtual ~NameStatusReq();

  NameStatusReq(const NameStatusReq& from);

  inline NameStatusReq& operator=(const NameStatusReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NameStatusReq& default_instance();

  void Swap(NameStatusReq* other);

  // implements Message ----------------------------------------------

  NameStatusReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NameStatusReq& from);
  void MergeFrom(const NameStatusReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 10;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 10;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string pk = 20;
  inline bool has_pk() const;
  inline void clear_pk();
  static const int kPkFieldNumber = 20;
  inline const ::std::string& pk() const;
  inline void set_pk(const ::std::string& value);
  inline void set_pk(const char* value);
  inline void set_pk(const char* value, size_t size);
  inline ::std::string* mutable_pk();
  inline ::std::string* release_pk();
  inline void set_allocated_pk(::std::string* pk);

  static const int kReqFieldNumber = 400;
  static ::google::protobuf::internal::ExtensionIdentifier< ::fantasybit::WsReq,
      ::google::protobuf::internal::MessageTypeTraits< ::fantasybit::NameStatusReq >, 11, false >
    req;
  // @@protoc_insertion_point(class_scope:fantasybit.NameStatusReq)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_pk();
  inline void clear_has_pk();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* pk_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static NameStatusReq* default_instance_;
};
// -------------------------------------------------------------------

class NameStatusRep : public ::google::protobuf::Message {
 public:
  NameStatusRep();
  virtual ~NameStatusRep();

  NameStatusRep(const NameStatusRep& from);

  inline NameStatusRep& operator=(const NameStatusRep& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NameStatusRep& default_instance();

  void Swap(NameStatusRep* other);

  // implements Message ----------------------------------------------

  NameStatusRep* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NameStatusRep& from);
  void MergeFrom(const NameStatusRep& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .fantasybit.MyNameStatus status = 10;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 10;
  inline ::fantasybit::MyNameStatus status() const;
  inline void set_status(::fantasybit::MyNameStatus value);

  // optional .fantasybit.NameStatusReq req = 20;
  inline bool has_req() const;
  inline void clear_req();
  static const int kReqFieldNumber = 20;
  inline const ::fantasybit::NameStatusReq& req() const;
  inline ::fantasybit::NameStatusReq* mutable_req();
  inline ::fantasybit::NameStatusReq* release_req();
  inline void set_allocated_req(::fantasybit::NameStatusReq* req);

  static const int kRepFieldNumber = 400;
  static ::google::protobuf::internal::ExtensionIdentifier< ::fantasybit::WSReply,
      ::google::protobuf::internal::MessageTypeTraits< ::fantasybit::NameStatusRep >, 11, false >
    rep;
  // @@protoc_insertion_point(class_scope:fantasybit.NameStatusRep)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_req();
  inline void clear_has_req();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::fantasybit::NameStatusReq* req_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static NameStatusRep* default_instance_;
};
// -------------------------------------------------------------------

class GetAllNamesRep : public ::google::protobuf::Message {
 public:
  GetAllNamesRep();
  virtual ~GetAllNamesRep();

  GetAllNamesRep(const GetAllNamesRep& from);

  inline GetAllNamesRep& operator=(const GetAllNamesRep& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAllNamesRep& default_instance();

  void Swap(GetAllNamesRep* other);

  // implements Message ----------------------------------------------

  GetAllNamesRep* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetAllNamesRep& from);
  void MergeFrom(const GetAllNamesRep& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string names = 10;
  inline int names_size() const;
  inline void clear_names();
  static const int kNamesFieldNumber = 10;
  inline const ::std::string& names(int index) const;
  inline ::std::string* mutable_names(int index);
  inline void set_names(int index, const ::std::string& value);
  inline void set_names(int index, const char* value);
  inline void set_names(int index, const char* value, size_t size);
  inline ::std::string* add_names();
  inline void add_names(const ::std::string& value);
  inline void add_names(const char* value);
  inline void add_names(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& names() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_names();

  // repeated .fantasybit.FantasyNameBal fnb = 20;
  inline int fnb_size() const;
  inline void clear_fnb();
  static const int kFnbFieldNumber = 20;
  inline const ::fantasybit::FantasyNameBal& fnb(int index) const;
  inline ::fantasybit::FantasyNameBal* mutable_fnb(int index);
  inline ::fantasybit::FantasyNameBal* add_fnb();
  inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::FantasyNameBal >&
      fnb() const;
  inline ::google::protobuf::RepeatedPtrField< ::fantasybit::FantasyNameBal >*
      mutable_fnb();

  static const int kRepFieldNumber = 500;
  static ::google::protobuf::internal::ExtensionIdentifier< ::fantasybit::WSReply,
      ::google::protobuf::internal::MessageTypeTraits< ::fantasybit::GetAllNamesRep >, 11, false >
    rep;
  // @@protoc_insertion_point(class_scope:fantasybit.GetAllNamesRep)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> names_;
  ::google::protobuf::RepeatedPtrField< ::fantasybit::FantasyNameBal > fnb_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static GetAllNamesRep* default_instance_;
};
// -------------------------------------------------------------------

class TeamRoster : public ::google::protobuf::Message {
 public:
  TeamRoster();
  virtual ~TeamRoster();

  TeamRoster(const TeamRoster& from);

  inline TeamRoster& operator=(const TeamRoster& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TeamRoster& default_instance();

  void Swap(TeamRoster* other);

  // implements Message ----------------------------------------------

  TeamRoster* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TeamRoster& from);
  void MergeFrom(const TeamRoster& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string teamid = 10;
  inline bool has_teamid() const;
  inline void clear_teamid();
  static const int kTeamidFieldNumber = 10;
  inline const ::std::string& teamid() const;
  inline void set_teamid(const ::std::string& value);
  inline void set_teamid(const char* value);
  inline void set_teamid(const char* value, size_t size);
  inline ::std::string* mutable_teamid();
  inline ::std::string* release_teamid();
  inline void set_allocated_teamid(::std::string* teamid);

  // repeated .fantasybit.PlayerData players = 20;
  inline int players_size() const;
  inline void clear_players();
  static const int kPlayersFieldNumber = 20;
  inline const ::fantasybit::PlayerData& players(int index) const;
  inline ::fantasybit::PlayerData* mutable_players(int index);
  inline ::fantasybit::PlayerData* add_players();
  inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::PlayerData >&
      players() const;
  inline ::google::protobuf::RepeatedPtrField< ::fantasybit::PlayerData >*
      mutable_players();

  // @@protoc_insertion_point(class_scope:fantasybit.TeamRoster)
 private:
  inline void set_has_teamid();
  inline void clear_has_teamid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* teamid_;
  ::google::protobuf::RepeatedPtrField< ::fantasybit::PlayerData > players_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static TeamRoster* default_instance_;
};
// -------------------------------------------------------------------

class GameDataRoster : public ::google::protobuf::Message {
 public:
  GameDataRoster();
  virtual ~GameDataRoster();

  GameDataRoster(const GameDataRoster& from);

  inline GameDataRoster& operator=(const GameDataRoster& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameDataRoster& default_instance();

  void Swap(GameDataRoster* other);

  // implements Message ----------------------------------------------

  GameDataRoster* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameDataRoster& from);
  void MergeFrom(const GameDataRoster& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .fantasybit.GameData game_data = 10;
  inline bool has_game_data() const;
  inline void clear_game_data();
  static const int kGameDataFieldNumber = 10;
  inline const ::fantasybit::GameData& game_data() const;
  inline ::fantasybit::GameData* mutable_game_data();
  inline ::fantasybit::GameData* release_game_data();
  inline void set_allocated_game_data(::fantasybit::GameData* game_data);

  // optional .fantasybit.TeamRoster homeroster = 20;
  inline bool has_homeroster() const;
  inline void clear_homeroster();
  static const int kHomerosterFieldNumber = 20;
  inline const ::fantasybit::TeamRoster& homeroster() const;
  inline ::fantasybit::TeamRoster* mutable_homeroster();
  inline ::fantasybit::TeamRoster* release_homeroster();
  inline void set_allocated_homeroster(::fantasybit::TeamRoster* homeroster);

  // optional .fantasybit.TeamRoster awayroster = 30;
  inline bool has_awayroster() const;
  inline void clear_awayroster();
  static const int kAwayrosterFieldNumber = 30;
  inline const ::fantasybit::TeamRoster& awayroster() const;
  inline ::fantasybit::TeamRoster* mutable_awayroster();
  inline ::fantasybit::TeamRoster* release_awayroster();
  inline void set_allocated_awayroster(::fantasybit::TeamRoster* awayroster);

  // @@protoc_insertion_point(class_scope:fantasybit.GameDataRoster)
 private:
  inline void set_has_game_data();
  inline void clear_has_game_data();
  inline void set_has_homeroster();
  inline void clear_has_homeroster();
  inline void set_has_awayroster();
  inline void clear_has_awayroster();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::fantasybit::GameData* game_data_;
  ::fantasybit::TeamRoster* homeroster_;
  ::fantasybit::TeamRoster* awayroster_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static GameDataRoster* default_instance_;
};
// -------------------------------------------------------------------

class GetCurrRostersRep : public ::google::protobuf::Message {
 public:
  GetCurrRostersRep();
  virtual ~GetCurrRostersRep();

  GetCurrRostersRep(const GetCurrRostersRep& from);

  inline GetCurrRostersRep& operator=(const GetCurrRostersRep& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetCurrRostersRep& default_instance();

  void Swap(GetCurrRostersRep* other);

  // implements Message ----------------------------------------------

  GetCurrRostersRep* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetCurrRostersRep& from);
  void MergeFrom(const GetCurrRostersRep& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 week = 10;
  inline bool has_week() const;
  inline void clear_week();
  static const int kWeekFieldNumber = 10;
  inline ::google::protobuf::int32 week() const;
  inline void set_week(::google::protobuf::int32 value);

  // repeated .fantasybit.GameDataRoster gamerosters = 20;
  inline int gamerosters_size() const;
  inline void clear_gamerosters();
  static const int kGamerostersFieldNumber = 20;
  inline const ::fantasybit::GameDataRoster& gamerosters(int index) const;
  inline ::fantasybit::GameDataRoster* mutable_gamerosters(int index);
  inline ::fantasybit::GameDataRoster* add_gamerosters();
  inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::GameDataRoster >&
      gamerosters() const;
  inline ::google::protobuf::RepeatedPtrField< ::fantasybit::GameDataRoster >*
      mutable_gamerosters();

  static const int kRepFieldNumber = 920;
  static ::google::protobuf::internal::ExtensionIdentifier< ::fantasybit::WSReply,
      ::google::protobuf::internal::MessageTypeTraits< ::fantasybit::GetCurrRostersRep >, 11, false >
    rep;
  // @@protoc_insertion_point(class_scope:fantasybit.GetCurrRostersRep)
 private:
  inline void set_has_week();
  inline void clear_has_week();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::fantasybit::GameDataRoster > gamerosters_;
  ::google::protobuf::int32 week_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static GetCurrRostersRep* default_instance_;
};
// -------------------------------------------------------------------

class ROWMarket : public ::google::protobuf::Message {
 public:
  ROWMarket();
  virtual ~ROWMarket();

  ROWMarket(const ROWMarket& from);

  inline ROWMarket& operator=(const ROWMarket& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ROWMarket& default_instance();

  void Swap(ROWMarket* other);

  // implements Message ----------------------------------------------

  ROWMarket* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ROWMarket& from);
  void MergeFrom(const ROWMarket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string pid = 10;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 10;
  inline const ::std::string& pid() const;
  inline void set_pid(const ::std::string& value);
  inline void set_pid(const char* value);
  inline void set_pid(const char* value, size_t size);
  inline ::std::string* mutable_pid();
  inline ::std::string* release_pid();
  inline void set_allocated_pid(::std::string* pid);

  // optional .fantasybit.MarketQuote quote = 30;
  inline bool has_quote() const;
  inline void clear_quote();
  static const int kQuoteFieldNumber = 30;
  inline const ::fantasybit::MarketQuote& quote() const;
  inline ::fantasybit::MarketQuote* mutable_quote();
  inline ::fantasybit::MarketQuote* release_quote();
  inline void set_allocated_quote(::fantasybit::MarketQuote* quote);

  // optional .fantasybit.PlayerData playerdata = 40;
  inline bool has_playerdata() const;
  inline void clear_playerdata();
  static const int kPlayerdataFieldNumber = 40;
  inline const ::fantasybit::PlayerData& playerdata() const;
  inline ::fantasybit::PlayerData* mutable_playerdata();
  inline ::fantasybit::PlayerData* release_playerdata();
  inline void set_allocated_playerdata(::fantasybit::PlayerData* playerdata);

  // optional .fantasybit.ContractOHLC ohlc = 50;
  inline bool has_ohlc() const;
  inline void clear_ohlc();
  static const int kOhlcFieldNumber = 50;
  inline const ::fantasybit::ContractOHLC& ohlc() const;
  inline ::fantasybit::ContractOHLC* mutable_ohlc();
  inline ::fantasybit::ContractOHLC* release_ohlc();
  inline void set_allocated_ohlc(::fantasybit::ContractOHLC* ohlc);

  // @@protoc_insertion_point(class_scope:fantasybit.ROWMarket)
 private:
  inline void set_has_pid();
  inline void clear_has_pid();
  inline void set_has_quote();
  inline void clear_has_quote();
  inline void set_has_playerdata();
  inline void clear_has_playerdata();
  inline void set_has_ohlc();
  inline void clear_has_ohlc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* pid_;
  ::fantasybit::MarketQuote* quote_;
  ::fantasybit::PlayerData* playerdata_;
  ::fantasybit::ContractOHLC* ohlc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static ROWMarket* default_instance_;
};
// -------------------------------------------------------------------

class GetROWMarketRep : public ::google::protobuf::Message {
 public:
  GetROWMarketRep();
  virtual ~GetROWMarketRep();

  GetROWMarketRep(const GetROWMarketRep& from);

  inline GetROWMarketRep& operator=(const GetROWMarketRep& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetROWMarketRep& default_instance();

  void Swap(GetROWMarketRep* other);

  // implements Message ----------------------------------------------

  GetROWMarketRep* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetROWMarketRep& from);
  void MergeFrom(const GetROWMarketRep& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .fantasybit.ROWMarket rowmarket = 10;
  inline int rowmarket_size() const;
  inline void clear_rowmarket();
  static const int kRowmarketFieldNumber = 10;
  inline const ::fantasybit::ROWMarket& rowmarket(int index) const;
  inline ::fantasybit::ROWMarket* mutable_rowmarket(int index);
  inline ::fantasybit::ROWMarket* add_rowmarket();
  inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::ROWMarket >&
      rowmarket() const;
  inline ::google::protobuf::RepeatedPtrField< ::fantasybit::ROWMarket >*
      mutable_rowmarket();

  static const int kRepFieldNumber = 600;
  static ::google::protobuf::internal::ExtensionIdentifier< ::fantasybit::WSReply,
      ::google::protobuf::internal::MessageTypeTraits< ::fantasybit::GetROWMarketRep >, 11, false >
    rep;
  // @@protoc_insertion_point(class_scope:fantasybit.GetROWMarketRep)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::fantasybit::ROWMarket > rowmarket_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static GetROWMarketRep* default_instance_;
};
// -------------------------------------------------------------------

class GetDepthReq : public ::google::protobuf::Message {
 public:
  GetDepthReq();
  virtual ~GetDepthReq();

  GetDepthReq(const GetDepthReq& from);

  inline GetDepthReq& operator=(const GetDepthReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetDepthReq& default_instance();

  void Swap(GetDepthReq* other);

  // implements Message ----------------------------------------------

  GetDepthReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetDepthReq& from);
  void MergeFrom(const GetDepthReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string pid = 10;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 10;
  inline const ::std::string& pid() const;
  inline void set_pid(const ::std::string& value);
  inline void set_pid(const char* value);
  inline void set_pid(const char* value, size_t size);
  inline ::std::string* mutable_pid();
  inline ::std::string* release_pid();
  inline void set_allocated_pid(::std::string* pid);

  static const int kReqFieldNumber = 700;
  static ::google::protobuf::internal::ExtensionIdentifier< ::fantasybit::WsReq,
      ::google::protobuf::internal::MessageTypeTraits< ::fantasybit::GetDepthReq >, 11, false >
    req;
  // @@protoc_insertion_point(class_scope:fantasybit.GetDepthReq)
 private:
  inline void set_has_pid();
  inline void clear_has_pid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* pid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static GetDepthReq* default_instance_;
};
// -------------------------------------------------------------------

class GetDepthRep : public ::google::protobuf::Message {
 public:
  GetDepthRep();
  virtual ~GetDepthRep();

  GetDepthRep(const GetDepthRep& from);

  inline GetDepthRep& operator=(const GetDepthRep& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetDepthRep& default_instance();

  void Swap(GetDepthRep* other);

  // implements Message ----------------------------------------------

  GetDepthRep* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetDepthRep& from);
  void MergeFrom(const GetDepthRep& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string pid = 10;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 10;
  inline const ::std::string& pid() const;
  inline void set_pid(const ::std::string& value);
  inline void set_pid(const char* value);
  inline void set_pid(const char* value, size_t size);
  inline ::std::string* mutable_pid();
  inline ::std::string* release_pid();
  inline void set_allocated_pid(::std::string* pid);

  // repeated .fantasybit.DepthItem depthitems = 20;
  inline int depthitems_size() const;
  inline void clear_depthitems();
  static const int kDepthitemsFieldNumber = 20;
  inline const ::fantasybit::DepthItem& depthitems(int index) const;
  inline ::fantasybit::DepthItem* mutable_depthitems(int index);
  inline ::fantasybit::DepthItem* add_depthitems();
  inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::DepthItem >&
      depthitems() const;
  inline ::google::protobuf::RepeatedPtrField< ::fantasybit::DepthItem >*
      mutable_depthitems();

  // optional .fantasybit.ROWMarket rowmarket = 30;
  inline bool has_rowmarket() const;
  inline void clear_rowmarket();
  static const int kRowmarketFieldNumber = 30;
  inline const ::fantasybit::ROWMarket& rowmarket() const;
  inline ::fantasybit::ROWMarket* mutable_rowmarket();
  inline ::fantasybit::ROWMarket* release_rowmarket();
  inline void set_allocated_rowmarket(::fantasybit::ROWMarket* rowmarket);

  static const int kRepFieldNumber = 700;
  static ::google::protobuf::internal::ExtensionIdentifier< ::fantasybit::WSReply,
      ::google::protobuf::internal::MessageTypeTraits< ::fantasybit::GetDepthRep >, 11, false >
    rep;
  // @@protoc_insertion_point(class_scope:fantasybit.GetDepthRep)
 private:
  inline void set_has_pid();
  inline void clear_has_pid();
  inline void set_has_rowmarket();
  inline void clear_has_rowmarket();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* pid_;
  ::google::protobuf::RepeatedPtrField< ::fantasybit::DepthItem > depthitems_;
  ::fantasybit::ROWMarket* rowmarket_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static GetDepthRep* default_instance_;
};
// -------------------------------------------------------------------

class AllOdersSymbol : public ::google::protobuf::Message {
 public:
  AllOdersSymbol();
  virtual ~AllOdersSymbol();

  AllOdersSymbol(const AllOdersSymbol& from);

  inline AllOdersSymbol& operator=(const AllOdersSymbol& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AllOdersSymbol& default_instance();

  void Swap(AllOdersSymbol* other);

  // implements Message ----------------------------------------------

  AllOdersSymbol* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AllOdersSymbol& from);
  void MergeFrom(const AllOdersSymbol& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string symbol = 10;
  inline bool has_symbol() const;
  inline void clear_symbol();
  static const int kSymbolFieldNumber = 10;
  inline const ::std::string& symbol() const;
  inline void set_symbol(const ::std::string& value);
  inline void set_symbol(const char* value);
  inline void set_symbol(const char* value, size_t size);
  inline ::std::string* mutable_symbol();
  inline ::std::string* release_symbol();
  inline void set_allocated_symbol(::std::string* symbol);

  // optional int32 netqty = 30;
  inline bool has_netqty() const;
  inline void clear_netqty();
  static const int kNetqtyFieldNumber = 30;
  inline ::google::protobuf::int32 netqty() const;
  inline void set_netqty(::google::protobuf::int32 value);

  // optional int32 netprice = 40;
  inline bool has_netprice() const;
  inline void clear_netprice();
  static const int kNetpriceFieldNumber = 40;
  inline ::google::protobuf::int32 netprice() const;
  inline void set_netprice(::google::protobuf::int32 value);

  // optional double avg = 50;
  inline bool has_avg() const;
  inline void clear_avg();
  static const int kAvgFieldNumber = 50;
  inline double avg() const;
  inline void set_avg(double value);

  // optional double pnl = 60;
  inline bool has_pnl() const;
  inline void clear_pnl();
  static const int kPnlFieldNumber = 60;
  inline double pnl() const;
  inline void set_pnl(double value);

  // repeated .fantasybit.Order orders = 20;
  inline int orders_size() const;
  inline void clear_orders();
  static const int kOrdersFieldNumber = 20;
  inline const ::fantasybit::Order& orders(int index) const;
  inline ::fantasybit::Order* mutable_orders(int index);
  inline ::fantasybit::Order* add_orders();
  inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::Order >&
      orders() const;
  inline ::google::protobuf::RepeatedPtrField< ::fantasybit::Order >*
      mutable_orders();

  // @@protoc_insertion_point(class_scope:fantasybit.AllOdersSymbol)
 private:
  inline void set_has_symbol();
  inline void clear_has_symbol();
  inline void set_has_netqty();
  inline void clear_has_netqty();
  inline void set_has_netprice();
  inline void clear_has_netprice();
  inline void set_has_avg();
  inline void clear_has_avg();
  inline void set_has_pnl();
  inline void clear_has_pnl();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* symbol_;
  ::google::protobuf::int32 netqty_;
  ::google::protobuf::int32 netprice_;
  double avg_;
  double pnl_;
  ::google::protobuf::RepeatedPtrField< ::fantasybit::Order > orders_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static AllOdersSymbol* default_instance_;
};
// -------------------------------------------------------------------

class AllOdersFname : public ::google::protobuf::Message {
 public:
  AllOdersFname();
  virtual ~AllOdersFname();

  AllOdersFname(const AllOdersFname& from);

  inline AllOdersFname& operator=(const AllOdersFname& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AllOdersFname& default_instance();

  void Swap(AllOdersFname* other);

  // implements Message ----------------------------------------------

  AllOdersFname* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AllOdersFname& from);
  void MergeFrom(const AllOdersFname& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string fname = 10;
  inline bool has_fname() const;
  inline void clear_fname();
  static const int kFnameFieldNumber = 10;
  inline const ::std::string& fname() const;
  inline void set_fname(const ::std::string& value);
  inline void set_fname(const char* value);
  inline void set_fname(const char* value, size_t size);
  inline ::std::string* mutable_fname();
  inline ::std::string* release_fname();
  inline void set_allocated_fname(::std::string* fname);

  // repeated .fantasybit.AllOdersSymbol pidorders = 20;
  inline int pidorders_size() const;
  inline void clear_pidorders();
  static const int kPidordersFieldNumber = 20;
  inline const ::fantasybit::AllOdersSymbol& pidorders(int index) const;
  inline ::fantasybit::AllOdersSymbol* mutable_pidorders(int index);
  inline ::fantasybit::AllOdersSymbol* add_pidorders();
  inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::AllOdersSymbol >&
      pidorders() const;
  inline ::google::protobuf::RepeatedPtrField< ::fantasybit::AllOdersSymbol >*
      mutable_pidorders();

  // @@protoc_insertion_point(class_scope:fantasybit.AllOdersFname)
 private:
  inline void set_has_fname();
  inline void clear_has_fname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* fname_;
  ::google::protobuf::RepeatedPtrField< ::fantasybit::AllOdersSymbol > pidorders_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static AllOdersFname* default_instance_;
};
// -------------------------------------------------------------------

class GetOrdersRep : public ::google::protobuf::Message {
 public:
  GetOrdersRep();
  virtual ~GetOrdersRep();

  GetOrdersRep(const GetOrdersRep& from);

  inline GetOrdersRep& operator=(const GetOrdersRep& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetOrdersRep& default_instance();

  void Swap(GetOrdersRep* other);

  // implements Message ----------------------------------------------

  GetOrdersRep* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetOrdersRep& from);
  void MergeFrom(const GetOrdersRep& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .fantasybit.GetOrdersReq req = 10;
  inline bool has_req() const;
  inline void clear_req();
  static const int kReqFieldNumber = 10;
  inline const ::fantasybit::GetOrdersReq& req() const;
  inline ::fantasybit::GetOrdersReq* mutable_req();
  inline ::fantasybit::GetOrdersReq* release_req();
  inline void set_allocated_req(::fantasybit::GetOrdersReq* req);

  // optional .fantasybit.AllOdersFname oorders = 20;
  inline bool has_oorders() const;
  inline void clear_oorders();
  static const int kOordersFieldNumber = 20;
  inline const ::fantasybit::AllOdersFname& oorders() const;
  inline ::fantasybit::AllOdersFname* mutable_oorders();
  inline ::fantasybit::AllOdersFname* release_oorders();
  inline void set_allocated_oorders(::fantasybit::AllOdersFname* oorders);

  static const int kRepFieldNumber = 800;
  static ::google::protobuf::internal::ExtensionIdentifier< ::fantasybit::WSReply,
      ::google::protobuf::internal::MessageTypeTraits< ::fantasybit::GetOrdersRep >, 11, false >
    rep;
  // @@protoc_insertion_point(class_scope:fantasybit.GetOrdersRep)
 private:
  inline void set_has_req();
  inline void clear_has_req();
  inline void set_has_oorders();
  inline void clear_has_oorders();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::fantasybit::GetOrdersReq* req_;
  ::fantasybit::AllOdersFname* oorders_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static GetOrdersRep* default_instance_;
};
// -------------------------------------------------------------------

class GetOrdersReq : public ::google::protobuf::Message {
 public:
  GetOrdersReq();
  virtual ~GetOrdersReq();

  GetOrdersReq(const GetOrdersReq& from);

  inline GetOrdersReq& operator=(const GetOrdersReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetOrdersReq& default_instance();

  void Swap(GetOrdersReq* other);

  // implements Message ----------------------------------------------

  GetOrdersReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetOrdersReq& from);
  void MergeFrom(const GetOrdersReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string symbol = 10;
  inline bool has_symbol() const;
  inline void clear_symbol();
  static const int kSymbolFieldNumber = 10;
  inline const ::std::string& symbol() const;
  inline void set_symbol(const ::std::string& value);
  inline void set_symbol(const char* value);
  inline void set_symbol(const char* value, size_t size);
  inline ::std::string* mutable_symbol();
  inline ::std::string* release_symbol();
  inline void set_allocated_symbol(::std::string* symbol);

  // optional string fname = 20;
  inline bool has_fname() const;
  inline void clear_fname();
  static const int kFnameFieldNumber = 20;
  inline const ::std::string& fname() const;
  inline void set_fname(const ::std::string& value);
  inline void set_fname(const char* value);
  inline void set_fname(const char* value, size_t size);
  inline ::std::string* mutable_fname();
  inline ::std::string* release_fname();
  inline void set_allocated_fname(::std::string* fname);

  // optional uint64 fchash = 30;
  inline bool has_fchash() const;
  inline void clear_fchash();
  static const int kFchashFieldNumber = 30;
  inline ::google::protobuf::uint64 fchash() const;
  inline void set_fchash(::google::protobuf::uint64 value);

  static const int kReqFieldNumber = 800;
  static ::google::protobuf::internal::ExtensionIdentifier< ::fantasybit::WsReq,
      ::google::protobuf::internal::MessageTypeTraits< ::fantasybit::GetOrdersReq >, 11, false >
    req;
  // @@protoc_insertion_point(class_scope:fantasybit.GetOrdersReq)
 private:
  inline void set_has_symbol();
  inline void clear_has_symbol();
  inline void set_has_fname();
  inline void clear_has_fname();
  inline void set_has_fchash();
  inline void clear_has_fchash();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* symbol_;
  ::std::string* fname_;
  ::google::protobuf::uint64 fchash_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static GetOrdersReq* default_instance_;
};
// -------------------------------------------------------------------

class GetProjectionReq : public ::google::protobuf::Message {
 public:
  GetProjectionReq();
  virtual ~GetProjectionReq();

  GetProjectionReq(const GetProjectionReq& from);

  inline GetProjectionReq& operator=(const GetProjectionReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetProjectionReq& default_instance();

  void Swap(GetProjectionReq* other);

  // implements Message ----------------------------------------------

  GetProjectionReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetProjectionReq& from);
  void MergeFrom(const GetProjectionReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string fname = 20;
  inline bool has_fname() const;
  inline void clear_fname();
  static const int kFnameFieldNumber = 20;
  inline const ::std::string& fname() const;
  inline void set_fname(const ::std::string& value);
  inline void set_fname(const char* value);
  inline void set_fname(const char* value, size_t size);
  inline ::std::string* mutable_fname();
  inline ::std::string* release_fname();
  inline void set_allocated_fname(::std::string* fname);

  // optional bool getavg = 30;
  inline bool has_getavg() const;
  inline void clear_getavg();
  static const int kGetavgFieldNumber = 30;
  inline bool getavg() const;
  inline void set_getavg(bool value);

  static const int kReqFieldNumber = 900;
  static ::google::protobuf::internal::ExtensionIdentifier< ::fantasybit::WsReq,
      ::google::protobuf::internal::MessageTypeTraits< ::fantasybit::GetProjectionReq >, 11, false >
    req;
  // @@protoc_insertion_point(class_scope:fantasybit.GetProjectionReq)
 private:
  inline void set_has_fname();
  inline void clear_has_fname();
  inline void set_has_getavg();
  inline void clear_has_getavg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* fname_;
  bool getavg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static GetProjectionReq* default_instance_;
};
// -------------------------------------------------------------------

class PlayerProj : public ::google::protobuf::Message {
 public:
  PlayerProj();
  virtual ~PlayerProj();

  PlayerProj(const PlayerProj& from);

  inline PlayerProj& operator=(const PlayerProj& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerProj& default_instance();

  void Swap(PlayerProj* other);

  // implements Message ----------------------------------------------

  PlayerProj* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerProj& from);
  void MergeFrom(const PlayerProj& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string playerid = 10;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 10;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  inline void set_allocated_playerid(::std::string* playerid);

  // optional int32 proj = 20;
  inline bool has_proj() const;
  inline void clear_proj();
  static const int kProjFieldNumber = 20;
  inline ::google::protobuf::int32 proj() const;
  inline void set_proj(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fantasybit.PlayerProj)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_proj();
  inline void clear_has_proj();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* playerid_;
  ::google::protobuf::int32 proj_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static PlayerProj* default_instance_;
};
// -------------------------------------------------------------------

class ProjByName : public ::google::protobuf::Message {
 public:
  ProjByName();
  virtual ~ProjByName();

  ProjByName(const ProjByName& from);

  inline ProjByName& operator=(const ProjByName& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProjByName& default_instance();

  void Swap(ProjByName* other);

  // implements Message ----------------------------------------------

  ProjByName* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProjByName& from);
  void MergeFrom(const ProjByName& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 10;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 10;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .fantasybit.PlayerProj playerproj = 20;
  inline int playerproj_size() const;
  inline void clear_playerproj();
  static const int kPlayerprojFieldNumber = 20;
  inline const ::fantasybit::PlayerProj& playerproj(int index) const;
  inline ::fantasybit::PlayerProj* mutable_playerproj(int index);
  inline ::fantasybit::PlayerProj* add_playerproj();
  inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::PlayerProj >&
      playerproj() const;
  inline ::google::protobuf::RepeatedPtrField< ::fantasybit::PlayerProj >*
      mutable_playerproj();

  // optional int32 count = 40;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 40;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // optional int32 block = 50;
  inline bool has_block() const;
  inline void clear_block();
  static const int kBlockFieldNumber = 50;
  inline ::google::protobuf::int32 block() const;
  inline void set_block(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fantasybit.ProjByName)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_block();
  inline void clear_has_block();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::fantasybit::PlayerProj > playerproj_;
  ::google::protobuf::int32 count_;
  ::google::protobuf::int32 block_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static ProjByName* default_instance_;
};
// -------------------------------------------------------------------

class GetProjectionRep : public ::google::protobuf::Message {
 public:
  GetProjectionRep();
  virtual ~GetProjectionRep();

  GetProjectionRep(const GetProjectionRep& from);

  inline GetProjectionRep& operator=(const GetProjectionRep& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetProjectionRep& default_instance();

  void Swap(GetProjectionRep* other);

  // implements Message ----------------------------------------------

  GetProjectionRep* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetProjectionRep& from);
  void MergeFrom(const GetProjectionRep& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .fantasybit.ProjByName projs = 20;
  inline bool has_projs() const;
  inline void clear_projs();
  static const int kProjsFieldNumber = 20;
  inline const ::fantasybit::ProjByName& projs() const;
  inline ::fantasybit::ProjByName* mutable_projs();
  inline ::fantasybit::ProjByName* release_projs();
  inline void set_allocated_projs(::fantasybit::ProjByName* projs);

  // optional .fantasybit.ProjByName avg = 30;
  inline bool has_avg() const;
  inline void clear_avg();
  static const int kAvgFieldNumber = 30;
  inline const ::fantasybit::ProjByName& avg() const;
  inline ::fantasybit::ProjByName* mutable_avg();
  inline ::fantasybit::ProjByName* release_avg();
  inline void set_allocated_avg(::fantasybit::ProjByName* avg);

  static const int kRepFieldNumber = 940;
  static ::google::protobuf::internal::ExtensionIdentifier< ::fantasybit::WSReply,
      ::google::protobuf::internal::MessageTypeTraits< ::fantasybit::GetProjectionRep >, 11, false >
    rep;
  // @@protoc_insertion_point(class_scope:fantasybit.GetProjectionRep)
 private:
  inline void set_has_projs();
  inline void clear_has_projs();
  inline void set_has_avg();
  inline void clear_has_avg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::fantasybit::ProjByName* projs_;
  ::fantasybit::ProjByName* avg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static GetProjectionRep* default_instance_;
};
// -------------------------------------------------------------------

class KeyValue : public ::google::protobuf::Message {
 public:
  KeyValue();
  virtual ~KeyValue();

  KeyValue(const KeyValue& from);

  inline KeyValue& operator=(const KeyValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyValue& default_instance();

  void Swap(KeyValue* other);

  // implements Message ----------------------------------------------

  KeyValue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KeyValue& from);
  void MergeFrom(const KeyValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes key = 10;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 10;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional bytes value = 20;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 20;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const void* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:fantasybit.KeyValue)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static KeyValue* default_instance_;
};
// -------------------------------------------------------------------

class Bootstrap : public ::google::protobuf::Message {
 public:
  Bootstrap();
  virtual ~Bootstrap();

  Bootstrap(const Bootstrap& from);

  inline Bootstrap& operator=(const Bootstrap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Bootstrap& default_instance();

  void Swap(Bootstrap* other);

  // implements Message ----------------------------------------------

  Bootstrap* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Bootstrap& from);
  void MergeFrom(const Bootstrap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional int32 blocknum = 2;
  inline bool has_blocknum() const;
  inline void clear_blocknum();
  static const int kBlocknumFieldNumber = 2;
  inline ::google::protobuf::int32 blocknum() const;
  inline void set_blocknum(::google::protobuf::int32 value);

  // optional int32 week = 3;
  inline bool has_week() const;
  inline void clear_week();
  static const int kWeekFieldNumber = 3;
  inline ::google::protobuf::int32 week() const;
  inline void set_week(::google::protobuf::int32 value);

  // optional int32 season = 4;
  inline bool has_season() const;
  inline void clear_season();
  static const int kSeasonFieldNumber = 4;
  inline ::google::protobuf::int32 season() const;
  inline void set_season(::google::protobuf::int32 value);

  // optional bytes gamemetaroot = 10;
  inline bool has_gamemetaroot() const;
  inline void clear_gamemetaroot();
  static const int kGamemetarootFieldNumber = 10;
  inline const ::std::string& gamemetaroot() const;
  inline void set_gamemetaroot(const ::std::string& value);
  inline void set_gamemetaroot(const char* value);
  inline void set_gamemetaroot(const void* value, size_t size);
  inline ::std::string* mutable_gamemetaroot();
  inline ::std::string* release_gamemetaroot();
  inline void set_allocated_gamemetaroot(::std::string* gamemetaroot);

  // optional bytes playermetaroot = 20;
  inline bool has_playermetaroot() const;
  inline void clear_playermetaroot();
  static const int kPlayermetarootFieldNumber = 20;
  inline const ::std::string& playermetaroot() const;
  inline void set_playermetaroot(const ::std::string& value);
  inline void set_playermetaroot(const char* value);
  inline void set_playermetaroot(const void* value, size_t size);
  inline ::std::string* mutable_playermetaroot();
  inline ::std::string* release_playermetaroot();
  inline void set_allocated_playermetaroot(::std::string* playermetaroot);

  // optional bytes fnamemetaroot = 30;
  inline bool has_fnamemetaroot() const;
  inline void clear_fnamemetaroot();
  static const int kFnamemetarootFieldNumber = 30;
  inline const ::std::string& fnamemetaroot() const;
  inline void set_fnamemetaroot(const ::std::string& value);
  inline void set_fnamemetaroot(const char* value);
  inline void set_fnamemetaroot(const void* value, size_t size);
  inline ::std::string* mutable_fnamemetaroot();
  inline ::std::string* release_fnamemetaroot();
  inline void set_allocated_fnamemetaroot(::std::string* fnamemetaroot);

  // optional bytes previd = 40;
  inline bool has_previd() const;
  inline void clear_previd();
  static const int kPrevidFieldNumber = 40;
  inline const ::std::string& previd() const;
  inline void set_previd(const ::std::string& value);
  inline void set_previd(const char* value);
  inline void set_previd(const void* value, size_t size);
  inline ::std::string* mutable_previd();
  inline ::std::string* release_previd();
  inline void set_allocated_previd(::std::string* previd);

  // optional bytes gameresultroot = 50;
  inline bool has_gameresultroot() const;
  inline void clear_gameresultroot();
  static const int kGameresultrootFieldNumber = 50;
  inline const ::std::string& gameresultroot() const;
  inline void set_gameresultroot(const ::std::string& value);
  inline void set_gameresultroot(const char* value);
  inline void set_gameresultroot(const void* value, size_t size);
  inline ::std::string* mutable_gameresultroot();
  inline ::std::string* release_gameresultroot();
  inline void set_allocated_gameresultroot(::std::string* gameresultroot);

  // optional bytes posmetaroot = 60;
  inline bool has_posmetaroot() const;
  inline void clear_posmetaroot();
  static const int kPosmetarootFieldNumber = 60;
  inline const ::std::string& posmetaroot() const;
  inline void set_posmetaroot(const ::std::string& value);
  inline void set_posmetaroot(const char* value);
  inline void set_posmetaroot(const void* value, size_t size);
  inline ::std::string* mutable_posmetaroot();
  inline ::std::string* release_posmetaroot();
  inline void set_allocated_posmetaroot(::std::string* posmetaroot);

  // @@protoc_insertion_point(class_scope:fantasybit.Bootstrap)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_blocknum();
  inline void clear_has_blocknum();
  inline void set_has_week();
  inline void clear_has_week();
  inline void set_has_season();
  inline void clear_has_season();
  inline void set_has_gamemetaroot();
  inline void clear_has_gamemetaroot();
  inline void set_has_playermetaroot();
  inline void clear_has_playermetaroot();
  inline void set_has_fnamemetaroot();
  inline void clear_has_fnamemetaroot();
  inline void set_has_previd();
  inline void clear_has_previd();
  inline void set_has_gameresultroot();
  inline void clear_has_gameresultroot();
  inline void set_has_posmetaroot();
  inline void clear_has_posmetaroot();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  ::google::protobuf::int32 blocknum_;
  ::google::protobuf::int32 week_;
  ::std::string* gamemetaroot_;
  ::std::string* playermetaroot_;
  ::std::string* fnamemetaroot_;
  ::std::string* previd_;
  ::std::string* gameresultroot_;
  ::std::string* posmetaroot_;
  ::google::protobuf::int32 season_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static Bootstrap* default_instance_;
};
// ===================================================================


// ===================================================================

// BlockMeta

// optional int32 blocknum = 40;
inline bool BlockMeta::has_blocknum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlockMeta::set_has_blocknum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlockMeta::clear_has_blocknum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlockMeta::clear_blocknum() {
  blocknum_ = 0;
  clear_has_blocknum();
}
inline ::google::protobuf::int32 BlockMeta::blocknum() const {
  return blocknum_;
}
inline void BlockMeta::set_blocknum(::google::protobuf::int32 value) {
  set_has_blocknum();
  blocknum_ = value;
}

// optional bytes trmetaid = 50;
inline bool BlockMeta::has_trmetaid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlockMeta::set_has_trmetaid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlockMeta::clear_has_trmetaid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlockMeta::clear_trmetaid() {
  if (trmetaid_ != &::google::protobuf::internal::kEmptyString) {
    trmetaid_->clear();
  }
  clear_has_trmetaid();
}
inline const ::std::string& BlockMeta::trmetaid() const {
  return *trmetaid_;
}
inline void BlockMeta::set_trmetaid(const ::std::string& value) {
  set_has_trmetaid();
  if (trmetaid_ == &::google::protobuf::internal::kEmptyString) {
    trmetaid_ = new ::std::string;
  }
  trmetaid_->assign(value);
}
inline void BlockMeta::set_trmetaid(const char* value) {
  set_has_trmetaid();
  if (trmetaid_ == &::google::protobuf::internal::kEmptyString) {
    trmetaid_ = new ::std::string;
  }
  trmetaid_->assign(value);
}
inline void BlockMeta::set_trmetaid(const void* value, size_t size) {
  set_has_trmetaid();
  if (trmetaid_ == &::google::protobuf::internal::kEmptyString) {
    trmetaid_ = new ::std::string;
  }
  trmetaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BlockMeta::mutable_trmetaid() {
  set_has_trmetaid();
  if (trmetaid_ == &::google::protobuf::internal::kEmptyString) {
    trmetaid_ = new ::std::string;
  }
  return trmetaid_;
}
inline ::std::string* BlockMeta::release_trmetaid() {
  clear_has_trmetaid();
  if (trmetaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = trmetaid_;
    trmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BlockMeta::set_allocated_trmetaid(::std::string* trmetaid) {
  if (trmetaid_ != &::google::protobuf::internal::kEmptyString) {
    delete trmetaid_;
  }
  if (trmetaid) {
    set_has_trmetaid();
    trmetaid_ = trmetaid;
  } else {
    clear_has_trmetaid();
    trmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes txmetaroot = 10;
inline bool BlockMeta::has_txmetaroot() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BlockMeta::set_has_txmetaroot() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BlockMeta::clear_has_txmetaroot() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BlockMeta::clear_txmetaroot() {
  if (txmetaroot_ != &::google::protobuf::internal::kEmptyString) {
    txmetaroot_->clear();
  }
  clear_has_txmetaroot();
}
inline const ::std::string& BlockMeta::txmetaroot() const {
  return *txmetaroot_;
}
inline void BlockMeta::set_txmetaroot(const ::std::string& value) {
  set_has_txmetaroot();
  if (txmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    txmetaroot_ = new ::std::string;
  }
  txmetaroot_->assign(value);
}
inline void BlockMeta::set_txmetaroot(const char* value) {
  set_has_txmetaroot();
  if (txmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    txmetaroot_ = new ::std::string;
  }
  txmetaroot_->assign(value);
}
inline void BlockMeta::set_txmetaroot(const void* value, size_t size) {
  set_has_txmetaroot();
  if (txmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    txmetaroot_ = new ::std::string;
  }
  txmetaroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BlockMeta::mutable_txmetaroot() {
  set_has_txmetaroot();
  if (txmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    txmetaroot_ = new ::std::string;
  }
  return txmetaroot_;
}
inline ::std::string* BlockMeta::release_txmetaroot() {
  clear_has_txmetaroot();
  if (txmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = txmetaroot_;
    txmetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BlockMeta::set_allocated_txmetaroot(::std::string* txmetaroot) {
  if (txmetaroot_ != &::google::protobuf::internal::kEmptyString) {
    delete txmetaroot_;
  }
  if (txmetaroot) {
    set_has_txmetaroot();
    txmetaroot_ = txmetaroot;
  } else {
    clear_has_txmetaroot();
    txmetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes pbstateid = 60;
inline bool BlockMeta::has_pbstateid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BlockMeta::set_has_pbstateid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BlockMeta::clear_has_pbstateid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BlockMeta::clear_pbstateid() {
  if (pbstateid_ != &::google::protobuf::internal::kEmptyString) {
    pbstateid_->clear();
  }
  clear_has_pbstateid();
}
inline const ::std::string& BlockMeta::pbstateid() const {
  return *pbstateid_;
}
inline void BlockMeta::set_pbstateid(const ::std::string& value) {
  set_has_pbstateid();
  if (pbstateid_ == &::google::protobuf::internal::kEmptyString) {
    pbstateid_ = new ::std::string;
  }
  pbstateid_->assign(value);
}
inline void BlockMeta::set_pbstateid(const char* value) {
  set_has_pbstateid();
  if (pbstateid_ == &::google::protobuf::internal::kEmptyString) {
    pbstateid_ = new ::std::string;
  }
  pbstateid_->assign(value);
}
inline void BlockMeta::set_pbstateid(const void* value, size_t size) {
  set_has_pbstateid();
  if (pbstateid_ == &::google::protobuf::internal::kEmptyString) {
    pbstateid_ = new ::std::string;
  }
  pbstateid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BlockMeta::mutable_pbstateid() {
  set_has_pbstateid();
  if (pbstateid_ == &::google::protobuf::internal::kEmptyString) {
    pbstateid_ = new ::std::string;
  }
  return pbstateid_;
}
inline ::std::string* BlockMeta::release_pbstateid() {
  clear_has_pbstateid();
  if (pbstateid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pbstateid_;
    pbstateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BlockMeta::set_allocated_pbstateid(::std::string* pbstateid) {
  if (pbstateid_ != &::google::protobuf::internal::kEmptyString) {
    delete pbstateid_;
  }
  if (pbstateid) {
    set_has_pbstateid();
    pbstateid_ = pbstateid;
  } else {
    clear_has_pbstateid();
    pbstateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes prev = 20;
inline bool BlockMeta::has_prev() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BlockMeta::set_has_prev() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BlockMeta::clear_has_prev() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BlockMeta::clear_prev() {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    prev_->clear();
  }
  clear_has_prev();
}
inline const ::std::string& BlockMeta::prev() const {
  return *prev_;
}
inline void BlockMeta::set_prev(const ::std::string& value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void BlockMeta::set_prev(const char* value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void BlockMeta::set_prev(const void* value, size_t size) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BlockMeta::mutable_prev() {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  return prev_;
}
inline ::std::string* BlockMeta::release_prev() {
  clear_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prev_;
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BlockMeta::set_allocated_prev(::std::string* prev) {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    delete prev_;
  }
  if (prev) {
    set_has_prev();
    prev_ = prev;
  } else {
    clear_has_prev();
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes next = 30;
inline bool BlockMeta::has_next() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BlockMeta::set_has_next() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BlockMeta::clear_has_next() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BlockMeta::clear_next() {
  if (next_ != &::google::protobuf::internal::kEmptyString) {
    next_->clear();
  }
  clear_has_next();
}
inline const ::std::string& BlockMeta::next() const {
  return *next_;
}
inline void BlockMeta::set_next(const ::std::string& value) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(value);
}
inline void BlockMeta::set_next(const char* value) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(value);
}
inline void BlockMeta::set_next(const void* value, size_t size) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BlockMeta::mutable_next() {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  return next_;
}
inline ::std::string* BlockMeta::release_next() {
  clear_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = next_;
    next_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BlockMeta::set_allocated_next(::std::string* next) {
  if (next_ != &::google::protobuf::internal::kEmptyString) {
    delete next_;
  }
  if (next) {
    set_has_next();
    next_ = next;
  } else {
    clear_has_next();
    next_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TxMeta

// optional int32 blocknum = 10;
inline bool TxMeta::has_blocknum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxMeta::set_has_blocknum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TxMeta::clear_has_blocknum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TxMeta::clear_blocknum() {
  blocknum_ = 0;
  clear_has_blocknum();
}
inline ::google::protobuf::int32 TxMeta::blocknum() const {
  return blocknum_;
}
inline void TxMeta::set_blocknum(::google::protobuf::int32 value) {
  set_has_blocknum();
  blocknum_ = value;
}

// optional int32 txnum = 20;
inline bool TxMeta::has_txnum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TxMeta::set_has_txnum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TxMeta::clear_has_txnum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TxMeta::clear_txnum() {
  txnum_ = 0;
  clear_has_txnum();
}
inline ::google::protobuf::int32 TxMeta::txnum() const {
  return txnum_;
}
inline void TxMeta::set_txnum(::google::protobuf::int32 value) {
  set_has_txnum();
  txnum_ = value;
}

// optional .fantasybit.TransType txtype = 40;
inline bool TxMeta::has_txtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TxMeta::set_has_txtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TxMeta::clear_has_txtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TxMeta::clear_txtype() {
  txtype_ = 0;
  clear_has_txtype();
}
inline ::fantasybit::TransType TxMeta::txtype() const {
  return static_cast< ::fantasybit::TransType >(txtype_);
}
inline void TxMeta::set_txtype(::fantasybit::TransType value) {
  assert(::fantasybit::TransType_IsValid(value));
  set_has_txtype();
  txtype_ = value;
}

// optional .fantasybit.Transaction tx = 50;
inline bool TxMeta::has_tx() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TxMeta::set_has_tx() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TxMeta::clear_has_tx() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TxMeta::clear_tx() {
  if (tx_ != NULL) tx_->::fantasybit::Transaction::Clear();
  clear_has_tx();
}
inline const ::fantasybit::Transaction& TxMeta::tx() const {
  return tx_ != NULL ? *tx_ : *default_instance_->tx_;
}
inline ::fantasybit::Transaction* TxMeta::mutable_tx() {
  set_has_tx();
  if (tx_ == NULL) tx_ = new ::fantasybit::Transaction;
  return tx_;
}
inline ::fantasybit::Transaction* TxMeta::release_tx() {
  clear_has_tx();
  ::fantasybit::Transaction* temp = tx_;
  tx_ = NULL;
  return temp;
}
inline void TxMeta::set_allocated_tx(::fantasybit::Transaction* tx) {
  delete tx_;
  tx_ = tx;
  if (tx) {
    set_has_tx();
  } else {
    clear_has_tx();
  }
}

// optional string fantasy_name = 60;
inline bool TxMeta::has_fantasy_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TxMeta::set_has_fantasy_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TxMeta::clear_has_fantasy_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TxMeta::clear_fantasy_name() {
  if (fantasy_name_ != &::google::protobuf::internal::kEmptyString) {
    fantasy_name_->clear();
  }
  clear_has_fantasy_name();
}
inline const ::std::string& TxMeta::fantasy_name() const {
  return *fantasy_name_;
}
inline void TxMeta::set_fantasy_name(const ::std::string& value) {
  set_has_fantasy_name();
  if (fantasy_name_ == &::google::protobuf::internal::kEmptyString) {
    fantasy_name_ = new ::std::string;
  }
  fantasy_name_->assign(value);
}
inline void TxMeta::set_fantasy_name(const char* value) {
  set_has_fantasy_name();
  if (fantasy_name_ == &::google::protobuf::internal::kEmptyString) {
    fantasy_name_ = new ::std::string;
  }
  fantasy_name_->assign(value);
}
inline void TxMeta::set_fantasy_name(const char* value, size_t size) {
  set_has_fantasy_name();
  if (fantasy_name_ == &::google::protobuf::internal::kEmptyString) {
    fantasy_name_ = new ::std::string;
  }
  fantasy_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TxMeta::mutable_fantasy_name() {
  set_has_fantasy_name();
  if (fantasy_name_ == &::google::protobuf::internal::kEmptyString) {
    fantasy_name_ = new ::std::string;
  }
  return fantasy_name_;
}
inline ::std::string* TxMeta::release_fantasy_name() {
  clear_has_fantasy_name();
  if (fantasy_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fantasy_name_;
    fantasy_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TxMeta::set_allocated_fantasy_name(::std::string* fantasy_name) {
  if (fantasy_name_ != &::google::protobuf::internal::kEmptyString) {
    delete fantasy_name_;
  }
  if (fantasy_name) {
    set_has_fantasy_name();
    fantasy_name_ = fantasy_name;
  } else {
    clear_has_fantasy_name();
    fantasy_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes id = 70;
inline bool TxMeta::has_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TxMeta::set_has_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TxMeta::clear_has_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TxMeta::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& TxMeta::id() const {
  return *id_;
}
inline void TxMeta::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void TxMeta::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void TxMeta::set_id(const void* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TxMeta::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* TxMeta::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TxMeta::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TrMeta

// optional int32 blocknum = 10;
inline bool TrMeta::has_blocknum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrMeta::set_has_blocknum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrMeta::clear_has_blocknum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrMeta::clear_blocknum() {
  blocknum_ = 0;
  clear_has_blocknum();
}
inline ::google::protobuf::int32 TrMeta::blocknum() const {
  return blocknum_;
}
inline void TrMeta::set_blocknum(::google::protobuf::int32 value) {
  set_has_blocknum();
  blocknum_ = value;
}

// optional .fantasybit.TrType type = 40;
inline bool TrMeta::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrMeta::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrMeta::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrMeta::clear_type() {
  type_ = 2;
  clear_has_type();
}
inline ::fantasybit::TrType TrMeta::type() const {
  return static_cast< ::fantasybit::TrType >(type_);
}
inline void TrMeta::set_type(::fantasybit::TrType value) {
  assert(::fantasybit::TrType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional uint32 season = 50;
inline bool TrMeta::has_season() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrMeta::set_has_season() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrMeta::clear_has_season() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrMeta::clear_season() {
  season_ = 0u;
  clear_has_season();
}
inline ::google::protobuf::uint32 TrMeta::season() const {
  return season_;
}
inline void TrMeta::set_season(::google::protobuf::uint32 value) {
  set_has_season();
  season_ = value;
}

// optional uint32 week = 60;
inline bool TrMeta::has_week() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrMeta::set_has_week() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrMeta::clear_has_week() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TrMeta::clear_week() {
  week_ = 0u;
  clear_has_week();
}
inline ::google::protobuf::uint32 TrMeta::week() const {
  return week_;
}
inline void TrMeta::set_week(::google::protobuf::uint32 value) {
  set_has_week();
  week_ = value;
}

// optional bytes gamemetaroot = 70;
inline bool TrMeta::has_gamemetaroot() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TrMeta::set_has_gamemetaroot() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TrMeta::clear_has_gamemetaroot() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TrMeta::clear_gamemetaroot() {
  if (gamemetaroot_ != &::google::protobuf::internal::kEmptyString) {
    gamemetaroot_->clear();
  }
  clear_has_gamemetaroot();
}
inline const ::std::string& TrMeta::gamemetaroot() const {
  return *gamemetaroot_;
}
inline void TrMeta::set_gamemetaroot(const ::std::string& value) {
  set_has_gamemetaroot();
  if (gamemetaroot_ == &::google::protobuf::internal::kEmptyString) {
    gamemetaroot_ = new ::std::string;
  }
  gamemetaroot_->assign(value);
}
inline void TrMeta::set_gamemetaroot(const char* value) {
  set_has_gamemetaroot();
  if (gamemetaroot_ == &::google::protobuf::internal::kEmptyString) {
    gamemetaroot_ = new ::std::string;
  }
  gamemetaroot_->assign(value);
}
inline void TrMeta::set_gamemetaroot(const void* value, size_t size) {
  set_has_gamemetaroot();
  if (gamemetaroot_ == &::google::protobuf::internal::kEmptyString) {
    gamemetaroot_ = new ::std::string;
  }
  gamemetaroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrMeta::mutable_gamemetaroot() {
  set_has_gamemetaroot();
  if (gamemetaroot_ == &::google::protobuf::internal::kEmptyString) {
    gamemetaroot_ = new ::std::string;
  }
  return gamemetaroot_;
}
inline ::std::string* TrMeta::release_gamemetaroot() {
  clear_has_gamemetaroot();
  if (gamemetaroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gamemetaroot_;
    gamemetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TrMeta::set_allocated_gamemetaroot(::std::string* gamemetaroot) {
  if (gamemetaroot_ != &::google::protobuf::internal::kEmptyString) {
    delete gamemetaroot_;
  }
  if (gamemetaroot) {
    set_has_gamemetaroot();
    gamemetaroot_ = gamemetaroot;
  } else {
    clear_has_gamemetaroot();
    gamemetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes datametaroot = 80;
inline bool TrMeta::has_datametaroot() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TrMeta::set_has_datametaroot() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TrMeta::clear_has_datametaroot() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TrMeta::clear_datametaroot() {
  if (datametaroot_ != &::google::protobuf::internal::kEmptyString) {
    datametaroot_->clear();
  }
  clear_has_datametaroot();
}
inline const ::std::string& TrMeta::datametaroot() const {
  return *datametaroot_;
}
inline void TrMeta::set_datametaroot(const ::std::string& value) {
  set_has_datametaroot();
  if (datametaroot_ == &::google::protobuf::internal::kEmptyString) {
    datametaroot_ = new ::std::string;
  }
  datametaroot_->assign(value);
}
inline void TrMeta::set_datametaroot(const char* value) {
  set_has_datametaroot();
  if (datametaroot_ == &::google::protobuf::internal::kEmptyString) {
    datametaroot_ = new ::std::string;
  }
  datametaroot_->assign(value);
}
inline void TrMeta::set_datametaroot(const void* value, size_t size) {
  set_has_datametaroot();
  if (datametaroot_ == &::google::protobuf::internal::kEmptyString) {
    datametaroot_ = new ::std::string;
  }
  datametaroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrMeta::mutable_datametaroot() {
  set_has_datametaroot();
  if (datametaroot_ == &::google::protobuf::internal::kEmptyString) {
    datametaroot_ = new ::std::string;
  }
  return datametaroot_;
}
inline ::std::string* TrMeta::release_datametaroot() {
  clear_has_datametaroot();
  if (datametaroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = datametaroot_;
    datametaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TrMeta::set_allocated_datametaroot(::std::string* datametaroot) {
  if (datametaroot_ != &::google::protobuf::internal::kEmptyString) {
    delete datametaroot_;
  }
  if (datametaroot) {
    set_has_datametaroot();
    datametaroot_ = datametaroot;
  } else {
    clear_has_datametaroot();
    datametaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes txmetaid = 100;
inline bool TrMeta::has_txmetaid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TrMeta::set_has_txmetaid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TrMeta::clear_has_txmetaid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TrMeta::clear_txmetaid() {
  if (txmetaid_ != &::google::protobuf::internal::kEmptyString) {
    txmetaid_->clear();
  }
  clear_has_txmetaid();
}
inline const ::std::string& TrMeta::txmetaid() const {
  return *txmetaid_;
}
inline void TrMeta::set_txmetaid(const ::std::string& value) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(value);
}
inline void TrMeta::set_txmetaid(const char* value) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(value);
}
inline void TrMeta::set_txmetaid(const void* value, size_t size) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrMeta::mutable_txmetaid() {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  return txmetaid_;
}
inline ::std::string* TrMeta::release_txmetaid() {
  clear_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = txmetaid_;
    txmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TrMeta::set_allocated_txmetaid(::std::string* txmetaid) {
  if (txmetaid_ != &::google::protobuf::internal::kEmptyString) {
    delete txmetaid_;
  }
  if (txmetaid) {
    set_has_txmetaid();
    txmetaid_ = txmetaid;
  } else {
    clear_has_txmetaid();
    txmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GameMeta

// optional bytes txmetaid = 10;
inline bool GameMeta::has_txmetaid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameMeta::set_has_txmetaid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameMeta::clear_has_txmetaid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameMeta::clear_txmetaid() {
  if (txmetaid_ != &::google::protobuf::internal::kEmptyString) {
    txmetaid_->clear();
  }
  clear_has_txmetaid();
}
inline const ::std::string& GameMeta::txmetaid() const {
  return *txmetaid_;
}
inline void GameMeta::set_txmetaid(const ::std::string& value) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(value);
}
inline void GameMeta::set_txmetaid(const char* value) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(value);
}
inline void GameMeta::set_txmetaid(const void* value, size_t size) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameMeta::mutable_txmetaid() {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  return txmetaid_;
}
inline ::std::string* GameMeta::release_txmetaid() {
  clear_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = txmetaid_;
    txmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameMeta::set_allocated_txmetaid(::std::string* txmetaid) {
  if (txmetaid_ != &::google::protobuf::internal::kEmptyString) {
    delete txmetaid_;
  }
  if (txmetaid) {
    set_has_txmetaid();
    txmetaid_ = txmetaid;
  } else {
    clear_has_txmetaid();
    txmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .fantasybit.GameData gamedata = 20;
inline bool GameMeta::has_gamedata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameMeta::set_has_gamedata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameMeta::clear_has_gamedata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameMeta::clear_gamedata() {
  if (gamedata_ != NULL) gamedata_->::fantasybit::GameData::Clear();
  clear_has_gamedata();
}
inline const ::fantasybit::GameData& GameMeta::gamedata() const {
  return gamedata_ != NULL ? *gamedata_ : *default_instance_->gamedata_;
}
inline ::fantasybit::GameData* GameMeta::mutable_gamedata() {
  set_has_gamedata();
  if (gamedata_ == NULL) gamedata_ = new ::fantasybit::GameData;
  return gamedata_;
}
inline ::fantasybit::GameData* GameMeta::release_gamedata() {
  clear_has_gamedata();
  ::fantasybit::GameData* temp = gamedata_;
  gamedata_ = NULL;
  return temp;
}
inline void GameMeta::set_allocated_gamedata(::fantasybit::GameData* gamedata) {
  delete gamedata_;
  gamedata_ = gamedata;
  if (gamedata) {
    set_has_gamedata();
  } else {
    clear_has_gamedata();
  }
}

// -------------------------------------------------------------------

// DataMeta

// optional bytes txmetaid = 10;
inline bool DataMeta::has_txmetaid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataMeta::set_has_txmetaid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataMeta::clear_has_txmetaid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataMeta::clear_txmetaid() {
  if (txmetaid_ != &::google::protobuf::internal::kEmptyString) {
    txmetaid_->clear();
  }
  clear_has_txmetaid();
}
inline const ::std::string& DataMeta::txmetaid() const {
  return *txmetaid_;
}
inline void DataMeta::set_txmetaid(const ::std::string& value) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(value);
}
inline void DataMeta::set_txmetaid(const char* value) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(value);
}
inline void DataMeta::set_txmetaid(const void* value, size_t size) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataMeta::mutable_txmetaid() {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  return txmetaid_;
}
inline ::std::string* DataMeta::release_txmetaid() {
  clear_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = txmetaid_;
    txmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DataMeta::set_allocated_txmetaid(::std::string* txmetaid) {
  if (txmetaid_ != &::google::protobuf::internal::kEmptyString) {
    delete txmetaid_;
  }
  if (txmetaid) {
    set_has_txmetaid();
    txmetaid_ = txmetaid;
  } else {
    clear_has_txmetaid();
    txmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .fantasybit.Data data = 20;
inline bool DataMeta::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataMeta::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataMeta::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataMeta::clear_data() {
  if (data_ != NULL) data_->::fantasybit::Data::Clear();
  clear_has_data();
}
inline const ::fantasybit::Data& DataMeta::data() const {
  return data_ != NULL ? *data_ : *default_instance_->data_;
}
inline ::fantasybit::Data* DataMeta::mutable_data() {
  set_has_data();
  if (data_ == NULL) data_ = new ::fantasybit::Data;
  return data_;
}
inline ::fantasybit::Data* DataMeta::release_data() {
  clear_has_data();
  ::fantasybit::Data* temp = data_;
  data_ = NULL;
  return temp;
}
inline void DataMeta::set_allocated_data(::fantasybit::Data* data) {
  delete data_;
  data_ = data;
  if (data) {
    set_has_data();
  } else {
    clear_has_data();
  }
}

// -------------------------------------------------------------------

// LeaderBoardMeta

// optional uint32 week = 10;
inline bool LeaderBoardMeta::has_week() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LeaderBoardMeta::set_has_week() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LeaderBoardMeta::clear_has_week() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LeaderBoardMeta::clear_week() {
  week_ = 0u;
  clear_has_week();
}
inline ::google::protobuf::uint32 LeaderBoardMeta::week() const {
  return week_;
}
inline void LeaderBoardMeta::set_week(::google::protobuf::uint32 value) {
  set_has_week();
  week_ = value;
}

// optional bytes fnbalmetaroot = 20;
inline bool LeaderBoardMeta::has_fnbalmetaroot() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LeaderBoardMeta::set_has_fnbalmetaroot() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LeaderBoardMeta::clear_has_fnbalmetaroot() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LeaderBoardMeta::clear_fnbalmetaroot() {
  if (fnbalmetaroot_ != &::google::protobuf::internal::kEmptyString) {
    fnbalmetaroot_->clear();
  }
  clear_has_fnbalmetaroot();
}
inline const ::std::string& LeaderBoardMeta::fnbalmetaroot() const {
  return *fnbalmetaroot_;
}
inline void LeaderBoardMeta::set_fnbalmetaroot(const ::std::string& value) {
  set_has_fnbalmetaroot();
  if (fnbalmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    fnbalmetaroot_ = new ::std::string;
  }
  fnbalmetaroot_->assign(value);
}
inline void LeaderBoardMeta::set_fnbalmetaroot(const char* value) {
  set_has_fnbalmetaroot();
  if (fnbalmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    fnbalmetaroot_ = new ::std::string;
  }
  fnbalmetaroot_->assign(value);
}
inline void LeaderBoardMeta::set_fnbalmetaroot(const void* value, size_t size) {
  set_has_fnbalmetaroot();
  if (fnbalmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    fnbalmetaroot_ = new ::std::string;
  }
  fnbalmetaroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LeaderBoardMeta::mutable_fnbalmetaroot() {
  set_has_fnbalmetaroot();
  if (fnbalmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    fnbalmetaroot_ = new ::std::string;
  }
  return fnbalmetaroot_;
}
inline ::std::string* LeaderBoardMeta::release_fnbalmetaroot() {
  clear_has_fnbalmetaroot();
  if (fnbalmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fnbalmetaroot_;
    fnbalmetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LeaderBoardMeta::set_allocated_fnbalmetaroot(::std::string* fnbalmetaroot) {
  if (fnbalmetaroot_ != &::google::protobuf::internal::kEmptyString) {
    delete fnbalmetaroot_;
  }
  if (fnbalmetaroot) {
    set_has_fnbalmetaroot();
    fnbalmetaroot_ = fnbalmetaroot;
  } else {
    clear_has_fnbalmetaroot();
    fnbalmetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes prev = 30;
inline bool LeaderBoardMeta::has_prev() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LeaderBoardMeta::set_has_prev() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LeaderBoardMeta::clear_has_prev() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LeaderBoardMeta::clear_prev() {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    prev_->clear();
  }
  clear_has_prev();
}
inline const ::std::string& LeaderBoardMeta::prev() const {
  return *prev_;
}
inline void LeaderBoardMeta::set_prev(const ::std::string& value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void LeaderBoardMeta::set_prev(const char* value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void LeaderBoardMeta::set_prev(const void* value, size_t size) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LeaderBoardMeta::mutable_prev() {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  return prev_;
}
inline ::std::string* LeaderBoardMeta::release_prev() {
  clear_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prev_;
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LeaderBoardMeta::set_allocated_prev(::std::string* prev) {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    delete prev_;
  }
  if (prev) {
    set_has_prev();
    prev_ = prev;
  } else {
    clear_has_prev();
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes next = 40;
inline bool LeaderBoardMeta::has_next() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LeaderBoardMeta::set_has_next() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LeaderBoardMeta::clear_has_next() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LeaderBoardMeta::clear_next() {
  if (next_ != &::google::protobuf::internal::kEmptyString) {
    next_->clear();
  }
  clear_has_next();
}
inline const ::std::string& LeaderBoardMeta::next() const {
  return *next_;
}
inline void LeaderBoardMeta::set_next(const ::std::string& value) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(value);
}
inline void LeaderBoardMeta::set_next(const char* value) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(value);
}
inline void LeaderBoardMeta::set_next(const void* value, size_t size) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LeaderBoardMeta::mutable_next() {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  return next_;
}
inline ::std::string* LeaderBoardMeta::release_next() {
  clear_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = next_;
    next_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LeaderBoardMeta::set_allocated_next(::std::string* next) {
  if (next_ != &::google::protobuf::internal::kEmptyString) {
    delete next_;
  }
  if (next) {
    set_has_next();
    next_ = next;
  } else {
    clear_has_next();
    next_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FantasyNameBalMeta

// optional bytes txmetaid = 10;
inline bool FantasyNameBalMeta::has_txmetaid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FantasyNameBalMeta::set_has_txmetaid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FantasyNameBalMeta::clear_has_txmetaid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FantasyNameBalMeta::clear_txmetaid() {
  if (txmetaid_ != &::google::protobuf::internal::kEmptyString) {
    txmetaid_->clear();
  }
  clear_has_txmetaid();
}
inline const ::std::string& FantasyNameBalMeta::txmetaid() const {
  return *txmetaid_;
}
inline void FantasyNameBalMeta::set_txmetaid(const ::std::string& value) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(value);
}
inline void FantasyNameBalMeta::set_txmetaid(const char* value) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(value);
}
inline void FantasyNameBalMeta::set_txmetaid(const void* value, size_t size) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FantasyNameBalMeta::mutable_txmetaid() {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  return txmetaid_;
}
inline ::std::string* FantasyNameBalMeta::release_txmetaid() {
  clear_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = txmetaid_;
    txmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FantasyNameBalMeta::set_allocated_txmetaid(::std::string* txmetaid) {
  if (txmetaid_ != &::google::protobuf::internal::kEmptyString) {
    delete txmetaid_;
  }
  if (txmetaid) {
    set_has_txmetaid();
    txmetaid_ = txmetaid;
  } else {
    clear_has_txmetaid();
    txmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes trmetaid = 20;
inline bool FantasyNameBalMeta::has_trmetaid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FantasyNameBalMeta::set_has_trmetaid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FantasyNameBalMeta::clear_has_trmetaid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FantasyNameBalMeta::clear_trmetaid() {
  if (trmetaid_ != &::google::protobuf::internal::kEmptyString) {
    trmetaid_->clear();
  }
  clear_has_trmetaid();
}
inline const ::std::string& FantasyNameBalMeta::trmetaid() const {
  return *trmetaid_;
}
inline void FantasyNameBalMeta::set_trmetaid(const ::std::string& value) {
  set_has_trmetaid();
  if (trmetaid_ == &::google::protobuf::internal::kEmptyString) {
    trmetaid_ = new ::std::string;
  }
  trmetaid_->assign(value);
}
inline void FantasyNameBalMeta::set_trmetaid(const char* value) {
  set_has_trmetaid();
  if (trmetaid_ == &::google::protobuf::internal::kEmptyString) {
    trmetaid_ = new ::std::string;
  }
  trmetaid_->assign(value);
}
inline void FantasyNameBalMeta::set_trmetaid(const void* value, size_t size) {
  set_has_trmetaid();
  if (trmetaid_ == &::google::protobuf::internal::kEmptyString) {
    trmetaid_ = new ::std::string;
  }
  trmetaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FantasyNameBalMeta::mutable_trmetaid() {
  set_has_trmetaid();
  if (trmetaid_ == &::google::protobuf::internal::kEmptyString) {
    trmetaid_ = new ::std::string;
  }
  return trmetaid_;
}
inline ::std::string* FantasyNameBalMeta::release_trmetaid() {
  clear_has_trmetaid();
  if (trmetaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = trmetaid_;
    trmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FantasyNameBalMeta::set_allocated_trmetaid(::std::string* trmetaid) {
  if (trmetaid_ != &::google::protobuf::internal::kEmptyString) {
    delete trmetaid_;
  }
  if (trmetaid) {
    set_has_trmetaid();
    trmetaid_ = trmetaid;
  } else {
    clear_has_trmetaid();
    trmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 25;
inline bool FantasyNameBalMeta::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FantasyNameBalMeta::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FantasyNameBalMeta::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FantasyNameBalMeta::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& FantasyNameBalMeta::name() const {
  return *name_;
}
inline void FantasyNameBalMeta::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FantasyNameBalMeta::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FantasyNameBalMeta::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FantasyNameBalMeta::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* FantasyNameBalMeta::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FantasyNameBalMeta::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string public_key = 30;
inline bool FantasyNameBalMeta::has_public_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FantasyNameBalMeta::set_has_public_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FantasyNameBalMeta::clear_has_public_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FantasyNameBalMeta::clear_public_key() {
  if (public_key_ != &::google::protobuf::internal::kEmptyString) {
    public_key_->clear();
  }
  clear_has_public_key();
}
inline const ::std::string& FantasyNameBalMeta::public_key() const {
  return *public_key_;
}
inline void FantasyNameBalMeta::set_public_key(const ::std::string& value) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void FantasyNameBalMeta::set_public_key(const char* value) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void FantasyNameBalMeta::set_public_key(const char* value, size_t size) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FantasyNameBalMeta::mutable_public_key() {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}
inline ::std::string* FantasyNameBalMeta::release_public_key() {
  clear_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = public_key_;
    public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FantasyNameBalMeta::set_allocated_public_key(::std::string* public_key) {
  if (public_key_ != &::google::protobuf::internal::kEmptyString) {
    delete public_key_;
  }
  if (public_key) {
    set_has_public_key();
    public_key_ = public_key;
  } else {
    clear_has_public_key();
    public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 bits = 35;
inline bool FantasyNameBalMeta::has_bits() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FantasyNameBalMeta::set_has_bits() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FantasyNameBalMeta::clear_has_bits() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FantasyNameBalMeta::clear_bits() {
  bits_ = GOOGLE_ULONGLONG(0);
  clear_has_bits();
}
inline ::google::protobuf::uint64 FantasyNameBalMeta::bits() const {
  return bits_;
}
inline void FantasyNameBalMeta::set_bits(::google::protobuf::uint64 value) {
  set_has_bits();
  bits_ = value;
}

// optional int64 stake = 40;
inline bool FantasyNameBalMeta::has_stake() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FantasyNameBalMeta::set_has_stake() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FantasyNameBalMeta::clear_has_stake() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FantasyNameBalMeta::clear_stake() {
  stake_ = GOOGLE_LONGLONG(0);
  clear_has_stake();
}
inline ::google::protobuf::int64 FantasyNameBalMeta::stake() const {
  return stake_;
}
inline void FantasyNameBalMeta::set_stake(::google::protobuf::int64 value) {
  set_has_stake();
  stake_ = value;
}

// optional int32 block = 41;
inline bool FantasyNameBalMeta::has_block() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FantasyNameBalMeta::set_has_block() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FantasyNameBalMeta::clear_has_block() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FantasyNameBalMeta::clear_block() {
  block_ = 0;
  clear_has_block();
}
inline ::google::protobuf::int32 FantasyNameBalMeta::block() const {
  return block_;
}
inline void FantasyNameBalMeta::set_block(::google::protobuf::int32 value) {
  set_has_block();
  block_ = value;
}

// optional int32 count = 42;
inline bool FantasyNameBalMeta::has_count() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FantasyNameBalMeta::set_has_count() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FantasyNameBalMeta::clear_has_count() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FantasyNameBalMeta::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 FantasyNameBalMeta::count() const {
  return count_;
}
inline void FantasyNameBalMeta::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// optional uint64 nonce = 45;
inline bool FantasyNameBalMeta::has_nonce() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void FantasyNameBalMeta::set_has_nonce() {
  _has_bits_[0] |= 0x00000100u;
}
inline void FantasyNameBalMeta::clear_has_nonce() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void FantasyNameBalMeta::clear_nonce() {
  nonce_ = GOOGLE_ULONGLONG(0);
  clear_has_nonce();
}
inline ::google::protobuf::uint64 FantasyNameBalMeta::nonce() const {
  return nonce_;
}
inline void FantasyNameBalMeta::set_nonce(::google::protobuf::uint64 value) {
  set_has_nonce();
  nonce_ = value;
}

// optional bytes awardmetaroot = 50;
inline bool FantasyNameBalMeta::has_awardmetaroot() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void FantasyNameBalMeta::set_has_awardmetaroot() {
  _has_bits_[0] |= 0x00000200u;
}
inline void FantasyNameBalMeta::clear_has_awardmetaroot() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void FantasyNameBalMeta::clear_awardmetaroot() {
  if (awardmetaroot_ != &::google::protobuf::internal::kEmptyString) {
    awardmetaroot_->clear();
  }
  clear_has_awardmetaroot();
}
inline const ::std::string& FantasyNameBalMeta::awardmetaroot() const {
  return *awardmetaroot_;
}
inline void FantasyNameBalMeta::set_awardmetaroot(const ::std::string& value) {
  set_has_awardmetaroot();
  if (awardmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    awardmetaroot_ = new ::std::string;
  }
  awardmetaroot_->assign(value);
}
inline void FantasyNameBalMeta::set_awardmetaroot(const char* value) {
  set_has_awardmetaroot();
  if (awardmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    awardmetaroot_ = new ::std::string;
  }
  awardmetaroot_->assign(value);
}
inline void FantasyNameBalMeta::set_awardmetaroot(const void* value, size_t size) {
  set_has_awardmetaroot();
  if (awardmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    awardmetaroot_ = new ::std::string;
  }
  awardmetaroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FantasyNameBalMeta::mutable_awardmetaroot() {
  set_has_awardmetaroot();
  if (awardmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    awardmetaroot_ = new ::std::string;
  }
  return awardmetaroot_;
}
inline ::std::string* FantasyNameBalMeta::release_awardmetaroot() {
  clear_has_awardmetaroot();
  if (awardmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = awardmetaroot_;
    awardmetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FantasyNameBalMeta::set_allocated_awardmetaroot(::std::string* awardmetaroot) {
  if (awardmetaroot_ != &::google::protobuf::internal::kEmptyString) {
    delete awardmetaroot_;
  }
  if (awardmetaroot) {
    set_has_awardmetaroot();
    awardmetaroot_ = awardmetaroot;
  } else {
    clear_has_awardmetaroot();
    awardmetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes pnlmetaroot = 60;
inline bool FantasyNameBalMeta::has_pnlmetaroot() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void FantasyNameBalMeta::set_has_pnlmetaroot() {
  _has_bits_[0] |= 0x00000400u;
}
inline void FantasyNameBalMeta::clear_has_pnlmetaroot() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void FantasyNameBalMeta::clear_pnlmetaroot() {
  if (pnlmetaroot_ != &::google::protobuf::internal::kEmptyString) {
    pnlmetaroot_->clear();
  }
  clear_has_pnlmetaroot();
}
inline const ::std::string& FantasyNameBalMeta::pnlmetaroot() const {
  return *pnlmetaroot_;
}
inline void FantasyNameBalMeta::set_pnlmetaroot(const ::std::string& value) {
  set_has_pnlmetaroot();
  if (pnlmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    pnlmetaroot_ = new ::std::string;
  }
  pnlmetaroot_->assign(value);
}
inline void FantasyNameBalMeta::set_pnlmetaroot(const char* value) {
  set_has_pnlmetaroot();
  if (pnlmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    pnlmetaroot_ = new ::std::string;
  }
  pnlmetaroot_->assign(value);
}
inline void FantasyNameBalMeta::set_pnlmetaroot(const void* value, size_t size) {
  set_has_pnlmetaroot();
  if (pnlmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    pnlmetaroot_ = new ::std::string;
  }
  pnlmetaroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FantasyNameBalMeta::mutable_pnlmetaroot() {
  set_has_pnlmetaroot();
  if (pnlmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    pnlmetaroot_ = new ::std::string;
  }
  return pnlmetaroot_;
}
inline ::std::string* FantasyNameBalMeta::release_pnlmetaroot() {
  clear_has_pnlmetaroot();
  if (pnlmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pnlmetaroot_;
    pnlmetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FantasyNameBalMeta::set_allocated_pnlmetaroot(::std::string* pnlmetaroot) {
  if (pnlmetaroot_ != &::google::protobuf::internal::kEmptyString) {
    delete pnlmetaroot_;
  }
  if (pnlmetaroot) {
    set_has_pnlmetaroot();
    pnlmetaroot_ = pnlmetaroot;
  } else {
    clear_has_pnlmetaroot();
    pnlmetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes prev = 70;
inline bool FantasyNameBalMeta::has_prev() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void FantasyNameBalMeta::set_has_prev() {
  _has_bits_[0] |= 0x00000800u;
}
inline void FantasyNameBalMeta::clear_has_prev() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void FantasyNameBalMeta::clear_prev() {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    prev_->clear();
  }
  clear_has_prev();
}
inline const ::std::string& FantasyNameBalMeta::prev() const {
  return *prev_;
}
inline void FantasyNameBalMeta::set_prev(const ::std::string& value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void FantasyNameBalMeta::set_prev(const char* value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void FantasyNameBalMeta::set_prev(const void* value, size_t size) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FantasyNameBalMeta::mutable_prev() {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  return prev_;
}
inline ::std::string* FantasyNameBalMeta::release_prev() {
  clear_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prev_;
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FantasyNameBalMeta::set_allocated_prev(::std::string* prev) {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    delete prev_;
  }
  if (prev) {
    set_has_prev();
    prev_ = prev;
  } else {
    clear_has_prev();
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes next = 80;
inline bool FantasyNameBalMeta::has_next() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void FantasyNameBalMeta::set_has_next() {
  _has_bits_[0] |= 0x00001000u;
}
inline void FantasyNameBalMeta::clear_has_next() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void FantasyNameBalMeta::clear_next() {
  if (next_ != &::google::protobuf::internal::kEmptyString) {
    next_->clear();
  }
  clear_has_next();
}
inline const ::std::string& FantasyNameBalMeta::next() const {
  return *next_;
}
inline void FantasyNameBalMeta::set_next(const ::std::string& value) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(value);
}
inline void FantasyNameBalMeta::set_next(const char* value) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(value);
}
inline void FantasyNameBalMeta::set_next(const void* value, size_t size) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FantasyNameBalMeta::mutable_next() {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  return next_;
}
inline ::std::string* FantasyNameBalMeta::release_next() {
  clear_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = next_;
    next_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FantasyNameBalMeta::set_allocated_next(::std::string* next) {
  if (next_ != &::google::protobuf::internal::kEmptyString) {
    delete next_;
  }
  if (next) {
    set_has_next();
    next_ = next;
  } else {
    clear_has_next();
    next_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FantasyNameState

// optional string name = 1;
inline bool FantasyNameState::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FantasyNameState::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FantasyNameState::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FantasyNameState::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& FantasyNameState::name() const {
  return *name_;
}
inline void FantasyNameState::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FantasyNameState::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FantasyNameState::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FantasyNameState::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* FantasyNameState::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FantasyNameState::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes fantasynamebalmetaid = 10;
inline bool FantasyNameState::has_fantasynamebalmetaid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FantasyNameState::set_has_fantasynamebalmetaid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FantasyNameState::clear_has_fantasynamebalmetaid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FantasyNameState::clear_fantasynamebalmetaid() {
  if (fantasynamebalmetaid_ != &::google::protobuf::internal::kEmptyString) {
    fantasynamebalmetaid_->clear();
  }
  clear_has_fantasynamebalmetaid();
}
inline const ::std::string& FantasyNameState::fantasynamebalmetaid() const {
  return *fantasynamebalmetaid_;
}
inline void FantasyNameState::set_fantasynamebalmetaid(const ::std::string& value) {
  set_has_fantasynamebalmetaid();
  if (fantasynamebalmetaid_ == &::google::protobuf::internal::kEmptyString) {
    fantasynamebalmetaid_ = new ::std::string;
  }
  fantasynamebalmetaid_->assign(value);
}
inline void FantasyNameState::set_fantasynamebalmetaid(const char* value) {
  set_has_fantasynamebalmetaid();
  if (fantasynamebalmetaid_ == &::google::protobuf::internal::kEmptyString) {
    fantasynamebalmetaid_ = new ::std::string;
  }
  fantasynamebalmetaid_->assign(value);
}
inline void FantasyNameState::set_fantasynamebalmetaid(const void* value, size_t size) {
  set_has_fantasynamebalmetaid();
  if (fantasynamebalmetaid_ == &::google::protobuf::internal::kEmptyString) {
    fantasynamebalmetaid_ = new ::std::string;
  }
  fantasynamebalmetaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FantasyNameState::mutable_fantasynamebalmetaid() {
  set_has_fantasynamebalmetaid();
  if (fantasynamebalmetaid_ == &::google::protobuf::internal::kEmptyString) {
    fantasynamebalmetaid_ = new ::std::string;
  }
  return fantasynamebalmetaid_;
}
inline ::std::string* FantasyNameState::release_fantasynamebalmetaid() {
  clear_has_fantasynamebalmetaid();
  if (fantasynamebalmetaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fantasynamebalmetaid_;
    fantasynamebalmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FantasyNameState::set_allocated_fantasynamebalmetaid(::std::string* fantasynamebalmetaid) {
  if (fantasynamebalmetaid_ != &::google::protobuf::internal::kEmptyString) {
    delete fantasynamebalmetaid_;
  }
  if (fantasynamebalmetaid) {
    set_has_fantasynamebalmetaid();
    fantasynamebalmetaid_ = fantasynamebalmetaid;
  } else {
    clear_has_fantasynamebalmetaid();
    fantasynamebalmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes posmetaroot = 20;
inline bool FantasyNameState::has_posmetaroot() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FantasyNameState::set_has_posmetaroot() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FantasyNameState::clear_has_posmetaroot() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FantasyNameState::clear_posmetaroot() {
  if (posmetaroot_ != &::google::protobuf::internal::kEmptyString) {
    posmetaroot_->clear();
  }
  clear_has_posmetaroot();
}
inline const ::std::string& FantasyNameState::posmetaroot() const {
  return *posmetaroot_;
}
inline void FantasyNameState::set_posmetaroot(const ::std::string& value) {
  set_has_posmetaroot();
  if (posmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    posmetaroot_ = new ::std::string;
  }
  posmetaroot_->assign(value);
}
inline void FantasyNameState::set_posmetaroot(const char* value) {
  set_has_posmetaroot();
  if (posmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    posmetaroot_ = new ::std::string;
  }
  posmetaroot_->assign(value);
}
inline void FantasyNameState::set_posmetaroot(const void* value, size_t size) {
  set_has_posmetaroot();
  if (posmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    posmetaroot_ = new ::std::string;
  }
  posmetaroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FantasyNameState::mutable_posmetaroot() {
  set_has_posmetaroot();
  if (posmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    posmetaroot_ = new ::std::string;
  }
  return posmetaroot_;
}
inline ::std::string* FantasyNameState::release_posmetaroot() {
  clear_has_posmetaroot();
  if (posmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = posmetaroot_;
    posmetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FantasyNameState::set_allocated_posmetaroot(::std::string* posmetaroot) {
  if (posmetaroot_ != &::google::protobuf::internal::kEmptyString) {
    delete posmetaroot_;
  }
  if (posmetaroot) {
    set_has_posmetaroot();
    posmetaroot_ = posmetaroot;
  } else {
    clear_has_posmetaroot();
    posmetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes ordersmetaroot = 30;
inline bool FantasyNameState::has_ordersmetaroot() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FantasyNameState::set_has_ordersmetaroot() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FantasyNameState::clear_has_ordersmetaroot() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FantasyNameState::clear_ordersmetaroot() {
  if (ordersmetaroot_ != &::google::protobuf::internal::kEmptyString) {
    ordersmetaroot_->clear();
  }
  clear_has_ordersmetaroot();
}
inline const ::std::string& FantasyNameState::ordersmetaroot() const {
  return *ordersmetaroot_;
}
inline void FantasyNameState::set_ordersmetaroot(const ::std::string& value) {
  set_has_ordersmetaroot();
  if (ordersmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    ordersmetaroot_ = new ::std::string;
  }
  ordersmetaroot_->assign(value);
}
inline void FantasyNameState::set_ordersmetaroot(const char* value) {
  set_has_ordersmetaroot();
  if (ordersmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    ordersmetaroot_ = new ::std::string;
  }
  ordersmetaroot_->assign(value);
}
inline void FantasyNameState::set_ordersmetaroot(const void* value, size_t size) {
  set_has_ordersmetaroot();
  if (ordersmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    ordersmetaroot_ = new ::std::string;
  }
  ordersmetaroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FantasyNameState::mutable_ordersmetaroot() {
  set_has_ordersmetaroot();
  if (ordersmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    ordersmetaroot_ = new ::std::string;
  }
  return ordersmetaroot_;
}
inline ::std::string* FantasyNameState::release_ordersmetaroot() {
  clear_has_ordersmetaroot();
  if (ordersmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ordersmetaroot_;
    ordersmetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FantasyNameState::set_allocated_ordersmetaroot(::std::string* ordersmetaroot) {
  if (ordersmetaroot_ != &::google::protobuf::internal::kEmptyString) {
    delete ordersmetaroot_;
  }
  if (ordersmetaroot) {
    set_has_ordersmetaroot();
    ordersmetaroot_ = ordersmetaroot;
  } else {
    clear_has_ordersmetaroot();
    ordersmetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes projmetaroot = 40;
inline bool FantasyNameState::has_projmetaroot() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FantasyNameState::set_has_projmetaroot() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FantasyNameState::clear_has_projmetaroot() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FantasyNameState::clear_projmetaroot() {
  if (projmetaroot_ != &::google::protobuf::internal::kEmptyString) {
    projmetaroot_->clear();
  }
  clear_has_projmetaroot();
}
inline const ::std::string& FantasyNameState::projmetaroot() const {
  return *projmetaroot_;
}
inline void FantasyNameState::set_projmetaroot(const ::std::string& value) {
  set_has_projmetaroot();
  if (projmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    projmetaroot_ = new ::std::string;
  }
  projmetaroot_->assign(value);
}
inline void FantasyNameState::set_projmetaroot(const char* value) {
  set_has_projmetaroot();
  if (projmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    projmetaroot_ = new ::std::string;
  }
  projmetaroot_->assign(value);
}
inline void FantasyNameState::set_projmetaroot(const void* value, size_t size) {
  set_has_projmetaroot();
  if (projmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    projmetaroot_ = new ::std::string;
  }
  projmetaroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FantasyNameState::mutable_projmetaroot() {
  set_has_projmetaroot();
  if (projmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    projmetaroot_ = new ::std::string;
  }
  return projmetaroot_;
}
inline ::std::string* FantasyNameState::release_projmetaroot() {
  clear_has_projmetaroot();
  if (projmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = projmetaroot_;
    projmetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FantasyNameState::set_allocated_projmetaroot(::std::string* projmetaroot) {
  if (projmetaroot_ != &::google::protobuf::internal::kEmptyString) {
    delete projmetaroot_;
  }
  if (projmetaroot) {
    set_has_projmetaroot();
    projmetaroot_ = projmetaroot;
  } else {
    clear_has_projmetaroot();
    projmetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes prev = 70;
inline bool FantasyNameState::has_prev() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FantasyNameState::set_has_prev() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FantasyNameState::clear_has_prev() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FantasyNameState::clear_prev() {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    prev_->clear();
  }
  clear_has_prev();
}
inline const ::std::string& FantasyNameState::prev() const {
  return *prev_;
}
inline void FantasyNameState::set_prev(const ::std::string& value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void FantasyNameState::set_prev(const char* value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void FantasyNameState::set_prev(const void* value, size_t size) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FantasyNameState::mutable_prev() {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  return prev_;
}
inline ::std::string* FantasyNameState::release_prev() {
  clear_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prev_;
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FantasyNameState::set_allocated_prev(::std::string* prev) {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    delete prev_;
  }
  if (prev) {
    set_has_prev();
    prev_ = prev;
  } else {
    clear_has_prev();
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes next = 80;
inline bool FantasyNameState::has_next() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FantasyNameState::set_has_next() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FantasyNameState::clear_has_next() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FantasyNameState::clear_next() {
  if (next_ != &::google::protobuf::internal::kEmptyString) {
    next_->clear();
  }
  clear_has_next();
}
inline const ::std::string& FantasyNameState::next() const {
  return *next_;
}
inline void FantasyNameState::set_next(const ::std::string& value) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(value);
}
inline void FantasyNameState::set_next(const char* value) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(value);
}
inline void FantasyNameState::set_next(const void* value, size_t size) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FantasyNameState::mutable_next() {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  return next_;
}
inline ::std::string* FantasyNameState::release_next() {
  clear_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = next_;
    next_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FantasyNameState::set_allocated_next(::std::string* next) {
  if (next_ != &::google::protobuf::internal::kEmptyString) {
    delete next_;
  }
  if (next) {
    set_has_next();
    next_ = next;
  } else {
    clear_has_next();
    next_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes txmetaid = 50;
inline bool FantasyNameState::has_txmetaid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FantasyNameState::set_has_txmetaid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FantasyNameState::clear_has_txmetaid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FantasyNameState::clear_txmetaid() {
  if (txmetaid_ != &::google::protobuf::internal::kEmptyString) {
    txmetaid_->clear();
  }
  clear_has_txmetaid();
}
inline const ::std::string& FantasyNameState::txmetaid() const {
  return *txmetaid_;
}
inline void FantasyNameState::set_txmetaid(const ::std::string& value) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(value);
}
inline void FantasyNameState::set_txmetaid(const char* value) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(value);
}
inline void FantasyNameState::set_txmetaid(const void* value, size_t size) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FantasyNameState::mutable_txmetaid() {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  return txmetaid_;
}
inline ::std::string* FantasyNameState::release_txmetaid() {
  clear_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = txmetaid_;
    txmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FantasyNameState::set_allocated_txmetaid(::std::string* txmetaid) {
  if (txmetaid_ != &::google::protobuf::internal::kEmptyString) {
    delete txmetaid_;
  }
  if (txmetaid) {
    set_has_txmetaid();
    txmetaid_ = txmetaid;
  } else {
    clear_has_txmetaid();
    txmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// WeekGameStatusMeta

// optional uint32 week = 10;
inline bool WeekGameStatusMeta::has_week() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WeekGameStatusMeta::set_has_week() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WeekGameStatusMeta::clear_has_week() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WeekGameStatusMeta::clear_week() {
  week_ = 0u;
  clear_has_week();
}
inline ::google::protobuf::uint32 WeekGameStatusMeta::week() const {
  return week_;
}
inline void WeekGameStatusMeta::set_week(::google::protobuf::uint32 value) {
  set_has_week();
  week_ = value;
}

// optional bytes gameresultmetaroot = 20;
inline bool WeekGameStatusMeta::has_gameresultmetaroot() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WeekGameStatusMeta::set_has_gameresultmetaroot() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WeekGameStatusMeta::clear_has_gameresultmetaroot() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WeekGameStatusMeta::clear_gameresultmetaroot() {
  if (gameresultmetaroot_ != &::google::protobuf::internal::kEmptyString) {
    gameresultmetaroot_->clear();
  }
  clear_has_gameresultmetaroot();
}
inline const ::std::string& WeekGameStatusMeta::gameresultmetaroot() const {
  return *gameresultmetaroot_;
}
inline void WeekGameStatusMeta::set_gameresultmetaroot(const ::std::string& value) {
  set_has_gameresultmetaroot();
  if (gameresultmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    gameresultmetaroot_ = new ::std::string;
  }
  gameresultmetaroot_->assign(value);
}
inline void WeekGameStatusMeta::set_gameresultmetaroot(const char* value) {
  set_has_gameresultmetaroot();
  if (gameresultmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    gameresultmetaroot_ = new ::std::string;
  }
  gameresultmetaroot_->assign(value);
}
inline void WeekGameStatusMeta::set_gameresultmetaroot(const void* value, size_t size) {
  set_has_gameresultmetaroot();
  if (gameresultmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    gameresultmetaroot_ = new ::std::string;
  }
  gameresultmetaroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WeekGameStatusMeta::mutable_gameresultmetaroot() {
  set_has_gameresultmetaroot();
  if (gameresultmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    gameresultmetaroot_ = new ::std::string;
  }
  return gameresultmetaroot_;
}
inline ::std::string* WeekGameStatusMeta::release_gameresultmetaroot() {
  clear_has_gameresultmetaroot();
  if (gameresultmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gameresultmetaroot_;
    gameresultmetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WeekGameStatusMeta::set_allocated_gameresultmetaroot(::std::string* gameresultmetaroot) {
  if (gameresultmetaroot_ != &::google::protobuf::internal::kEmptyString) {
    delete gameresultmetaroot_;
  }
  if (gameresultmetaroot) {
    set_has_gameresultmetaroot();
    gameresultmetaroot_ = gameresultmetaroot;
  } else {
    clear_has_gameresultmetaroot();
    gameresultmetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes ingameprojmetaroot = 30;
inline bool WeekGameStatusMeta::has_ingameprojmetaroot() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WeekGameStatusMeta::set_has_ingameprojmetaroot() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WeekGameStatusMeta::clear_has_ingameprojmetaroot() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WeekGameStatusMeta::clear_ingameprojmetaroot() {
  if (ingameprojmetaroot_ != &::google::protobuf::internal::kEmptyString) {
    ingameprojmetaroot_->clear();
  }
  clear_has_ingameprojmetaroot();
}
inline const ::std::string& WeekGameStatusMeta::ingameprojmetaroot() const {
  return *ingameprojmetaroot_;
}
inline void WeekGameStatusMeta::set_ingameprojmetaroot(const ::std::string& value) {
  set_has_ingameprojmetaroot();
  if (ingameprojmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    ingameprojmetaroot_ = new ::std::string;
  }
  ingameprojmetaroot_->assign(value);
}
inline void WeekGameStatusMeta::set_ingameprojmetaroot(const char* value) {
  set_has_ingameprojmetaroot();
  if (ingameprojmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    ingameprojmetaroot_ = new ::std::string;
  }
  ingameprojmetaroot_->assign(value);
}
inline void WeekGameStatusMeta::set_ingameprojmetaroot(const void* value, size_t size) {
  set_has_ingameprojmetaroot();
  if (ingameprojmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    ingameprojmetaroot_ = new ::std::string;
  }
  ingameprojmetaroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WeekGameStatusMeta::mutable_ingameprojmetaroot() {
  set_has_ingameprojmetaroot();
  if (ingameprojmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    ingameprojmetaroot_ = new ::std::string;
  }
  return ingameprojmetaroot_;
}
inline ::std::string* WeekGameStatusMeta::release_ingameprojmetaroot() {
  clear_has_ingameprojmetaroot();
  if (ingameprojmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ingameprojmetaroot_;
    ingameprojmetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WeekGameStatusMeta::set_allocated_ingameprojmetaroot(::std::string* ingameprojmetaroot) {
  if (ingameprojmetaroot_ != &::google::protobuf::internal::kEmptyString) {
    delete ingameprojmetaroot_;
  }
  if (ingameprojmetaroot) {
    set_has_ingameprojmetaroot();
    ingameprojmetaroot_ = ingameprojmetaroot;
  } else {
    clear_has_ingameprojmetaroot();
    ingameprojmetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes opengamestatusroot = 40;
inline bool WeekGameStatusMeta::has_opengamestatusroot() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WeekGameStatusMeta::set_has_opengamestatusroot() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WeekGameStatusMeta::clear_has_opengamestatusroot() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WeekGameStatusMeta::clear_opengamestatusroot() {
  if (opengamestatusroot_ != &::google::protobuf::internal::kEmptyString) {
    opengamestatusroot_->clear();
  }
  clear_has_opengamestatusroot();
}
inline const ::std::string& WeekGameStatusMeta::opengamestatusroot() const {
  return *opengamestatusroot_;
}
inline void WeekGameStatusMeta::set_opengamestatusroot(const ::std::string& value) {
  set_has_opengamestatusroot();
  if (opengamestatusroot_ == &::google::protobuf::internal::kEmptyString) {
    opengamestatusroot_ = new ::std::string;
  }
  opengamestatusroot_->assign(value);
}
inline void WeekGameStatusMeta::set_opengamestatusroot(const char* value) {
  set_has_opengamestatusroot();
  if (opengamestatusroot_ == &::google::protobuf::internal::kEmptyString) {
    opengamestatusroot_ = new ::std::string;
  }
  opengamestatusroot_->assign(value);
}
inline void WeekGameStatusMeta::set_opengamestatusroot(const void* value, size_t size) {
  set_has_opengamestatusroot();
  if (opengamestatusroot_ == &::google::protobuf::internal::kEmptyString) {
    opengamestatusroot_ = new ::std::string;
  }
  opengamestatusroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WeekGameStatusMeta::mutable_opengamestatusroot() {
  set_has_opengamestatusroot();
  if (opengamestatusroot_ == &::google::protobuf::internal::kEmptyString) {
    opengamestatusroot_ = new ::std::string;
  }
  return opengamestatusroot_;
}
inline ::std::string* WeekGameStatusMeta::release_opengamestatusroot() {
  clear_has_opengamestatusroot();
  if (opengamestatusroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = opengamestatusroot_;
    opengamestatusroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WeekGameStatusMeta::set_allocated_opengamestatusroot(::std::string* opengamestatusroot) {
  if (opengamestatusroot_ != &::google::protobuf::internal::kEmptyString) {
    delete opengamestatusroot_;
  }
  if (opengamestatusroot) {
    set_has_opengamestatusroot();
    opengamestatusroot_ = opengamestatusroot;
  } else {
    clear_has_opengamestatusroot();
    opengamestatusroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes prev = 50;
inline bool WeekGameStatusMeta::has_prev() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WeekGameStatusMeta::set_has_prev() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WeekGameStatusMeta::clear_has_prev() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WeekGameStatusMeta::clear_prev() {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    prev_->clear();
  }
  clear_has_prev();
}
inline const ::std::string& WeekGameStatusMeta::prev() const {
  return *prev_;
}
inline void WeekGameStatusMeta::set_prev(const ::std::string& value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void WeekGameStatusMeta::set_prev(const char* value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void WeekGameStatusMeta::set_prev(const void* value, size_t size) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WeekGameStatusMeta::mutable_prev() {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  return prev_;
}
inline ::std::string* WeekGameStatusMeta::release_prev() {
  clear_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prev_;
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WeekGameStatusMeta::set_allocated_prev(::std::string* prev) {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    delete prev_;
  }
  if (prev) {
    set_has_prev();
    prev_ = prev;
  } else {
    clear_has_prev();
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes next = 60;
inline bool WeekGameStatusMeta::has_next() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void WeekGameStatusMeta::set_has_next() {
  _has_bits_[0] |= 0x00000020u;
}
inline void WeekGameStatusMeta::clear_has_next() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void WeekGameStatusMeta::clear_next() {
  if (next_ != &::google::protobuf::internal::kEmptyString) {
    next_->clear();
  }
  clear_has_next();
}
inline const ::std::string& WeekGameStatusMeta::next() const {
  return *next_;
}
inline void WeekGameStatusMeta::set_next(const ::std::string& value) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(value);
}
inline void WeekGameStatusMeta::set_next(const char* value) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(value);
}
inline void WeekGameStatusMeta::set_next(const void* value, size_t size) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WeekGameStatusMeta::mutable_next() {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  return next_;
}
inline ::std::string* WeekGameStatusMeta::release_next() {
  clear_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = next_;
    next_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WeekGameStatusMeta::set_allocated_next(::std::string* next) {
  if (next_ != &::google::protobuf::internal::kEmptyString) {
    delete next_;
  }
  if (next) {
    set_has_next();
    next_ = next;
  } else {
    clear_has_next();
    next_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// InGameProjMeta

// optional string gameid = 20;
inline bool InGameProjMeta::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InGameProjMeta::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InGameProjMeta::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InGameProjMeta::clear_gameid() {
  if (gameid_ != &::google::protobuf::internal::kEmptyString) {
    gameid_->clear();
  }
  clear_has_gameid();
}
inline const ::std::string& InGameProjMeta::gameid() const {
  return *gameid_;
}
inline void InGameProjMeta::set_gameid(const ::std::string& value) {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  gameid_->assign(value);
}
inline void InGameProjMeta::set_gameid(const char* value) {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  gameid_->assign(value);
}
inline void InGameProjMeta::set_gameid(const char* value, size_t size) {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  gameid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InGameProjMeta::mutable_gameid() {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  return gameid_;
}
inline ::std::string* InGameProjMeta::release_gameid() {
  clear_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gameid_;
    gameid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InGameProjMeta::set_allocated_gameid(::std::string* gameid) {
  if (gameid_ != &::google::protobuf::internal::kEmptyString) {
    delete gameid_;
  }
  if (gameid) {
    set_has_gameid();
    gameid_ = gameid;
  } else {
    clear_has_gameid();
    gameid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes gamestatusmetaid = 40;
inline bool InGameProjMeta::has_gamestatusmetaid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InGameProjMeta::set_has_gamestatusmetaid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InGameProjMeta::clear_has_gamestatusmetaid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InGameProjMeta::clear_gamestatusmetaid() {
  if (gamestatusmetaid_ != &::google::protobuf::internal::kEmptyString) {
    gamestatusmetaid_->clear();
  }
  clear_has_gamestatusmetaid();
}
inline const ::std::string& InGameProjMeta::gamestatusmetaid() const {
  return *gamestatusmetaid_;
}
inline void InGameProjMeta::set_gamestatusmetaid(const ::std::string& value) {
  set_has_gamestatusmetaid();
  if (gamestatusmetaid_ == &::google::protobuf::internal::kEmptyString) {
    gamestatusmetaid_ = new ::std::string;
  }
  gamestatusmetaid_->assign(value);
}
inline void InGameProjMeta::set_gamestatusmetaid(const char* value) {
  set_has_gamestatusmetaid();
  if (gamestatusmetaid_ == &::google::protobuf::internal::kEmptyString) {
    gamestatusmetaid_ = new ::std::string;
  }
  gamestatusmetaid_->assign(value);
}
inline void InGameProjMeta::set_gamestatusmetaid(const void* value, size_t size) {
  set_has_gamestatusmetaid();
  if (gamestatusmetaid_ == &::google::protobuf::internal::kEmptyString) {
    gamestatusmetaid_ = new ::std::string;
  }
  gamestatusmetaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InGameProjMeta::mutable_gamestatusmetaid() {
  set_has_gamestatusmetaid();
  if (gamestatusmetaid_ == &::google::protobuf::internal::kEmptyString) {
    gamestatusmetaid_ = new ::std::string;
  }
  return gamestatusmetaid_;
}
inline ::std::string* InGameProjMeta::release_gamestatusmetaid() {
  clear_has_gamestatusmetaid();
  if (gamestatusmetaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gamestatusmetaid_;
    gamestatusmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InGameProjMeta::set_allocated_gamestatusmetaid(::std::string* gamestatusmetaid) {
  if (gamestatusmetaid_ != &::google::protobuf::internal::kEmptyString) {
    delete gamestatusmetaid_;
  }
  if (gamestatusmetaid) {
    set_has_gamestatusmetaid();
    gamestatusmetaid_ = gamestatusmetaid;
  } else {
    clear_has_gamestatusmetaid();
    gamestatusmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes homeprojmeta = 60;
inline bool InGameProjMeta::has_homeprojmeta() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InGameProjMeta::set_has_homeprojmeta() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InGameProjMeta::clear_has_homeprojmeta() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InGameProjMeta::clear_homeprojmeta() {
  if (homeprojmeta_ != &::google::protobuf::internal::kEmptyString) {
    homeprojmeta_->clear();
  }
  clear_has_homeprojmeta();
}
inline const ::std::string& InGameProjMeta::homeprojmeta() const {
  return *homeprojmeta_;
}
inline void InGameProjMeta::set_homeprojmeta(const ::std::string& value) {
  set_has_homeprojmeta();
  if (homeprojmeta_ == &::google::protobuf::internal::kEmptyString) {
    homeprojmeta_ = new ::std::string;
  }
  homeprojmeta_->assign(value);
}
inline void InGameProjMeta::set_homeprojmeta(const char* value) {
  set_has_homeprojmeta();
  if (homeprojmeta_ == &::google::protobuf::internal::kEmptyString) {
    homeprojmeta_ = new ::std::string;
  }
  homeprojmeta_->assign(value);
}
inline void InGameProjMeta::set_homeprojmeta(const void* value, size_t size) {
  set_has_homeprojmeta();
  if (homeprojmeta_ == &::google::protobuf::internal::kEmptyString) {
    homeprojmeta_ = new ::std::string;
  }
  homeprojmeta_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InGameProjMeta::mutable_homeprojmeta() {
  set_has_homeprojmeta();
  if (homeprojmeta_ == &::google::protobuf::internal::kEmptyString) {
    homeprojmeta_ = new ::std::string;
  }
  return homeprojmeta_;
}
inline ::std::string* InGameProjMeta::release_homeprojmeta() {
  clear_has_homeprojmeta();
  if (homeprojmeta_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = homeprojmeta_;
    homeprojmeta_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InGameProjMeta::set_allocated_homeprojmeta(::std::string* homeprojmeta) {
  if (homeprojmeta_ != &::google::protobuf::internal::kEmptyString) {
    delete homeprojmeta_;
  }
  if (homeprojmeta) {
    set_has_homeprojmeta();
    homeprojmeta_ = homeprojmeta;
  } else {
    clear_has_homeprojmeta();
    homeprojmeta_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes awayprojmeta = 70;
inline bool InGameProjMeta::has_awayprojmeta() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InGameProjMeta::set_has_awayprojmeta() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InGameProjMeta::clear_has_awayprojmeta() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InGameProjMeta::clear_awayprojmeta() {
  if (awayprojmeta_ != &::google::protobuf::internal::kEmptyString) {
    awayprojmeta_->clear();
  }
  clear_has_awayprojmeta();
}
inline const ::std::string& InGameProjMeta::awayprojmeta() const {
  return *awayprojmeta_;
}
inline void InGameProjMeta::set_awayprojmeta(const ::std::string& value) {
  set_has_awayprojmeta();
  if (awayprojmeta_ == &::google::protobuf::internal::kEmptyString) {
    awayprojmeta_ = new ::std::string;
  }
  awayprojmeta_->assign(value);
}
inline void InGameProjMeta::set_awayprojmeta(const char* value) {
  set_has_awayprojmeta();
  if (awayprojmeta_ == &::google::protobuf::internal::kEmptyString) {
    awayprojmeta_ = new ::std::string;
  }
  awayprojmeta_->assign(value);
}
inline void InGameProjMeta::set_awayprojmeta(const void* value, size_t size) {
  set_has_awayprojmeta();
  if (awayprojmeta_ == &::google::protobuf::internal::kEmptyString) {
    awayprojmeta_ = new ::std::string;
  }
  awayprojmeta_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InGameProjMeta::mutable_awayprojmeta() {
  set_has_awayprojmeta();
  if (awayprojmeta_ == &::google::protobuf::internal::kEmptyString) {
    awayprojmeta_ = new ::std::string;
  }
  return awayprojmeta_;
}
inline ::std::string* InGameProjMeta::release_awayprojmeta() {
  clear_has_awayprojmeta();
  if (awayprojmeta_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = awayprojmeta_;
    awayprojmeta_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InGameProjMeta::set_allocated_awayprojmeta(::std::string* awayprojmeta) {
  if (awayprojmeta_ != &::google::protobuf::internal::kEmptyString) {
    delete awayprojmeta_;
  }
  if (awayprojmeta) {
    set_has_awayprojmeta();
    awayprojmeta_ = awayprojmeta;
  } else {
    clear_has_awayprojmeta();
    awayprojmeta_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes gamedatametaid = 50;
inline bool InGameProjMeta::has_gamedatametaid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InGameProjMeta::set_has_gamedatametaid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InGameProjMeta::clear_has_gamedatametaid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InGameProjMeta::clear_gamedatametaid() {
  if (gamedatametaid_ != &::google::protobuf::internal::kEmptyString) {
    gamedatametaid_->clear();
  }
  clear_has_gamedatametaid();
}
inline const ::std::string& InGameProjMeta::gamedatametaid() const {
  return *gamedatametaid_;
}
inline void InGameProjMeta::set_gamedatametaid(const ::std::string& value) {
  set_has_gamedatametaid();
  if (gamedatametaid_ == &::google::protobuf::internal::kEmptyString) {
    gamedatametaid_ = new ::std::string;
  }
  gamedatametaid_->assign(value);
}
inline void InGameProjMeta::set_gamedatametaid(const char* value) {
  set_has_gamedatametaid();
  if (gamedatametaid_ == &::google::protobuf::internal::kEmptyString) {
    gamedatametaid_ = new ::std::string;
  }
  gamedatametaid_->assign(value);
}
inline void InGameProjMeta::set_gamedatametaid(const void* value, size_t size) {
  set_has_gamedatametaid();
  if (gamedatametaid_ == &::google::protobuf::internal::kEmptyString) {
    gamedatametaid_ = new ::std::string;
  }
  gamedatametaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InGameProjMeta::mutable_gamedatametaid() {
  set_has_gamedatametaid();
  if (gamedatametaid_ == &::google::protobuf::internal::kEmptyString) {
    gamedatametaid_ = new ::std::string;
  }
  return gamedatametaid_;
}
inline ::std::string* InGameProjMeta::release_gamedatametaid() {
  clear_has_gamedatametaid();
  if (gamedatametaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gamedatametaid_;
    gamedatametaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InGameProjMeta::set_allocated_gamedatametaid(::std::string* gamedatametaid) {
  if (gamedatametaid_ != &::google::protobuf::internal::kEmptyString) {
    delete gamedatametaid_;
  }
  if (gamedatametaid) {
    set_has_gamedatametaid();
    gamedatametaid_ = gamedatametaid;
  } else {
    clear_has_gamedatametaid();
    gamedatametaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GameResultsMeta

// optional string gameid = 20;
inline bool GameResultsMeta::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameResultsMeta::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameResultsMeta::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameResultsMeta::clear_gameid() {
  if (gameid_ != &::google::protobuf::internal::kEmptyString) {
    gameid_->clear();
  }
  clear_has_gameid();
}
inline const ::std::string& GameResultsMeta::gameid() const {
  return *gameid_;
}
inline void GameResultsMeta::set_gameid(const ::std::string& value) {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  gameid_->assign(value);
}
inline void GameResultsMeta::set_gameid(const char* value) {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  gameid_->assign(value);
}
inline void GameResultsMeta::set_gameid(const char* value, size_t size) {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  gameid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameResultsMeta::mutable_gameid() {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  return gameid_;
}
inline ::std::string* GameResultsMeta::release_gameid() {
  clear_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gameid_;
    gameid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameResultsMeta::set_allocated_gameid(::std::string* gameid) {
  if (gameid_ != &::google::protobuf::internal::kEmptyString) {
    delete gameid_;
  }
  if (gameid) {
    set_has_gameid();
    gameid_ = gameid;
  } else {
    clear_has_gameid();
    gameid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes gamestatusmetaid = 40;
inline bool GameResultsMeta::has_gamestatusmetaid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameResultsMeta::set_has_gamestatusmetaid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameResultsMeta::clear_has_gamestatusmetaid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameResultsMeta::clear_gamestatusmetaid() {
  if (gamestatusmetaid_ != &::google::protobuf::internal::kEmptyString) {
    gamestatusmetaid_->clear();
  }
  clear_has_gamestatusmetaid();
}
inline const ::std::string& GameResultsMeta::gamestatusmetaid() const {
  return *gamestatusmetaid_;
}
inline void GameResultsMeta::set_gamestatusmetaid(const ::std::string& value) {
  set_has_gamestatusmetaid();
  if (gamestatusmetaid_ == &::google::protobuf::internal::kEmptyString) {
    gamestatusmetaid_ = new ::std::string;
  }
  gamestatusmetaid_->assign(value);
}
inline void GameResultsMeta::set_gamestatusmetaid(const char* value) {
  set_has_gamestatusmetaid();
  if (gamestatusmetaid_ == &::google::protobuf::internal::kEmptyString) {
    gamestatusmetaid_ = new ::std::string;
  }
  gamestatusmetaid_->assign(value);
}
inline void GameResultsMeta::set_gamestatusmetaid(const void* value, size_t size) {
  set_has_gamestatusmetaid();
  if (gamestatusmetaid_ == &::google::protobuf::internal::kEmptyString) {
    gamestatusmetaid_ = new ::std::string;
  }
  gamestatusmetaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameResultsMeta::mutable_gamestatusmetaid() {
  set_has_gamestatusmetaid();
  if (gamestatusmetaid_ == &::google::protobuf::internal::kEmptyString) {
    gamestatusmetaid_ = new ::std::string;
  }
  return gamestatusmetaid_;
}
inline ::std::string* GameResultsMeta::release_gamestatusmetaid() {
  clear_has_gamestatusmetaid();
  if (gamestatusmetaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gamestatusmetaid_;
    gamestatusmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameResultsMeta::set_allocated_gamestatusmetaid(::std::string* gamestatusmetaid) {
  if (gamestatusmetaid_ != &::google::protobuf::internal::kEmptyString) {
    delete gamestatusmetaid_;
  }
  if (gamestatusmetaid) {
    set_has_gamestatusmetaid();
    gamestatusmetaid_ = gamestatusmetaid;
  } else {
    clear_has_gamestatusmetaid();
    gamestatusmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes homeresultmeta = 60;
inline bool GameResultsMeta::has_homeresultmeta() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameResultsMeta::set_has_homeresultmeta() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameResultsMeta::clear_has_homeresultmeta() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameResultsMeta::clear_homeresultmeta() {
  if (homeresultmeta_ != &::google::protobuf::internal::kEmptyString) {
    homeresultmeta_->clear();
  }
  clear_has_homeresultmeta();
}
inline const ::std::string& GameResultsMeta::homeresultmeta() const {
  return *homeresultmeta_;
}
inline void GameResultsMeta::set_homeresultmeta(const ::std::string& value) {
  set_has_homeresultmeta();
  if (homeresultmeta_ == &::google::protobuf::internal::kEmptyString) {
    homeresultmeta_ = new ::std::string;
  }
  homeresultmeta_->assign(value);
}
inline void GameResultsMeta::set_homeresultmeta(const char* value) {
  set_has_homeresultmeta();
  if (homeresultmeta_ == &::google::protobuf::internal::kEmptyString) {
    homeresultmeta_ = new ::std::string;
  }
  homeresultmeta_->assign(value);
}
inline void GameResultsMeta::set_homeresultmeta(const void* value, size_t size) {
  set_has_homeresultmeta();
  if (homeresultmeta_ == &::google::protobuf::internal::kEmptyString) {
    homeresultmeta_ = new ::std::string;
  }
  homeresultmeta_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameResultsMeta::mutable_homeresultmeta() {
  set_has_homeresultmeta();
  if (homeresultmeta_ == &::google::protobuf::internal::kEmptyString) {
    homeresultmeta_ = new ::std::string;
  }
  return homeresultmeta_;
}
inline ::std::string* GameResultsMeta::release_homeresultmeta() {
  clear_has_homeresultmeta();
  if (homeresultmeta_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = homeresultmeta_;
    homeresultmeta_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameResultsMeta::set_allocated_homeresultmeta(::std::string* homeresultmeta) {
  if (homeresultmeta_ != &::google::protobuf::internal::kEmptyString) {
    delete homeresultmeta_;
  }
  if (homeresultmeta) {
    set_has_homeresultmeta();
    homeresultmeta_ = homeresultmeta;
  } else {
    clear_has_homeresultmeta();
    homeresultmeta_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes awayresultmeta = 70;
inline bool GameResultsMeta::has_awayresultmeta() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameResultsMeta::set_has_awayresultmeta() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameResultsMeta::clear_has_awayresultmeta() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameResultsMeta::clear_awayresultmeta() {
  if (awayresultmeta_ != &::google::protobuf::internal::kEmptyString) {
    awayresultmeta_->clear();
  }
  clear_has_awayresultmeta();
}
inline const ::std::string& GameResultsMeta::awayresultmeta() const {
  return *awayresultmeta_;
}
inline void GameResultsMeta::set_awayresultmeta(const ::std::string& value) {
  set_has_awayresultmeta();
  if (awayresultmeta_ == &::google::protobuf::internal::kEmptyString) {
    awayresultmeta_ = new ::std::string;
  }
  awayresultmeta_->assign(value);
}
inline void GameResultsMeta::set_awayresultmeta(const char* value) {
  set_has_awayresultmeta();
  if (awayresultmeta_ == &::google::protobuf::internal::kEmptyString) {
    awayresultmeta_ = new ::std::string;
  }
  awayresultmeta_->assign(value);
}
inline void GameResultsMeta::set_awayresultmeta(const void* value, size_t size) {
  set_has_awayresultmeta();
  if (awayresultmeta_ == &::google::protobuf::internal::kEmptyString) {
    awayresultmeta_ = new ::std::string;
  }
  awayresultmeta_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameResultsMeta::mutable_awayresultmeta() {
  set_has_awayresultmeta();
  if (awayresultmeta_ == &::google::protobuf::internal::kEmptyString) {
    awayresultmeta_ = new ::std::string;
  }
  return awayresultmeta_;
}
inline ::std::string* GameResultsMeta::release_awayresultmeta() {
  clear_has_awayresultmeta();
  if (awayresultmeta_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = awayresultmeta_;
    awayresultmeta_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameResultsMeta::set_allocated_awayresultmeta(::std::string* awayresultmeta) {
  if (awayresultmeta_ != &::google::protobuf::internal::kEmptyString) {
    delete awayresultmeta_;
  }
  if (awayresultmeta) {
    set_has_awayresultmeta();
    awayresultmeta_ = awayresultmeta;
  } else {
    clear_has_awayresultmeta();
    awayresultmeta_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes resultdatametaid = 50;
inline bool GameResultsMeta::has_resultdatametaid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameResultsMeta::set_has_resultdatametaid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameResultsMeta::clear_has_resultdatametaid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameResultsMeta::clear_resultdatametaid() {
  if (resultdatametaid_ != &::google::protobuf::internal::kEmptyString) {
    resultdatametaid_->clear();
  }
  clear_has_resultdatametaid();
}
inline const ::std::string& GameResultsMeta::resultdatametaid() const {
  return *resultdatametaid_;
}
inline void GameResultsMeta::set_resultdatametaid(const ::std::string& value) {
  set_has_resultdatametaid();
  if (resultdatametaid_ == &::google::protobuf::internal::kEmptyString) {
    resultdatametaid_ = new ::std::string;
  }
  resultdatametaid_->assign(value);
}
inline void GameResultsMeta::set_resultdatametaid(const char* value) {
  set_has_resultdatametaid();
  if (resultdatametaid_ == &::google::protobuf::internal::kEmptyString) {
    resultdatametaid_ = new ::std::string;
  }
  resultdatametaid_->assign(value);
}
inline void GameResultsMeta::set_resultdatametaid(const void* value, size_t size) {
  set_has_resultdatametaid();
  if (resultdatametaid_ == &::google::protobuf::internal::kEmptyString) {
    resultdatametaid_ = new ::std::string;
  }
  resultdatametaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameResultsMeta::mutable_resultdatametaid() {
  set_has_resultdatametaid();
  if (resultdatametaid_ == &::google::protobuf::internal::kEmptyString) {
    resultdatametaid_ = new ::std::string;
  }
  return resultdatametaid_;
}
inline ::std::string* GameResultsMeta::release_resultdatametaid() {
  clear_has_resultdatametaid();
  if (resultdatametaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resultdatametaid_;
    resultdatametaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameResultsMeta::set_allocated_resultdatametaid(::std::string* resultdatametaid) {
  if (resultdatametaid_ != &::google::protobuf::internal::kEmptyString) {
    delete resultdatametaid_;
  }
  if (resultdatametaid) {
    set_has_resultdatametaid();
    resultdatametaid_ = resultdatametaid;
  } else {
    clear_has_resultdatametaid();
    resultdatametaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GameStatusMeta

// optional string id = 1;
inline bool GameStatusMeta::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameStatusMeta::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameStatusMeta::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameStatusMeta::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& GameStatusMeta::id() const {
  return *id_;
}
inline void GameStatusMeta::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void GameStatusMeta::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void GameStatusMeta::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameStatusMeta::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* GameStatusMeta::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameStatusMeta::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 week = 2;
inline bool GameStatusMeta::has_week() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameStatusMeta::set_has_week() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameStatusMeta::clear_has_week() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameStatusMeta::clear_week() {
  week_ = 0;
  clear_has_week();
}
inline ::google::protobuf::int32 GameStatusMeta::week() const {
  return week_;
}
inline void GameStatusMeta::set_week(::google::protobuf::int32 value) {
  set_has_week();
  week_ = value;
}

// optional .fantasybit.GameInfo gameinfo = 10;
inline bool GameStatusMeta::has_gameinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameStatusMeta::set_has_gameinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameStatusMeta::clear_has_gameinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameStatusMeta::clear_gameinfo() {
  if (gameinfo_ != NULL) gameinfo_->::fantasybit::GameInfo::Clear();
  clear_has_gameinfo();
}
inline const ::fantasybit::GameInfo& GameStatusMeta::gameinfo() const {
  return gameinfo_ != NULL ? *gameinfo_ : *default_instance_->gameinfo_;
}
inline ::fantasybit::GameInfo* GameStatusMeta::mutable_gameinfo() {
  set_has_gameinfo();
  if (gameinfo_ == NULL) gameinfo_ = new ::fantasybit::GameInfo;
  return gameinfo_;
}
inline ::fantasybit::GameInfo* GameStatusMeta::release_gameinfo() {
  clear_has_gameinfo();
  ::fantasybit::GameInfo* temp = gameinfo_;
  gameinfo_ = NULL;
  return temp;
}
inline void GameStatusMeta::set_allocated_gameinfo(::fantasybit::GameInfo* gameinfo) {
  delete gameinfo_;
  gameinfo_ = gameinfo;
  if (gameinfo) {
    set_has_gameinfo();
  } else {
    clear_has_gameinfo();
  }
}

// optional .fantasybit.GameStatus gamesatus = 20;
inline bool GameStatusMeta::has_gamesatus() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameStatusMeta::set_has_gamesatus() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameStatusMeta::clear_has_gamesatus() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameStatusMeta::clear_gamesatus() {
  if (gamesatus_ != NULL) gamesatus_->::fantasybit::GameStatus::Clear();
  clear_has_gamesatus();
}
inline const ::fantasybit::GameStatus& GameStatusMeta::gamesatus() const {
  return gamesatus_ != NULL ? *gamesatus_ : *default_instance_->gamesatus_;
}
inline ::fantasybit::GameStatus* GameStatusMeta::mutable_gamesatus() {
  set_has_gamesatus();
  if (gamesatus_ == NULL) gamesatus_ = new ::fantasybit::GameStatus;
  return gamesatus_;
}
inline ::fantasybit::GameStatus* GameStatusMeta::release_gamesatus() {
  clear_has_gamesatus();
  ::fantasybit::GameStatus* temp = gamesatus_;
  gamesatus_ = NULL;
  return temp;
}
inline void GameStatusMeta::set_allocated_gamesatus(::fantasybit::GameStatus* gamesatus) {
  delete gamesatus_;
  gamesatus_ = gamesatus;
  if (gamesatus) {
    set_has_gamesatus();
  } else {
    clear_has_gamesatus();
  }
}

// optional bytes gamemetaid = 30;
inline bool GameStatusMeta::has_gamemetaid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameStatusMeta::set_has_gamemetaid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameStatusMeta::clear_has_gamemetaid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameStatusMeta::clear_gamemetaid() {
  if (gamemetaid_ != &::google::protobuf::internal::kEmptyString) {
    gamemetaid_->clear();
  }
  clear_has_gamemetaid();
}
inline const ::std::string& GameStatusMeta::gamemetaid() const {
  return *gamemetaid_;
}
inline void GameStatusMeta::set_gamemetaid(const ::std::string& value) {
  set_has_gamemetaid();
  if (gamemetaid_ == &::google::protobuf::internal::kEmptyString) {
    gamemetaid_ = new ::std::string;
  }
  gamemetaid_->assign(value);
}
inline void GameStatusMeta::set_gamemetaid(const char* value) {
  set_has_gamemetaid();
  if (gamemetaid_ == &::google::protobuf::internal::kEmptyString) {
    gamemetaid_ = new ::std::string;
  }
  gamemetaid_->assign(value);
}
inline void GameStatusMeta::set_gamemetaid(const void* value, size_t size) {
  set_has_gamemetaid();
  if (gamemetaid_ == &::google::protobuf::internal::kEmptyString) {
    gamemetaid_ = new ::std::string;
  }
  gamemetaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameStatusMeta::mutable_gamemetaid() {
  set_has_gamemetaid();
  if (gamemetaid_ == &::google::protobuf::internal::kEmptyString) {
    gamemetaid_ = new ::std::string;
  }
  return gamemetaid_;
}
inline ::std::string* GameStatusMeta::release_gamemetaid() {
  clear_has_gamemetaid();
  if (gamemetaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gamemetaid_;
    gamemetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameStatusMeta::set_allocated_gamemetaid(::std::string* gamemetaid) {
  if (gamemetaid_ != &::google::protobuf::internal::kEmptyString) {
    delete gamemetaid_;
  }
  if (gamemetaid) {
    set_has_gamemetaid();
    gamemetaid_ = gamemetaid;
  } else {
    clear_has_gamemetaid();
    gamemetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes datametaid = 40;
inline bool GameStatusMeta::has_datametaid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GameStatusMeta::set_has_datametaid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GameStatusMeta::clear_has_datametaid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GameStatusMeta::clear_datametaid() {
  if (datametaid_ != &::google::protobuf::internal::kEmptyString) {
    datametaid_->clear();
  }
  clear_has_datametaid();
}
inline const ::std::string& GameStatusMeta::datametaid() const {
  return *datametaid_;
}
inline void GameStatusMeta::set_datametaid(const ::std::string& value) {
  set_has_datametaid();
  if (datametaid_ == &::google::protobuf::internal::kEmptyString) {
    datametaid_ = new ::std::string;
  }
  datametaid_->assign(value);
}
inline void GameStatusMeta::set_datametaid(const char* value) {
  set_has_datametaid();
  if (datametaid_ == &::google::protobuf::internal::kEmptyString) {
    datametaid_ = new ::std::string;
  }
  datametaid_->assign(value);
}
inline void GameStatusMeta::set_datametaid(const void* value, size_t size) {
  set_has_datametaid();
  if (datametaid_ == &::google::protobuf::internal::kEmptyString) {
    datametaid_ = new ::std::string;
  }
  datametaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameStatusMeta::mutable_datametaid() {
  set_has_datametaid();
  if (datametaid_ == &::google::protobuf::internal::kEmptyString) {
    datametaid_ = new ::std::string;
  }
  return datametaid_;
}
inline ::std::string* GameStatusMeta::release_datametaid() {
  clear_has_datametaid();
  if (datametaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = datametaid_;
    datametaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameStatusMeta::set_allocated_datametaid(::std::string* datametaid) {
  if (datametaid_ != &::google::protobuf::internal::kEmptyString) {
    delete datametaid_;
  }
  if (datametaid) {
    set_has_datametaid();
    datametaid_ = datametaid;
  } else {
    clear_has_datametaid();
    datametaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes prev = 50;
inline bool GameStatusMeta::has_prev() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GameStatusMeta::set_has_prev() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GameStatusMeta::clear_has_prev() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GameStatusMeta::clear_prev() {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    prev_->clear();
  }
  clear_has_prev();
}
inline const ::std::string& GameStatusMeta::prev() const {
  return *prev_;
}
inline void GameStatusMeta::set_prev(const ::std::string& value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void GameStatusMeta::set_prev(const char* value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void GameStatusMeta::set_prev(const void* value, size_t size) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameStatusMeta::mutable_prev() {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  return prev_;
}
inline ::std::string* GameStatusMeta::release_prev() {
  clear_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prev_;
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameStatusMeta::set_allocated_prev(::std::string* prev) {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    delete prev_;
  }
  if (prev) {
    set_has_prev();
    prev_ = prev;
  } else {
    clear_has_prev();
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes next = 60;
inline bool GameStatusMeta::has_next() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GameStatusMeta::set_has_next() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GameStatusMeta::clear_has_next() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GameStatusMeta::clear_next() {
  if (next_ != &::google::protobuf::internal::kEmptyString) {
    next_->clear();
  }
  clear_has_next();
}
inline const ::std::string& GameStatusMeta::next() const {
  return *next_;
}
inline void GameStatusMeta::set_next(const ::std::string& value) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(value);
}
inline void GameStatusMeta::set_next(const char* value) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(value);
}
inline void GameStatusMeta::set_next(const void* value, size_t size) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameStatusMeta::mutable_next() {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  return next_;
}
inline ::std::string* GameStatusMeta::release_next() {
  clear_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = next_;
    next_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameStatusMeta::set_allocated_next(::std::string* next) {
  if (next_ != &::google::protobuf::internal::kEmptyString) {
    delete next_;
  }
  if (next) {
    set_has_next();
    next_ = next;
  } else {
    clear_has_next();
    next_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 season = 70;
inline bool GameStatusMeta::has_season() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GameStatusMeta::set_has_season() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GameStatusMeta::clear_has_season() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GameStatusMeta::clear_season() {
  season_ = 0;
  clear_has_season();
}
inline ::google::protobuf::int32 GameStatusMeta::season() const {
  return season_;
}
inline void GameStatusMeta::set_season(::google::protobuf::int32 value) {
  set_has_season();
  season_ = value;
}

// -------------------------------------------------------------------

// TeamProjMeta

// optional string gameid = 20;
inline bool TeamProjMeta::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TeamProjMeta::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TeamProjMeta::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TeamProjMeta::clear_gameid() {
  if (gameid_ != &::google::protobuf::internal::kEmptyString) {
    gameid_->clear();
  }
  clear_has_gameid();
}
inline const ::std::string& TeamProjMeta::gameid() const {
  return *gameid_;
}
inline void TeamProjMeta::set_gameid(const ::std::string& value) {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  gameid_->assign(value);
}
inline void TeamProjMeta::set_gameid(const char* value) {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  gameid_->assign(value);
}
inline void TeamProjMeta::set_gameid(const char* value, size_t size) {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  gameid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TeamProjMeta::mutable_gameid() {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  return gameid_;
}
inline ::std::string* TeamProjMeta::release_gameid() {
  clear_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gameid_;
    gameid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TeamProjMeta::set_allocated_gameid(::std::string* gameid) {
  if (gameid_ != &::google::protobuf::internal::kEmptyString) {
    delete gameid_;
  }
  if (gameid) {
    set_has_gameid();
    gameid_ = gameid;
  } else {
    clear_has_gameid();
    gameid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string team = 30;
inline bool TeamProjMeta::has_team() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TeamProjMeta::set_has_team() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TeamProjMeta::clear_has_team() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TeamProjMeta::clear_team() {
  if (team_ != &::google::protobuf::internal::kEmptyString) {
    team_->clear();
  }
  clear_has_team();
}
inline const ::std::string& TeamProjMeta::team() const {
  return *team_;
}
inline void TeamProjMeta::set_team(const ::std::string& value) {
  set_has_team();
  if (team_ == &::google::protobuf::internal::kEmptyString) {
    team_ = new ::std::string;
  }
  team_->assign(value);
}
inline void TeamProjMeta::set_team(const char* value) {
  set_has_team();
  if (team_ == &::google::protobuf::internal::kEmptyString) {
    team_ = new ::std::string;
  }
  team_->assign(value);
}
inline void TeamProjMeta::set_team(const char* value, size_t size) {
  set_has_team();
  if (team_ == &::google::protobuf::internal::kEmptyString) {
    team_ = new ::std::string;
  }
  team_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TeamProjMeta::mutable_team() {
  set_has_team();
  if (team_ == &::google::protobuf::internal::kEmptyString) {
    team_ = new ::std::string;
  }
  return team_;
}
inline ::std::string* TeamProjMeta::release_team() {
  clear_has_team();
  if (team_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = team_;
    team_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TeamProjMeta::set_allocated_team(::std::string* team) {
  if (team_ != &::google::protobuf::internal::kEmptyString) {
    delete team_;
  }
  if (team) {
    set_has_team();
    team_ = team;
  } else {
    clear_has_team();
    team_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 kickofftime = 40;
inline bool TeamProjMeta::has_kickofftime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TeamProjMeta::set_has_kickofftime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TeamProjMeta::clear_has_kickofftime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TeamProjMeta::clear_kickofftime() {
  kickofftime_ = 0u;
  clear_has_kickofftime();
}
inline ::google::protobuf::uint32 TeamProjMeta::kickofftime() const {
  return kickofftime_;
}
inline void TeamProjMeta::set_kickofftime(::google::protobuf::uint32 value) {
  set_has_kickofftime();
  kickofftime_ = value;
}

// optional uint32 week = 50;
inline bool TeamProjMeta::has_week() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TeamProjMeta::set_has_week() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TeamProjMeta::clear_has_week() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TeamProjMeta::clear_week() {
  week_ = 0u;
  clear_has_week();
}
inline ::google::protobuf::uint32 TeamProjMeta::week() const {
  return week_;
}
inline void TeamProjMeta::set_week(::google::protobuf::uint32 value) {
  set_has_week();
  week_ = value;
}

// optional bytes gameplayerprojmetaroot = 60;
inline bool TeamProjMeta::has_gameplayerprojmetaroot() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TeamProjMeta::set_has_gameplayerprojmetaroot() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TeamProjMeta::clear_has_gameplayerprojmetaroot() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TeamProjMeta::clear_gameplayerprojmetaroot() {
  if (gameplayerprojmetaroot_ != &::google::protobuf::internal::kEmptyString) {
    gameplayerprojmetaroot_->clear();
  }
  clear_has_gameplayerprojmetaroot();
}
inline const ::std::string& TeamProjMeta::gameplayerprojmetaroot() const {
  return *gameplayerprojmetaroot_;
}
inline void TeamProjMeta::set_gameplayerprojmetaroot(const ::std::string& value) {
  set_has_gameplayerprojmetaroot();
  if (gameplayerprojmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    gameplayerprojmetaroot_ = new ::std::string;
  }
  gameplayerprojmetaroot_->assign(value);
}
inline void TeamProjMeta::set_gameplayerprojmetaroot(const char* value) {
  set_has_gameplayerprojmetaroot();
  if (gameplayerprojmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    gameplayerprojmetaroot_ = new ::std::string;
  }
  gameplayerprojmetaroot_->assign(value);
}
inline void TeamProjMeta::set_gameplayerprojmetaroot(const void* value, size_t size) {
  set_has_gameplayerprojmetaroot();
  if (gameplayerprojmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    gameplayerprojmetaroot_ = new ::std::string;
  }
  gameplayerprojmetaroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TeamProjMeta::mutable_gameplayerprojmetaroot() {
  set_has_gameplayerprojmetaroot();
  if (gameplayerprojmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    gameplayerprojmetaroot_ = new ::std::string;
  }
  return gameplayerprojmetaroot_;
}
inline ::std::string* TeamProjMeta::release_gameplayerprojmetaroot() {
  clear_has_gameplayerprojmetaroot();
  if (gameplayerprojmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gameplayerprojmetaroot_;
    gameplayerprojmetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TeamProjMeta::set_allocated_gameplayerprojmetaroot(::std::string* gameplayerprojmetaroot) {
  if (gameplayerprojmetaroot_ != &::google::protobuf::internal::kEmptyString) {
    delete gameplayerprojmetaroot_;
  }
  if (gameplayerprojmetaroot) {
    set_has_gameplayerprojmetaroot();
    gameplayerprojmetaroot_ = gameplayerprojmetaroot;
  } else {
    clear_has_gameplayerprojmetaroot();
    gameplayerprojmetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes gamedatametaid = 70;
inline bool TeamProjMeta::has_gamedatametaid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TeamProjMeta::set_has_gamedatametaid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TeamProjMeta::clear_has_gamedatametaid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TeamProjMeta::clear_gamedatametaid() {
  if (gamedatametaid_ != &::google::protobuf::internal::kEmptyString) {
    gamedatametaid_->clear();
  }
  clear_has_gamedatametaid();
}
inline const ::std::string& TeamProjMeta::gamedatametaid() const {
  return *gamedatametaid_;
}
inline void TeamProjMeta::set_gamedatametaid(const ::std::string& value) {
  set_has_gamedatametaid();
  if (gamedatametaid_ == &::google::protobuf::internal::kEmptyString) {
    gamedatametaid_ = new ::std::string;
  }
  gamedatametaid_->assign(value);
}
inline void TeamProjMeta::set_gamedatametaid(const char* value) {
  set_has_gamedatametaid();
  if (gamedatametaid_ == &::google::protobuf::internal::kEmptyString) {
    gamedatametaid_ = new ::std::string;
  }
  gamedatametaid_->assign(value);
}
inline void TeamProjMeta::set_gamedatametaid(const void* value, size_t size) {
  set_has_gamedatametaid();
  if (gamedatametaid_ == &::google::protobuf::internal::kEmptyString) {
    gamedatametaid_ = new ::std::string;
  }
  gamedatametaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TeamProjMeta::mutable_gamedatametaid() {
  set_has_gamedatametaid();
  if (gamedatametaid_ == &::google::protobuf::internal::kEmptyString) {
    gamedatametaid_ = new ::std::string;
  }
  return gamedatametaid_;
}
inline ::std::string* TeamProjMeta::release_gamedatametaid() {
  clear_has_gamedatametaid();
  if (gamedatametaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gamedatametaid_;
    gamedatametaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TeamProjMeta::set_allocated_gamedatametaid(::std::string* gamedatametaid) {
  if (gamedatametaid_ != &::google::protobuf::internal::kEmptyString) {
    delete gamedatametaid_;
  }
  if (gamedatametaid) {
    set_has_gamedatametaid();
    gamedatametaid_ = gamedatametaid;
  } else {
    clear_has_gamedatametaid();
    gamedatametaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TeamResultMeta

// optional string gameid = 20;
inline bool TeamResultMeta::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TeamResultMeta::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TeamResultMeta::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TeamResultMeta::clear_gameid() {
  if (gameid_ != &::google::protobuf::internal::kEmptyString) {
    gameid_->clear();
  }
  clear_has_gameid();
}
inline const ::std::string& TeamResultMeta::gameid() const {
  return *gameid_;
}
inline void TeamResultMeta::set_gameid(const ::std::string& value) {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  gameid_->assign(value);
}
inline void TeamResultMeta::set_gameid(const char* value) {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  gameid_->assign(value);
}
inline void TeamResultMeta::set_gameid(const char* value, size_t size) {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  gameid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TeamResultMeta::mutable_gameid() {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  return gameid_;
}
inline ::std::string* TeamResultMeta::release_gameid() {
  clear_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gameid_;
    gameid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TeamResultMeta::set_allocated_gameid(::std::string* gameid) {
  if (gameid_ != &::google::protobuf::internal::kEmptyString) {
    delete gameid_;
  }
  if (gameid) {
    set_has_gameid();
    gameid_ = gameid;
  } else {
    clear_has_gameid();
    gameid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string team = 30;
inline bool TeamResultMeta::has_team() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TeamResultMeta::set_has_team() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TeamResultMeta::clear_has_team() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TeamResultMeta::clear_team() {
  if (team_ != &::google::protobuf::internal::kEmptyString) {
    team_->clear();
  }
  clear_has_team();
}
inline const ::std::string& TeamResultMeta::team() const {
  return *team_;
}
inline void TeamResultMeta::set_team(const ::std::string& value) {
  set_has_team();
  if (team_ == &::google::protobuf::internal::kEmptyString) {
    team_ = new ::std::string;
  }
  team_->assign(value);
}
inline void TeamResultMeta::set_team(const char* value) {
  set_has_team();
  if (team_ == &::google::protobuf::internal::kEmptyString) {
    team_ = new ::std::string;
  }
  team_->assign(value);
}
inline void TeamResultMeta::set_team(const char* value, size_t size) {
  set_has_team();
  if (team_ == &::google::protobuf::internal::kEmptyString) {
    team_ = new ::std::string;
  }
  team_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TeamResultMeta::mutable_team() {
  set_has_team();
  if (team_ == &::google::protobuf::internal::kEmptyString) {
    team_ = new ::std::string;
  }
  return team_;
}
inline ::std::string* TeamResultMeta::release_team() {
  clear_has_team();
  if (team_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = team_;
    team_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TeamResultMeta::set_allocated_team(::std::string* team) {
  if (team_ != &::google::protobuf::internal::kEmptyString) {
    delete team_;
  }
  if (team) {
    set_has_team();
    team_ = team;
  } else {
    clear_has_team();
    team_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 kickofftime = 40;
inline bool TeamResultMeta::has_kickofftime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TeamResultMeta::set_has_kickofftime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TeamResultMeta::clear_has_kickofftime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TeamResultMeta::clear_kickofftime() {
  kickofftime_ = 0u;
  clear_has_kickofftime();
}
inline ::google::protobuf::uint32 TeamResultMeta::kickofftime() const {
  return kickofftime_;
}
inline void TeamResultMeta::set_kickofftime(::google::protobuf::uint32 value) {
  set_has_kickofftime();
  kickofftime_ = value;
}

// optional uint32 week = 50;
inline bool TeamResultMeta::has_week() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TeamResultMeta::set_has_week() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TeamResultMeta::clear_has_week() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TeamResultMeta::clear_week() {
  week_ = 0u;
  clear_has_week();
}
inline ::google::protobuf::uint32 TeamResultMeta::week() const {
  return week_;
}
inline void TeamResultMeta::set_week(::google::protobuf::uint32 value) {
  set_has_week();
  week_ = value;
}

// optional bytes playerresultmetaroot = 60;
inline bool TeamResultMeta::has_playerresultmetaroot() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TeamResultMeta::set_has_playerresultmetaroot() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TeamResultMeta::clear_has_playerresultmetaroot() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TeamResultMeta::clear_playerresultmetaroot() {
  if (playerresultmetaroot_ != &::google::protobuf::internal::kEmptyString) {
    playerresultmetaroot_->clear();
  }
  clear_has_playerresultmetaroot();
}
inline const ::std::string& TeamResultMeta::playerresultmetaroot() const {
  return *playerresultmetaroot_;
}
inline void TeamResultMeta::set_playerresultmetaroot(const ::std::string& value) {
  set_has_playerresultmetaroot();
  if (playerresultmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    playerresultmetaroot_ = new ::std::string;
  }
  playerresultmetaroot_->assign(value);
}
inline void TeamResultMeta::set_playerresultmetaroot(const char* value) {
  set_has_playerresultmetaroot();
  if (playerresultmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    playerresultmetaroot_ = new ::std::string;
  }
  playerresultmetaroot_->assign(value);
}
inline void TeamResultMeta::set_playerresultmetaroot(const void* value, size_t size) {
  set_has_playerresultmetaroot();
  if (playerresultmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    playerresultmetaroot_ = new ::std::string;
  }
  playerresultmetaroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TeamResultMeta::mutable_playerresultmetaroot() {
  set_has_playerresultmetaroot();
  if (playerresultmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    playerresultmetaroot_ = new ::std::string;
  }
  return playerresultmetaroot_;
}
inline ::std::string* TeamResultMeta::release_playerresultmetaroot() {
  clear_has_playerresultmetaroot();
  if (playerresultmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerresultmetaroot_;
    playerresultmetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TeamResultMeta::set_allocated_playerresultmetaroot(::std::string* playerresultmetaroot) {
  if (playerresultmetaroot_ != &::google::protobuf::internal::kEmptyString) {
    delete playerresultmetaroot_;
  }
  if (playerresultmetaroot) {
    set_has_playerresultmetaroot();
    playerresultmetaroot_ = playerresultmetaroot;
  } else {
    clear_has_playerresultmetaroot();
    playerresultmetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes resultdatametaid = 70;
inline bool TeamResultMeta::has_resultdatametaid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TeamResultMeta::set_has_resultdatametaid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TeamResultMeta::clear_has_resultdatametaid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TeamResultMeta::clear_resultdatametaid() {
  if (resultdatametaid_ != &::google::protobuf::internal::kEmptyString) {
    resultdatametaid_->clear();
  }
  clear_has_resultdatametaid();
}
inline const ::std::string& TeamResultMeta::resultdatametaid() const {
  return *resultdatametaid_;
}
inline void TeamResultMeta::set_resultdatametaid(const ::std::string& value) {
  set_has_resultdatametaid();
  if (resultdatametaid_ == &::google::protobuf::internal::kEmptyString) {
    resultdatametaid_ = new ::std::string;
  }
  resultdatametaid_->assign(value);
}
inline void TeamResultMeta::set_resultdatametaid(const char* value) {
  set_has_resultdatametaid();
  if (resultdatametaid_ == &::google::protobuf::internal::kEmptyString) {
    resultdatametaid_ = new ::std::string;
  }
  resultdatametaid_->assign(value);
}
inline void TeamResultMeta::set_resultdatametaid(const void* value, size_t size) {
  set_has_resultdatametaid();
  if (resultdatametaid_ == &::google::protobuf::internal::kEmptyString) {
    resultdatametaid_ = new ::std::string;
  }
  resultdatametaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TeamResultMeta::mutable_resultdatametaid() {
  set_has_resultdatametaid();
  if (resultdatametaid_ == &::google::protobuf::internal::kEmptyString) {
    resultdatametaid_ = new ::std::string;
  }
  return resultdatametaid_;
}
inline ::std::string* TeamResultMeta::release_resultdatametaid() {
  clear_has_resultdatametaid();
  if (resultdatametaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resultdatametaid_;
    resultdatametaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TeamResultMeta::set_allocated_resultdatametaid(::std::string* resultdatametaid) {
  if (resultdatametaid_ != &::google::protobuf::internal::kEmptyString) {
    delete resultdatametaid_;
  }
  if (resultdatametaid) {
    set_has_resultdatametaid();
    resultdatametaid_ = resultdatametaid;
  } else {
    clear_has_resultdatametaid();
    resultdatametaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GamePlayerProjMeta

// optional string playerid = 20;
inline bool GamePlayerProjMeta::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GamePlayerProjMeta::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GamePlayerProjMeta::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GamePlayerProjMeta::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& GamePlayerProjMeta::playerid() const {
  return *playerid_;
}
inline void GamePlayerProjMeta::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void GamePlayerProjMeta::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void GamePlayerProjMeta::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GamePlayerProjMeta::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* GamePlayerProjMeta::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GamePlayerProjMeta::set_allocated_playerid(::std::string* playerid) {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    delete playerid_;
  }
  if (playerid) {
    set_has_playerid();
    playerid_ = playerid;
  } else {
    clear_has_playerid();
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes gamestatusmetaid = 30;
inline bool GamePlayerProjMeta::has_gamestatusmetaid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GamePlayerProjMeta::set_has_gamestatusmetaid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GamePlayerProjMeta::clear_has_gamestatusmetaid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GamePlayerProjMeta::clear_gamestatusmetaid() {
  if (gamestatusmetaid_ != &::google::protobuf::internal::kEmptyString) {
    gamestatusmetaid_->clear();
  }
  clear_has_gamestatusmetaid();
}
inline const ::std::string& GamePlayerProjMeta::gamestatusmetaid() const {
  return *gamestatusmetaid_;
}
inline void GamePlayerProjMeta::set_gamestatusmetaid(const ::std::string& value) {
  set_has_gamestatusmetaid();
  if (gamestatusmetaid_ == &::google::protobuf::internal::kEmptyString) {
    gamestatusmetaid_ = new ::std::string;
  }
  gamestatusmetaid_->assign(value);
}
inline void GamePlayerProjMeta::set_gamestatusmetaid(const char* value) {
  set_has_gamestatusmetaid();
  if (gamestatusmetaid_ == &::google::protobuf::internal::kEmptyString) {
    gamestatusmetaid_ = new ::std::string;
  }
  gamestatusmetaid_->assign(value);
}
inline void GamePlayerProjMeta::set_gamestatusmetaid(const void* value, size_t size) {
  set_has_gamestatusmetaid();
  if (gamestatusmetaid_ == &::google::protobuf::internal::kEmptyString) {
    gamestatusmetaid_ = new ::std::string;
  }
  gamestatusmetaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GamePlayerProjMeta::mutable_gamestatusmetaid() {
  set_has_gamestatusmetaid();
  if (gamestatusmetaid_ == &::google::protobuf::internal::kEmptyString) {
    gamestatusmetaid_ = new ::std::string;
  }
  return gamestatusmetaid_;
}
inline ::std::string* GamePlayerProjMeta::release_gamestatusmetaid() {
  clear_has_gamestatusmetaid();
  if (gamestatusmetaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gamestatusmetaid_;
    gamestatusmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GamePlayerProjMeta::set_allocated_gamestatusmetaid(::std::string* gamestatusmetaid) {
  if (gamestatusmetaid_ != &::google::protobuf::internal::kEmptyString) {
    delete gamestatusmetaid_;
  }
  if (gamestatusmetaid) {
    set_has_gamestatusmetaid();
    gamestatusmetaid_ = gamestatusmetaid;
  } else {
    clear_has_gamestatusmetaid();
    gamestatusmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes projmetaplayerroot = 60;
inline bool GamePlayerProjMeta::has_projmetaplayerroot() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GamePlayerProjMeta::set_has_projmetaplayerroot() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GamePlayerProjMeta::clear_has_projmetaplayerroot() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GamePlayerProjMeta::clear_projmetaplayerroot() {
  if (projmetaplayerroot_ != &::google::protobuf::internal::kEmptyString) {
    projmetaplayerroot_->clear();
  }
  clear_has_projmetaplayerroot();
}
inline const ::std::string& GamePlayerProjMeta::projmetaplayerroot() const {
  return *projmetaplayerroot_;
}
inline void GamePlayerProjMeta::set_projmetaplayerroot(const ::std::string& value) {
  set_has_projmetaplayerroot();
  if (projmetaplayerroot_ == &::google::protobuf::internal::kEmptyString) {
    projmetaplayerroot_ = new ::std::string;
  }
  projmetaplayerroot_->assign(value);
}
inline void GamePlayerProjMeta::set_projmetaplayerroot(const char* value) {
  set_has_projmetaplayerroot();
  if (projmetaplayerroot_ == &::google::protobuf::internal::kEmptyString) {
    projmetaplayerroot_ = new ::std::string;
  }
  projmetaplayerroot_->assign(value);
}
inline void GamePlayerProjMeta::set_projmetaplayerroot(const void* value, size_t size) {
  set_has_projmetaplayerroot();
  if (projmetaplayerroot_ == &::google::protobuf::internal::kEmptyString) {
    projmetaplayerroot_ = new ::std::string;
  }
  projmetaplayerroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GamePlayerProjMeta::mutable_projmetaplayerroot() {
  set_has_projmetaplayerroot();
  if (projmetaplayerroot_ == &::google::protobuf::internal::kEmptyString) {
    projmetaplayerroot_ = new ::std::string;
  }
  return projmetaplayerroot_;
}
inline ::std::string* GamePlayerProjMeta::release_projmetaplayerroot() {
  clear_has_projmetaplayerroot();
  if (projmetaplayerroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = projmetaplayerroot_;
    projmetaplayerroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GamePlayerProjMeta::set_allocated_projmetaplayerroot(::std::string* projmetaplayerroot) {
  if (projmetaplayerroot_ != &::google::protobuf::internal::kEmptyString) {
    delete projmetaplayerroot_;
  }
  if (projmetaplayerroot) {
    set_has_projmetaplayerroot();
    projmetaplayerroot_ = projmetaplayerroot;
  } else {
    clear_has_projmetaplayerroot();
    projmetaplayerroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes posmetaplayerroot = 70;
inline bool GamePlayerProjMeta::has_posmetaplayerroot() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GamePlayerProjMeta::set_has_posmetaplayerroot() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GamePlayerProjMeta::clear_has_posmetaplayerroot() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GamePlayerProjMeta::clear_posmetaplayerroot() {
  if (posmetaplayerroot_ != &::google::protobuf::internal::kEmptyString) {
    posmetaplayerroot_->clear();
  }
  clear_has_posmetaplayerroot();
}
inline const ::std::string& GamePlayerProjMeta::posmetaplayerroot() const {
  return *posmetaplayerroot_;
}
inline void GamePlayerProjMeta::set_posmetaplayerroot(const ::std::string& value) {
  set_has_posmetaplayerroot();
  if (posmetaplayerroot_ == &::google::protobuf::internal::kEmptyString) {
    posmetaplayerroot_ = new ::std::string;
  }
  posmetaplayerroot_->assign(value);
}
inline void GamePlayerProjMeta::set_posmetaplayerroot(const char* value) {
  set_has_posmetaplayerroot();
  if (posmetaplayerroot_ == &::google::protobuf::internal::kEmptyString) {
    posmetaplayerroot_ = new ::std::string;
  }
  posmetaplayerroot_->assign(value);
}
inline void GamePlayerProjMeta::set_posmetaplayerroot(const void* value, size_t size) {
  set_has_posmetaplayerroot();
  if (posmetaplayerroot_ == &::google::protobuf::internal::kEmptyString) {
    posmetaplayerroot_ = new ::std::string;
  }
  posmetaplayerroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GamePlayerProjMeta::mutable_posmetaplayerroot() {
  set_has_posmetaplayerroot();
  if (posmetaplayerroot_ == &::google::protobuf::internal::kEmptyString) {
    posmetaplayerroot_ = new ::std::string;
  }
  return posmetaplayerroot_;
}
inline ::std::string* GamePlayerProjMeta::release_posmetaplayerroot() {
  clear_has_posmetaplayerroot();
  if (posmetaplayerroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = posmetaplayerroot_;
    posmetaplayerroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GamePlayerProjMeta::set_allocated_posmetaplayerroot(::std::string* posmetaplayerroot) {
  if (posmetaplayerroot_ != &::google::protobuf::internal::kEmptyString) {
    delete posmetaplayerroot_;
  }
  if (posmetaplayerroot) {
    set_has_posmetaplayerroot();
    posmetaplayerroot_ = posmetaplayerroot;
  } else {
    clear_has_posmetaplayerroot();
    posmetaplayerroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes gamedatametaid = 80;
inline bool GamePlayerProjMeta::has_gamedatametaid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GamePlayerProjMeta::set_has_gamedatametaid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GamePlayerProjMeta::clear_has_gamedatametaid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GamePlayerProjMeta::clear_gamedatametaid() {
  if (gamedatametaid_ != &::google::protobuf::internal::kEmptyString) {
    gamedatametaid_->clear();
  }
  clear_has_gamedatametaid();
}
inline const ::std::string& GamePlayerProjMeta::gamedatametaid() const {
  return *gamedatametaid_;
}
inline void GamePlayerProjMeta::set_gamedatametaid(const ::std::string& value) {
  set_has_gamedatametaid();
  if (gamedatametaid_ == &::google::protobuf::internal::kEmptyString) {
    gamedatametaid_ = new ::std::string;
  }
  gamedatametaid_->assign(value);
}
inline void GamePlayerProjMeta::set_gamedatametaid(const char* value) {
  set_has_gamedatametaid();
  if (gamedatametaid_ == &::google::protobuf::internal::kEmptyString) {
    gamedatametaid_ = new ::std::string;
  }
  gamedatametaid_->assign(value);
}
inline void GamePlayerProjMeta::set_gamedatametaid(const void* value, size_t size) {
  set_has_gamedatametaid();
  if (gamedatametaid_ == &::google::protobuf::internal::kEmptyString) {
    gamedatametaid_ = new ::std::string;
  }
  gamedatametaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GamePlayerProjMeta::mutable_gamedatametaid() {
  set_has_gamedatametaid();
  if (gamedatametaid_ == &::google::protobuf::internal::kEmptyString) {
    gamedatametaid_ = new ::std::string;
  }
  return gamedatametaid_;
}
inline ::std::string* GamePlayerProjMeta::release_gamedatametaid() {
  clear_has_gamedatametaid();
  if (gamedatametaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gamedatametaid_;
    gamedatametaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GamePlayerProjMeta::set_allocated_gamedatametaid(::std::string* gamedatametaid) {
  if (gamedatametaid_ != &::google::protobuf::internal::kEmptyString) {
    delete gamedatametaid_;
  }
  if (gamedatametaid) {
    set_has_gamedatametaid();
    gamedatametaid_ = gamedatametaid;
  } else {
    clear_has_gamedatametaid();
    gamedatametaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ProjMeta

// optional string name = 10;
inline bool ProjMeta::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProjMeta::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProjMeta::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProjMeta::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ProjMeta::name() const {
  return *name_;
}
inline void ProjMeta::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ProjMeta::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ProjMeta::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProjMeta::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ProjMeta::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProjMeta::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 proj = 20;
inline bool ProjMeta::has_proj() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProjMeta::set_has_proj() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProjMeta::clear_has_proj() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProjMeta::clear_proj() {
  proj_ = 0;
  clear_has_proj();
}
inline ::google::protobuf::int32 ProjMeta::proj() const {
  return proj_;
}
inline void ProjMeta::set_proj(::google::protobuf::int32 value) {
  set_has_proj();
  proj_ = value;
}

// optional string playerid = 30;
inline bool ProjMeta::has_playerid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProjMeta::set_has_playerid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProjMeta::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProjMeta::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& ProjMeta::playerid() const {
  return *playerid_;
}
inline void ProjMeta::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void ProjMeta::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void ProjMeta::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProjMeta::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* ProjMeta::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProjMeta::set_allocated_playerid(::std::string* playerid) {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    delete playerid_;
  }
  if (playerid) {
    set_has_playerid();
    playerid_ = playerid;
  } else {
    clear_has_playerid();
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes txmetaid = 40;
inline bool ProjMeta::has_txmetaid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProjMeta::set_has_txmetaid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProjMeta::clear_has_txmetaid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProjMeta::clear_txmetaid() {
  if (txmetaid_ != &::google::protobuf::internal::kEmptyString) {
    txmetaid_->clear();
  }
  clear_has_txmetaid();
}
inline const ::std::string& ProjMeta::txmetaid() const {
  return *txmetaid_;
}
inline void ProjMeta::set_txmetaid(const ::std::string& value) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(value);
}
inline void ProjMeta::set_txmetaid(const char* value) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(value);
}
inline void ProjMeta::set_txmetaid(const void* value, size_t size) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProjMeta::mutable_txmetaid() {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  return txmetaid_;
}
inline ::std::string* ProjMeta::release_txmetaid() {
  clear_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = txmetaid_;
    txmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProjMeta::set_allocated_txmetaid(::std::string* txmetaid) {
  if (txmetaid_ != &::google::protobuf::internal::kEmptyString) {
    delete txmetaid_;
  }
  if (txmetaid) {
    set_has_txmetaid();
    txmetaid_ = txmetaid;
  } else {
    clear_has_txmetaid();
    txmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes prev = 50;
inline bool ProjMeta::has_prev() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProjMeta::set_has_prev() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProjMeta::clear_has_prev() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProjMeta::clear_prev() {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    prev_->clear();
  }
  clear_has_prev();
}
inline const ::std::string& ProjMeta::prev() const {
  return *prev_;
}
inline void ProjMeta::set_prev(const ::std::string& value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void ProjMeta::set_prev(const char* value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void ProjMeta::set_prev(const void* value, size_t size) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProjMeta::mutable_prev() {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  return prev_;
}
inline ::std::string* ProjMeta::release_prev() {
  clear_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prev_;
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProjMeta::set_allocated_prev(::std::string* prev) {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    delete prev_;
  }
  if (prev) {
    set_has_prev();
    prev_ = prev;
  } else {
    clear_has_prev();
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PosMeta

// optional string name = 10;
inline bool PosMeta::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PosMeta::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PosMeta::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PosMeta::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PosMeta::name() const {
  return *name_;
}
inline void PosMeta::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PosMeta::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PosMeta::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PosMeta::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* PosMeta::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PosMeta::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 qty = 20;
inline bool PosMeta::has_qty() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PosMeta::set_has_qty() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PosMeta::clear_has_qty() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PosMeta::clear_qty() {
  qty_ = 0;
  clear_has_qty();
}
inline ::google::protobuf::int32 PosMeta::qty() const {
  return qty_;
}
inline void PosMeta::set_qty(::google::protobuf::int32 value) {
  set_has_qty();
  qty_ = value;
}

// optional int32 price = 30;
inline bool PosMeta::has_price() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PosMeta::set_has_price() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PosMeta::clear_has_price() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PosMeta::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 PosMeta::price() const {
  return price_;
}
inline void PosMeta::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
}

// optional string playerid = 40;
inline bool PosMeta::has_playerid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PosMeta::set_has_playerid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PosMeta::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PosMeta::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& PosMeta::playerid() const {
  return *playerid_;
}
inline void PosMeta::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void PosMeta::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void PosMeta::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PosMeta::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* PosMeta::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PosMeta::set_allocated_playerid(::std::string* playerid) {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    delete playerid_;
  }
  if (playerid) {
    set_has_playerid();
    playerid_ = playerid;
  } else {
    clear_has_playerid();
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes txmetaid = 50;
inline bool PosMeta::has_txmetaid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PosMeta::set_has_txmetaid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PosMeta::clear_has_txmetaid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PosMeta::clear_txmetaid() {
  if (txmetaid_ != &::google::protobuf::internal::kEmptyString) {
    txmetaid_->clear();
  }
  clear_has_txmetaid();
}
inline const ::std::string& PosMeta::txmetaid() const {
  return *txmetaid_;
}
inline void PosMeta::set_txmetaid(const ::std::string& value) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(value);
}
inline void PosMeta::set_txmetaid(const char* value) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(value);
}
inline void PosMeta::set_txmetaid(const void* value, size_t size) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PosMeta::mutable_txmetaid() {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  return txmetaid_;
}
inline ::std::string* PosMeta::release_txmetaid() {
  clear_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = txmetaid_;
    txmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PosMeta::set_allocated_txmetaid(::std::string* txmetaid) {
  if (txmetaid_ != &::google::protobuf::internal::kEmptyString) {
    delete txmetaid_;
  }
  if (txmetaid) {
    set_has_txmetaid();
    txmetaid_ = txmetaid;
  } else {
    clear_has_txmetaid();
    txmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes prev = 60;
inline bool PosMeta::has_prev() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PosMeta::set_has_prev() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PosMeta::clear_has_prev() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PosMeta::clear_prev() {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    prev_->clear();
  }
  clear_has_prev();
}
inline const ::std::string& PosMeta::prev() const {
  return *prev_;
}
inline void PosMeta::set_prev(const ::std::string& value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void PosMeta::set_prev(const char* value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void PosMeta::set_prev(const void* value, size_t size) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PosMeta::mutable_prev() {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  return prev_;
}
inline ::std::string* PosMeta::release_prev() {
  clear_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prev_;
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PosMeta::set_allocated_prev(::std::string* prev) {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    delete prev_;
  }
  if (prev) {
    set_has_prev();
    prev_ = prev;
  } else {
    clear_has_prev();
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PlayerResultMeta

// optional bytes playergamestatsid = 10;
inline bool PlayerResultMeta::has_playergamestatsid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerResultMeta::set_has_playergamestatsid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerResultMeta::clear_has_playergamestatsid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerResultMeta::clear_playergamestatsid() {
  if (playergamestatsid_ != &::google::protobuf::internal::kEmptyString) {
    playergamestatsid_->clear();
  }
  clear_has_playergamestatsid();
}
inline const ::std::string& PlayerResultMeta::playergamestatsid() const {
  return *playergamestatsid_;
}
inline void PlayerResultMeta::set_playergamestatsid(const ::std::string& value) {
  set_has_playergamestatsid();
  if (playergamestatsid_ == &::google::protobuf::internal::kEmptyString) {
    playergamestatsid_ = new ::std::string;
  }
  playergamestatsid_->assign(value);
}
inline void PlayerResultMeta::set_playergamestatsid(const char* value) {
  set_has_playergamestatsid();
  if (playergamestatsid_ == &::google::protobuf::internal::kEmptyString) {
    playergamestatsid_ = new ::std::string;
  }
  playergamestatsid_->assign(value);
}
inline void PlayerResultMeta::set_playergamestatsid(const void* value, size_t size) {
  set_has_playergamestatsid();
  if (playergamestatsid_ == &::google::protobuf::internal::kEmptyString) {
    playergamestatsid_ = new ::std::string;
  }
  playergamestatsid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerResultMeta::mutable_playergamestatsid() {
  set_has_playergamestatsid();
  if (playergamestatsid_ == &::google::protobuf::internal::kEmptyString) {
    playergamestatsid_ = new ::std::string;
  }
  return playergamestatsid_;
}
inline ::std::string* PlayerResultMeta::release_playergamestatsid() {
  clear_has_playergamestatsid();
  if (playergamestatsid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playergamestatsid_;
    playergamestatsid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerResultMeta::set_allocated_playergamestatsid(::std::string* playergamestatsid) {
  if (playergamestatsid_ != &::google::protobuf::internal::kEmptyString) {
    delete playergamestatsid_;
  }
  if (playergamestatsid) {
    set_has_playergamestatsid();
    playergamestatsid_ = playergamestatsid;
  } else {
    clear_has_playergamestatsid();
    playergamestatsid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes gamestatusmetaid = 30;
inline bool PlayerResultMeta::has_gamestatusmetaid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerResultMeta::set_has_gamestatusmetaid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerResultMeta::clear_has_gamestatusmetaid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerResultMeta::clear_gamestatusmetaid() {
  if (gamestatusmetaid_ != &::google::protobuf::internal::kEmptyString) {
    gamestatusmetaid_->clear();
  }
  clear_has_gamestatusmetaid();
}
inline const ::std::string& PlayerResultMeta::gamestatusmetaid() const {
  return *gamestatusmetaid_;
}
inline void PlayerResultMeta::set_gamestatusmetaid(const ::std::string& value) {
  set_has_gamestatusmetaid();
  if (gamestatusmetaid_ == &::google::protobuf::internal::kEmptyString) {
    gamestatusmetaid_ = new ::std::string;
  }
  gamestatusmetaid_->assign(value);
}
inline void PlayerResultMeta::set_gamestatusmetaid(const char* value) {
  set_has_gamestatusmetaid();
  if (gamestatusmetaid_ == &::google::protobuf::internal::kEmptyString) {
    gamestatusmetaid_ = new ::std::string;
  }
  gamestatusmetaid_->assign(value);
}
inline void PlayerResultMeta::set_gamestatusmetaid(const void* value, size_t size) {
  set_has_gamestatusmetaid();
  if (gamestatusmetaid_ == &::google::protobuf::internal::kEmptyString) {
    gamestatusmetaid_ = new ::std::string;
  }
  gamestatusmetaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerResultMeta::mutable_gamestatusmetaid() {
  set_has_gamestatusmetaid();
  if (gamestatusmetaid_ == &::google::protobuf::internal::kEmptyString) {
    gamestatusmetaid_ = new ::std::string;
  }
  return gamestatusmetaid_;
}
inline ::std::string* PlayerResultMeta::release_gamestatusmetaid() {
  clear_has_gamestatusmetaid();
  if (gamestatusmetaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gamestatusmetaid_;
    gamestatusmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerResultMeta::set_allocated_gamestatusmetaid(::std::string* gamestatusmetaid) {
  if (gamestatusmetaid_ != &::google::protobuf::internal::kEmptyString) {
    delete gamestatusmetaid_;
  }
  if (gamestatusmetaid) {
    set_has_gamestatusmetaid();
    gamestatusmetaid_ = gamestatusmetaid;
  } else {
    clear_has_gamestatusmetaid();
    gamestatusmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes awardmetaplayerroot = 60;
inline bool PlayerResultMeta::has_awardmetaplayerroot() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerResultMeta::set_has_awardmetaplayerroot() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerResultMeta::clear_has_awardmetaplayerroot() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerResultMeta::clear_awardmetaplayerroot() {
  if (awardmetaplayerroot_ != &::google::protobuf::internal::kEmptyString) {
    awardmetaplayerroot_->clear();
  }
  clear_has_awardmetaplayerroot();
}
inline const ::std::string& PlayerResultMeta::awardmetaplayerroot() const {
  return *awardmetaplayerroot_;
}
inline void PlayerResultMeta::set_awardmetaplayerroot(const ::std::string& value) {
  set_has_awardmetaplayerroot();
  if (awardmetaplayerroot_ == &::google::protobuf::internal::kEmptyString) {
    awardmetaplayerroot_ = new ::std::string;
  }
  awardmetaplayerroot_->assign(value);
}
inline void PlayerResultMeta::set_awardmetaplayerroot(const char* value) {
  set_has_awardmetaplayerroot();
  if (awardmetaplayerroot_ == &::google::protobuf::internal::kEmptyString) {
    awardmetaplayerroot_ = new ::std::string;
  }
  awardmetaplayerroot_->assign(value);
}
inline void PlayerResultMeta::set_awardmetaplayerroot(const void* value, size_t size) {
  set_has_awardmetaplayerroot();
  if (awardmetaplayerroot_ == &::google::protobuf::internal::kEmptyString) {
    awardmetaplayerroot_ = new ::std::string;
  }
  awardmetaplayerroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerResultMeta::mutable_awardmetaplayerroot() {
  set_has_awardmetaplayerroot();
  if (awardmetaplayerroot_ == &::google::protobuf::internal::kEmptyString) {
    awardmetaplayerroot_ = new ::std::string;
  }
  return awardmetaplayerroot_;
}
inline ::std::string* PlayerResultMeta::release_awardmetaplayerroot() {
  clear_has_awardmetaplayerroot();
  if (awardmetaplayerroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = awardmetaplayerroot_;
    awardmetaplayerroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerResultMeta::set_allocated_awardmetaplayerroot(::std::string* awardmetaplayerroot) {
  if (awardmetaplayerroot_ != &::google::protobuf::internal::kEmptyString) {
    delete awardmetaplayerroot_;
  }
  if (awardmetaplayerroot) {
    set_has_awardmetaplayerroot();
    awardmetaplayerroot_ = awardmetaplayerroot;
  } else {
    clear_has_awardmetaplayerroot();
    awardmetaplayerroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes pnlmetaplayerroot = 70;
inline bool PlayerResultMeta::has_pnlmetaplayerroot() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerResultMeta::set_has_pnlmetaplayerroot() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerResultMeta::clear_has_pnlmetaplayerroot() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerResultMeta::clear_pnlmetaplayerroot() {
  if (pnlmetaplayerroot_ != &::google::protobuf::internal::kEmptyString) {
    pnlmetaplayerroot_->clear();
  }
  clear_has_pnlmetaplayerroot();
}
inline const ::std::string& PlayerResultMeta::pnlmetaplayerroot() const {
  return *pnlmetaplayerroot_;
}
inline void PlayerResultMeta::set_pnlmetaplayerroot(const ::std::string& value) {
  set_has_pnlmetaplayerroot();
  if (pnlmetaplayerroot_ == &::google::protobuf::internal::kEmptyString) {
    pnlmetaplayerroot_ = new ::std::string;
  }
  pnlmetaplayerroot_->assign(value);
}
inline void PlayerResultMeta::set_pnlmetaplayerroot(const char* value) {
  set_has_pnlmetaplayerroot();
  if (pnlmetaplayerroot_ == &::google::protobuf::internal::kEmptyString) {
    pnlmetaplayerroot_ = new ::std::string;
  }
  pnlmetaplayerroot_->assign(value);
}
inline void PlayerResultMeta::set_pnlmetaplayerroot(const void* value, size_t size) {
  set_has_pnlmetaplayerroot();
  if (pnlmetaplayerroot_ == &::google::protobuf::internal::kEmptyString) {
    pnlmetaplayerroot_ = new ::std::string;
  }
  pnlmetaplayerroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerResultMeta::mutable_pnlmetaplayerroot() {
  set_has_pnlmetaplayerroot();
  if (pnlmetaplayerroot_ == &::google::protobuf::internal::kEmptyString) {
    pnlmetaplayerroot_ = new ::std::string;
  }
  return pnlmetaplayerroot_;
}
inline ::std::string* PlayerResultMeta::release_pnlmetaplayerroot() {
  clear_has_pnlmetaplayerroot();
  if (pnlmetaplayerroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pnlmetaplayerroot_;
    pnlmetaplayerroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerResultMeta::set_allocated_pnlmetaplayerroot(::std::string* pnlmetaplayerroot) {
  if (pnlmetaplayerroot_ != &::google::protobuf::internal::kEmptyString) {
    delete pnlmetaplayerroot_;
  }
  if (pnlmetaplayerroot) {
    set_has_pnlmetaplayerroot();
    pnlmetaplayerroot_ = pnlmetaplayerroot;
  } else {
    clear_has_pnlmetaplayerroot();
    pnlmetaplayerroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes resultdatametaid = 80;
inline bool PlayerResultMeta::has_resultdatametaid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayerResultMeta::set_has_resultdatametaid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayerResultMeta::clear_has_resultdatametaid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayerResultMeta::clear_resultdatametaid() {
  if (resultdatametaid_ != &::google::protobuf::internal::kEmptyString) {
    resultdatametaid_->clear();
  }
  clear_has_resultdatametaid();
}
inline const ::std::string& PlayerResultMeta::resultdatametaid() const {
  return *resultdatametaid_;
}
inline void PlayerResultMeta::set_resultdatametaid(const ::std::string& value) {
  set_has_resultdatametaid();
  if (resultdatametaid_ == &::google::protobuf::internal::kEmptyString) {
    resultdatametaid_ = new ::std::string;
  }
  resultdatametaid_->assign(value);
}
inline void PlayerResultMeta::set_resultdatametaid(const char* value) {
  set_has_resultdatametaid();
  if (resultdatametaid_ == &::google::protobuf::internal::kEmptyString) {
    resultdatametaid_ = new ::std::string;
  }
  resultdatametaid_->assign(value);
}
inline void PlayerResultMeta::set_resultdatametaid(const void* value, size_t size) {
  set_has_resultdatametaid();
  if (resultdatametaid_ == &::google::protobuf::internal::kEmptyString) {
    resultdatametaid_ = new ::std::string;
  }
  resultdatametaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerResultMeta::mutable_resultdatametaid() {
  set_has_resultdatametaid();
  if (resultdatametaid_ == &::google::protobuf::internal::kEmptyString) {
    resultdatametaid_ = new ::std::string;
  }
  return resultdatametaid_;
}
inline ::std::string* PlayerResultMeta::release_resultdatametaid() {
  clear_has_resultdatametaid();
  if (resultdatametaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resultdatametaid_;
    resultdatametaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerResultMeta::set_allocated_resultdatametaid(::std::string* resultdatametaid) {
  if (resultdatametaid_ != &::google::protobuf::internal::kEmptyString) {
    delete resultdatametaid_;
  }
  if (resultdatametaid) {
    set_has_resultdatametaid();
    resultdatametaid_ = resultdatametaid;
  } else {
    clear_has_resultdatametaid();
    resultdatametaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PlayerGameStats

// optional string playerid = 20;
inline bool PlayerGameStats::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerGameStats::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerGameStats::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerGameStats::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& PlayerGameStats::playerid() const {
  return *playerid_;
}
inline void PlayerGameStats::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void PlayerGameStats::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void PlayerGameStats::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerGameStats::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* PlayerGameStats::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerGameStats::set_allocated_playerid(::std::string* playerid) {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    delete playerid_;
  }
  if (playerid) {
    set_has_playerid();
    playerid_ = playerid;
  } else {
    clear_has_playerid();
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float result = 40;
inline bool PlayerGameStats::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerGameStats::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerGameStats::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerGameStats::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline float PlayerGameStats::result() const {
  return result_;
}
inline void PlayerGameStats::set_result(float value) {
  set_has_result();
  result_ = value;
}

// optional .fantasybit.Stats stats = 50;
inline bool PlayerGameStats::has_stats() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerGameStats::set_has_stats() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerGameStats::clear_has_stats() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerGameStats::clear_stats() {
  if (stats_ != NULL) stats_->::fantasybit::Stats::Clear();
  clear_has_stats();
}
inline const ::fantasybit::Stats& PlayerGameStats::stats() const {
  return stats_ != NULL ? *stats_ : *default_instance_->stats_;
}
inline ::fantasybit::Stats* PlayerGameStats::mutable_stats() {
  set_has_stats();
  if (stats_ == NULL) stats_ = new ::fantasybit::Stats;
  return stats_;
}
inline ::fantasybit::Stats* PlayerGameStats::release_stats() {
  clear_has_stats();
  ::fantasybit::Stats* temp = stats_;
  stats_ = NULL;
  return temp;
}
inline void PlayerGameStats::set_allocated_stats(::fantasybit::Stats* stats) {
  delete stats_;
  stats_ = stats;
  if (stats) {
    set_has_stats();
  } else {
    clear_has_stats();
  }
}

// optional string gameid = 60;
inline bool PlayerGameStats::has_gameid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerGameStats::set_has_gameid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerGameStats::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerGameStats::clear_gameid() {
  if (gameid_ != &::google::protobuf::internal::kEmptyString) {
    gameid_->clear();
  }
  clear_has_gameid();
}
inline const ::std::string& PlayerGameStats::gameid() const {
  return *gameid_;
}
inline void PlayerGameStats::set_gameid(const ::std::string& value) {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  gameid_->assign(value);
}
inline void PlayerGameStats::set_gameid(const char* value) {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  gameid_->assign(value);
}
inline void PlayerGameStats::set_gameid(const char* value, size_t size) {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  gameid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerGameStats::mutable_gameid() {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  return gameid_;
}
inline ::std::string* PlayerGameStats::release_gameid() {
  clear_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gameid_;
    gameid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerGameStats::set_allocated_gameid(::std::string* gameid) {
  if (gameid_ != &::google::protobuf::internal::kEmptyString) {
    delete gameid_;
  }
  if (gameid) {
    set_has_gameid();
    gameid_ = gameid;
  } else {
    clear_has_gameid();
    gameid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AwardMeta

// optional string name = 10;
inline bool AwardMeta::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AwardMeta::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AwardMeta::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AwardMeta::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AwardMeta::name() const {
  return *name_;
}
inline void AwardMeta::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AwardMeta::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AwardMeta::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AwardMeta::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* AwardMeta::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AwardMeta::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 proj = 20;
inline bool AwardMeta::has_proj() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AwardMeta::set_has_proj() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AwardMeta::clear_has_proj() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AwardMeta::clear_proj() {
  proj_ = 0;
  clear_has_proj();
}
inline ::google::protobuf::int32 AwardMeta::proj() const {
  return proj_;
}
inline void AwardMeta::set_proj(::google::protobuf::int32 value) {
  set_has_proj();
  proj_ = value;
}

// optional uint64 award = 30;
inline bool AwardMeta::has_award() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AwardMeta::set_has_award() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AwardMeta::clear_has_award() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AwardMeta::clear_award() {
  award_ = GOOGLE_ULONGLONG(0);
  clear_has_award();
}
inline ::google::protobuf::uint64 AwardMeta::award() const {
  return award_;
}
inline void AwardMeta::set_award(::google::protobuf::uint64 value) {
  set_has_award();
  award_ = value;
}

// optional bytes projmetaid = 40;
inline bool AwardMeta::has_projmetaid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AwardMeta::set_has_projmetaid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AwardMeta::clear_has_projmetaid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AwardMeta::clear_projmetaid() {
  if (projmetaid_ != &::google::protobuf::internal::kEmptyString) {
    projmetaid_->clear();
  }
  clear_has_projmetaid();
}
inline const ::std::string& AwardMeta::projmetaid() const {
  return *projmetaid_;
}
inline void AwardMeta::set_projmetaid(const ::std::string& value) {
  set_has_projmetaid();
  if (projmetaid_ == &::google::protobuf::internal::kEmptyString) {
    projmetaid_ = new ::std::string;
  }
  projmetaid_->assign(value);
}
inline void AwardMeta::set_projmetaid(const char* value) {
  set_has_projmetaid();
  if (projmetaid_ == &::google::protobuf::internal::kEmptyString) {
    projmetaid_ = new ::std::string;
  }
  projmetaid_->assign(value);
}
inline void AwardMeta::set_projmetaid(const void* value, size_t size) {
  set_has_projmetaid();
  if (projmetaid_ == &::google::protobuf::internal::kEmptyString) {
    projmetaid_ = new ::std::string;
  }
  projmetaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AwardMeta::mutable_projmetaid() {
  set_has_projmetaid();
  if (projmetaid_ == &::google::protobuf::internal::kEmptyString) {
    projmetaid_ = new ::std::string;
  }
  return projmetaid_;
}
inline ::std::string* AwardMeta::release_projmetaid() {
  clear_has_projmetaid();
  if (projmetaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = projmetaid_;
    projmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AwardMeta::set_allocated_projmetaid(::std::string* projmetaid) {
  if (projmetaid_ != &::google::protobuf::internal::kEmptyString) {
    delete projmetaid_;
  }
  if (projmetaid) {
    set_has_projmetaid();
    projmetaid_ = projmetaid;
  } else {
    clear_has_projmetaid();
    projmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes playergamestatsid = 50;
inline bool AwardMeta::has_playergamestatsid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AwardMeta::set_has_playergamestatsid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AwardMeta::clear_has_playergamestatsid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AwardMeta::clear_playergamestatsid() {
  if (playergamestatsid_ != &::google::protobuf::internal::kEmptyString) {
    playergamestatsid_->clear();
  }
  clear_has_playergamestatsid();
}
inline const ::std::string& AwardMeta::playergamestatsid() const {
  return *playergamestatsid_;
}
inline void AwardMeta::set_playergamestatsid(const ::std::string& value) {
  set_has_playergamestatsid();
  if (playergamestatsid_ == &::google::protobuf::internal::kEmptyString) {
    playergamestatsid_ = new ::std::string;
  }
  playergamestatsid_->assign(value);
}
inline void AwardMeta::set_playergamestatsid(const char* value) {
  set_has_playergamestatsid();
  if (playergamestatsid_ == &::google::protobuf::internal::kEmptyString) {
    playergamestatsid_ = new ::std::string;
  }
  playergamestatsid_->assign(value);
}
inline void AwardMeta::set_playergamestatsid(const void* value, size_t size) {
  set_has_playergamestatsid();
  if (playergamestatsid_ == &::google::protobuf::internal::kEmptyString) {
    playergamestatsid_ = new ::std::string;
  }
  playergamestatsid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AwardMeta::mutable_playergamestatsid() {
  set_has_playergamestatsid();
  if (playergamestatsid_ == &::google::protobuf::internal::kEmptyString) {
    playergamestatsid_ = new ::std::string;
  }
  return playergamestatsid_;
}
inline ::std::string* AwardMeta::release_playergamestatsid() {
  clear_has_playergamestatsid();
  if (playergamestatsid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playergamestatsid_;
    playergamestatsid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AwardMeta::set_allocated_playergamestatsid(::std::string* playergamestatsid) {
  if (playergamestatsid_ != &::google::protobuf::internal::kEmptyString) {
    delete playergamestatsid_;
  }
  if (playergamestatsid) {
    set_has_playergamestatsid();
    playergamestatsid_ = playergamestatsid;
  } else {
    clear_has_playergamestatsid();
    playergamestatsid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PnlMeta

// optional string name = 10;
inline bool PnlMeta::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PnlMeta::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PnlMeta::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PnlMeta::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PnlMeta::name() const {
  return *name_;
}
inline void PnlMeta::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PnlMeta::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PnlMeta::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PnlMeta::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* PnlMeta::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PnlMeta::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 qty = 20;
inline bool PnlMeta::has_qty() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PnlMeta::set_has_qty() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PnlMeta::clear_has_qty() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PnlMeta::clear_qty() {
  qty_ = 0;
  clear_has_qty();
}
inline ::google::protobuf::int32 PnlMeta::qty() const {
  return qty_;
}
inline void PnlMeta::set_qty(::google::protobuf::int32 value) {
  set_has_qty();
  qty_ = value;
}

// optional int32 price = 30;
inline bool PnlMeta::has_price() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PnlMeta::set_has_price() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PnlMeta::clear_has_price() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PnlMeta::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 PnlMeta::price() const {
  return price_;
}
inline void PnlMeta::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
}

// optional int64 pnl = 40;
inline bool PnlMeta::has_pnl() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PnlMeta::set_has_pnl() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PnlMeta::clear_has_pnl() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PnlMeta::clear_pnl() {
  pnl_ = GOOGLE_LONGLONG(0);
  clear_has_pnl();
}
inline ::google::protobuf::int64 PnlMeta::pnl() const {
  return pnl_;
}
inline void PnlMeta::set_pnl(::google::protobuf::int64 value) {
  set_has_pnl();
  pnl_ = value;
}

// optional bytes posmetaid = 50;
inline bool PnlMeta::has_posmetaid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PnlMeta::set_has_posmetaid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PnlMeta::clear_has_posmetaid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PnlMeta::clear_posmetaid() {
  if (posmetaid_ != &::google::protobuf::internal::kEmptyString) {
    posmetaid_->clear();
  }
  clear_has_posmetaid();
}
inline const ::std::string& PnlMeta::posmetaid() const {
  return *posmetaid_;
}
inline void PnlMeta::set_posmetaid(const ::std::string& value) {
  set_has_posmetaid();
  if (posmetaid_ == &::google::protobuf::internal::kEmptyString) {
    posmetaid_ = new ::std::string;
  }
  posmetaid_->assign(value);
}
inline void PnlMeta::set_posmetaid(const char* value) {
  set_has_posmetaid();
  if (posmetaid_ == &::google::protobuf::internal::kEmptyString) {
    posmetaid_ = new ::std::string;
  }
  posmetaid_->assign(value);
}
inline void PnlMeta::set_posmetaid(const void* value, size_t size) {
  set_has_posmetaid();
  if (posmetaid_ == &::google::protobuf::internal::kEmptyString) {
    posmetaid_ = new ::std::string;
  }
  posmetaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PnlMeta::mutable_posmetaid() {
  set_has_posmetaid();
  if (posmetaid_ == &::google::protobuf::internal::kEmptyString) {
    posmetaid_ = new ::std::string;
  }
  return posmetaid_;
}
inline ::std::string* PnlMeta::release_posmetaid() {
  clear_has_posmetaid();
  if (posmetaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = posmetaid_;
    posmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PnlMeta::set_allocated_posmetaid(::std::string* posmetaid) {
  if (posmetaid_ != &::google::protobuf::internal::kEmptyString) {
    delete posmetaid_;
  }
  if (posmetaid) {
    set_has_posmetaid();
    posmetaid_ = posmetaid;
  } else {
    clear_has_posmetaid();
    posmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes playergamestatsid = 60;
inline bool PnlMeta::has_playergamestatsid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PnlMeta::set_has_playergamestatsid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PnlMeta::clear_has_playergamestatsid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PnlMeta::clear_playergamestatsid() {
  if (playergamestatsid_ != &::google::protobuf::internal::kEmptyString) {
    playergamestatsid_->clear();
  }
  clear_has_playergamestatsid();
}
inline const ::std::string& PnlMeta::playergamestatsid() const {
  return *playergamestatsid_;
}
inline void PnlMeta::set_playergamestatsid(const ::std::string& value) {
  set_has_playergamestatsid();
  if (playergamestatsid_ == &::google::protobuf::internal::kEmptyString) {
    playergamestatsid_ = new ::std::string;
  }
  playergamestatsid_->assign(value);
}
inline void PnlMeta::set_playergamestatsid(const char* value) {
  set_has_playergamestatsid();
  if (playergamestatsid_ == &::google::protobuf::internal::kEmptyString) {
    playergamestatsid_ = new ::std::string;
  }
  playergamestatsid_->assign(value);
}
inline void PnlMeta::set_playergamestatsid(const void* value, size_t size) {
  set_has_playergamestatsid();
  if (playergamestatsid_ == &::google::protobuf::internal::kEmptyString) {
    playergamestatsid_ = new ::std::string;
  }
  playergamestatsid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PnlMeta::mutable_playergamestatsid() {
  set_has_playergamestatsid();
  if (playergamestatsid_ == &::google::protobuf::internal::kEmptyString) {
    playergamestatsid_ = new ::std::string;
  }
  return playergamestatsid_;
}
inline ::std::string* PnlMeta::release_playergamestatsid() {
  clear_has_playergamestatsid();
  if (playergamestatsid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playergamestatsid_;
    playergamestatsid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PnlMeta::set_allocated_playergamestatsid(::std::string* playergamestatsid) {
  if (playergamestatsid_ != &::google::protobuf::internal::kEmptyString) {
    delete playergamestatsid_;
  }
  if (playergamestatsid) {
    set_has_playergamestatsid();
    playergamestatsid_ = playergamestatsid;
  } else {
    clear_has_playergamestatsid();
    playergamestatsid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PlayerMarketState

// optional bytes limitbookmetaid = 10;
inline bool PlayerMarketState::has_limitbookmetaid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerMarketState::set_has_limitbookmetaid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerMarketState::clear_has_limitbookmetaid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerMarketState::clear_limitbookmetaid() {
  if (limitbookmetaid_ != &::google::protobuf::internal::kEmptyString) {
    limitbookmetaid_->clear();
  }
  clear_has_limitbookmetaid();
}
inline const ::std::string& PlayerMarketState::limitbookmetaid() const {
  return *limitbookmetaid_;
}
inline void PlayerMarketState::set_limitbookmetaid(const ::std::string& value) {
  set_has_limitbookmetaid();
  if (limitbookmetaid_ == &::google::protobuf::internal::kEmptyString) {
    limitbookmetaid_ = new ::std::string;
  }
  limitbookmetaid_->assign(value);
}
inline void PlayerMarketState::set_limitbookmetaid(const char* value) {
  set_has_limitbookmetaid();
  if (limitbookmetaid_ == &::google::protobuf::internal::kEmptyString) {
    limitbookmetaid_ = new ::std::string;
  }
  limitbookmetaid_->assign(value);
}
inline void PlayerMarketState::set_limitbookmetaid(const void* value, size_t size) {
  set_has_limitbookmetaid();
  if (limitbookmetaid_ == &::google::protobuf::internal::kEmptyString) {
    limitbookmetaid_ = new ::std::string;
  }
  limitbookmetaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerMarketState::mutable_limitbookmetaid() {
  set_has_limitbookmetaid();
  if (limitbookmetaid_ == &::google::protobuf::internal::kEmptyString) {
    limitbookmetaid_ = new ::std::string;
  }
  return limitbookmetaid_;
}
inline ::std::string* PlayerMarketState::release_limitbookmetaid() {
  clear_has_limitbookmetaid();
  if (limitbookmetaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = limitbookmetaid_;
    limitbookmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerMarketState::set_allocated_limitbookmetaid(::std::string* limitbookmetaid) {
  if (limitbookmetaid_ != &::google::protobuf::internal::kEmptyString) {
    delete limitbookmetaid_;
  }
  if (limitbookmetaid) {
    set_has_limitbookmetaid();
    limitbookmetaid_ = limitbookmetaid;
  } else {
    clear_has_limitbookmetaid();
    limitbookmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string playerid = 20;
inline bool PlayerMarketState::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerMarketState::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerMarketState::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerMarketState::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& PlayerMarketState::playerid() const {
  return *playerid_;
}
inline void PlayerMarketState::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void PlayerMarketState::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void PlayerMarketState::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerMarketState::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* PlayerMarketState::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerMarketState::set_allocated_playerid(::std::string* playerid) {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    delete playerid_;
  }
  if (playerid) {
    set_has_playerid();
    playerid_ = playerid;
  } else {
    clear_has_playerid();
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes marketticmetaid = 30;
inline bool PlayerMarketState::has_marketticmetaid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerMarketState::set_has_marketticmetaid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerMarketState::clear_has_marketticmetaid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerMarketState::clear_marketticmetaid() {
  if (marketticmetaid_ != &::google::protobuf::internal::kEmptyString) {
    marketticmetaid_->clear();
  }
  clear_has_marketticmetaid();
}
inline const ::std::string& PlayerMarketState::marketticmetaid() const {
  return *marketticmetaid_;
}
inline void PlayerMarketState::set_marketticmetaid(const ::std::string& value) {
  set_has_marketticmetaid();
  if (marketticmetaid_ == &::google::protobuf::internal::kEmptyString) {
    marketticmetaid_ = new ::std::string;
  }
  marketticmetaid_->assign(value);
}
inline void PlayerMarketState::set_marketticmetaid(const char* value) {
  set_has_marketticmetaid();
  if (marketticmetaid_ == &::google::protobuf::internal::kEmptyString) {
    marketticmetaid_ = new ::std::string;
  }
  marketticmetaid_->assign(value);
}
inline void PlayerMarketState::set_marketticmetaid(const void* value, size_t size) {
  set_has_marketticmetaid();
  if (marketticmetaid_ == &::google::protobuf::internal::kEmptyString) {
    marketticmetaid_ = new ::std::string;
  }
  marketticmetaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerMarketState::mutable_marketticmetaid() {
  set_has_marketticmetaid();
  if (marketticmetaid_ == &::google::protobuf::internal::kEmptyString) {
    marketticmetaid_ = new ::std::string;
  }
  return marketticmetaid_;
}
inline ::std::string* PlayerMarketState::release_marketticmetaid() {
  clear_has_marketticmetaid();
  if (marketticmetaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = marketticmetaid_;
    marketticmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerMarketState::set_allocated_marketticmetaid(::std::string* marketticmetaid) {
  if (marketticmetaid_ != &::google::protobuf::internal::kEmptyString) {
    delete marketticmetaid_;
  }
  if (marketticmetaid) {
    set_has_marketticmetaid();
    marketticmetaid_ = marketticmetaid;
  } else {
    clear_has_marketticmetaid();
    marketticmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool locked = 31;
inline bool PlayerMarketState::has_locked() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerMarketState::set_has_locked() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerMarketState::clear_has_locked() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerMarketState::clear_locked() {
  locked_ = false;
  clear_has_locked();
}
inline bool PlayerMarketState::locked() const {
  return locked_;
}
inline void PlayerMarketState::set_locked(bool value) {
  set_has_locked();
  locked_ = value;
}

// optional bytes prev = 40;
inline bool PlayerMarketState::has_prev() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayerMarketState::set_has_prev() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayerMarketState::clear_has_prev() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayerMarketState::clear_prev() {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    prev_->clear();
  }
  clear_has_prev();
}
inline const ::std::string& PlayerMarketState::prev() const {
  return *prev_;
}
inline void PlayerMarketState::set_prev(const ::std::string& value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void PlayerMarketState::set_prev(const char* value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void PlayerMarketState::set_prev(const void* value, size_t size) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerMarketState::mutable_prev() {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  return prev_;
}
inline ::std::string* PlayerMarketState::release_prev() {
  clear_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prev_;
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerMarketState::set_allocated_prev(::std::string* prev) {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    delete prev_;
  }
  if (prev) {
    set_has_prev();
    prev_ = prev;
  } else {
    clear_has_prev();
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes next = 50;
inline bool PlayerMarketState::has_next() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PlayerMarketState::set_has_next() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PlayerMarketState::clear_has_next() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PlayerMarketState::clear_next() {
  if (next_ != &::google::protobuf::internal::kEmptyString) {
    next_->clear();
  }
  clear_has_next();
}
inline const ::std::string& PlayerMarketState::next() const {
  return *next_;
}
inline void PlayerMarketState::set_next(const ::std::string& value) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(value);
}
inline void PlayerMarketState::set_next(const char* value) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(value);
}
inline void PlayerMarketState::set_next(const void* value, size_t size) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerMarketState::mutable_next() {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  return next_;
}
inline ::std::string* PlayerMarketState::release_next() {
  clear_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = next_;
    next_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerMarketState::set_allocated_next(::std::string* next) {
  if (next_ != &::google::protobuf::internal::kEmptyString) {
    delete next_;
  }
  if (next) {
    set_has_next();
    next_ = next;
  } else {
    clear_has_next();
    next_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LimitBookMeta

// optional int32 bid = 10;
inline bool LimitBookMeta::has_bid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LimitBookMeta::set_has_bid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LimitBookMeta::clear_has_bid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LimitBookMeta::clear_bid() {
  bid_ = 0;
  clear_has_bid();
}
inline ::google::protobuf::int32 LimitBookMeta::bid() const {
  return bid_;
}
inline void LimitBookMeta::set_bid(::google::protobuf::int32 value) {
  set_has_bid();
  bid_ = value;
}

// optional int32 bidsize = 20;
inline bool LimitBookMeta::has_bidsize() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LimitBookMeta::set_has_bidsize() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LimitBookMeta::clear_has_bidsize() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LimitBookMeta::clear_bidsize() {
  bidsize_ = 0;
  clear_has_bidsize();
}
inline ::google::protobuf::int32 LimitBookMeta::bidsize() const {
  return bidsize_;
}
inline void LimitBookMeta::set_bidsize(::google::protobuf::int32 value) {
  set_has_bidsize();
  bidsize_ = value;
}

// optional int32 asksize = 30;
inline bool LimitBookMeta::has_asksize() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LimitBookMeta::set_has_asksize() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LimitBookMeta::clear_has_asksize() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LimitBookMeta::clear_asksize() {
  asksize_ = 0;
  clear_has_asksize();
}
inline ::google::protobuf::int32 LimitBookMeta::asksize() const {
  return asksize_;
}
inline void LimitBookMeta::set_asksize(::google::protobuf::int32 value) {
  set_has_asksize();
  asksize_ = value;
}

// optional int32 ask = 40;
inline bool LimitBookMeta::has_ask() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LimitBookMeta::set_has_ask() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LimitBookMeta::clear_has_ask() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LimitBookMeta::clear_ask() {
  ask_ = 0;
  clear_has_ask();
}
inline ::google::protobuf::int32 LimitBookMeta::ask() const {
  return ask_;
}
inline void LimitBookMeta::set_ask(::google::protobuf::int32 value) {
  set_has_ask();
  ask_ = value;
}

// optional bytes bidordermetaroot = 50;
inline bool LimitBookMeta::has_bidordermetaroot() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LimitBookMeta::set_has_bidordermetaroot() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LimitBookMeta::clear_has_bidordermetaroot() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LimitBookMeta::clear_bidordermetaroot() {
  if (bidordermetaroot_ != &::google::protobuf::internal::kEmptyString) {
    bidordermetaroot_->clear();
  }
  clear_has_bidordermetaroot();
}
inline const ::std::string& LimitBookMeta::bidordermetaroot() const {
  return *bidordermetaroot_;
}
inline void LimitBookMeta::set_bidordermetaroot(const ::std::string& value) {
  set_has_bidordermetaroot();
  if (bidordermetaroot_ == &::google::protobuf::internal::kEmptyString) {
    bidordermetaroot_ = new ::std::string;
  }
  bidordermetaroot_->assign(value);
}
inline void LimitBookMeta::set_bidordermetaroot(const char* value) {
  set_has_bidordermetaroot();
  if (bidordermetaroot_ == &::google::protobuf::internal::kEmptyString) {
    bidordermetaroot_ = new ::std::string;
  }
  bidordermetaroot_->assign(value);
}
inline void LimitBookMeta::set_bidordermetaroot(const void* value, size_t size) {
  set_has_bidordermetaroot();
  if (bidordermetaroot_ == &::google::protobuf::internal::kEmptyString) {
    bidordermetaroot_ = new ::std::string;
  }
  bidordermetaroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LimitBookMeta::mutable_bidordermetaroot() {
  set_has_bidordermetaroot();
  if (bidordermetaroot_ == &::google::protobuf::internal::kEmptyString) {
    bidordermetaroot_ = new ::std::string;
  }
  return bidordermetaroot_;
}
inline ::std::string* LimitBookMeta::release_bidordermetaroot() {
  clear_has_bidordermetaroot();
  if (bidordermetaroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bidordermetaroot_;
    bidordermetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LimitBookMeta::set_allocated_bidordermetaroot(::std::string* bidordermetaroot) {
  if (bidordermetaroot_ != &::google::protobuf::internal::kEmptyString) {
    delete bidordermetaroot_;
  }
  if (bidordermetaroot) {
    set_has_bidordermetaroot();
    bidordermetaroot_ = bidordermetaroot;
  } else {
    clear_has_bidordermetaroot();
    bidordermetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes askordermetaroot = 60;
inline bool LimitBookMeta::has_askordermetaroot() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LimitBookMeta::set_has_askordermetaroot() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LimitBookMeta::clear_has_askordermetaroot() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LimitBookMeta::clear_askordermetaroot() {
  if (askordermetaroot_ != &::google::protobuf::internal::kEmptyString) {
    askordermetaroot_->clear();
  }
  clear_has_askordermetaroot();
}
inline const ::std::string& LimitBookMeta::askordermetaroot() const {
  return *askordermetaroot_;
}
inline void LimitBookMeta::set_askordermetaroot(const ::std::string& value) {
  set_has_askordermetaroot();
  if (askordermetaroot_ == &::google::protobuf::internal::kEmptyString) {
    askordermetaroot_ = new ::std::string;
  }
  askordermetaroot_->assign(value);
}
inline void LimitBookMeta::set_askordermetaroot(const char* value) {
  set_has_askordermetaroot();
  if (askordermetaroot_ == &::google::protobuf::internal::kEmptyString) {
    askordermetaroot_ = new ::std::string;
  }
  askordermetaroot_->assign(value);
}
inline void LimitBookMeta::set_askordermetaroot(const void* value, size_t size) {
  set_has_askordermetaroot();
  if (askordermetaroot_ == &::google::protobuf::internal::kEmptyString) {
    askordermetaroot_ = new ::std::string;
  }
  askordermetaroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LimitBookMeta::mutable_askordermetaroot() {
  set_has_askordermetaroot();
  if (askordermetaroot_ == &::google::protobuf::internal::kEmptyString) {
    askordermetaroot_ = new ::std::string;
  }
  return askordermetaroot_;
}
inline ::std::string* LimitBookMeta::release_askordermetaroot() {
  clear_has_askordermetaroot();
  if (askordermetaroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = askordermetaroot_;
    askordermetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LimitBookMeta::set_allocated_askordermetaroot(::std::string* askordermetaroot) {
  if (askordermetaroot_ != &::google::protobuf::internal::kEmptyString) {
    delete askordermetaroot_;
  }
  if (askordermetaroot) {
    set_has_askordermetaroot();
    askordermetaroot_ = askordermetaroot;
  } else {
    clear_has_askordermetaroot();
    askordermetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MarketTicMeta

// optional int32 price = 20;
inline bool MarketTicMeta::has_price() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketTicMeta::set_has_price() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketTicMeta::clear_has_price() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketTicMeta::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 MarketTicMeta::price() const {
  return price_;
}
inline void MarketTicMeta::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
}

// optional int32 size = 30;
inline bool MarketTicMeta::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketTicMeta::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketTicMeta::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketTicMeta::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::google::protobuf::int32 MarketTicMeta::size() const {
  return size_;
}
inline void MarketTicMeta::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
}

// optional bytes orderfillhead = 40;
inline bool MarketTicMeta::has_orderfillhead() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketTicMeta::set_has_orderfillhead() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketTicMeta::clear_has_orderfillhead() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketTicMeta::clear_orderfillhead() {
  if (orderfillhead_ != &::google::protobuf::internal::kEmptyString) {
    orderfillhead_->clear();
  }
  clear_has_orderfillhead();
}
inline const ::std::string& MarketTicMeta::orderfillhead() const {
  return *orderfillhead_;
}
inline void MarketTicMeta::set_orderfillhead(const ::std::string& value) {
  set_has_orderfillhead();
  if (orderfillhead_ == &::google::protobuf::internal::kEmptyString) {
    orderfillhead_ = new ::std::string;
  }
  orderfillhead_->assign(value);
}
inline void MarketTicMeta::set_orderfillhead(const char* value) {
  set_has_orderfillhead();
  if (orderfillhead_ == &::google::protobuf::internal::kEmptyString) {
    orderfillhead_ = new ::std::string;
  }
  orderfillhead_->assign(value);
}
inline void MarketTicMeta::set_orderfillhead(const void* value, size_t size) {
  set_has_orderfillhead();
  if (orderfillhead_ == &::google::protobuf::internal::kEmptyString) {
    orderfillhead_ = new ::std::string;
  }
  orderfillhead_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MarketTicMeta::mutable_orderfillhead() {
  set_has_orderfillhead();
  if (orderfillhead_ == &::google::protobuf::internal::kEmptyString) {
    orderfillhead_ = new ::std::string;
  }
  return orderfillhead_;
}
inline ::std::string* MarketTicMeta::release_orderfillhead() {
  clear_has_orderfillhead();
  if (orderfillhead_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = orderfillhead_;
    orderfillhead_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MarketTicMeta::set_allocated_orderfillhead(::std::string* orderfillhead) {
  if (orderfillhead_ != &::google::protobuf::internal::kEmptyString) {
    delete orderfillhead_;
  }
  if (orderfillhead) {
    set_has_orderfillhead();
    orderfillhead_ = orderfillhead;
  } else {
    clear_has_orderfillhead();
    orderfillhead_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes prev = 50;
inline bool MarketTicMeta::has_prev() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MarketTicMeta::set_has_prev() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MarketTicMeta::clear_has_prev() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MarketTicMeta::clear_prev() {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    prev_->clear();
  }
  clear_has_prev();
}
inline const ::std::string& MarketTicMeta::prev() const {
  return *prev_;
}
inline void MarketTicMeta::set_prev(const ::std::string& value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void MarketTicMeta::set_prev(const char* value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void MarketTicMeta::set_prev(const void* value, size_t size) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MarketTicMeta::mutable_prev() {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  return prev_;
}
inline ::std::string* MarketTicMeta::release_prev() {
  clear_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prev_;
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MarketTicMeta::set_allocated_prev(::std::string* prev) {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    delete prev_;
  }
  if (prev) {
    set_has_prev();
    prev_ = prev;
  } else {
    clear_has_prev();
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// OrderMeta

// optional int32 refnum = 1;
inline bool OrderMeta::has_refnum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OrderMeta::set_has_refnum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OrderMeta::clear_has_refnum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OrderMeta::clear_refnum() {
  refnum_ = 0;
  clear_has_refnum();
}
inline ::google::protobuf::int32 OrderMeta::refnum() const {
  return refnum_;
}
inline void OrderMeta::set_refnum(::google::protobuf::int32 value) {
  set_has_refnum();
  refnum_ = value;
}

// optional string fname = 10;
inline bool OrderMeta::has_fname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OrderMeta::set_has_fname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OrderMeta::clear_has_fname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OrderMeta::clear_fname() {
  if (fname_ != &::google::protobuf::internal::kEmptyString) {
    fname_->clear();
  }
  clear_has_fname();
}
inline const ::std::string& OrderMeta::fname() const {
  return *fname_;
}
inline void OrderMeta::set_fname(const ::std::string& value) {
  set_has_fname();
  if (fname_ == &::google::protobuf::internal::kEmptyString) {
    fname_ = new ::std::string;
  }
  fname_->assign(value);
}
inline void OrderMeta::set_fname(const char* value) {
  set_has_fname();
  if (fname_ == &::google::protobuf::internal::kEmptyString) {
    fname_ = new ::std::string;
  }
  fname_->assign(value);
}
inline void OrderMeta::set_fname(const char* value, size_t size) {
  set_has_fname();
  if (fname_ == &::google::protobuf::internal::kEmptyString) {
    fname_ = new ::std::string;
  }
  fname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderMeta::mutable_fname() {
  set_has_fname();
  if (fname_ == &::google::protobuf::internal::kEmptyString) {
    fname_ = new ::std::string;
  }
  return fname_;
}
inline ::std::string* OrderMeta::release_fname() {
  clear_has_fname();
  if (fname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fname_;
    fname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderMeta::set_allocated_fname(::std::string* fname) {
  if (fname_ != &::google::protobuf::internal::kEmptyString) {
    delete fname_;
  }
  if (fname) {
    set_has_fname();
    fname_ = fname;
  } else {
    clear_has_fname();
    fname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string playerid = 20;
inline bool OrderMeta::has_playerid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OrderMeta::set_has_playerid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OrderMeta::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OrderMeta::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& OrderMeta::playerid() const {
  return *playerid_;
}
inline void OrderMeta::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void OrderMeta::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void OrderMeta::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderMeta::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* OrderMeta::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderMeta::set_allocated_playerid(::std::string* playerid) {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    delete playerid_;
  }
  if (playerid) {
    set_has_playerid();
    playerid_ = playerid;
  } else {
    clear_has_playerid();
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool buyside = 30;
inline bool OrderMeta::has_buyside() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OrderMeta::set_has_buyside() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OrderMeta::clear_has_buyside() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OrderMeta::clear_buyside() {
  buyside_ = false;
  clear_has_buyside();
}
inline bool OrderMeta::buyside() const {
  return buyside_;
}
inline void OrderMeta::set_buyside(bool value) {
  set_has_buyside();
  buyside_ = value;
}

// optional int32 size = 40;
inline bool OrderMeta::has_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OrderMeta::set_has_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OrderMeta::clear_has_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OrderMeta::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::google::protobuf::int32 OrderMeta::size() const {
  return size_;
}
inline void OrderMeta::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
}

// optional int32 price = 50;
inline bool OrderMeta::has_price() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OrderMeta::set_has_price() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OrderMeta::clear_has_price() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OrderMeta::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 OrderMeta::price() const {
  return price_;
}
inline void OrderMeta::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
}

// optional bytes txmetaid = 60;
inline bool OrderMeta::has_txmetaid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OrderMeta::set_has_txmetaid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OrderMeta::clear_has_txmetaid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OrderMeta::clear_txmetaid() {
  if (txmetaid_ != &::google::protobuf::internal::kEmptyString) {
    txmetaid_->clear();
  }
  clear_has_txmetaid();
}
inline const ::std::string& OrderMeta::txmetaid() const {
  return *txmetaid_;
}
inline void OrderMeta::set_txmetaid(const ::std::string& value) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(value);
}
inline void OrderMeta::set_txmetaid(const char* value) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(value);
}
inline void OrderMeta::set_txmetaid(const void* value, size_t size) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderMeta::mutable_txmetaid() {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  return txmetaid_;
}
inline ::std::string* OrderMeta::release_txmetaid() {
  clear_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = txmetaid_;
    txmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderMeta::set_allocated_txmetaid(::std::string* txmetaid) {
  if (txmetaid_ != &::google::protobuf::internal::kEmptyString) {
    delete txmetaid_;
  }
  if (txmetaid) {
    set_has_txmetaid();
    txmetaid_ = txmetaid;
  } else {
    clear_has_txmetaid();
    txmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes orderfillmetaid = 70;
inline bool OrderMeta::has_orderfillmetaid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void OrderMeta::set_has_orderfillmetaid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void OrderMeta::clear_has_orderfillmetaid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void OrderMeta::clear_orderfillmetaid() {
  if (orderfillmetaid_ != &::google::protobuf::internal::kEmptyString) {
    orderfillmetaid_->clear();
  }
  clear_has_orderfillmetaid();
}
inline const ::std::string& OrderMeta::orderfillmetaid() const {
  return *orderfillmetaid_;
}
inline void OrderMeta::set_orderfillmetaid(const ::std::string& value) {
  set_has_orderfillmetaid();
  if (orderfillmetaid_ == &::google::protobuf::internal::kEmptyString) {
    orderfillmetaid_ = new ::std::string;
  }
  orderfillmetaid_->assign(value);
}
inline void OrderMeta::set_orderfillmetaid(const char* value) {
  set_has_orderfillmetaid();
  if (orderfillmetaid_ == &::google::protobuf::internal::kEmptyString) {
    orderfillmetaid_ = new ::std::string;
  }
  orderfillmetaid_->assign(value);
}
inline void OrderMeta::set_orderfillmetaid(const void* value, size_t size) {
  set_has_orderfillmetaid();
  if (orderfillmetaid_ == &::google::protobuf::internal::kEmptyString) {
    orderfillmetaid_ = new ::std::string;
  }
  orderfillmetaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderMeta::mutable_orderfillmetaid() {
  set_has_orderfillmetaid();
  if (orderfillmetaid_ == &::google::protobuf::internal::kEmptyString) {
    orderfillmetaid_ = new ::std::string;
  }
  return orderfillmetaid_;
}
inline ::std::string* OrderMeta::release_orderfillmetaid() {
  clear_has_orderfillmetaid();
  if (orderfillmetaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = orderfillmetaid_;
    orderfillmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderMeta::set_allocated_orderfillmetaid(::std::string* orderfillmetaid) {
  if (orderfillmetaid_ != &::google::protobuf::internal::kEmptyString) {
    delete orderfillmetaid_;
  }
  if (orderfillmetaid) {
    set_has_orderfillmetaid();
    orderfillmetaid_ = orderfillmetaid;
  } else {
    clear_has_orderfillmetaid();
    orderfillmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 timestamp = 75;
inline bool OrderMeta::has_timestamp() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void OrderMeta::set_has_timestamp() {
  _has_bits_[0] |= 0x00000100u;
}
inline void OrderMeta::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void OrderMeta::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline ::google::protobuf::int32 OrderMeta::timestamp() const {
  return timestamp_;
}
inline void OrderMeta::set_timestamp(::google::protobuf::int32 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional bytes prev = 80;
inline bool OrderMeta::has_prev() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void OrderMeta::set_has_prev() {
  _has_bits_[0] |= 0x00000200u;
}
inline void OrderMeta::clear_has_prev() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void OrderMeta::clear_prev() {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    prev_->clear();
  }
  clear_has_prev();
}
inline const ::std::string& OrderMeta::prev() const {
  return *prev_;
}
inline void OrderMeta::set_prev(const ::std::string& value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void OrderMeta::set_prev(const char* value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void OrderMeta::set_prev(const void* value, size_t size) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderMeta::mutable_prev() {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  return prev_;
}
inline ::std::string* OrderMeta::release_prev() {
  clear_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prev_;
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderMeta::set_allocated_prev(::std::string* prev) {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    delete prev_;
  }
  if (prev) {
    set_has_prev();
    prev_ = prev;
  } else {
    clear_has_prev();
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// OrderFillMeta

// optional int32 refnum = 1;
inline bool OrderFillMeta::has_refnum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OrderFillMeta::set_has_refnum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OrderFillMeta::clear_has_refnum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OrderFillMeta::clear_refnum() {
  refnum_ = 0;
  clear_has_refnum();
}
inline ::google::protobuf::int32 OrderFillMeta::refnum() const {
  return refnum_;
}
inline void OrderFillMeta::set_refnum(::google::protobuf::int32 value) {
  set_has_refnum();
  refnum_ = value;
}

// optional string fname = 10;
inline bool OrderFillMeta::has_fname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OrderFillMeta::set_has_fname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OrderFillMeta::clear_has_fname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OrderFillMeta::clear_fname() {
  if (fname_ != &::google::protobuf::internal::kEmptyString) {
    fname_->clear();
  }
  clear_has_fname();
}
inline const ::std::string& OrderFillMeta::fname() const {
  return *fname_;
}
inline void OrderFillMeta::set_fname(const ::std::string& value) {
  set_has_fname();
  if (fname_ == &::google::protobuf::internal::kEmptyString) {
    fname_ = new ::std::string;
  }
  fname_->assign(value);
}
inline void OrderFillMeta::set_fname(const char* value) {
  set_has_fname();
  if (fname_ == &::google::protobuf::internal::kEmptyString) {
    fname_ = new ::std::string;
  }
  fname_->assign(value);
}
inline void OrderFillMeta::set_fname(const char* value, size_t size) {
  set_has_fname();
  if (fname_ == &::google::protobuf::internal::kEmptyString) {
    fname_ = new ::std::string;
  }
  fname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderFillMeta::mutable_fname() {
  set_has_fname();
  if (fname_ == &::google::protobuf::internal::kEmptyString) {
    fname_ = new ::std::string;
  }
  return fname_;
}
inline ::std::string* OrderFillMeta::release_fname() {
  clear_has_fname();
  if (fname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fname_;
    fname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderFillMeta::set_allocated_fname(::std::string* fname) {
  if (fname_ != &::google::protobuf::internal::kEmptyString) {
    delete fname_;
  }
  if (fname) {
    set_has_fname();
    fname_ = fname;
  } else {
    clear_has_fname();
    fname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string playerid = 15;
inline bool OrderFillMeta::has_playerid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OrderFillMeta::set_has_playerid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OrderFillMeta::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OrderFillMeta::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& OrderFillMeta::playerid() const {
  return *playerid_;
}
inline void OrderFillMeta::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void OrderFillMeta::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void OrderFillMeta::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderFillMeta::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* OrderFillMeta::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderFillMeta::set_allocated_playerid(::std::string* playerid) {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    delete playerid_;
  }
  if (playerid) {
    set_has_playerid();
    playerid_ = playerid;
  } else {
    clear_has_playerid();
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 fillprice = 20;
inline bool OrderFillMeta::has_fillprice() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OrderFillMeta::set_has_fillprice() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OrderFillMeta::clear_has_fillprice() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OrderFillMeta::clear_fillprice() {
  fillprice_ = 0;
  clear_has_fillprice();
}
inline ::google::protobuf::int32 OrderFillMeta::fillprice() const {
  return fillprice_;
}
inline void OrderFillMeta::set_fillprice(::google::protobuf::int32 value) {
  set_has_fillprice();
  fillprice_ = value;
}

// optional int32 fillsize = 30;
inline bool OrderFillMeta::has_fillsize() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OrderFillMeta::set_has_fillsize() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OrderFillMeta::clear_has_fillsize() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OrderFillMeta::clear_fillsize() {
  fillsize_ = 0;
  clear_has_fillsize();
}
inline ::google::protobuf::int32 OrderFillMeta::fillsize() const {
  return fillsize_;
}
inline void OrderFillMeta::set_fillsize(::google::protobuf::int32 value) {
  set_has_fillsize();
  fillsize_ = value;
}

// optional bool buyside = 35;
inline bool OrderFillMeta::has_buyside() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OrderFillMeta::set_has_buyside() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OrderFillMeta::clear_has_buyside() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OrderFillMeta::clear_buyside() {
  buyside_ = false;
  clear_has_buyside();
}
inline bool OrderFillMeta::buyside() const {
  return buyside_;
}
inline void OrderFillMeta::set_buyside(bool value) {
  set_has_buyside();
  buyside_ = value;
}

// optional uint64 timestamp = 40;
inline bool OrderFillMeta::has_timestamp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OrderFillMeta::set_has_timestamp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OrderFillMeta::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OrderFillMeta::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 OrderFillMeta::timestamp() const {
  return timestamp_;
}
inline void OrderFillMeta::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional bytes txmetaid = 60;
inline bool OrderFillMeta::has_txmetaid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void OrderFillMeta::set_has_txmetaid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void OrderFillMeta::clear_has_txmetaid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void OrderFillMeta::clear_txmetaid() {
  if (txmetaid_ != &::google::protobuf::internal::kEmptyString) {
    txmetaid_->clear();
  }
  clear_has_txmetaid();
}
inline const ::std::string& OrderFillMeta::txmetaid() const {
  return *txmetaid_;
}
inline void OrderFillMeta::set_txmetaid(const ::std::string& value) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(value);
}
inline void OrderFillMeta::set_txmetaid(const char* value) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(value);
}
inline void OrderFillMeta::set_txmetaid(const void* value, size_t size) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderFillMeta::mutable_txmetaid() {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  return txmetaid_;
}
inline ::std::string* OrderFillMeta::release_txmetaid() {
  clear_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = txmetaid_;
    txmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderFillMeta::set_allocated_txmetaid(::std::string* txmetaid) {
  if (txmetaid_ != &::google::protobuf::internal::kEmptyString) {
    delete txmetaid_;
  }
  if (txmetaid) {
    set_has_txmetaid();
    txmetaid_ = txmetaid;
  } else {
    clear_has_txmetaid();
    txmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes prev = 70;
inline bool OrderFillMeta::has_prev() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void OrderFillMeta::set_has_prev() {
  _has_bits_[0] |= 0x00000100u;
}
inline void OrderFillMeta::clear_has_prev() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void OrderFillMeta::clear_prev() {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    prev_->clear();
  }
  clear_has_prev();
}
inline const ::std::string& OrderFillMeta::prev() const {
  return *prev_;
}
inline void OrderFillMeta::set_prev(const ::std::string& value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void OrderFillMeta::set_prev(const char* value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void OrderFillMeta::set_prev(const void* value, size_t size) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderFillMeta::mutable_prev() {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  return prev_;
}
inline ::std::string* OrderFillMeta::release_prev() {
  clear_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prev_;
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderFillMeta::set_allocated_prev(::std::string* prev) {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    delete prev_;
  }
  if (prev) {
    set_has_prev();
    prev_ = prev;
  } else {
    clear_has_prev();
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GlobalStateMeta

// optional .fantasybit.GlobalState globalstate = 10;
inline bool GlobalStateMeta::has_globalstate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GlobalStateMeta::set_has_globalstate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GlobalStateMeta::clear_has_globalstate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GlobalStateMeta::clear_globalstate() {
  if (globalstate_ != NULL) globalstate_->::fantasybit::GlobalState::Clear();
  clear_has_globalstate();
}
inline const ::fantasybit::GlobalState& GlobalStateMeta::globalstate() const {
  return globalstate_ != NULL ? *globalstate_ : *default_instance_->globalstate_;
}
inline ::fantasybit::GlobalState* GlobalStateMeta::mutable_globalstate() {
  set_has_globalstate();
  if (globalstate_ == NULL) globalstate_ = new ::fantasybit::GlobalState;
  return globalstate_;
}
inline ::fantasybit::GlobalState* GlobalStateMeta::release_globalstate() {
  clear_has_globalstate();
  ::fantasybit::GlobalState* temp = globalstate_;
  globalstate_ = NULL;
  return temp;
}
inline void GlobalStateMeta::set_allocated_globalstate(::fantasybit::GlobalState* globalstate) {
  delete globalstate_;
  globalstate_ = globalstate;
  if (globalstate) {
    set_has_globalstate();
  } else {
    clear_has_globalstate();
  }
}

// optional bytes trmetaid = 20;
inline bool GlobalStateMeta::has_trmetaid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GlobalStateMeta::set_has_trmetaid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GlobalStateMeta::clear_has_trmetaid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GlobalStateMeta::clear_trmetaid() {
  if (trmetaid_ != &::google::protobuf::internal::kEmptyString) {
    trmetaid_->clear();
  }
  clear_has_trmetaid();
}
inline const ::std::string& GlobalStateMeta::trmetaid() const {
  return *trmetaid_;
}
inline void GlobalStateMeta::set_trmetaid(const ::std::string& value) {
  set_has_trmetaid();
  if (trmetaid_ == &::google::protobuf::internal::kEmptyString) {
    trmetaid_ = new ::std::string;
  }
  trmetaid_->assign(value);
}
inline void GlobalStateMeta::set_trmetaid(const char* value) {
  set_has_trmetaid();
  if (trmetaid_ == &::google::protobuf::internal::kEmptyString) {
    trmetaid_ = new ::std::string;
  }
  trmetaid_->assign(value);
}
inline void GlobalStateMeta::set_trmetaid(const void* value, size_t size) {
  set_has_trmetaid();
  if (trmetaid_ == &::google::protobuf::internal::kEmptyString) {
    trmetaid_ = new ::std::string;
  }
  trmetaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GlobalStateMeta::mutable_trmetaid() {
  set_has_trmetaid();
  if (trmetaid_ == &::google::protobuf::internal::kEmptyString) {
    trmetaid_ = new ::std::string;
  }
  return trmetaid_;
}
inline ::std::string* GlobalStateMeta::release_trmetaid() {
  clear_has_trmetaid();
  if (trmetaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = trmetaid_;
    trmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GlobalStateMeta::set_allocated_trmetaid(::std::string* trmetaid) {
  if (trmetaid_ != &::google::protobuf::internal::kEmptyString) {
    delete trmetaid_;
  }
  if (trmetaid) {
    set_has_trmetaid();
    trmetaid_ = trmetaid;
  } else {
    clear_has_trmetaid();
    trmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes prev = 30;
inline bool GlobalStateMeta::has_prev() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GlobalStateMeta::set_has_prev() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GlobalStateMeta::clear_has_prev() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GlobalStateMeta::clear_prev() {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    prev_->clear();
  }
  clear_has_prev();
}
inline const ::std::string& GlobalStateMeta::prev() const {
  return *prev_;
}
inline void GlobalStateMeta::set_prev(const ::std::string& value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void GlobalStateMeta::set_prev(const char* value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void GlobalStateMeta::set_prev(const void* value, size_t size) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GlobalStateMeta::mutable_prev() {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  return prev_;
}
inline ::std::string* GlobalStateMeta::release_prev() {
  clear_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prev_;
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GlobalStateMeta::set_allocated_prev(::std::string* prev) {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    delete prev_;
  }
  if (prev) {
    set_has_prev();
    prev_ = prev;
  } else {
    clear_has_prev();
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes next = 40;
inline bool GlobalStateMeta::has_next() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GlobalStateMeta::set_has_next() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GlobalStateMeta::clear_has_next() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GlobalStateMeta::clear_next() {
  if (next_ != &::google::protobuf::internal::kEmptyString) {
    next_->clear();
  }
  clear_has_next();
}
inline const ::std::string& GlobalStateMeta::next() const {
  return *next_;
}
inline void GlobalStateMeta::set_next(const ::std::string& value) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(value);
}
inline void GlobalStateMeta::set_next(const char* value) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(value);
}
inline void GlobalStateMeta::set_next(const void* value, size_t size) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GlobalStateMeta::mutable_next() {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  return next_;
}
inline ::std::string* GlobalStateMeta::release_next() {
  clear_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = next_;
    next_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GlobalStateMeta::set_allocated_next(::std::string* next) {
  if (next_ != &::google::protobuf::internal::kEmptyString) {
    delete next_;
  }
  if (next) {
    set_has_next();
    next_ = next;
  } else {
    clear_has_next();
    next_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PlayerMeta

// optional string playerid = 10;
inline bool PlayerMeta::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerMeta::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerMeta::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerMeta::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& PlayerMeta::playerid() const {
  return *playerid_;
}
inline void PlayerMeta::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void PlayerMeta::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void PlayerMeta::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerMeta::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* PlayerMeta::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerMeta::set_allocated_playerid(::std::string* playerid) {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    delete playerid_;
  }
  if (playerid) {
    set_has_playerid();
    playerid_ = playerid;
  } else {
    clear_has_playerid();
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .fantasybit.PlayerBase player_base = 20;
inline bool PlayerMeta::has_player_base() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerMeta::set_has_player_base() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerMeta::clear_has_player_base() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerMeta::clear_player_base() {
  if (player_base_ != NULL) player_base_->::fantasybit::PlayerBase::Clear();
  clear_has_player_base();
}
inline const ::fantasybit::PlayerBase& PlayerMeta::player_base() const {
  return player_base_ != NULL ? *player_base_ : *default_instance_->player_base_;
}
inline ::fantasybit::PlayerBase* PlayerMeta::mutable_player_base() {
  set_has_player_base();
  if (player_base_ == NULL) player_base_ = new ::fantasybit::PlayerBase;
  return player_base_;
}
inline ::fantasybit::PlayerBase* PlayerMeta::release_player_base() {
  clear_has_player_base();
  ::fantasybit::PlayerBase* temp = player_base_;
  player_base_ = NULL;
  return temp;
}
inline void PlayerMeta::set_allocated_player_base(::fantasybit::PlayerBase* player_base) {
  delete player_base_;
  player_base_ = player_base;
  if (player_base) {
    set_has_player_base();
  } else {
    clear_has_player_base();
  }
}

// optional .fantasybit.PlayerStatus player_status = 30;
inline bool PlayerMeta::has_player_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerMeta::set_has_player_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerMeta::clear_has_player_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerMeta::clear_player_status() {
  if (player_status_ != NULL) player_status_->::fantasybit::PlayerStatus::Clear();
  clear_has_player_status();
}
inline const ::fantasybit::PlayerStatus& PlayerMeta::player_status() const {
  return player_status_ != NULL ? *player_status_ : *default_instance_->player_status_;
}
inline ::fantasybit::PlayerStatus* PlayerMeta::mutable_player_status() {
  set_has_player_status();
  if (player_status_ == NULL) player_status_ = new ::fantasybit::PlayerStatus;
  return player_status_;
}
inline ::fantasybit::PlayerStatus* PlayerMeta::release_player_status() {
  clear_has_player_status();
  ::fantasybit::PlayerStatus* temp = player_status_;
  player_status_ = NULL;
  return temp;
}
inline void PlayerMeta::set_allocated_player_status(::fantasybit::PlayerStatus* player_status) {
  delete player_status_;
  player_status_ = player_status;
  if (player_status) {
    set_has_player_status();
  } else {
    clear_has_player_status();
  }
}

// optional bytes datametaid = 40;
inline bool PlayerMeta::has_datametaid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerMeta::set_has_datametaid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerMeta::clear_has_datametaid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerMeta::clear_datametaid() {
  if (datametaid_ != &::google::protobuf::internal::kEmptyString) {
    datametaid_->clear();
  }
  clear_has_datametaid();
}
inline const ::std::string& PlayerMeta::datametaid() const {
  return *datametaid_;
}
inline void PlayerMeta::set_datametaid(const ::std::string& value) {
  set_has_datametaid();
  if (datametaid_ == &::google::protobuf::internal::kEmptyString) {
    datametaid_ = new ::std::string;
  }
  datametaid_->assign(value);
}
inline void PlayerMeta::set_datametaid(const char* value) {
  set_has_datametaid();
  if (datametaid_ == &::google::protobuf::internal::kEmptyString) {
    datametaid_ = new ::std::string;
  }
  datametaid_->assign(value);
}
inline void PlayerMeta::set_datametaid(const void* value, size_t size) {
  set_has_datametaid();
  if (datametaid_ == &::google::protobuf::internal::kEmptyString) {
    datametaid_ = new ::std::string;
  }
  datametaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerMeta::mutable_datametaid() {
  set_has_datametaid();
  if (datametaid_ == &::google::protobuf::internal::kEmptyString) {
    datametaid_ = new ::std::string;
  }
  return datametaid_;
}
inline ::std::string* PlayerMeta::release_datametaid() {
  clear_has_datametaid();
  if (datametaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = datametaid_;
    datametaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerMeta::set_allocated_datametaid(::std::string* datametaid) {
  if (datametaid_ != &::google::protobuf::internal::kEmptyString) {
    delete datametaid_;
  }
  if (datametaid) {
    set_has_datametaid();
    datametaid_ = datametaid;
  } else {
    clear_has_datametaid();
    datametaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes prev = 50;
inline bool PlayerMeta::has_prev() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayerMeta::set_has_prev() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayerMeta::clear_has_prev() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayerMeta::clear_prev() {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    prev_->clear();
  }
  clear_has_prev();
}
inline const ::std::string& PlayerMeta::prev() const {
  return *prev_;
}
inline void PlayerMeta::set_prev(const ::std::string& value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void PlayerMeta::set_prev(const char* value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void PlayerMeta::set_prev(const void* value, size_t size) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerMeta::mutable_prev() {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  return prev_;
}
inline ::std::string* PlayerMeta::release_prev() {
  clear_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prev_;
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerMeta::set_allocated_prev(::std::string* prev) {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    delete prev_;
  }
  if (prev) {
    set_has_prev();
    prev_ = prev;
  } else {
    clear_has_prev();
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TeamMeta

// optional string teamid = 10;
inline bool TeamMeta::has_teamid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TeamMeta::set_has_teamid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TeamMeta::clear_has_teamid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TeamMeta::clear_teamid() {
  if (teamid_ != &::google::protobuf::internal::kEmptyString) {
    teamid_->clear();
  }
  clear_has_teamid();
}
inline const ::std::string& TeamMeta::teamid() const {
  return *teamid_;
}
inline void TeamMeta::set_teamid(const ::std::string& value) {
  set_has_teamid();
  if (teamid_ == &::google::protobuf::internal::kEmptyString) {
    teamid_ = new ::std::string;
  }
  teamid_->assign(value);
}
inline void TeamMeta::set_teamid(const char* value) {
  set_has_teamid();
  if (teamid_ == &::google::protobuf::internal::kEmptyString) {
    teamid_ = new ::std::string;
  }
  teamid_->assign(value);
}
inline void TeamMeta::set_teamid(const char* value, size_t size) {
  set_has_teamid();
  if (teamid_ == &::google::protobuf::internal::kEmptyString) {
    teamid_ = new ::std::string;
  }
  teamid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TeamMeta::mutable_teamid() {
  set_has_teamid();
  if (teamid_ == &::google::protobuf::internal::kEmptyString) {
    teamid_ = new ::std::string;
  }
  return teamid_;
}
inline ::std::string* TeamMeta::release_teamid() {
  clear_has_teamid();
  if (teamid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = teamid_;
    teamid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TeamMeta::set_allocated_teamid(::std::string* teamid) {
  if (teamid_ != &::google::protobuf::internal::kEmptyString) {
    delete teamid_;
  }
  if (teamid) {
    set_has_teamid();
    teamid_ = teamid;
  } else {
    clear_has_teamid();
    teamid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes playermetaidroot = 20;
inline bool TeamMeta::has_playermetaidroot() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TeamMeta::set_has_playermetaidroot() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TeamMeta::clear_has_playermetaidroot() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TeamMeta::clear_playermetaidroot() {
  if (playermetaidroot_ != &::google::protobuf::internal::kEmptyString) {
    playermetaidroot_->clear();
  }
  clear_has_playermetaidroot();
}
inline const ::std::string& TeamMeta::playermetaidroot() const {
  return *playermetaidroot_;
}
inline void TeamMeta::set_playermetaidroot(const ::std::string& value) {
  set_has_playermetaidroot();
  if (playermetaidroot_ == &::google::protobuf::internal::kEmptyString) {
    playermetaidroot_ = new ::std::string;
  }
  playermetaidroot_->assign(value);
}
inline void TeamMeta::set_playermetaidroot(const char* value) {
  set_has_playermetaidroot();
  if (playermetaidroot_ == &::google::protobuf::internal::kEmptyString) {
    playermetaidroot_ = new ::std::string;
  }
  playermetaidroot_->assign(value);
}
inline void TeamMeta::set_playermetaidroot(const void* value, size_t size) {
  set_has_playermetaidroot();
  if (playermetaidroot_ == &::google::protobuf::internal::kEmptyString) {
    playermetaidroot_ = new ::std::string;
  }
  playermetaidroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TeamMeta::mutable_playermetaidroot() {
  set_has_playermetaidroot();
  if (playermetaidroot_ == &::google::protobuf::internal::kEmptyString) {
    playermetaidroot_ = new ::std::string;
  }
  return playermetaidroot_;
}
inline ::std::string* TeamMeta::release_playermetaidroot() {
  clear_has_playermetaidroot();
  if (playermetaidroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playermetaidroot_;
    playermetaidroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TeamMeta::set_allocated_playermetaidroot(::std::string* playermetaidroot) {
  if (playermetaidroot_ != &::google::protobuf::internal::kEmptyString) {
    delete playermetaidroot_;
  }
  if (playermetaidroot) {
    set_has_playermetaidroot();
    playermetaidroot_ = playermetaidroot;
  } else {
    clear_has_playermetaidroot();
    playermetaidroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes prev = 30;
inline bool TeamMeta::has_prev() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TeamMeta::set_has_prev() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TeamMeta::clear_has_prev() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TeamMeta::clear_prev() {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    prev_->clear();
  }
  clear_has_prev();
}
inline const ::std::string& TeamMeta::prev() const {
  return *prev_;
}
inline void TeamMeta::set_prev(const ::std::string& value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void TeamMeta::set_prev(const char* value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void TeamMeta::set_prev(const void* value, size_t size) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TeamMeta::mutable_prev() {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  return prev_;
}
inline ::std::string* TeamMeta::release_prev() {
  clear_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prev_;
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TeamMeta::set_allocated_prev(::std::string* prev) {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    delete prev_;
  }
  if (prev) {
    set_has_prev();
    prev_ = prev;
  } else {
    clear_has_prev();
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// pbstate

// optional bytes schedulestateid = 10;
inline bool pbstate::has_schedulestateid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbstate::set_has_schedulestateid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbstate::clear_has_schedulestateid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbstate::clear_schedulestateid() {
  if (schedulestateid_ != &::google::protobuf::internal::kEmptyString) {
    schedulestateid_->clear();
  }
  clear_has_schedulestateid();
}
inline const ::std::string& pbstate::schedulestateid() const {
  return *schedulestateid_;
}
inline void pbstate::set_schedulestateid(const ::std::string& value) {
  set_has_schedulestateid();
  if (schedulestateid_ == &::google::protobuf::internal::kEmptyString) {
    schedulestateid_ = new ::std::string;
  }
  schedulestateid_->assign(value);
}
inline void pbstate::set_schedulestateid(const char* value) {
  set_has_schedulestateid();
  if (schedulestateid_ == &::google::protobuf::internal::kEmptyString) {
    schedulestateid_ = new ::std::string;
  }
  schedulestateid_->assign(value);
}
inline void pbstate::set_schedulestateid(const void* value, size_t size) {
  set_has_schedulestateid();
  if (schedulestateid_ == &::google::protobuf::internal::kEmptyString) {
    schedulestateid_ = new ::std::string;
  }
  schedulestateid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbstate::mutable_schedulestateid() {
  set_has_schedulestateid();
  if (schedulestateid_ == &::google::protobuf::internal::kEmptyString) {
    schedulestateid_ = new ::std::string;
  }
  return schedulestateid_;
}
inline ::std::string* pbstate::release_schedulestateid() {
  clear_has_schedulestateid();
  if (schedulestateid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = schedulestateid_;
    schedulestateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbstate::set_allocated_schedulestateid(::std::string* schedulestateid) {
  if (schedulestateid_ != &::google::protobuf::internal::kEmptyString) {
    delete schedulestateid_;
  }
  if (schedulestateid) {
    set_has_schedulestateid();
    schedulestateid_ = schedulestateid;
  } else {
    clear_has_schedulestateid();
    schedulestateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes leaderboardstateid = 20;
inline bool pbstate::has_leaderboardstateid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbstate::set_has_leaderboardstateid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbstate::clear_has_leaderboardstateid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbstate::clear_leaderboardstateid() {
  if (leaderboardstateid_ != &::google::protobuf::internal::kEmptyString) {
    leaderboardstateid_->clear();
  }
  clear_has_leaderboardstateid();
}
inline const ::std::string& pbstate::leaderboardstateid() const {
  return *leaderboardstateid_;
}
inline void pbstate::set_leaderboardstateid(const ::std::string& value) {
  set_has_leaderboardstateid();
  if (leaderboardstateid_ == &::google::protobuf::internal::kEmptyString) {
    leaderboardstateid_ = new ::std::string;
  }
  leaderboardstateid_->assign(value);
}
inline void pbstate::set_leaderboardstateid(const char* value) {
  set_has_leaderboardstateid();
  if (leaderboardstateid_ == &::google::protobuf::internal::kEmptyString) {
    leaderboardstateid_ = new ::std::string;
  }
  leaderboardstateid_->assign(value);
}
inline void pbstate::set_leaderboardstateid(const void* value, size_t size) {
  set_has_leaderboardstateid();
  if (leaderboardstateid_ == &::google::protobuf::internal::kEmptyString) {
    leaderboardstateid_ = new ::std::string;
  }
  leaderboardstateid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbstate::mutable_leaderboardstateid() {
  set_has_leaderboardstateid();
  if (leaderboardstateid_ == &::google::protobuf::internal::kEmptyString) {
    leaderboardstateid_ = new ::std::string;
  }
  return leaderboardstateid_;
}
inline ::std::string* pbstate::release_leaderboardstateid() {
  clear_has_leaderboardstateid();
  if (leaderboardstateid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leaderboardstateid_;
    leaderboardstateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbstate::set_allocated_leaderboardstateid(::std::string* leaderboardstateid) {
  if (leaderboardstateid_ != &::google::protobuf::internal::kEmptyString) {
    delete leaderboardstateid_;
  }
  if (leaderboardstateid) {
    set_has_leaderboardstateid();
    leaderboardstateid_ = leaderboardstateid;
  } else {
    clear_has_leaderboardstateid();
    leaderboardstateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes projstateid = 30;
inline bool pbstate::has_projstateid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void pbstate::set_has_projstateid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void pbstate::clear_has_projstateid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void pbstate::clear_projstateid() {
  if (projstateid_ != &::google::protobuf::internal::kEmptyString) {
    projstateid_->clear();
  }
  clear_has_projstateid();
}
inline const ::std::string& pbstate::projstateid() const {
  return *projstateid_;
}
inline void pbstate::set_projstateid(const ::std::string& value) {
  set_has_projstateid();
  if (projstateid_ == &::google::protobuf::internal::kEmptyString) {
    projstateid_ = new ::std::string;
  }
  projstateid_->assign(value);
}
inline void pbstate::set_projstateid(const char* value) {
  set_has_projstateid();
  if (projstateid_ == &::google::protobuf::internal::kEmptyString) {
    projstateid_ = new ::std::string;
  }
  projstateid_->assign(value);
}
inline void pbstate::set_projstateid(const void* value, size_t size) {
  set_has_projstateid();
  if (projstateid_ == &::google::protobuf::internal::kEmptyString) {
    projstateid_ = new ::std::string;
  }
  projstateid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbstate::mutable_projstateid() {
  set_has_projstateid();
  if (projstateid_ == &::google::protobuf::internal::kEmptyString) {
    projstateid_ = new ::std::string;
  }
  return projstateid_;
}
inline ::std::string* pbstate::release_projstateid() {
  clear_has_projstateid();
  if (projstateid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = projstateid_;
    projstateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbstate::set_allocated_projstateid(::std::string* projstateid) {
  if (projstateid_ != &::google::protobuf::internal::kEmptyString) {
    delete projstateid_;
  }
  if (projstateid) {
    set_has_projstateid();
    projstateid_ = projstateid;
  } else {
    clear_has_projstateid();
    projstateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes posstateid = 35;
inline bool pbstate::has_posstateid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void pbstate::set_has_posstateid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void pbstate::clear_has_posstateid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void pbstate::clear_posstateid() {
  if (posstateid_ != &::google::protobuf::internal::kEmptyString) {
    posstateid_->clear();
  }
  clear_has_posstateid();
}
inline const ::std::string& pbstate::posstateid() const {
  return *posstateid_;
}
inline void pbstate::set_posstateid(const ::std::string& value) {
  set_has_posstateid();
  if (posstateid_ == &::google::protobuf::internal::kEmptyString) {
    posstateid_ = new ::std::string;
  }
  posstateid_->assign(value);
}
inline void pbstate::set_posstateid(const char* value) {
  set_has_posstateid();
  if (posstateid_ == &::google::protobuf::internal::kEmptyString) {
    posstateid_ = new ::std::string;
  }
  posstateid_->assign(value);
}
inline void pbstate::set_posstateid(const void* value, size_t size) {
  set_has_posstateid();
  if (posstateid_ == &::google::protobuf::internal::kEmptyString) {
    posstateid_ = new ::std::string;
  }
  posstateid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbstate::mutable_posstateid() {
  set_has_posstateid();
  if (posstateid_ == &::google::protobuf::internal::kEmptyString) {
    posstateid_ = new ::std::string;
  }
  return posstateid_;
}
inline ::std::string* pbstate::release_posstateid() {
  clear_has_posstateid();
  if (posstateid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = posstateid_;
    posstateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbstate::set_allocated_posstateid(::std::string* posstateid) {
  if (posstateid_ != &::google::protobuf::internal::kEmptyString) {
    delete posstateid_;
  }
  if (posstateid) {
    set_has_posstateid();
    posstateid_ = posstateid;
  } else {
    clear_has_posstateid();
    posstateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes orderstateid = 40;
inline bool pbstate::has_orderstateid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void pbstate::set_has_orderstateid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void pbstate::clear_has_orderstateid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void pbstate::clear_orderstateid() {
  if (orderstateid_ != &::google::protobuf::internal::kEmptyString) {
    orderstateid_->clear();
  }
  clear_has_orderstateid();
}
inline const ::std::string& pbstate::orderstateid() const {
  return *orderstateid_;
}
inline void pbstate::set_orderstateid(const ::std::string& value) {
  set_has_orderstateid();
  if (orderstateid_ == &::google::protobuf::internal::kEmptyString) {
    orderstateid_ = new ::std::string;
  }
  orderstateid_->assign(value);
}
inline void pbstate::set_orderstateid(const char* value) {
  set_has_orderstateid();
  if (orderstateid_ == &::google::protobuf::internal::kEmptyString) {
    orderstateid_ = new ::std::string;
  }
  orderstateid_->assign(value);
}
inline void pbstate::set_orderstateid(const void* value, size_t size) {
  set_has_orderstateid();
  if (orderstateid_ == &::google::protobuf::internal::kEmptyString) {
    orderstateid_ = new ::std::string;
  }
  orderstateid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbstate::mutable_orderstateid() {
  set_has_orderstateid();
  if (orderstateid_ == &::google::protobuf::internal::kEmptyString) {
    orderstateid_ = new ::std::string;
  }
  return orderstateid_;
}
inline ::std::string* pbstate::release_orderstateid() {
  clear_has_orderstateid();
  if (orderstateid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = orderstateid_;
    orderstateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbstate::set_allocated_orderstateid(::std::string* orderstateid) {
  if (orderstateid_ != &::google::protobuf::internal::kEmptyString) {
    delete orderstateid_;
  }
  if (orderstateid) {
    set_has_orderstateid();
    orderstateid_ = orderstateid;
  } else {
    clear_has_orderstateid();
    orderstateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes marketstateid = 50;
inline bool pbstate::has_marketstateid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void pbstate::set_has_marketstateid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void pbstate::clear_has_marketstateid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void pbstate::clear_marketstateid() {
  if (marketstateid_ != &::google::protobuf::internal::kEmptyString) {
    marketstateid_->clear();
  }
  clear_has_marketstateid();
}
inline const ::std::string& pbstate::marketstateid() const {
  return *marketstateid_;
}
inline void pbstate::set_marketstateid(const ::std::string& value) {
  set_has_marketstateid();
  if (marketstateid_ == &::google::protobuf::internal::kEmptyString) {
    marketstateid_ = new ::std::string;
  }
  marketstateid_->assign(value);
}
inline void pbstate::set_marketstateid(const char* value) {
  set_has_marketstateid();
  if (marketstateid_ == &::google::protobuf::internal::kEmptyString) {
    marketstateid_ = new ::std::string;
  }
  marketstateid_->assign(value);
}
inline void pbstate::set_marketstateid(const void* value, size_t size) {
  set_has_marketstateid();
  if (marketstateid_ == &::google::protobuf::internal::kEmptyString) {
    marketstateid_ = new ::std::string;
  }
  marketstateid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbstate::mutable_marketstateid() {
  set_has_marketstateid();
  if (marketstateid_ == &::google::protobuf::internal::kEmptyString) {
    marketstateid_ = new ::std::string;
  }
  return marketstateid_;
}
inline ::std::string* pbstate::release_marketstateid() {
  clear_has_marketstateid();
  if (marketstateid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = marketstateid_;
    marketstateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbstate::set_allocated_marketstateid(::std::string* marketstateid) {
  if (marketstateid_ != &::google::protobuf::internal::kEmptyString) {
    delete marketstateid_;
  }
  if (marketstateid) {
    set_has_marketstateid();
    marketstateid_ = marketstateid;
  } else {
    clear_has_marketstateid();
    marketstateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes globalstateid = 60;
inline bool pbstate::has_globalstateid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void pbstate::set_has_globalstateid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void pbstate::clear_has_globalstateid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void pbstate::clear_globalstateid() {
  if (globalstateid_ != &::google::protobuf::internal::kEmptyString) {
    globalstateid_->clear();
  }
  clear_has_globalstateid();
}
inline const ::std::string& pbstate::globalstateid() const {
  return *globalstateid_;
}
inline void pbstate::set_globalstateid(const ::std::string& value) {
  set_has_globalstateid();
  if (globalstateid_ == &::google::protobuf::internal::kEmptyString) {
    globalstateid_ = new ::std::string;
  }
  globalstateid_->assign(value);
}
inline void pbstate::set_globalstateid(const char* value) {
  set_has_globalstateid();
  if (globalstateid_ == &::google::protobuf::internal::kEmptyString) {
    globalstateid_ = new ::std::string;
  }
  globalstateid_->assign(value);
}
inline void pbstate::set_globalstateid(const void* value, size_t size) {
  set_has_globalstateid();
  if (globalstateid_ == &::google::protobuf::internal::kEmptyString) {
    globalstateid_ = new ::std::string;
  }
  globalstateid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbstate::mutable_globalstateid() {
  set_has_globalstateid();
  if (globalstateid_ == &::google::protobuf::internal::kEmptyString) {
    globalstateid_ = new ::std::string;
  }
  return globalstateid_;
}
inline ::std::string* pbstate::release_globalstateid() {
  clear_has_globalstateid();
  if (globalstateid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = globalstateid_;
    globalstateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbstate::set_allocated_globalstateid(::std::string* globalstateid) {
  if (globalstateid_ != &::google::protobuf::internal::kEmptyString) {
    delete globalstateid_;
  }
  if (globalstateid) {
    set_has_globalstateid();
    globalstateid_ = globalstateid;
  } else {
    clear_has_globalstateid();
    globalstateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes teamstatemid = 70;
inline bool pbstate::has_teamstatemid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void pbstate::set_has_teamstatemid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void pbstate::clear_has_teamstatemid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void pbstate::clear_teamstatemid() {
  if (teamstatemid_ != &::google::protobuf::internal::kEmptyString) {
    teamstatemid_->clear();
  }
  clear_has_teamstatemid();
}
inline const ::std::string& pbstate::teamstatemid() const {
  return *teamstatemid_;
}
inline void pbstate::set_teamstatemid(const ::std::string& value) {
  set_has_teamstatemid();
  if (teamstatemid_ == &::google::protobuf::internal::kEmptyString) {
    teamstatemid_ = new ::std::string;
  }
  teamstatemid_->assign(value);
}
inline void pbstate::set_teamstatemid(const char* value) {
  set_has_teamstatemid();
  if (teamstatemid_ == &::google::protobuf::internal::kEmptyString) {
    teamstatemid_ = new ::std::string;
  }
  teamstatemid_->assign(value);
}
inline void pbstate::set_teamstatemid(const void* value, size_t size) {
  set_has_teamstatemid();
  if (teamstatemid_ == &::google::protobuf::internal::kEmptyString) {
    teamstatemid_ = new ::std::string;
  }
  teamstatemid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbstate::mutable_teamstatemid() {
  set_has_teamstatemid();
  if (teamstatemid_ == &::google::protobuf::internal::kEmptyString) {
    teamstatemid_ = new ::std::string;
  }
  return teamstatemid_;
}
inline ::std::string* pbstate::release_teamstatemid() {
  clear_has_teamstatemid();
  if (teamstatemid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = teamstatemid_;
    teamstatemid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbstate::set_allocated_teamstatemid(::std::string* teamstatemid) {
  if (teamstatemid_ != &::google::protobuf::internal::kEmptyString) {
    delete teamstatemid_;
  }
  if (teamstatemid) {
    set_has_teamstatemid();
    teamstatemid_ = teamstatemid;
  } else {
    clear_has_teamstatemid();
    teamstatemid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes fantasynamestateid = 80;
inline bool pbstate::has_fantasynamestateid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void pbstate::set_has_fantasynamestateid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void pbstate::clear_has_fantasynamestateid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void pbstate::clear_fantasynamestateid() {
  if (fantasynamestateid_ != &::google::protobuf::internal::kEmptyString) {
    fantasynamestateid_->clear();
  }
  clear_has_fantasynamestateid();
}
inline const ::std::string& pbstate::fantasynamestateid() const {
  return *fantasynamestateid_;
}
inline void pbstate::set_fantasynamestateid(const ::std::string& value) {
  set_has_fantasynamestateid();
  if (fantasynamestateid_ == &::google::protobuf::internal::kEmptyString) {
    fantasynamestateid_ = new ::std::string;
  }
  fantasynamestateid_->assign(value);
}
inline void pbstate::set_fantasynamestateid(const char* value) {
  set_has_fantasynamestateid();
  if (fantasynamestateid_ == &::google::protobuf::internal::kEmptyString) {
    fantasynamestateid_ = new ::std::string;
  }
  fantasynamestateid_->assign(value);
}
inline void pbstate::set_fantasynamestateid(const void* value, size_t size) {
  set_has_fantasynamestateid();
  if (fantasynamestateid_ == &::google::protobuf::internal::kEmptyString) {
    fantasynamestateid_ = new ::std::string;
  }
  fantasynamestateid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbstate::mutable_fantasynamestateid() {
  set_has_fantasynamestateid();
  if (fantasynamestateid_ == &::google::protobuf::internal::kEmptyString) {
    fantasynamestateid_ = new ::std::string;
  }
  return fantasynamestateid_;
}
inline ::std::string* pbstate::release_fantasynamestateid() {
  clear_has_fantasynamestateid();
  if (fantasynamestateid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fantasynamestateid_;
    fantasynamestateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbstate::set_allocated_fantasynamestateid(::std::string* fantasynamestateid) {
  if (fantasynamestateid_ != &::google::protobuf::internal::kEmptyString) {
    delete fantasynamestateid_;
  }
  if (fantasynamestateid) {
    set_has_fantasynamestateid();
    fantasynamestateid_ = fantasynamestateid;
  } else {
    clear_has_fantasynamestateid();
    fantasynamestateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MerkleTree

// optional bytes root = 10;
inline bool MerkleTree::has_root() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MerkleTree::set_has_root() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MerkleTree::clear_has_root() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MerkleTree::clear_root() {
  if (root_ != &::google::protobuf::internal::kEmptyString) {
    root_->clear();
  }
  clear_has_root();
}
inline const ::std::string& MerkleTree::root() const {
  return *root_;
}
inline void MerkleTree::set_root(const ::std::string& value) {
  set_has_root();
  if (root_ == &::google::protobuf::internal::kEmptyString) {
    root_ = new ::std::string;
  }
  root_->assign(value);
}
inline void MerkleTree::set_root(const char* value) {
  set_has_root();
  if (root_ == &::google::protobuf::internal::kEmptyString) {
    root_ = new ::std::string;
  }
  root_->assign(value);
}
inline void MerkleTree::set_root(const void* value, size_t size) {
  set_has_root();
  if (root_ == &::google::protobuf::internal::kEmptyString) {
    root_ = new ::std::string;
  }
  root_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MerkleTree::mutable_root() {
  set_has_root();
  if (root_ == &::google::protobuf::internal::kEmptyString) {
    root_ = new ::std::string;
  }
  return root_;
}
inline ::std::string* MerkleTree::release_root() {
  clear_has_root();
  if (root_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = root_;
    root_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MerkleTree::set_allocated_root(::std::string* root) {
  if (root_ != &::google::protobuf::internal::kEmptyString) {
    delete root_;
  }
  if (root) {
    set_has_root();
    root_ = root;
  } else {
    clear_has_root();
    root_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated bytes leaves = 20;
inline int MerkleTree::leaves_size() const {
  return leaves_.size();
}
inline void MerkleTree::clear_leaves() {
  leaves_.Clear();
}
inline const ::std::string& MerkleTree::leaves(int index) const {
  return leaves_.Get(index);
}
inline ::std::string* MerkleTree::mutable_leaves(int index) {
  return leaves_.Mutable(index);
}
inline void MerkleTree::set_leaves(int index, const ::std::string& value) {
  leaves_.Mutable(index)->assign(value);
}
inline void MerkleTree::set_leaves(int index, const char* value) {
  leaves_.Mutable(index)->assign(value);
}
inline void MerkleTree::set_leaves(int index, const void* value, size_t size) {
  leaves_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MerkleTree::add_leaves() {
  return leaves_.Add();
}
inline void MerkleTree::add_leaves(const ::std::string& value) {
  leaves_.Add()->assign(value);
}
inline void MerkleTree::add_leaves(const char* value) {
  leaves_.Add()->assign(value);
}
inline void MerkleTree::add_leaves(const void* value, size_t size) {
  leaves_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MerkleTree::leaves() const {
  return leaves_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MerkleTree::mutable_leaves() {
  return &leaves_;
}

// -------------------------------------------------------------------

// NewPlayerModel

// repeated .fantasybit.PlayerMeta players = 10;
inline int NewPlayerModel::players_size() const {
  return players_.size();
}
inline void NewPlayerModel::clear_players() {
  players_.Clear();
}
inline const ::fantasybit::PlayerMeta& NewPlayerModel::players(int index) const {
  return players_.Get(index);
}
inline ::fantasybit::PlayerMeta* NewPlayerModel::mutable_players(int index) {
  return players_.Mutable(index);
}
inline ::fantasybit::PlayerMeta* NewPlayerModel::add_players() {
  return players_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::PlayerMeta >&
NewPlayerModel::players() const {
  return players_;
}
inline ::google::protobuf::RepeatedPtrField< ::fantasybit::PlayerMeta >*
NewPlayerModel::mutable_players() {
  return &players_;
}

// -------------------------------------------------------------------

// WsReq

// optional int32 version = 1;
inline bool WsReq::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WsReq::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WsReq::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WsReq::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 WsReq::version() const {
  return version_;
}
inline void WsReq::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
}

// optional .fantasybit.CType ctype = 2;
inline bool WsReq::has_ctype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WsReq::set_has_ctype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WsReq::clear_has_ctype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WsReq::clear_ctype() {
  ctype_ = 0;
  clear_has_ctype();
}
inline ::fantasybit::CType WsReq::ctype() const {
  return static_cast< ::fantasybit::CType >(ctype_);
}
inline void WsReq::set_ctype(::fantasybit::CType value) {
  assert(::fantasybit::CType_IsValid(value));
  set_has_ctype();
  ctype_ = value;
}

// -------------------------------------------------------------------

// WSReply

// optional int32 version = 1;
inline bool WSReply::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WSReply::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WSReply::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WSReply::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 WSReply::version() const {
  return version_;
}
inline void WSReply::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
}

// optional .fantasybit.CType ctype = 2;
inline bool WSReply::has_ctype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WSReply::set_has_ctype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WSReply::clear_has_ctype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WSReply::clear_ctype() {
  ctype_ = 0;
  clear_has_ctype();
}
inline ::fantasybit::CType WSReply::ctype() const {
  return static_cast< ::fantasybit::CType >(ctype_);
}
inline void WSReply::set_ctype(::fantasybit::CType value) {
  assert(::fantasybit::CType_IsValid(value));
  set_has_ctype();
  ctype_ = value;
}

// optional .fantasybit.WsReq req = 20;
inline bool WSReply::has_req() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WSReply::set_has_req() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WSReply::clear_has_req() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WSReply::clear_req() {
  if (req_ != NULL) req_->::fantasybit::WsReq::Clear();
  clear_has_req();
}
inline const ::fantasybit::WsReq& WSReply::req() const {
  return req_ != NULL ? *req_ : *default_instance_->req_;
}
inline ::fantasybit::WsReq* WSReply::mutable_req() {
  set_has_req();
  if (req_ == NULL) req_ = new ::fantasybit::WsReq;
  return req_;
}
inline ::fantasybit::WsReq* WSReply::release_req() {
  clear_has_req();
  ::fantasybit::WsReq* temp = req_;
  req_ = NULL;
  return temp;
}
inline void WSReply::set_allocated_req(::fantasybit::WsReq* req) {
  delete req_;
  req_ = req;
  if (req) {
    set_has_req();
  } else {
    clear_has_req();
  }
}

// optional string data = 30;
inline bool WSReply::has_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WSReply::set_has_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WSReply::clear_has_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WSReply::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& WSReply::data() const {
  return *data_;
}
inline void WSReply::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void WSReply::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void WSReply::set_data(const char* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WSReply::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* WSReply::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WSReply::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GetGlobalStateRep

// optional .fantasybit.GlobalState globalstate = 10;
inline bool GetGlobalStateRep::has_globalstate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetGlobalStateRep::set_has_globalstate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetGlobalStateRep::clear_has_globalstate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetGlobalStateRep::clear_globalstate() {
  if (globalstate_ != NULL) globalstate_->::fantasybit::GlobalState::Clear();
  clear_has_globalstate();
}
inline const ::fantasybit::GlobalState& GetGlobalStateRep::globalstate() const {
  return globalstate_ != NULL ? *globalstate_ : *default_instance_->globalstate_;
}
inline ::fantasybit::GlobalState* GetGlobalStateRep::mutable_globalstate() {
  set_has_globalstate();
  if (globalstate_ == NULL) globalstate_ = new ::fantasybit::GlobalState;
  return globalstate_;
}
inline ::fantasybit::GlobalState* GetGlobalStateRep::release_globalstate() {
  clear_has_globalstate();
  ::fantasybit::GlobalState* temp = globalstate_;
  globalstate_ = NULL;
  return temp;
}
inline void GetGlobalStateRep::set_allocated_globalstate(::fantasybit::GlobalState* globalstate) {
  delete globalstate_;
  globalstate_ = globalstate;
  if (globalstate) {
    set_has_globalstate();
  } else {
    clear_has_globalstate();
  }
}

// -------------------------------------------------------------------

// GetScheduleRep

// optional .fantasybit.ScheduleData scheduledata = 10;
inline bool GetScheduleRep::has_scheduledata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetScheduleRep::set_has_scheduledata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetScheduleRep::clear_has_scheduledata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetScheduleRep::clear_scheduledata() {
  if (scheduledata_ != NULL) scheduledata_->::fantasybit::ScheduleData::Clear();
  clear_has_scheduledata();
}
inline const ::fantasybit::ScheduleData& GetScheduleRep::scheduledata() const {
  return scheduledata_ != NULL ? *scheduledata_ : *default_instance_->scheduledata_;
}
inline ::fantasybit::ScheduleData* GetScheduleRep::mutable_scheduledata() {
  set_has_scheduledata();
  if (scheduledata_ == NULL) scheduledata_ = new ::fantasybit::ScheduleData;
  return scheduledata_;
}
inline ::fantasybit::ScheduleData* GetScheduleRep::release_scheduledata() {
  clear_has_scheduledata();
  ::fantasybit::ScheduleData* temp = scheduledata_;
  scheduledata_ = NULL;
  return temp;
}
inline void GetScheduleRep::set_allocated_scheduledata(::fantasybit::ScheduleData* scheduledata) {
  delete scheduledata_;
  scheduledata_ = scheduledata;
  if (scheduledata) {
    set_has_scheduledata();
  } else {
    clear_has_scheduledata();
  }
}

// -------------------------------------------------------------------

// CheckNameReq

// optional string fantasy_name = 10;
inline bool CheckNameReq::has_fantasy_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckNameReq::set_has_fantasy_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckNameReq::clear_has_fantasy_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckNameReq::clear_fantasy_name() {
  if (fantasy_name_ != &::google::protobuf::internal::kEmptyString) {
    fantasy_name_->clear();
  }
  clear_has_fantasy_name();
}
inline const ::std::string& CheckNameReq::fantasy_name() const {
  return *fantasy_name_;
}
inline void CheckNameReq::set_fantasy_name(const ::std::string& value) {
  set_has_fantasy_name();
  if (fantasy_name_ == &::google::protobuf::internal::kEmptyString) {
    fantasy_name_ = new ::std::string;
  }
  fantasy_name_->assign(value);
}
inline void CheckNameReq::set_fantasy_name(const char* value) {
  set_has_fantasy_name();
  if (fantasy_name_ == &::google::protobuf::internal::kEmptyString) {
    fantasy_name_ = new ::std::string;
  }
  fantasy_name_->assign(value);
}
inline void CheckNameReq::set_fantasy_name(const char* value, size_t size) {
  set_has_fantasy_name();
  if (fantasy_name_ == &::google::protobuf::internal::kEmptyString) {
    fantasy_name_ = new ::std::string;
  }
  fantasy_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CheckNameReq::mutable_fantasy_name() {
  set_has_fantasy_name();
  if (fantasy_name_ == &::google::protobuf::internal::kEmptyString) {
    fantasy_name_ = new ::std::string;
  }
  return fantasy_name_;
}
inline ::std::string* CheckNameReq::release_fantasy_name() {
  clear_has_fantasy_name();
  if (fantasy_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fantasy_name_;
    fantasy_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CheckNameReq::set_allocated_fantasy_name(::std::string* fantasy_name) {
  if (fantasy_name_ != &::google::protobuf::internal::kEmptyString) {
    delete fantasy_name_;
  }
  if (fantasy_name) {
    set_has_fantasy_name();
    fantasy_name_ = fantasy_name;
  } else {
    clear_has_fantasy_name();
    fantasy_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CheckNameRep

// optional string isavail = 10;
inline bool CheckNameRep::has_isavail() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckNameRep::set_has_isavail() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckNameRep::clear_has_isavail() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckNameRep::clear_isavail() {
  if (isavail_ != &::google::protobuf::internal::kEmptyString) {
    isavail_->clear();
  }
  clear_has_isavail();
}
inline const ::std::string& CheckNameRep::isavail() const {
  return *isavail_;
}
inline void CheckNameRep::set_isavail(const ::std::string& value) {
  set_has_isavail();
  if (isavail_ == &::google::protobuf::internal::kEmptyString) {
    isavail_ = new ::std::string;
  }
  isavail_->assign(value);
}
inline void CheckNameRep::set_isavail(const char* value) {
  set_has_isavail();
  if (isavail_ == &::google::protobuf::internal::kEmptyString) {
    isavail_ = new ::std::string;
  }
  isavail_->assign(value);
}
inline void CheckNameRep::set_isavail(const char* value, size_t size) {
  set_has_isavail();
  if (isavail_ == &::google::protobuf::internal::kEmptyString) {
    isavail_ = new ::std::string;
  }
  isavail_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CheckNameRep::mutable_isavail() {
  set_has_isavail();
  if (isavail_ == &::google::protobuf::internal::kEmptyString) {
    isavail_ = new ::std::string;
  }
  return isavail_;
}
inline ::std::string* CheckNameRep::release_isavail() {
  clear_has_isavail();
  if (isavail_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = isavail_;
    isavail_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CheckNameRep::set_allocated_isavail(::std::string* isavail) {
  if (isavail_ != &::google::protobuf::internal::kEmptyString) {
    delete isavail_;
  }
  if (isavail) {
    set_has_isavail();
    isavail_ = isavail;
  } else {
    clear_has_isavail();
    isavail_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .fantasybit.CheckNameReq req = 20;
inline bool CheckNameRep::has_req() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CheckNameRep::set_has_req() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CheckNameRep::clear_has_req() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CheckNameRep::clear_req() {
  if (req_ != NULL) req_->::fantasybit::CheckNameReq::Clear();
  clear_has_req();
}
inline const ::fantasybit::CheckNameReq& CheckNameRep::req() const {
  return req_ != NULL ? *req_ : *default_instance_->req_;
}
inline ::fantasybit::CheckNameReq* CheckNameRep::mutable_req() {
  set_has_req();
  if (req_ == NULL) req_ = new ::fantasybit::CheckNameReq;
  return req_;
}
inline ::fantasybit::CheckNameReq* CheckNameRep::release_req() {
  clear_has_req();
  ::fantasybit::CheckNameReq* temp = req_;
  req_ = NULL;
  return temp;
}
inline void CheckNameRep::set_allocated_req(::fantasybit::CheckNameReq* req) {
  delete req_;
  req_ = req;
  if (req) {
    set_has_req();
  } else {
    clear_has_req();
  }
}

// -------------------------------------------------------------------

// Pk2FnameReq

// optional string pk = 10;
inline bool Pk2FnameReq::has_pk() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Pk2FnameReq::set_has_pk() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Pk2FnameReq::clear_has_pk() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Pk2FnameReq::clear_pk() {
  if (pk_ != &::google::protobuf::internal::kEmptyString) {
    pk_->clear();
  }
  clear_has_pk();
}
inline const ::std::string& Pk2FnameReq::pk() const {
  return *pk_;
}
inline void Pk2FnameReq::set_pk(const ::std::string& value) {
  set_has_pk();
  if (pk_ == &::google::protobuf::internal::kEmptyString) {
    pk_ = new ::std::string;
  }
  pk_->assign(value);
}
inline void Pk2FnameReq::set_pk(const char* value) {
  set_has_pk();
  if (pk_ == &::google::protobuf::internal::kEmptyString) {
    pk_ = new ::std::string;
  }
  pk_->assign(value);
}
inline void Pk2FnameReq::set_pk(const char* value, size_t size) {
  set_has_pk();
  if (pk_ == &::google::protobuf::internal::kEmptyString) {
    pk_ = new ::std::string;
  }
  pk_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Pk2FnameReq::mutable_pk() {
  set_has_pk();
  if (pk_ == &::google::protobuf::internal::kEmptyString) {
    pk_ = new ::std::string;
  }
  return pk_;
}
inline ::std::string* Pk2FnameReq::release_pk() {
  clear_has_pk();
  if (pk_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pk_;
    pk_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Pk2FnameReq::set_allocated_pk(::std::string* pk) {
  if (pk_ != &::google::protobuf::internal::kEmptyString) {
    delete pk_;
  }
  if (pk) {
    set_has_pk();
    pk_ = pk;
  } else {
    clear_has_pk();
    pk_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Pk2FnameRep

// optional string fname = 10;
inline bool Pk2FnameRep::has_fname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Pk2FnameRep::set_has_fname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Pk2FnameRep::clear_has_fname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Pk2FnameRep::clear_fname() {
  if (fname_ != &::google::protobuf::internal::kEmptyString) {
    fname_->clear();
  }
  clear_has_fname();
}
inline const ::std::string& Pk2FnameRep::fname() const {
  return *fname_;
}
inline void Pk2FnameRep::set_fname(const ::std::string& value) {
  set_has_fname();
  if (fname_ == &::google::protobuf::internal::kEmptyString) {
    fname_ = new ::std::string;
  }
  fname_->assign(value);
}
inline void Pk2FnameRep::set_fname(const char* value) {
  set_has_fname();
  if (fname_ == &::google::protobuf::internal::kEmptyString) {
    fname_ = new ::std::string;
  }
  fname_->assign(value);
}
inline void Pk2FnameRep::set_fname(const char* value, size_t size) {
  set_has_fname();
  if (fname_ == &::google::protobuf::internal::kEmptyString) {
    fname_ = new ::std::string;
  }
  fname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Pk2FnameRep::mutable_fname() {
  set_has_fname();
  if (fname_ == &::google::protobuf::internal::kEmptyString) {
    fname_ = new ::std::string;
  }
  return fname_;
}
inline ::std::string* Pk2FnameRep::release_fname() {
  clear_has_fname();
  if (fname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fname_;
    fname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Pk2FnameRep::set_allocated_fname(::std::string* fname) {
  if (fname_ != &::google::protobuf::internal::kEmptyString) {
    delete fname_;
  }
  if (fname) {
    set_has_fname();
    fname_ = fname;
  } else {
    clear_has_fname();
    fname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .fantasybit.Pk2FnameReq req = 20;
inline bool Pk2FnameRep::has_req() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Pk2FnameRep::set_has_req() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Pk2FnameRep::clear_has_req() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Pk2FnameRep::clear_req() {
  if (req_ != NULL) req_->::fantasybit::Pk2FnameReq::Clear();
  clear_has_req();
}
inline const ::fantasybit::Pk2FnameReq& Pk2FnameRep::req() const {
  return req_ != NULL ? *req_ : *default_instance_->req_;
}
inline ::fantasybit::Pk2FnameReq* Pk2FnameRep::mutable_req() {
  set_has_req();
  if (req_ == NULL) req_ = new ::fantasybit::Pk2FnameReq;
  return req_;
}
inline ::fantasybit::Pk2FnameReq* Pk2FnameRep::release_req() {
  clear_has_req();
  ::fantasybit::Pk2FnameReq* temp = req_;
  req_ = NULL;
  return temp;
}
inline void Pk2FnameRep::set_allocated_req(::fantasybit::Pk2FnameReq* req) {
  delete req_;
  req_ = req;
  if (req) {
    set_has_req();
  } else {
    clear_has_req();
  }
}

// optional .fantasybit.FantasyNameBal fnb = 30;
inline bool Pk2FnameRep::has_fnb() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Pk2FnameRep::set_has_fnb() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Pk2FnameRep::clear_has_fnb() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Pk2FnameRep::clear_fnb() {
  if (fnb_ != NULL) fnb_->::fantasybit::FantasyNameBal::Clear();
  clear_has_fnb();
}
inline const ::fantasybit::FantasyNameBal& Pk2FnameRep::fnb() const {
  return fnb_ != NULL ? *fnb_ : *default_instance_->fnb_;
}
inline ::fantasybit::FantasyNameBal* Pk2FnameRep::mutable_fnb() {
  set_has_fnb();
  if (fnb_ == NULL) fnb_ = new ::fantasybit::FantasyNameBal;
  return fnb_;
}
inline ::fantasybit::FantasyNameBal* Pk2FnameRep::release_fnb() {
  clear_has_fnb();
  ::fantasybit::FantasyNameBal* temp = fnb_;
  fnb_ = NULL;
  return temp;
}
inline void Pk2FnameRep::set_allocated_fnb(::fantasybit::FantasyNameBal* fnb) {
  delete fnb_;
  fnb_ = fnb;
  if (fnb) {
    set_has_fnb();
  } else {
    clear_has_fnb();
  }
}

// -------------------------------------------------------------------

// SubscribeReq

// optional string name = 10;
inline bool SubscribeReq::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubscribeReq::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubscribeReq::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubscribeReq::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& SubscribeReq::name() const {
  return *name_;
}
inline void SubscribeReq::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SubscribeReq::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SubscribeReq::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SubscribeReq::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* SubscribeReq::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SubscribeReq::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 fchash = 30;
inline bool SubscribeReq::has_fchash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SubscribeReq::set_has_fchash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SubscribeReq::clear_has_fchash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SubscribeReq::clear_fchash() {
  fchash_ = GOOGLE_ULONGLONG(0);
  clear_has_fchash();
}
inline ::google::protobuf::uint64 SubscribeReq::fchash() const {
  return fchash_;
}
inline void SubscribeReq::set_fchash(::google::protobuf::uint64 value) {
  set_has_fchash();
  fchash_ = value;
}

// -------------------------------------------------------------------

// NameStatusReq

// optional string name = 10;
inline bool NameStatusReq::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NameStatusReq::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NameStatusReq::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NameStatusReq::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& NameStatusReq::name() const {
  return *name_;
}
inline void NameStatusReq::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NameStatusReq::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NameStatusReq::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NameStatusReq::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* NameStatusReq::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NameStatusReq::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string pk = 20;
inline bool NameStatusReq::has_pk() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NameStatusReq::set_has_pk() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NameStatusReq::clear_has_pk() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NameStatusReq::clear_pk() {
  if (pk_ != &::google::protobuf::internal::kEmptyString) {
    pk_->clear();
  }
  clear_has_pk();
}
inline const ::std::string& NameStatusReq::pk() const {
  return *pk_;
}
inline void NameStatusReq::set_pk(const ::std::string& value) {
  set_has_pk();
  if (pk_ == &::google::protobuf::internal::kEmptyString) {
    pk_ = new ::std::string;
  }
  pk_->assign(value);
}
inline void NameStatusReq::set_pk(const char* value) {
  set_has_pk();
  if (pk_ == &::google::protobuf::internal::kEmptyString) {
    pk_ = new ::std::string;
  }
  pk_->assign(value);
}
inline void NameStatusReq::set_pk(const char* value, size_t size) {
  set_has_pk();
  if (pk_ == &::google::protobuf::internal::kEmptyString) {
    pk_ = new ::std::string;
  }
  pk_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NameStatusReq::mutable_pk() {
  set_has_pk();
  if (pk_ == &::google::protobuf::internal::kEmptyString) {
    pk_ = new ::std::string;
  }
  return pk_;
}
inline ::std::string* NameStatusReq::release_pk() {
  clear_has_pk();
  if (pk_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pk_;
    pk_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NameStatusReq::set_allocated_pk(::std::string* pk) {
  if (pk_ != &::google::protobuf::internal::kEmptyString) {
    delete pk_;
  }
  if (pk) {
    set_has_pk();
    pk_ = pk;
  } else {
    clear_has_pk();
    pk_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// NameStatusRep

// optional .fantasybit.MyNameStatus status = 10;
inline bool NameStatusRep::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NameStatusRep::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NameStatusRep::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NameStatusRep::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::fantasybit::MyNameStatus NameStatusRep::status() const {
  return static_cast< ::fantasybit::MyNameStatus >(status_);
}
inline void NameStatusRep::set_status(::fantasybit::MyNameStatus value) {
  assert(::fantasybit::MyNameStatus_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional .fantasybit.NameStatusReq req = 20;
inline bool NameStatusRep::has_req() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NameStatusRep::set_has_req() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NameStatusRep::clear_has_req() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NameStatusRep::clear_req() {
  if (req_ != NULL) req_->::fantasybit::NameStatusReq::Clear();
  clear_has_req();
}
inline const ::fantasybit::NameStatusReq& NameStatusRep::req() const {
  return req_ != NULL ? *req_ : *default_instance_->req_;
}
inline ::fantasybit::NameStatusReq* NameStatusRep::mutable_req() {
  set_has_req();
  if (req_ == NULL) req_ = new ::fantasybit::NameStatusReq;
  return req_;
}
inline ::fantasybit::NameStatusReq* NameStatusRep::release_req() {
  clear_has_req();
  ::fantasybit::NameStatusReq* temp = req_;
  req_ = NULL;
  return temp;
}
inline void NameStatusRep::set_allocated_req(::fantasybit::NameStatusReq* req) {
  delete req_;
  req_ = req;
  if (req) {
    set_has_req();
  } else {
    clear_has_req();
  }
}

// -------------------------------------------------------------------

// GetAllNamesRep

// repeated string names = 10;
inline int GetAllNamesRep::names_size() const {
  return names_.size();
}
inline void GetAllNamesRep::clear_names() {
  names_.Clear();
}
inline const ::std::string& GetAllNamesRep::names(int index) const {
  return names_.Get(index);
}
inline ::std::string* GetAllNamesRep::mutable_names(int index) {
  return names_.Mutable(index);
}
inline void GetAllNamesRep::set_names(int index, const ::std::string& value) {
  names_.Mutable(index)->assign(value);
}
inline void GetAllNamesRep::set_names(int index, const char* value) {
  names_.Mutable(index)->assign(value);
}
inline void GetAllNamesRep::set_names(int index, const char* value, size_t size) {
  names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetAllNamesRep::add_names() {
  return names_.Add();
}
inline void GetAllNamesRep::add_names(const ::std::string& value) {
  names_.Add()->assign(value);
}
inline void GetAllNamesRep::add_names(const char* value) {
  names_.Add()->assign(value);
}
inline void GetAllNamesRep::add_names(const char* value, size_t size) {
  names_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetAllNamesRep::names() const {
  return names_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetAllNamesRep::mutable_names() {
  return &names_;
}

// repeated .fantasybit.FantasyNameBal fnb = 20;
inline int GetAllNamesRep::fnb_size() const {
  return fnb_.size();
}
inline void GetAllNamesRep::clear_fnb() {
  fnb_.Clear();
}
inline const ::fantasybit::FantasyNameBal& GetAllNamesRep::fnb(int index) const {
  return fnb_.Get(index);
}
inline ::fantasybit::FantasyNameBal* GetAllNamesRep::mutable_fnb(int index) {
  return fnb_.Mutable(index);
}
inline ::fantasybit::FantasyNameBal* GetAllNamesRep::add_fnb() {
  return fnb_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::FantasyNameBal >&
GetAllNamesRep::fnb() const {
  return fnb_;
}
inline ::google::protobuf::RepeatedPtrField< ::fantasybit::FantasyNameBal >*
GetAllNamesRep::mutable_fnb() {
  return &fnb_;
}

// -------------------------------------------------------------------

// TeamRoster

// optional string teamid = 10;
inline bool TeamRoster::has_teamid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TeamRoster::set_has_teamid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TeamRoster::clear_has_teamid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TeamRoster::clear_teamid() {
  if (teamid_ != &::google::protobuf::internal::kEmptyString) {
    teamid_->clear();
  }
  clear_has_teamid();
}
inline const ::std::string& TeamRoster::teamid() const {
  return *teamid_;
}
inline void TeamRoster::set_teamid(const ::std::string& value) {
  set_has_teamid();
  if (teamid_ == &::google::protobuf::internal::kEmptyString) {
    teamid_ = new ::std::string;
  }
  teamid_->assign(value);
}
inline void TeamRoster::set_teamid(const char* value) {
  set_has_teamid();
  if (teamid_ == &::google::protobuf::internal::kEmptyString) {
    teamid_ = new ::std::string;
  }
  teamid_->assign(value);
}
inline void TeamRoster::set_teamid(const char* value, size_t size) {
  set_has_teamid();
  if (teamid_ == &::google::protobuf::internal::kEmptyString) {
    teamid_ = new ::std::string;
  }
  teamid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TeamRoster::mutable_teamid() {
  set_has_teamid();
  if (teamid_ == &::google::protobuf::internal::kEmptyString) {
    teamid_ = new ::std::string;
  }
  return teamid_;
}
inline ::std::string* TeamRoster::release_teamid() {
  clear_has_teamid();
  if (teamid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = teamid_;
    teamid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TeamRoster::set_allocated_teamid(::std::string* teamid) {
  if (teamid_ != &::google::protobuf::internal::kEmptyString) {
    delete teamid_;
  }
  if (teamid) {
    set_has_teamid();
    teamid_ = teamid;
  } else {
    clear_has_teamid();
    teamid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .fantasybit.PlayerData players = 20;
inline int TeamRoster::players_size() const {
  return players_.size();
}
inline void TeamRoster::clear_players() {
  players_.Clear();
}
inline const ::fantasybit::PlayerData& TeamRoster::players(int index) const {
  return players_.Get(index);
}
inline ::fantasybit::PlayerData* TeamRoster::mutable_players(int index) {
  return players_.Mutable(index);
}
inline ::fantasybit::PlayerData* TeamRoster::add_players() {
  return players_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::PlayerData >&
TeamRoster::players() const {
  return players_;
}
inline ::google::protobuf::RepeatedPtrField< ::fantasybit::PlayerData >*
TeamRoster::mutable_players() {
  return &players_;
}

// -------------------------------------------------------------------

// GameDataRoster

// optional .fantasybit.GameData game_data = 10;
inline bool GameDataRoster::has_game_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameDataRoster::set_has_game_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameDataRoster::clear_has_game_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameDataRoster::clear_game_data() {
  if (game_data_ != NULL) game_data_->::fantasybit::GameData::Clear();
  clear_has_game_data();
}
inline const ::fantasybit::GameData& GameDataRoster::game_data() const {
  return game_data_ != NULL ? *game_data_ : *default_instance_->game_data_;
}
inline ::fantasybit::GameData* GameDataRoster::mutable_game_data() {
  set_has_game_data();
  if (game_data_ == NULL) game_data_ = new ::fantasybit::GameData;
  return game_data_;
}
inline ::fantasybit::GameData* GameDataRoster::release_game_data() {
  clear_has_game_data();
  ::fantasybit::GameData* temp = game_data_;
  game_data_ = NULL;
  return temp;
}
inline void GameDataRoster::set_allocated_game_data(::fantasybit::GameData* game_data) {
  delete game_data_;
  game_data_ = game_data;
  if (game_data) {
    set_has_game_data();
  } else {
    clear_has_game_data();
  }
}

// optional .fantasybit.TeamRoster homeroster = 20;
inline bool GameDataRoster::has_homeroster() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameDataRoster::set_has_homeroster() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameDataRoster::clear_has_homeroster() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameDataRoster::clear_homeroster() {
  if (homeroster_ != NULL) homeroster_->::fantasybit::TeamRoster::Clear();
  clear_has_homeroster();
}
inline const ::fantasybit::TeamRoster& GameDataRoster::homeroster() const {
  return homeroster_ != NULL ? *homeroster_ : *default_instance_->homeroster_;
}
inline ::fantasybit::TeamRoster* GameDataRoster::mutable_homeroster() {
  set_has_homeroster();
  if (homeroster_ == NULL) homeroster_ = new ::fantasybit::TeamRoster;
  return homeroster_;
}
inline ::fantasybit::TeamRoster* GameDataRoster::release_homeroster() {
  clear_has_homeroster();
  ::fantasybit::TeamRoster* temp = homeroster_;
  homeroster_ = NULL;
  return temp;
}
inline void GameDataRoster::set_allocated_homeroster(::fantasybit::TeamRoster* homeroster) {
  delete homeroster_;
  homeroster_ = homeroster;
  if (homeroster) {
    set_has_homeroster();
  } else {
    clear_has_homeroster();
  }
}

// optional .fantasybit.TeamRoster awayroster = 30;
inline bool GameDataRoster::has_awayroster() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameDataRoster::set_has_awayroster() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameDataRoster::clear_has_awayroster() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameDataRoster::clear_awayroster() {
  if (awayroster_ != NULL) awayroster_->::fantasybit::TeamRoster::Clear();
  clear_has_awayroster();
}
inline const ::fantasybit::TeamRoster& GameDataRoster::awayroster() const {
  return awayroster_ != NULL ? *awayroster_ : *default_instance_->awayroster_;
}
inline ::fantasybit::TeamRoster* GameDataRoster::mutable_awayroster() {
  set_has_awayroster();
  if (awayroster_ == NULL) awayroster_ = new ::fantasybit::TeamRoster;
  return awayroster_;
}
inline ::fantasybit::TeamRoster* GameDataRoster::release_awayroster() {
  clear_has_awayroster();
  ::fantasybit::TeamRoster* temp = awayroster_;
  awayroster_ = NULL;
  return temp;
}
inline void GameDataRoster::set_allocated_awayroster(::fantasybit::TeamRoster* awayroster) {
  delete awayroster_;
  awayroster_ = awayroster;
  if (awayroster) {
    set_has_awayroster();
  } else {
    clear_has_awayroster();
  }
}

// -------------------------------------------------------------------

// GetCurrRostersRep

// optional int32 week = 10;
inline bool GetCurrRostersRep::has_week() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetCurrRostersRep::set_has_week() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetCurrRostersRep::clear_has_week() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetCurrRostersRep::clear_week() {
  week_ = 0;
  clear_has_week();
}
inline ::google::protobuf::int32 GetCurrRostersRep::week() const {
  return week_;
}
inline void GetCurrRostersRep::set_week(::google::protobuf::int32 value) {
  set_has_week();
  week_ = value;
}

// repeated .fantasybit.GameDataRoster gamerosters = 20;
inline int GetCurrRostersRep::gamerosters_size() const {
  return gamerosters_.size();
}
inline void GetCurrRostersRep::clear_gamerosters() {
  gamerosters_.Clear();
}
inline const ::fantasybit::GameDataRoster& GetCurrRostersRep::gamerosters(int index) const {
  return gamerosters_.Get(index);
}
inline ::fantasybit::GameDataRoster* GetCurrRostersRep::mutable_gamerosters(int index) {
  return gamerosters_.Mutable(index);
}
inline ::fantasybit::GameDataRoster* GetCurrRostersRep::add_gamerosters() {
  return gamerosters_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::GameDataRoster >&
GetCurrRostersRep::gamerosters() const {
  return gamerosters_;
}
inline ::google::protobuf::RepeatedPtrField< ::fantasybit::GameDataRoster >*
GetCurrRostersRep::mutable_gamerosters() {
  return &gamerosters_;
}

// -------------------------------------------------------------------

// ROWMarket

// optional string pid = 10;
inline bool ROWMarket::has_pid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ROWMarket::set_has_pid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ROWMarket::clear_has_pid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ROWMarket::clear_pid() {
  if (pid_ != &::google::protobuf::internal::kEmptyString) {
    pid_->clear();
  }
  clear_has_pid();
}
inline const ::std::string& ROWMarket::pid() const {
  return *pid_;
}
inline void ROWMarket::set_pid(const ::std::string& value) {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  pid_->assign(value);
}
inline void ROWMarket::set_pid(const char* value) {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  pid_->assign(value);
}
inline void ROWMarket::set_pid(const char* value, size_t size) {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  pid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ROWMarket::mutable_pid() {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  return pid_;
}
inline ::std::string* ROWMarket::release_pid() {
  clear_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pid_;
    pid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ROWMarket::set_allocated_pid(::std::string* pid) {
  if (pid_ != &::google::protobuf::internal::kEmptyString) {
    delete pid_;
  }
  if (pid) {
    set_has_pid();
    pid_ = pid;
  } else {
    clear_has_pid();
    pid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .fantasybit.MarketQuote quote = 30;
inline bool ROWMarket::has_quote() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ROWMarket::set_has_quote() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ROWMarket::clear_has_quote() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ROWMarket::clear_quote() {
  if (quote_ != NULL) quote_->::fantasybit::MarketQuote::Clear();
  clear_has_quote();
}
inline const ::fantasybit::MarketQuote& ROWMarket::quote() const {
  return quote_ != NULL ? *quote_ : *default_instance_->quote_;
}
inline ::fantasybit::MarketQuote* ROWMarket::mutable_quote() {
  set_has_quote();
  if (quote_ == NULL) quote_ = new ::fantasybit::MarketQuote;
  return quote_;
}
inline ::fantasybit::MarketQuote* ROWMarket::release_quote() {
  clear_has_quote();
  ::fantasybit::MarketQuote* temp = quote_;
  quote_ = NULL;
  return temp;
}
inline void ROWMarket::set_allocated_quote(::fantasybit::MarketQuote* quote) {
  delete quote_;
  quote_ = quote;
  if (quote) {
    set_has_quote();
  } else {
    clear_has_quote();
  }
}

// optional .fantasybit.PlayerData playerdata = 40;
inline bool ROWMarket::has_playerdata() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ROWMarket::set_has_playerdata() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ROWMarket::clear_has_playerdata() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ROWMarket::clear_playerdata() {
  if (playerdata_ != NULL) playerdata_->::fantasybit::PlayerData::Clear();
  clear_has_playerdata();
}
inline const ::fantasybit::PlayerData& ROWMarket::playerdata() const {
  return playerdata_ != NULL ? *playerdata_ : *default_instance_->playerdata_;
}
inline ::fantasybit::PlayerData* ROWMarket::mutable_playerdata() {
  set_has_playerdata();
  if (playerdata_ == NULL) playerdata_ = new ::fantasybit::PlayerData;
  return playerdata_;
}
inline ::fantasybit::PlayerData* ROWMarket::release_playerdata() {
  clear_has_playerdata();
  ::fantasybit::PlayerData* temp = playerdata_;
  playerdata_ = NULL;
  return temp;
}
inline void ROWMarket::set_allocated_playerdata(::fantasybit::PlayerData* playerdata) {
  delete playerdata_;
  playerdata_ = playerdata;
  if (playerdata) {
    set_has_playerdata();
  } else {
    clear_has_playerdata();
  }
}

// optional .fantasybit.ContractOHLC ohlc = 50;
inline bool ROWMarket::has_ohlc() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ROWMarket::set_has_ohlc() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ROWMarket::clear_has_ohlc() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ROWMarket::clear_ohlc() {
  if (ohlc_ != NULL) ohlc_->::fantasybit::ContractOHLC::Clear();
  clear_has_ohlc();
}
inline const ::fantasybit::ContractOHLC& ROWMarket::ohlc() const {
  return ohlc_ != NULL ? *ohlc_ : *default_instance_->ohlc_;
}
inline ::fantasybit::ContractOHLC* ROWMarket::mutable_ohlc() {
  set_has_ohlc();
  if (ohlc_ == NULL) ohlc_ = new ::fantasybit::ContractOHLC;
  return ohlc_;
}
inline ::fantasybit::ContractOHLC* ROWMarket::release_ohlc() {
  clear_has_ohlc();
  ::fantasybit::ContractOHLC* temp = ohlc_;
  ohlc_ = NULL;
  return temp;
}
inline void ROWMarket::set_allocated_ohlc(::fantasybit::ContractOHLC* ohlc) {
  delete ohlc_;
  ohlc_ = ohlc;
  if (ohlc) {
    set_has_ohlc();
  } else {
    clear_has_ohlc();
  }
}

// -------------------------------------------------------------------

// GetROWMarketRep

// repeated .fantasybit.ROWMarket rowmarket = 10;
inline int GetROWMarketRep::rowmarket_size() const {
  return rowmarket_.size();
}
inline void GetROWMarketRep::clear_rowmarket() {
  rowmarket_.Clear();
}
inline const ::fantasybit::ROWMarket& GetROWMarketRep::rowmarket(int index) const {
  return rowmarket_.Get(index);
}
inline ::fantasybit::ROWMarket* GetROWMarketRep::mutable_rowmarket(int index) {
  return rowmarket_.Mutable(index);
}
inline ::fantasybit::ROWMarket* GetROWMarketRep::add_rowmarket() {
  return rowmarket_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::ROWMarket >&
GetROWMarketRep::rowmarket() const {
  return rowmarket_;
}
inline ::google::protobuf::RepeatedPtrField< ::fantasybit::ROWMarket >*
GetROWMarketRep::mutable_rowmarket() {
  return &rowmarket_;
}

// -------------------------------------------------------------------

// GetDepthReq

// optional string pid = 10;
inline bool GetDepthReq::has_pid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetDepthReq::set_has_pid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetDepthReq::clear_has_pid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetDepthReq::clear_pid() {
  if (pid_ != &::google::protobuf::internal::kEmptyString) {
    pid_->clear();
  }
  clear_has_pid();
}
inline const ::std::string& GetDepthReq::pid() const {
  return *pid_;
}
inline void GetDepthReq::set_pid(const ::std::string& value) {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  pid_->assign(value);
}
inline void GetDepthReq::set_pid(const char* value) {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  pid_->assign(value);
}
inline void GetDepthReq::set_pid(const char* value, size_t size) {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  pid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetDepthReq::mutable_pid() {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  return pid_;
}
inline ::std::string* GetDepthReq::release_pid() {
  clear_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pid_;
    pid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetDepthReq::set_allocated_pid(::std::string* pid) {
  if (pid_ != &::google::protobuf::internal::kEmptyString) {
    delete pid_;
  }
  if (pid) {
    set_has_pid();
    pid_ = pid;
  } else {
    clear_has_pid();
    pid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GetDepthRep

// optional string pid = 10;
inline bool GetDepthRep::has_pid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetDepthRep::set_has_pid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetDepthRep::clear_has_pid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetDepthRep::clear_pid() {
  if (pid_ != &::google::protobuf::internal::kEmptyString) {
    pid_->clear();
  }
  clear_has_pid();
}
inline const ::std::string& GetDepthRep::pid() const {
  return *pid_;
}
inline void GetDepthRep::set_pid(const ::std::string& value) {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  pid_->assign(value);
}
inline void GetDepthRep::set_pid(const char* value) {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  pid_->assign(value);
}
inline void GetDepthRep::set_pid(const char* value, size_t size) {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  pid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetDepthRep::mutable_pid() {
  set_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    pid_ = new ::std::string;
  }
  return pid_;
}
inline ::std::string* GetDepthRep::release_pid() {
  clear_has_pid();
  if (pid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pid_;
    pid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetDepthRep::set_allocated_pid(::std::string* pid) {
  if (pid_ != &::google::protobuf::internal::kEmptyString) {
    delete pid_;
  }
  if (pid) {
    set_has_pid();
    pid_ = pid;
  } else {
    clear_has_pid();
    pid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .fantasybit.DepthItem depthitems = 20;
inline int GetDepthRep::depthitems_size() const {
  return depthitems_.size();
}
inline void GetDepthRep::clear_depthitems() {
  depthitems_.Clear();
}
inline const ::fantasybit::DepthItem& GetDepthRep::depthitems(int index) const {
  return depthitems_.Get(index);
}
inline ::fantasybit::DepthItem* GetDepthRep::mutable_depthitems(int index) {
  return depthitems_.Mutable(index);
}
inline ::fantasybit::DepthItem* GetDepthRep::add_depthitems() {
  return depthitems_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::DepthItem >&
GetDepthRep::depthitems() const {
  return depthitems_;
}
inline ::google::protobuf::RepeatedPtrField< ::fantasybit::DepthItem >*
GetDepthRep::mutable_depthitems() {
  return &depthitems_;
}

// optional .fantasybit.ROWMarket rowmarket = 30;
inline bool GetDepthRep::has_rowmarket() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetDepthRep::set_has_rowmarket() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetDepthRep::clear_has_rowmarket() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetDepthRep::clear_rowmarket() {
  if (rowmarket_ != NULL) rowmarket_->::fantasybit::ROWMarket::Clear();
  clear_has_rowmarket();
}
inline const ::fantasybit::ROWMarket& GetDepthRep::rowmarket() const {
  return rowmarket_ != NULL ? *rowmarket_ : *default_instance_->rowmarket_;
}
inline ::fantasybit::ROWMarket* GetDepthRep::mutable_rowmarket() {
  set_has_rowmarket();
  if (rowmarket_ == NULL) rowmarket_ = new ::fantasybit::ROWMarket;
  return rowmarket_;
}
inline ::fantasybit::ROWMarket* GetDepthRep::release_rowmarket() {
  clear_has_rowmarket();
  ::fantasybit::ROWMarket* temp = rowmarket_;
  rowmarket_ = NULL;
  return temp;
}
inline void GetDepthRep::set_allocated_rowmarket(::fantasybit::ROWMarket* rowmarket) {
  delete rowmarket_;
  rowmarket_ = rowmarket;
  if (rowmarket) {
    set_has_rowmarket();
  } else {
    clear_has_rowmarket();
  }
}

// -------------------------------------------------------------------

// AllOdersSymbol

// optional string symbol = 10;
inline bool AllOdersSymbol::has_symbol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AllOdersSymbol::set_has_symbol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AllOdersSymbol::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AllOdersSymbol::clear_symbol() {
  if (symbol_ != &::google::protobuf::internal::kEmptyString) {
    symbol_->clear();
  }
  clear_has_symbol();
}
inline const ::std::string& AllOdersSymbol::symbol() const {
  return *symbol_;
}
inline void AllOdersSymbol::set_symbol(const ::std::string& value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void AllOdersSymbol::set_symbol(const char* value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void AllOdersSymbol::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AllOdersSymbol::mutable_symbol() {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  return symbol_;
}
inline ::std::string* AllOdersSymbol::release_symbol() {
  clear_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = symbol_;
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AllOdersSymbol::set_allocated_symbol(::std::string* symbol) {
  if (symbol_ != &::google::protobuf::internal::kEmptyString) {
    delete symbol_;
  }
  if (symbol) {
    set_has_symbol();
    symbol_ = symbol;
  } else {
    clear_has_symbol();
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 netqty = 30;
inline bool AllOdersSymbol::has_netqty() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AllOdersSymbol::set_has_netqty() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AllOdersSymbol::clear_has_netqty() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AllOdersSymbol::clear_netqty() {
  netqty_ = 0;
  clear_has_netqty();
}
inline ::google::protobuf::int32 AllOdersSymbol::netqty() const {
  return netqty_;
}
inline void AllOdersSymbol::set_netqty(::google::protobuf::int32 value) {
  set_has_netqty();
  netqty_ = value;
}

// optional int32 netprice = 40;
inline bool AllOdersSymbol::has_netprice() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AllOdersSymbol::set_has_netprice() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AllOdersSymbol::clear_has_netprice() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AllOdersSymbol::clear_netprice() {
  netprice_ = 0;
  clear_has_netprice();
}
inline ::google::protobuf::int32 AllOdersSymbol::netprice() const {
  return netprice_;
}
inline void AllOdersSymbol::set_netprice(::google::protobuf::int32 value) {
  set_has_netprice();
  netprice_ = value;
}

// optional double avg = 50;
inline bool AllOdersSymbol::has_avg() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AllOdersSymbol::set_has_avg() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AllOdersSymbol::clear_has_avg() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AllOdersSymbol::clear_avg() {
  avg_ = 0;
  clear_has_avg();
}
inline double AllOdersSymbol::avg() const {
  return avg_;
}
inline void AllOdersSymbol::set_avg(double value) {
  set_has_avg();
  avg_ = value;
}

// optional double pnl = 60;
inline bool AllOdersSymbol::has_pnl() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AllOdersSymbol::set_has_pnl() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AllOdersSymbol::clear_has_pnl() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AllOdersSymbol::clear_pnl() {
  pnl_ = 0;
  clear_has_pnl();
}
inline double AllOdersSymbol::pnl() const {
  return pnl_;
}
inline void AllOdersSymbol::set_pnl(double value) {
  set_has_pnl();
  pnl_ = value;
}

// repeated .fantasybit.Order orders = 20;
inline int AllOdersSymbol::orders_size() const {
  return orders_.size();
}
inline void AllOdersSymbol::clear_orders() {
  orders_.Clear();
}
inline const ::fantasybit::Order& AllOdersSymbol::orders(int index) const {
  return orders_.Get(index);
}
inline ::fantasybit::Order* AllOdersSymbol::mutable_orders(int index) {
  return orders_.Mutable(index);
}
inline ::fantasybit::Order* AllOdersSymbol::add_orders() {
  return orders_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::Order >&
AllOdersSymbol::orders() const {
  return orders_;
}
inline ::google::protobuf::RepeatedPtrField< ::fantasybit::Order >*
AllOdersSymbol::mutable_orders() {
  return &orders_;
}

// -------------------------------------------------------------------

// AllOdersFname

// optional string fname = 10;
inline bool AllOdersFname::has_fname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AllOdersFname::set_has_fname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AllOdersFname::clear_has_fname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AllOdersFname::clear_fname() {
  if (fname_ != &::google::protobuf::internal::kEmptyString) {
    fname_->clear();
  }
  clear_has_fname();
}
inline const ::std::string& AllOdersFname::fname() const {
  return *fname_;
}
inline void AllOdersFname::set_fname(const ::std::string& value) {
  set_has_fname();
  if (fname_ == &::google::protobuf::internal::kEmptyString) {
    fname_ = new ::std::string;
  }
  fname_->assign(value);
}
inline void AllOdersFname::set_fname(const char* value) {
  set_has_fname();
  if (fname_ == &::google::protobuf::internal::kEmptyString) {
    fname_ = new ::std::string;
  }
  fname_->assign(value);
}
inline void AllOdersFname::set_fname(const char* value, size_t size) {
  set_has_fname();
  if (fname_ == &::google::protobuf::internal::kEmptyString) {
    fname_ = new ::std::string;
  }
  fname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AllOdersFname::mutable_fname() {
  set_has_fname();
  if (fname_ == &::google::protobuf::internal::kEmptyString) {
    fname_ = new ::std::string;
  }
  return fname_;
}
inline ::std::string* AllOdersFname::release_fname() {
  clear_has_fname();
  if (fname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fname_;
    fname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AllOdersFname::set_allocated_fname(::std::string* fname) {
  if (fname_ != &::google::protobuf::internal::kEmptyString) {
    delete fname_;
  }
  if (fname) {
    set_has_fname();
    fname_ = fname;
  } else {
    clear_has_fname();
    fname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .fantasybit.AllOdersSymbol pidorders = 20;
inline int AllOdersFname::pidorders_size() const {
  return pidorders_.size();
}
inline void AllOdersFname::clear_pidorders() {
  pidorders_.Clear();
}
inline const ::fantasybit::AllOdersSymbol& AllOdersFname::pidorders(int index) const {
  return pidorders_.Get(index);
}
inline ::fantasybit::AllOdersSymbol* AllOdersFname::mutable_pidorders(int index) {
  return pidorders_.Mutable(index);
}
inline ::fantasybit::AllOdersSymbol* AllOdersFname::add_pidorders() {
  return pidorders_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::AllOdersSymbol >&
AllOdersFname::pidorders() const {
  return pidorders_;
}
inline ::google::protobuf::RepeatedPtrField< ::fantasybit::AllOdersSymbol >*
AllOdersFname::mutable_pidorders() {
  return &pidorders_;
}

// -------------------------------------------------------------------

// GetOrdersRep

// optional .fantasybit.GetOrdersReq req = 10;
inline bool GetOrdersRep::has_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetOrdersRep::set_has_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetOrdersRep::clear_has_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetOrdersRep::clear_req() {
  if (req_ != NULL) req_->::fantasybit::GetOrdersReq::Clear();
  clear_has_req();
}
inline const ::fantasybit::GetOrdersReq& GetOrdersRep::req() const {
  return req_ != NULL ? *req_ : *default_instance_->req_;
}
inline ::fantasybit::GetOrdersReq* GetOrdersRep::mutable_req() {
  set_has_req();
  if (req_ == NULL) req_ = new ::fantasybit::GetOrdersReq;
  return req_;
}
inline ::fantasybit::GetOrdersReq* GetOrdersRep::release_req() {
  clear_has_req();
  ::fantasybit::GetOrdersReq* temp = req_;
  req_ = NULL;
  return temp;
}
inline void GetOrdersRep::set_allocated_req(::fantasybit::GetOrdersReq* req) {
  delete req_;
  req_ = req;
  if (req) {
    set_has_req();
  } else {
    clear_has_req();
  }
}

// optional .fantasybit.AllOdersFname oorders = 20;
inline bool GetOrdersRep::has_oorders() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetOrdersRep::set_has_oorders() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetOrdersRep::clear_has_oorders() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetOrdersRep::clear_oorders() {
  if (oorders_ != NULL) oorders_->::fantasybit::AllOdersFname::Clear();
  clear_has_oorders();
}
inline const ::fantasybit::AllOdersFname& GetOrdersRep::oorders() const {
  return oorders_ != NULL ? *oorders_ : *default_instance_->oorders_;
}
inline ::fantasybit::AllOdersFname* GetOrdersRep::mutable_oorders() {
  set_has_oorders();
  if (oorders_ == NULL) oorders_ = new ::fantasybit::AllOdersFname;
  return oorders_;
}
inline ::fantasybit::AllOdersFname* GetOrdersRep::release_oorders() {
  clear_has_oorders();
  ::fantasybit::AllOdersFname* temp = oorders_;
  oorders_ = NULL;
  return temp;
}
inline void GetOrdersRep::set_allocated_oorders(::fantasybit::AllOdersFname* oorders) {
  delete oorders_;
  oorders_ = oorders;
  if (oorders) {
    set_has_oorders();
  } else {
    clear_has_oorders();
  }
}

// -------------------------------------------------------------------

// GetOrdersReq

// optional string symbol = 10;
inline bool GetOrdersReq::has_symbol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetOrdersReq::set_has_symbol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetOrdersReq::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetOrdersReq::clear_symbol() {
  if (symbol_ != &::google::protobuf::internal::kEmptyString) {
    symbol_->clear();
  }
  clear_has_symbol();
}
inline const ::std::string& GetOrdersReq::symbol() const {
  return *symbol_;
}
inline void GetOrdersReq::set_symbol(const ::std::string& value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void GetOrdersReq::set_symbol(const char* value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void GetOrdersReq::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetOrdersReq::mutable_symbol() {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  return symbol_;
}
inline ::std::string* GetOrdersReq::release_symbol() {
  clear_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = symbol_;
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetOrdersReq::set_allocated_symbol(::std::string* symbol) {
  if (symbol_ != &::google::protobuf::internal::kEmptyString) {
    delete symbol_;
  }
  if (symbol) {
    set_has_symbol();
    symbol_ = symbol;
  } else {
    clear_has_symbol();
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string fname = 20;
inline bool GetOrdersReq::has_fname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetOrdersReq::set_has_fname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetOrdersReq::clear_has_fname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetOrdersReq::clear_fname() {
  if (fname_ != &::google::protobuf::internal::kEmptyString) {
    fname_->clear();
  }
  clear_has_fname();
}
inline const ::std::string& GetOrdersReq::fname() const {
  return *fname_;
}
inline void GetOrdersReq::set_fname(const ::std::string& value) {
  set_has_fname();
  if (fname_ == &::google::protobuf::internal::kEmptyString) {
    fname_ = new ::std::string;
  }
  fname_->assign(value);
}
inline void GetOrdersReq::set_fname(const char* value) {
  set_has_fname();
  if (fname_ == &::google::protobuf::internal::kEmptyString) {
    fname_ = new ::std::string;
  }
  fname_->assign(value);
}
inline void GetOrdersReq::set_fname(const char* value, size_t size) {
  set_has_fname();
  if (fname_ == &::google::protobuf::internal::kEmptyString) {
    fname_ = new ::std::string;
  }
  fname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetOrdersReq::mutable_fname() {
  set_has_fname();
  if (fname_ == &::google::protobuf::internal::kEmptyString) {
    fname_ = new ::std::string;
  }
  return fname_;
}
inline ::std::string* GetOrdersReq::release_fname() {
  clear_has_fname();
  if (fname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fname_;
    fname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetOrdersReq::set_allocated_fname(::std::string* fname) {
  if (fname_ != &::google::protobuf::internal::kEmptyString) {
    delete fname_;
  }
  if (fname) {
    set_has_fname();
    fname_ = fname;
  } else {
    clear_has_fname();
    fname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 fchash = 30;
inline bool GetOrdersReq::has_fchash() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetOrdersReq::set_has_fchash() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetOrdersReq::clear_has_fchash() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetOrdersReq::clear_fchash() {
  fchash_ = GOOGLE_ULONGLONG(0);
  clear_has_fchash();
}
inline ::google::protobuf::uint64 GetOrdersReq::fchash() const {
  return fchash_;
}
inline void GetOrdersReq::set_fchash(::google::protobuf::uint64 value) {
  set_has_fchash();
  fchash_ = value;
}

// -------------------------------------------------------------------

// GetProjectionReq

// optional string fname = 20;
inline bool GetProjectionReq::has_fname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetProjectionReq::set_has_fname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetProjectionReq::clear_has_fname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetProjectionReq::clear_fname() {
  if (fname_ != &::google::protobuf::internal::kEmptyString) {
    fname_->clear();
  }
  clear_has_fname();
}
inline const ::std::string& GetProjectionReq::fname() const {
  return *fname_;
}
inline void GetProjectionReq::set_fname(const ::std::string& value) {
  set_has_fname();
  if (fname_ == &::google::protobuf::internal::kEmptyString) {
    fname_ = new ::std::string;
  }
  fname_->assign(value);
}
inline void GetProjectionReq::set_fname(const char* value) {
  set_has_fname();
  if (fname_ == &::google::protobuf::internal::kEmptyString) {
    fname_ = new ::std::string;
  }
  fname_->assign(value);
}
inline void GetProjectionReq::set_fname(const char* value, size_t size) {
  set_has_fname();
  if (fname_ == &::google::protobuf::internal::kEmptyString) {
    fname_ = new ::std::string;
  }
  fname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetProjectionReq::mutable_fname() {
  set_has_fname();
  if (fname_ == &::google::protobuf::internal::kEmptyString) {
    fname_ = new ::std::string;
  }
  return fname_;
}
inline ::std::string* GetProjectionReq::release_fname() {
  clear_has_fname();
  if (fname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fname_;
    fname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GetProjectionReq::set_allocated_fname(::std::string* fname) {
  if (fname_ != &::google::protobuf::internal::kEmptyString) {
    delete fname_;
  }
  if (fname) {
    set_has_fname();
    fname_ = fname;
  } else {
    clear_has_fname();
    fname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool getavg = 30;
inline bool GetProjectionReq::has_getavg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetProjectionReq::set_has_getavg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetProjectionReq::clear_has_getavg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetProjectionReq::clear_getavg() {
  getavg_ = false;
  clear_has_getavg();
}
inline bool GetProjectionReq::getavg() const {
  return getavg_;
}
inline void GetProjectionReq::set_getavg(bool value) {
  set_has_getavg();
  getavg_ = value;
}

// -------------------------------------------------------------------

// PlayerProj

// optional string playerid = 10;
inline bool PlayerProj::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerProj::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerProj::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerProj::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& PlayerProj::playerid() const {
  return *playerid_;
}
inline void PlayerProj::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void PlayerProj::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void PlayerProj::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerProj::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* PlayerProj::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerProj::set_allocated_playerid(::std::string* playerid) {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    delete playerid_;
  }
  if (playerid) {
    set_has_playerid();
    playerid_ = playerid;
  } else {
    clear_has_playerid();
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 proj = 20;
inline bool PlayerProj::has_proj() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerProj::set_has_proj() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerProj::clear_has_proj() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerProj::clear_proj() {
  proj_ = 0;
  clear_has_proj();
}
inline ::google::protobuf::int32 PlayerProj::proj() const {
  return proj_;
}
inline void PlayerProj::set_proj(::google::protobuf::int32 value) {
  set_has_proj();
  proj_ = value;
}

// -------------------------------------------------------------------

// ProjByName

// optional string name = 10;
inline bool ProjByName::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProjByName::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProjByName::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProjByName::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ProjByName::name() const {
  return *name_;
}
inline void ProjByName::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ProjByName::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ProjByName::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProjByName::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ProjByName::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProjByName::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .fantasybit.PlayerProj playerproj = 20;
inline int ProjByName::playerproj_size() const {
  return playerproj_.size();
}
inline void ProjByName::clear_playerproj() {
  playerproj_.Clear();
}
inline const ::fantasybit::PlayerProj& ProjByName::playerproj(int index) const {
  return playerproj_.Get(index);
}
inline ::fantasybit::PlayerProj* ProjByName::mutable_playerproj(int index) {
  return playerproj_.Mutable(index);
}
inline ::fantasybit::PlayerProj* ProjByName::add_playerproj() {
  return playerproj_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::PlayerProj >&
ProjByName::playerproj() const {
  return playerproj_;
}
inline ::google::protobuf::RepeatedPtrField< ::fantasybit::PlayerProj >*
ProjByName::mutable_playerproj() {
  return &playerproj_;
}

// optional int32 count = 40;
inline bool ProjByName::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProjByName::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProjByName::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProjByName::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 ProjByName::count() const {
  return count_;
}
inline void ProjByName::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// optional int32 block = 50;
inline bool ProjByName::has_block() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProjByName::set_has_block() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProjByName::clear_has_block() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProjByName::clear_block() {
  block_ = 0;
  clear_has_block();
}
inline ::google::protobuf::int32 ProjByName::block() const {
  return block_;
}
inline void ProjByName::set_block(::google::protobuf::int32 value) {
  set_has_block();
  block_ = value;
}

// -------------------------------------------------------------------

// GetProjectionRep

// optional .fantasybit.ProjByName projs = 20;
inline bool GetProjectionRep::has_projs() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetProjectionRep::set_has_projs() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetProjectionRep::clear_has_projs() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetProjectionRep::clear_projs() {
  if (projs_ != NULL) projs_->::fantasybit::ProjByName::Clear();
  clear_has_projs();
}
inline const ::fantasybit::ProjByName& GetProjectionRep::projs() const {
  return projs_ != NULL ? *projs_ : *default_instance_->projs_;
}
inline ::fantasybit::ProjByName* GetProjectionRep::mutable_projs() {
  set_has_projs();
  if (projs_ == NULL) projs_ = new ::fantasybit::ProjByName;
  return projs_;
}
inline ::fantasybit::ProjByName* GetProjectionRep::release_projs() {
  clear_has_projs();
  ::fantasybit::ProjByName* temp = projs_;
  projs_ = NULL;
  return temp;
}
inline void GetProjectionRep::set_allocated_projs(::fantasybit::ProjByName* projs) {
  delete projs_;
  projs_ = projs;
  if (projs) {
    set_has_projs();
  } else {
    clear_has_projs();
  }
}

// optional .fantasybit.ProjByName avg = 30;
inline bool GetProjectionRep::has_avg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetProjectionRep::set_has_avg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetProjectionRep::clear_has_avg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetProjectionRep::clear_avg() {
  if (avg_ != NULL) avg_->::fantasybit::ProjByName::Clear();
  clear_has_avg();
}
inline const ::fantasybit::ProjByName& GetProjectionRep::avg() const {
  return avg_ != NULL ? *avg_ : *default_instance_->avg_;
}
inline ::fantasybit::ProjByName* GetProjectionRep::mutable_avg() {
  set_has_avg();
  if (avg_ == NULL) avg_ = new ::fantasybit::ProjByName;
  return avg_;
}
inline ::fantasybit::ProjByName* GetProjectionRep::release_avg() {
  clear_has_avg();
  ::fantasybit::ProjByName* temp = avg_;
  avg_ = NULL;
  return temp;
}
inline void GetProjectionRep::set_allocated_avg(::fantasybit::ProjByName* avg) {
  delete avg_;
  avg_ = avg;
  if (avg) {
    set_has_avg();
  } else {
    clear_has_avg();
  }
}

// -------------------------------------------------------------------

// KeyValue

// optional bytes key = 10;
inline bool KeyValue::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeyValue::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeyValue::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeyValue::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& KeyValue::key() const {
  return *key_;
}
inline void KeyValue::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void KeyValue::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void KeyValue::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeyValue::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* KeyValue::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void KeyValue::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes value = 20;
inline bool KeyValue::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KeyValue::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KeyValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KeyValue::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& KeyValue::value() const {
  return *value_;
}
inline void KeyValue::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void KeyValue::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void KeyValue::set_value(const void* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeyValue::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* KeyValue::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void KeyValue::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Bootstrap

// optional string key = 1;
inline bool Bootstrap::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Bootstrap::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Bootstrap::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Bootstrap::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& Bootstrap::key() const {
  return *key_;
}
inline void Bootstrap::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Bootstrap::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Bootstrap::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Bootstrap::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* Bootstrap::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Bootstrap::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 blocknum = 2;
inline bool Bootstrap::has_blocknum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Bootstrap::set_has_blocknum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Bootstrap::clear_has_blocknum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Bootstrap::clear_blocknum() {
  blocknum_ = 0;
  clear_has_blocknum();
}
inline ::google::protobuf::int32 Bootstrap::blocknum() const {
  return blocknum_;
}
inline void Bootstrap::set_blocknum(::google::protobuf::int32 value) {
  set_has_blocknum();
  blocknum_ = value;
}

// optional int32 week = 3;
inline bool Bootstrap::has_week() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Bootstrap::set_has_week() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Bootstrap::clear_has_week() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Bootstrap::clear_week() {
  week_ = 0;
  clear_has_week();
}
inline ::google::protobuf::int32 Bootstrap::week() const {
  return week_;
}
inline void Bootstrap::set_week(::google::protobuf::int32 value) {
  set_has_week();
  week_ = value;
}

// optional int32 season = 4;
inline bool Bootstrap::has_season() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Bootstrap::set_has_season() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Bootstrap::clear_has_season() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Bootstrap::clear_season() {
  season_ = 0;
  clear_has_season();
}
inline ::google::protobuf::int32 Bootstrap::season() const {
  return season_;
}
inline void Bootstrap::set_season(::google::protobuf::int32 value) {
  set_has_season();
  season_ = value;
}

// optional bytes gamemetaroot = 10;
inline bool Bootstrap::has_gamemetaroot() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Bootstrap::set_has_gamemetaroot() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Bootstrap::clear_has_gamemetaroot() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Bootstrap::clear_gamemetaroot() {
  if (gamemetaroot_ != &::google::protobuf::internal::kEmptyString) {
    gamemetaroot_->clear();
  }
  clear_has_gamemetaroot();
}
inline const ::std::string& Bootstrap::gamemetaroot() const {
  return *gamemetaroot_;
}
inline void Bootstrap::set_gamemetaroot(const ::std::string& value) {
  set_has_gamemetaroot();
  if (gamemetaroot_ == &::google::protobuf::internal::kEmptyString) {
    gamemetaroot_ = new ::std::string;
  }
  gamemetaroot_->assign(value);
}
inline void Bootstrap::set_gamemetaroot(const char* value) {
  set_has_gamemetaroot();
  if (gamemetaroot_ == &::google::protobuf::internal::kEmptyString) {
    gamemetaroot_ = new ::std::string;
  }
  gamemetaroot_->assign(value);
}
inline void Bootstrap::set_gamemetaroot(const void* value, size_t size) {
  set_has_gamemetaroot();
  if (gamemetaroot_ == &::google::protobuf::internal::kEmptyString) {
    gamemetaroot_ = new ::std::string;
  }
  gamemetaroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Bootstrap::mutable_gamemetaroot() {
  set_has_gamemetaroot();
  if (gamemetaroot_ == &::google::protobuf::internal::kEmptyString) {
    gamemetaroot_ = new ::std::string;
  }
  return gamemetaroot_;
}
inline ::std::string* Bootstrap::release_gamemetaroot() {
  clear_has_gamemetaroot();
  if (gamemetaroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gamemetaroot_;
    gamemetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Bootstrap::set_allocated_gamemetaroot(::std::string* gamemetaroot) {
  if (gamemetaroot_ != &::google::protobuf::internal::kEmptyString) {
    delete gamemetaroot_;
  }
  if (gamemetaroot) {
    set_has_gamemetaroot();
    gamemetaroot_ = gamemetaroot;
  } else {
    clear_has_gamemetaroot();
    gamemetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes playermetaroot = 20;
inline bool Bootstrap::has_playermetaroot() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Bootstrap::set_has_playermetaroot() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Bootstrap::clear_has_playermetaroot() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Bootstrap::clear_playermetaroot() {
  if (playermetaroot_ != &::google::protobuf::internal::kEmptyString) {
    playermetaroot_->clear();
  }
  clear_has_playermetaroot();
}
inline const ::std::string& Bootstrap::playermetaroot() const {
  return *playermetaroot_;
}
inline void Bootstrap::set_playermetaroot(const ::std::string& value) {
  set_has_playermetaroot();
  if (playermetaroot_ == &::google::protobuf::internal::kEmptyString) {
    playermetaroot_ = new ::std::string;
  }
  playermetaroot_->assign(value);
}
inline void Bootstrap::set_playermetaroot(const char* value) {
  set_has_playermetaroot();
  if (playermetaroot_ == &::google::protobuf::internal::kEmptyString) {
    playermetaroot_ = new ::std::string;
  }
  playermetaroot_->assign(value);
}
inline void Bootstrap::set_playermetaroot(const void* value, size_t size) {
  set_has_playermetaroot();
  if (playermetaroot_ == &::google::protobuf::internal::kEmptyString) {
    playermetaroot_ = new ::std::string;
  }
  playermetaroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Bootstrap::mutable_playermetaroot() {
  set_has_playermetaroot();
  if (playermetaroot_ == &::google::protobuf::internal::kEmptyString) {
    playermetaroot_ = new ::std::string;
  }
  return playermetaroot_;
}
inline ::std::string* Bootstrap::release_playermetaroot() {
  clear_has_playermetaroot();
  if (playermetaroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playermetaroot_;
    playermetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Bootstrap::set_allocated_playermetaroot(::std::string* playermetaroot) {
  if (playermetaroot_ != &::google::protobuf::internal::kEmptyString) {
    delete playermetaroot_;
  }
  if (playermetaroot) {
    set_has_playermetaroot();
    playermetaroot_ = playermetaroot;
  } else {
    clear_has_playermetaroot();
    playermetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes fnamemetaroot = 30;
inline bool Bootstrap::has_fnamemetaroot() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Bootstrap::set_has_fnamemetaroot() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Bootstrap::clear_has_fnamemetaroot() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Bootstrap::clear_fnamemetaroot() {
  if (fnamemetaroot_ != &::google::protobuf::internal::kEmptyString) {
    fnamemetaroot_->clear();
  }
  clear_has_fnamemetaroot();
}
inline const ::std::string& Bootstrap::fnamemetaroot() const {
  return *fnamemetaroot_;
}
inline void Bootstrap::set_fnamemetaroot(const ::std::string& value) {
  set_has_fnamemetaroot();
  if (fnamemetaroot_ == &::google::protobuf::internal::kEmptyString) {
    fnamemetaroot_ = new ::std::string;
  }
  fnamemetaroot_->assign(value);
}
inline void Bootstrap::set_fnamemetaroot(const char* value) {
  set_has_fnamemetaroot();
  if (fnamemetaroot_ == &::google::protobuf::internal::kEmptyString) {
    fnamemetaroot_ = new ::std::string;
  }
  fnamemetaroot_->assign(value);
}
inline void Bootstrap::set_fnamemetaroot(const void* value, size_t size) {
  set_has_fnamemetaroot();
  if (fnamemetaroot_ == &::google::protobuf::internal::kEmptyString) {
    fnamemetaroot_ = new ::std::string;
  }
  fnamemetaroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Bootstrap::mutable_fnamemetaroot() {
  set_has_fnamemetaroot();
  if (fnamemetaroot_ == &::google::protobuf::internal::kEmptyString) {
    fnamemetaroot_ = new ::std::string;
  }
  return fnamemetaroot_;
}
inline ::std::string* Bootstrap::release_fnamemetaroot() {
  clear_has_fnamemetaroot();
  if (fnamemetaroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fnamemetaroot_;
    fnamemetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Bootstrap::set_allocated_fnamemetaroot(::std::string* fnamemetaroot) {
  if (fnamemetaroot_ != &::google::protobuf::internal::kEmptyString) {
    delete fnamemetaroot_;
  }
  if (fnamemetaroot) {
    set_has_fnamemetaroot();
    fnamemetaroot_ = fnamemetaroot;
  } else {
    clear_has_fnamemetaroot();
    fnamemetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes previd = 40;
inline bool Bootstrap::has_previd() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Bootstrap::set_has_previd() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Bootstrap::clear_has_previd() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Bootstrap::clear_previd() {
  if (previd_ != &::google::protobuf::internal::kEmptyString) {
    previd_->clear();
  }
  clear_has_previd();
}
inline const ::std::string& Bootstrap::previd() const {
  return *previd_;
}
inline void Bootstrap::set_previd(const ::std::string& value) {
  set_has_previd();
  if (previd_ == &::google::protobuf::internal::kEmptyString) {
    previd_ = new ::std::string;
  }
  previd_->assign(value);
}
inline void Bootstrap::set_previd(const char* value) {
  set_has_previd();
  if (previd_ == &::google::protobuf::internal::kEmptyString) {
    previd_ = new ::std::string;
  }
  previd_->assign(value);
}
inline void Bootstrap::set_previd(const void* value, size_t size) {
  set_has_previd();
  if (previd_ == &::google::protobuf::internal::kEmptyString) {
    previd_ = new ::std::string;
  }
  previd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Bootstrap::mutable_previd() {
  set_has_previd();
  if (previd_ == &::google::protobuf::internal::kEmptyString) {
    previd_ = new ::std::string;
  }
  return previd_;
}
inline ::std::string* Bootstrap::release_previd() {
  clear_has_previd();
  if (previd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = previd_;
    previd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Bootstrap::set_allocated_previd(::std::string* previd) {
  if (previd_ != &::google::protobuf::internal::kEmptyString) {
    delete previd_;
  }
  if (previd) {
    set_has_previd();
    previd_ = previd;
  } else {
    clear_has_previd();
    previd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes gameresultroot = 50;
inline bool Bootstrap::has_gameresultroot() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Bootstrap::set_has_gameresultroot() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Bootstrap::clear_has_gameresultroot() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Bootstrap::clear_gameresultroot() {
  if (gameresultroot_ != &::google::protobuf::internal::kEmptyString) {
    gameresultroot_->clear();
  }
  clear_has_gameresultroot();
}
inline const ::std::string& Bootstrap::gameresultroot() const {
  return *gameresultroot_;
}
inline void Bootstrap::set_gameresultroot(const ::std::string& value) {
  set_has_gameresultroot();
  if (gameresultroot_ == &::google::protobuf::internal::kEmptyString) {
    gameresultroot_ = new ::std::string;
  }
  gameresultroot_->assign(value);
}
inline void Bootstrap::set_gameresultroot(const char* value) {
  set_has_gameresultroot();
  if (gameresultroot_ == &::google::protobuf::internal::kEmptyString) {
    gameresultroot_ = new ::std::string;
  }
  gameresultroot_->assign(value);
}
inline void Bootstrap::set_gameresultroot(const void* value, size_t size) {
  set_has_gameresultroot();
  if (gameresultroot_ == &::google::protobuf::internal::kEmptyString) {
    gameresultroot_ = new ::std::string;
  }
  gameresultroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Bootstrap::mutable_gameresultroot() {
  set_has_gameresultroot();
  if (gameresultroot_ == &::google::protobuf::internal::kEmptyString) {
    gameresultroot_ = new ::std::string;
  }
  return gameresultroot_;
}
inline ::std::string* Bootstrap::release_gameresultroot() {
  clear_has_gameresultroot();
  if (gameresultroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gameresultroot_;
    gameresultroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Bootstrap::set_allocated_gameresultroot(::std::string* gameresultroot) {
  if (gameresultroot_ != &::google::protobuf::internal::kEmptyString) {
    delete gameresultroot_;
  }
  if (gameresultroot) {
    set_has_gameresultroot();
    gameresultroot_ = gameresultroot;
  } else {
    clear_has_gameresultroot();
    gameresultroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes posmetaroot = 60;
inline bool Bootstrap::has_posmetaroot() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Bootstrap::set_has_posmetaroot() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Bootstrap::clear_has_posmetaroot() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Bootstrap::clear_posmetaroot() {
  if (posmetaroot_ != &::google::protobuf::internal::kEmptyString) {
    posmetaroot_->clear();
  }
  clear_has_posmetaroot();
}
inline const ::std::string& Bootstrap::posmetaroot() const {
  return *posmetaroot_;
}
inline void Bootstrap::set_posmetaroot(const ::std::string& value) {
  set_has_posmetaroot();
  if (posmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    posmetaroot_ = new ::std::string;
  }
  posmetaroot_->assign(value);
}
inline void Bootstrap::set_posmetaroot(const char* value) {
  set_has_posmetaroot();
  if (posmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    posmetaroot_ = new ::std::string;
  }
  posmetaroot_->assign(value);
}
inline void Bootstrap::set_posmetaroot(const void* value, size_t size) {
  set_has_posmetaroot();
  if (posmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    posmetaroot_ = new ::std::string;
  }
  posmetaroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Bootstrap::mutable_posmetaroot() {
  set_has_posmetaroot();
  if (posmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    posmetaroot_ = new ::std::string;
  }
  return posmetaroot_;
}
inline ::std::string* Bootstrap::release_posmetaroot() {
  clear_has_posmetaroot();
  if (posmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = posmetaroot_;
    posmetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Bootstrap::set_allocated_posmetaroot(::std::string* posmetaroot) {
  if (posmetaroot_ != &::google::protobuf::internal::kEmptyString) {
    delete posmetaroot_;
  }
  if (posmetaroot) {
    set_has_posmetaroot();
    posmetaroot_ = posmetaroot;
  } else {
    clear_has_posmetaroot();
    posmetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace fantasybit

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fantasybit::CType>() {
  return ::fantasybit::CType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_StateData_2eproto__INCLUDED
