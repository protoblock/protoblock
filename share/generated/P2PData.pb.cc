// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: P2PData.proto

#include "P2PData.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_P2PData_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ChainHead_P2PData_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_P2PData_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_MsgAlive_P2PData_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_P2PData_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_MsgHello_P2PData_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_P2PData_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_MsgIntro_P2PData_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_P2PData_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Peer_P2PData_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_P2PData_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_PeerChainStatus_P2PData_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_P2PData_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SessionId_P2PData_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_P2PData_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_WirePeer_P2PData_2eproto;
namespace fantasybit {
class PeerDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Peer> _instance;
} _Peer_default_instance_;
class SessionIdDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<SessionId> _instance;
} _SessionId_default_instance_;
class WirePeerDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<WirePeer> _instance;
} _WirePeer_default_instance_;
class MsgIntroDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<MsgIntro> _instance;
} _MsgIntro_default_instance_;
class ChainHeadDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ChainHead> _instance;
} _ChainHead_default_instance_;
class PeerChainStatusDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<PeerChainStatus> _instance;
} _PeerChainStatus_default_instance_;
class MsgAliveDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<MsgAlive> _instance;
} _MsgAlive_default_instance_;
class MsgHelloDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<MsgHello> _instance;
} _MsgHello_default_instance_;
class WireMsgDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<WireMsg> _instance;
} _WireMsg_default_instance_;
}  // namespace fantasybit
static void InitDefaultsscc_info_ChainHead_P2PData_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::fantasybit::_ChainHead_default_instance_;
    new (ptr) ::fantasybit::ChainHead();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::fantasybit::ChainHead::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ChainHead_P2PData_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_ChainHead_P2PData_2eproto}, {}};

static void InitDefaultsscc_info_MsgAlive_P2PData_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::fantasybit::_MsgAlive_default_instance_;
    new (ptr) ::fantasybit::MsgAlive();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::fantasybit::MsgAlive::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_MsgAlive_P2PData_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_MsgAlive_P2PData_2eproto}, {
      &scc_info_PeerChainStatus_P2PData_2eproto.base,}};

static void InitDefaultsscc_info_MsgHello_P2PData_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::fantasybit::_MsgHello_default_instance_;
    new (ptr) ::fantasybit::MsgHello();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::fantasybit::MsgHello::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_MsgHello_P2PData_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_MsgHello_P2PData_2eproto}, {
      &scc_info_MsgIntro_P2PData_2eproto.base,
      &scc_info_WirePeer_P2PData_2eproto.base,}};

static void InitDefaultsscc_info_MsgIntro_P2PData_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::fantasybit::_MsgIntro_default_instance_;
    new (ptr) ::fantasybit::MsgIntro();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::fantasybit::MsgIntro::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_MsgIntro_P2PData_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_MsgIntro_P2PData_2eproto}, {
      &scc_info_WirePeer_P2PData_2eproto.base,
      &scc_info_Peer_P2PData_2eproto.base,}};

static void InitDefaultsscc_info_Peer_P2PData_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::fantasybit::_Peer_default_instance_;
    new (ptr) ::fantasybit::Peer();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::fantasybit::Peer::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Peer_P2PData_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_Peer_P2PData_2eproto}, {}};

static void InitDefaultsscc_info_PeerChainStatus_P2PData_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::fantasybit::_PeerChainStatus_default_instance_;
    new (ptr) ::fantasybit::PeerChainStatus();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::fantasybit::PeerChainStatus::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_PeerChainStatus_P2PData_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_PeerChainStatus_P2PData_2eproto}, {
      &scc_info_ChainHead_P2PData_2eproto.base,}};

static void InitDefaultsscc_info_SessionId_P2PData_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::fantasybit::_SessionId_default_instance_;
    new (ptr) ::fantasybit::SessionId();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::fantasybit::SessionId::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SessionId_P2PData_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_SessionId_P2PData_2eproto}, {}};

static void InitDefaultsscc_info_WireMsg_P2PData_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::fantasybit::_WireMsg_default_instance_;
    new (ptr) ::fantasybit::WireMsg();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::fantasybit::WireMsg::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_WireMsg_P2PData_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 3, 0, InitDefaultsscc_info_WireMsg_P2PData_2eproto}, {
      &scc_info_MsgIntro_P2PData_2eproto.base,
      &scc_info_MsgHello_P2PData_2eproto.base,
      &scc_info_MsgAlive_P2PData_2eproto.base,}};

static void InitDefaultsscc_info_WirePeer_P2PData_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::fantasybit::_WirePeer_default_instance_;
    new (ptr) ::fantasybit::WirePeer();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::fantasybit::WirePeer::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_WirePeer_P2PData_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_WirePeer_P2PData_2eproto}, {
      &scc_info_SessionId_P2PData_2eproto.base,
      &scc_info_Peer_P2PData_2eproto.base,}};

static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_P2PData_2eproto[9];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_P2PData_2eproto[4];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_P2PData_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_P2PData_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::fantasybit::Peer, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::fantasybit::Peer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::fantasybit::Peer, address_),
  PROTOBUF_FIELD_OFFSET(::fantasybit::Peer, port_),
  PROTOBUF_FIELD_OFFSET(::fantasybit::Peer, is_listening_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::fantasybit::SessionId, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::fantasybit::SessionId, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::fantasybit::SessionId, network_id_),
  PROTOBUF_FIELD_OFFSET(::fantasybit::SessionId, wire_version_),
  PROTOBUF_FIELD_OFFSET(::fantasybit::SessionId, start_time_),
  PROTOBUF_FIELD_OFFSET(::fantasybit::SessionId, uuid_),
  2,
  3,
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::fantasybit::WirePeer, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::fantasybit::WirePeer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::fantasybit::WirePeer, session_id_),
  PROTOBUF_FIELD_OFFSET(::fantasybit::WirePeer, peer_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::fantasybit::MsgIntro, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::fantasybit::MsgIntro, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::fantasybit::MsgIntro, iam_),
  PROTOBUF_FIELD_OFFSET(::fantasybit::MsgIntro, youare_),
  PROTOBUF_FIELD_OFFSET(::fantasybit::MsgIntro, everyone_),
  0,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::fantasybit::ChainHead, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::fantasybit::ChainHead, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::fantasybit::ChainHead, height_),
  PROTOBUF_FIELD_OFFSET(::fantasybit::ChainHead, weight_),
  PROTOBUF_FIELD_OFFSET(::fantasybit::ChainHead, id_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::fantasybit::PeerChainStatus, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::fantasybit::PeerChainStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::fantasybit::PeerChainStatus, chain_state_),
  PROTOBUF_FIELD_OFFSET(::fantasybit::PeerChainStatus, last_dea_),
  PROTOBUF_FIELD_OFFSET(::fantasybit::PeerChainStatus, last_irreversible_),
  PROTOBUF_FIELD_OFFSET(::fantasybit::PeerChainStatus, mempool_count_),
  PROTOBUF_FIELD_OFFSET(::fantasybit::PeerChainStatus, mempool_size_),
  PROTOBUF_FIELD_OFFSET(::fantasybit::PeerChainStatus, last_block_timestamp_),
  PROTOBUF_FIELD_OFFSET(::fantasybit::PeerChainStatus, last_tx_timestamp_),
  3,
  0,
  1,
  4,
  2,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::fantasybit::MsgAlive, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::fantasybit::MsgAlive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::fantasybit::MsgAlive, peer_status_),
  PROTOBUF_FIELD_OFFSET(::fantasybit::MsgAlive, timestamp_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::fantasybit::MsgHello, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::fantasybit::MsgHello, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::fantasybit::MsgHello, update_),
  PROTOBUF_FIELD_OFFSET(::fantasybit::MsgHello, connections_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::fantasybit::WireMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::fantasybit::WireMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::fantasybit::WireMsg, type_),
  PROTOBUF_FIELD_OFFSET(::fantasybit::WireMsg, intro_),
  PROTOBUF_FIELD_OFFSET(::fantasybit::WireMsg, hello_),
  PROTOBUF_FIELD_OFFSET(::fantasybit::WireMsg, alive_),
  3,
  0,
  1,
  2,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, sizeof(::fantasybit::Peer)},
  { 11, 20, sizeof(::fantasybit::SessionId)},
  { 24, 31, sizeof(::fantasybit::WirePeer)},
  { 33, 41, sizeof(::fantasybit::MsgIntro)},
  { 44, 52, sizeof(::fantasybit::ChainHead)},
  { 55, 67, sizeof(::fantasybit::PeerChainStatus)},
  { 74, 81, sizeof(::fantasybit::MsgAlive)},
  { 83, 90, sizeof(::fantasybit::MsgHello)},
  { 92, 101, sizeof(::fantasybit::WireMsg)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::fantasybit::_Peer_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::fantasybit::_SessionId_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::fantasybit::_WirePeer_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::fantasybit::_MsgIntro_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::fantasybit::_ChainHead_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::fantasybit::_PeerChainStatus_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::fantasybit::_MsgAlive_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::fantasybit::_MsgHello_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::fantasybit::_WireMsg_default_instance_),
};

const char descriptor_table_protodef_P2PData_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\rP2PData.proto\022\nfantasybit\"\243\001\n\004Peer\022\017\n\007"
  "address\030\n \001(\t\022\014\n\004port\030\036 \001(\r\0222\n\014is_listen"
  "ing\030( \001(\0162\034.fantasybit.Peer.IsListening\""
  "H\n\013IsListening\022\r\n\t_dontuse_\020\000\022\013\n\007NOTSURE"
  "\020\001\022\014\n\010ITHINKSO\020\002\022\007\n\003YES\020\003\022\006\n\002NO\020\004\"\250\001\n\tSe"
  "ssionId\0223\n\nnetwork_id\030\001 \001(\0162\037.fantasybit"
  ".SessionId.NetworkID\022\024\n\014wire_version\030\n \001"
  "(\r\022\022\n\nstart_time\030\024 \001(\r\022\014\n\004uuid\030\036 \001(\014\".\n\t"
  "NetworkID\022\r\n\t_dontuse_\020\000\022\010\n\004TEST\020\001\022\010\n\004PR"
  "OD\020\002\"U\n\010WirePeer\022)\n\nsession_id\030\n \001(\0132\025.f"
  "antasybit.SessionId\022\036\n\004peer\030\024 \001(\0132\020.fant"
  "asybit.Peer\"w\n\010MsgIntro\022!\n\003iam\030\n \001(\0132\024.f"
  "antasybit.WirePeer\022$\n\006youare\030\024 \001(\0132\024.fan"
  "tasybit.WirePeer\022\"\n\010everyone\030\036 \003(\0132\020.fan"
  "tasybit.Peer\"7\n\tChainHead\022\016\n\006height\030\n \001("
  "\005\022\016\n\006weight\030\024 \001(\005\022\n\n\002id\030\036 \001(\014\"\230\003\n\017PeerCh"
  "ainStatus\022;\n\013chain_state\030\001 \001(\0162&.fantasy"
  "bit.PeerChainStatus.ChainState\022\'\n\010last_d"
  "ea\030\n \001(\0132\025.fantasybit.ChainHead\0220\n\021last_"
  "irreversible\030\024 \001(\0132\025.fantasybit.ChainHea"
  "d\022\025\n\rmempool_count\030\036 \001(\r\022\024\n\014mempool_size"
  "\030( \001(\r\022\034\n\024last_block_timestamp\0302 \001(\004\022\031\n\021"
  "last_tx_timestamp\030< \001(\004\"\206\001\n\nChainState\022\r"
  "\n\t_dontuse_\020\000\022\014\n\010STARTING\020\002\022\r\n\tSEARCHING"
  "\020\004\022\t\n\005REORG\020\006\022\014\n\010STOPPING\020\010\022\014\n\010ABORTING\020"
  "\n\022\016\n\nCONNECTING\020(\022\013\n\007SYNCING\0202\022\010\n\004LIVE\020<"
  "\"O\n\010MsgAlive\0220\n\013peer_status\030\036 \001(\0132\033.fant"
  "asybit.PeerChainStatus\022\021\n\ttimestamp\030( \001("
  "\004\"[\n\010MsgHello\022$\n\006update\030\n \001(\0132\024.fantasyb"
  "it.MsgIntro\022)\n\013connections\030\024 \003(\0132\024.fanta"
  "sybit.WirePeer\"\233\001\n\007WireMsg\022!\n\004type\030\n \001(\016"
  "2\023.fantasybit.MsgType\022#\n\005intro\030\024 \001(\0132\024.f"
  "antasybit.MsgIntro\022#\n\005hello\030\036 \001(\0132\024.fant"
  "asybit.MsgHello\022#\n\005alive\030( \001(\0132\024.fantasy"
  "bit.MsgAlive*9\n\007MsgType\022\r\n\t_dontuse_\020\000\022\t"
  "\n\005INTRO\020\001\022\t\n\005HELLO\020\002\022\t\n\005ALIVE\020\004"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_P2PData_2eproto_deps[1] = {
};
static ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase*const descriptor_table_P2PData_2eproto_sccs[9] = {
  &scc_info_ChainHead_P2PData_2eproto.base,
  &scc_info_MsgAlive_P2PData_2eproto.base,
  &scc_info_MsgHello_P2PData_2eproto.base,
  &scc_info_MsgIntro_P2PData_2eproto.base,
  &scc_info_Peer_P2PData_2eproto.base,
  &scc_info_PeerChainStatus_P2PData_2eproto.base,
  &scc_info_SessionId_P2PData_2eproto.base,
  &scc_info_WireMsg_P2PData_2eproto.base,
  &scc_info_WirePeer_P2PData_2eproto.base,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_P2PData_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_P2PData_2eproto = {
  false, false, descriptor_table_protodef_P2PData_2eproto, "P2PData.proto", 1431,
  &descriptor_table_P2PData_2eproto_once, descriptor_table_P2PData_2eproto_sccs, descriptor_table_P2PData_2eproto_deps, 9, 0,
  schemas, file_default_instances, TableStruct_P2PData_2eproto::offsets,
  file_level_metadata_P2PData_2eproto, 9, file_level_enum_descriptors_P2PData_2eproto, file_level_service_descriptors_P2PData_2eproto,
};

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_P2PData_2eproto = (static_cast<void>(::PROTOBUF_NAMESPACE_ID::internal::AddDescriptors(&descriptor_table_P2PData_2eproto)), true);
namespace fantasybit {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Peer_IsListening_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_P2PData_2eproto);
  return file_level_enum_descriptors_P2PData_2eproto[0];
}
bool Peer_IsListening_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr Peer_IsListening Peer::_dontuse_;
constexpr Peer_IsListening Peer::NOTSURE;
constexpr Peer_IsListening Peer::ITHINKSO;
constexpr Peer_IsListening Peer::YES;
constexpr Peer_IsListening Peer::NO;
constexpr Peer_IsListening Peer::IsListening_MIN;
constexpr Peer_IsListening Peer::IsListening_MAX;
constexpr int Peer::IsListening_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SessionId_NetworkID_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_P2PData_2eproto);
  return file_level_enum_descriptors_P2PData_2eproto[1];
}
bool SessionId_NetworkID_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr SessionId_NetworkID SessionId::_dontuse_;
constexpr SessionId_NetworkID SessionId::TEST;
constexpr SessionId_NetworkID SessionId::PROD;
constexpr SessionId_NetworkID SessionId::NetworkID_MIN;
constexpr SessionId_NetworkID SessionId::NetworkID_MAX;
constexpr int SessionId::NetworkID_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PeerChainStatus_ChainState_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_P2PData_2eproto);
  return file_level_enum_descriptors_P2PData_2eproto[2];
}
bool PeerChainStatus_ChainState_IsValid(int value) {
  switch (value) {
    case 0:
    case 2:
    case 4:
    case 6:
    case 8:
    case 10:
    case 40:
    case 50:
    case 60:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr PeerChainStatus_ChainState PeerChainStatus::_dontuse_;
constexpr PeerChainStatus_ChainState PeerChainStatus::STARTING;
constexpr PeerChainStatus_ChainState PeerChainStatus::SEARCHING;
constexpr PeerChainStatus_ChainState PeerChainStatus::REORG;
constexpr PeerChainStatus_ChainState PeerChainStatus::STOPPING;
constexpr PeerChainStatus_ChainState PeerChainStatus::ABORTING;
constexpr PeerChainStatus_ChainState PeerChainStatus::CONNECTING;
constexpr PeerChainStatus_ChainState PeerChainStatus::SYNCING;
constexpr PeerChainStatus_ChainState PeerChainStatus::LIVE;
constexpr PeerChainStatus_ChainState PeerChainStatus::ChainState_MIN;
constexpr PeerChainStatus_ChainState PeerChainStatus::ChainState_MAX;
constexpr int PeerChainStatus::ChainState_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MsgType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_P2PData_2eproto);
  return file_level_enum_descriptors_P2PData_2eproto[3];
}
bool MsgType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 4:
      return true;
    default:
      return false;
  }
}


// ===================================================================

void Peer::InitAsDefaultInstance() {
}
class Peer::_Internal {
 public:
  using HasBits = decltype(std::declval<Peer>()._has_bits_);
  static void set_has_address(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_port(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_is_listening(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Peer::Peer(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:fantasybit.Peer)
}
Peer::Peer(const Peer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_address()) {
    address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_address(),
      GetArena());
  }
  ::memcpy(&port_, &from.port_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_listening_) -
    reinterpret_cast<char*>(&port_)) + sizeof(is_listening_));
  // @@protoc_insertion_point(copy_constructor:fantasybit.Peer)
}

void Peer::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Peer_P2PData_2eproto.base);
  address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&port_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&is_listening_) -
      reinterpret_cast<char*>(&port_)) + sizeof(is_listening_));
}

Peer::~Peer() {
  // @@protoc_insertion_point(destructor:fantasybit.Peer)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Peer::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  address_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void Peer::ArenaDtor(void* object) {
  Peer* _this = reinterpret_cast< Peer* >(object);
  (void)_this;
}
void Peer::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Peer::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Peer& Peer::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Peer_P2PData_2eproto.base);
  return *internal_default_instance();
}


void Peer::Clear() {
// @@protoc_insertion_point(message_clear_start:fantasybit.Peer)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    address_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&port_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_listening_) -
        reinterpret_cast<char*>(&port_)) + sizeof(is_listening_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Peer::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string address = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          auto str = _internal_mutable_address();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "fantasybit.Peer.address");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 port = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 240)) {
          _Internal::set_has_port(&has_bits);
          port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .fantasybit.Peer.IsListening is_listening = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::fantasybit::Peer_IsListening_IsValid(val))) {
            _internal_set_is_listening(static_cast<::fantasybit::Peer_IsListening>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(40, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Peer::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:fantasybit.Peer)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string address = 10;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_address().data(), static_cast<int>(this->_internal_address().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "fantasybit.Peer.address");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_address(), target);
  }

  // optional uint32 port = 30;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(30, this->_internal_port(), target);
  }

  // optional .fantasybit.Peer.IsListening is_listening = 40;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      40, this->_internal_is_listening(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:fantasybit.Peer)
  return target;
}

size_t Peer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:fantasybit.Peer)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string address = 10;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_address());
    }

    // optional uint32 port = 30;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_port());
    }

    // optional .fantasybit.Peer.IsListening is_listening = 40;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_is_listening());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Peer::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:fantasybit.Peer)
  GOOGLE_DCHECK_NE(&from, this);
  const Peer* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Peer>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:fantasybit.Peer)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:fantasybit.Peer)
    MergeFrom(*source);
  }
}

void Peer::MergeFrom(const Peer& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:fantasybit.Peer)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_address(from._internal_address());
    }
    if (cached_has_bits & 0x00000002u) {
      port_ = from.port_;
    }
    if (cached_has_bits & 0x00000004u) {
      is_listening_ = from.is_listening_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Peer::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:fantasybit.Peer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Peer::CopyFrom(const Peer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:fantasybit.Peer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Peer::IsInitialized() const {
  return true;
}

void Peer::InternalSwap(Peer* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  address_.Swap(&other->address_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Peer, is_listening_)
      + sizeof(Peer::is_listening_)
      - PROTOBUF_FIELD_OFFSET(Peer, port_)>(
          reinterpret_cast<char*>(&port_),
          reinterpret_cast<char*>(&other->port_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Peer::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void SessionId::InitAsDefaultInstance() {
}
class SessionId::_Internal {
 public:
  using HasBits = decltype(std::declval<SessionId>()._has_bits_);
  static void set_has_network_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_wire_version(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_start_time(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_uuid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

SessionId::SessionId(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:fantasybit.SessionId)
}
SessionId::SessionId(const SessionId& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  uuid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_uuid()) {
    uuid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_uuid(),
      GetArena());
  }
  ::memcpy(&start_time_, &from.start_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&wire_version_) -
    reinterpret_cast<char*>(&start_time_)) + sizeof(wire_version_));
  // @@protoc_insertion_point(copy_constructor:fantasybit.SessionId)
}

void SessionId::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_SessionId_P2PData_2eproto.base);
  uuid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&start_time_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&wire_version_) -
      reinterpret_cast<char*>(&start_time_)) + sizeof(wire_version_));
}

SessionId::~SessionId() {
  // @@protoc_insertion_point(destructor:fantasybit.SessionId)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void SessionId::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  uuid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void SessionId::ArenaDtor(void* object) {
  SessionId* _this = reinterpret_cast< SessionId* >(object);
  (void)_this;
}
void SessionId::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SessionId::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SessionId& SessionId::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_SessionId_P2PData_2eproto.base);
  return *internal_default_instance();
}


void SessionId::Clear() {
// @@protoc_insertion_point(message_clear_start:fantasybit.SessionId)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    uuid_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&start_time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&wire_version_) -
        reinterpret_cast<char*>(&start_time_)) + sizeof(wire_version_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SessionId::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .fantasybit.SessionId.NetworkID network_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::fantasybit::SessionId_NetworkID_IsValid(val))) {
            _internal_set_network_id(static_cast<::fantasybit::SessionId_NetworkID>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint32 wire_version = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_wire_version(&has_bits);
          wire_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 start_time = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 160)) {
          _Internal::set_has_start_time(&has_bits);
          start_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes uuid = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 242)) {
          auto str = _internal_mutable_uuid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SessionId::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:fantasybit.SessionId)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .fantasybit.SessionId.NetworkID network_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_network_id(), target);
  }

  // optional uint32 wire_version = 10;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(10, this->_internal_wire_version(), target);
  }

  // optional uint32 start_time = 20;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(20, this->_internal_start_time(), target);
  }

  // optional bytes uuid = 30;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        30, this->_internal_uuid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:fantasybit.SessionId)
  return target;
}

size_t SessionId::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:fantasybit.SessionId)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes uuid = 30;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_uuid());
    }

    // optional uint32 start_time = 20;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_start_time());
    }

    // optional .fantasybit.SessionId.NetworkID network_id = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_network_id());
    }

    // optional uint32 wire_version = 10;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_wire_version());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SessionId::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:fantasybit.SessionId)
  GOOGLE_DCHECK_NE(&from, this);
  const SessionId* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<SessionId>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:fantasybit.SessionId)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:fantasybit.SessionId)
    MergeFrom(*source);
  }
}

void SessionId::MergeFrom(const SessionId& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:fantasybit.SessionId)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_uuid(from._internal_uuid());
    }
    if (cached_has_bits & 0x00000002u) {
      start_time_ = from.start_time_;
    }
    if (cached_has_bits & 0x00000004u) {
      network_id_ = from.network_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      wire_version_ = from.wire_version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SessionId::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:fantasybit.SessionId)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SessionId::CopyFrom(const SessionId& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:fantasybit.SessionId)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SessionId::IsInitialized() const {
  return true;
}

void SessionId::InternalSwap(SessionId* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  uuid_.Swap(&other->uuid_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SessionId, wire_version_)
      + sizeof(SessionId::wire_version_)
      - PROTOBUF_FIELD_OFFSET(SessionId, start_time_)>(
          reinterpret_cast<char*>(&start_time_),
          reinterpret_cast<char*>(&other->start_time_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SessionId::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void WirePeer::InitAsDefaultInstance() {
  ::fantasybit::_WirePeer_default_instance_._instance.get_mutable()->session_id_ = const_cast< ::fantasybit::SessionId*>(
      ::fantasybit::SessionId::internal_default_instance());
  ::fantasybit::_WirePeer_default_instance_._instance.get_mutable()->peer_ = const_cast< ::fantasybit::Peer*>(
      ::fantasybit::Peer::internal_default_instance());
}
class WirePeer::_Internal {
 public:
  using HasBits = decltype(std::declval<WirePeer>()._has_bits_);
  static const ::fantasybit::SessionId& session_id(const WirePeer* msg);
  static void set_has_session_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::fantasybit::Peer& peer(const WirePeer* msg);
  static void set_has_peer(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::fantasybit::SessionId&
WirePeer::_Internal::session_id(const WirePeer* msg) {
  return *msg->session_id_;
}
const ::fantasybit::Peer&
WirePeer::_Internal::peer(const WirePeer* msg) {
  return *msg->peer_;
}
WirePeer::WirePeer(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:fantasybit.WirePeer)
}
WirePeer::WirePeer(const WirePeer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_session_id()) {
    session_id_ = new ::fantasybit::SessionId(*from.session_id_);
  } else {
    session_id_ = nullptr;
  }
  if (from._internal_has_peer()) {
    peer_ = new ::fantasybit::Peer(*from.peer_);
  } else {
    peer_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:fantasybit.WirePeer)
}

void WirePeer::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_WirePeer_P2PData_2eproto.base);
  ::memset(&session_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&peer_) -
      reinterpret_cast<char*>(&session_id_)) + sizeof(peer_));
}

WirePeer::~WirePeer() {
  // @@protoc_insertion_point(destructor:fantasybit.WirePeer)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void WirePeer::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete session_id_;
  if (this != internal_default_instance()) delete peer_;
}

void WirePeer::ArenaDtor(void* object) {
  WirePeer* _this = reinterpret_cast< WirePeer* >(object);
  (void)_this;
}
void WirePeer::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void WirePeer::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const WirePeer& WirePeer::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_WirePeer_P2PData_2eproto.base);
  return *internal_default_instance();
}


void WirePeer::Clear() {
// @@protoc_insertion_point(message_clear_start:fantasybit.WirePeer)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(session_id_ != nullptr);
      session_id_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(peer_ != nullptr);
      peer_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WirePeer::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .fantasybit.SessionId session_id = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_session_id(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .fantasybit.Peer peer = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_peer(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* WirePeer::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:fantasybit.WirePeer)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .fantasybit.SessionId session_id = 10;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::session_id(this), target, stream);
  }

  // optional .fantasybit.Peer peer = 20;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        20, _Internal::peer(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:fantasybit.WirePeer)
  return target;
}

size_t WirePeer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:fantasybit.WirePeer)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .fantasybit.SessionId session_id = 10;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *session_id_);
    }

    // optional .fantasybit.Peer peer = 20;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *peer_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void WirePeer::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:fantasybit.WirePeer)
  GOOGLE_DCHECK_NE(&from, this);
  const WirePeer* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<WirePeer>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:fantasybit.WirePeer)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:fantasybit.WirePeer)
    MergeFrom(*source);
  }
}

void WirePeer::MergeFrom(const WirePeer& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:fantasybit.WirePeer)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_session_id()->::fantasybit::SessionId::MergeFrom(from._internal_session_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_peer()->::fantasybit::Peer::MergeFrom(from._internal_peer());
    }
  }
}

void WirePeer::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:fantasybit.WirePeer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WirePeer::CopyFrom(const WirePeer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:fantasybit.WirePeer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WirePeer::IsInitialized() const {
  return true;
}

void WirePeer::InternalSwap(WirePeer* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(WirePeer, peer_)
      + sizeof(WirePeer::peer_)
      - PROTOBUF_FIELD_OFFSET(WirePeer, session_id_)>(
          reinterpret_cast<char*>(&session_id_),
          reinterpret_cast<char*>(&other->session_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata WirePeer::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void MsgIntro::InitAsDefaultInstance() {
  ::fantasybit::_MsgIntro_default_instance_._instance.get_mutable()->iam_ = const_cast< ::fantasybit::WirePeer*>(
      ::fantasybit::WirePeer::internal_default_instance());
  ::fantasybit::_MsgIntro_default_instance_._instance.get_mutable()->youare_ = const_cast< ::fantasybit::WirePeer*>(
      ::fantasybit::WirePeer::internal_default_instance());
}
class MsgIntro::_Internal {
 public:
  using HasBits = decltype(std::declval<MsgIntro>()._has_bits_);
  static const ::fantasybit::WirePeer& iam(const MsgIntro* msg);
  static void set_has_iam(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::fantasybit::WirePeer& youare(const MsgIntro* msg);
  static void set_has_youare(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::fantasybit::WirePeer&
MsgIntro::_Internal::iam(const MsgIntro* msg) {
  return *msg->iam_;
}
const ::fantasybit::WirePeer&
MsgIntro::_Internal::youare(const MsgIntro* msg) {
  return *msg->youare_;
}
MsgIntro::MsgIntro(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  everyone_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:fantasybit.MsgIntro)
}
MsgIntro::MsgIntro(const MsgIntro& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      everyone_(from.everyone_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_iam()) {
    iam_ = new ::fantasybit::WirePeer(*from.iam_);
  } else {
    iam_ = nullptr;
  }
  if (from._internal_has_youare()) {
    youare_ = new ::fantasybit::WirePeer(*from.youare_);
  } else {
    youare_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:fantasybit.MsgIntro)
}

void MsgIntro::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_MsgIntro_P2PData_2eproto.base);
  ::memset(&iam_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&youare_) -
      reinterpret_cast<char*>(&iam_)) + sizeof(youare_));
}

MsgIntro::~MsgIntro() {
  // @@protoc_insertion_point(destructor:fantasybit.MsgIntro)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void MsgIntro::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete iam_;
  if (this != internal_default_instance()) delete youare_;
}

void MsgIntro::ArenaDtor(void* object) {
  MsgIntro* _this = reinterpret_cast< MsgIntro* >(object);
  (void)_this;
}
void MsgIntro::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MsgIntro::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MsgIntro& MsgIntro::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_MsgIntro_P2PData_2eproto.base);
  return *internal_default_instance();
}


void MsgIntro::Clear() {
// @@protoc_insertion_point(message_clear_start:fantasybit.MsgIntro)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  everyone_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(iam_ != nullptr);
      iam_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(youare_ != nullptr);
      youare_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MsgIntro::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .fantasybit.WirePeer iam = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_iam(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .fantasybit.WirePeer youare = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_youare(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .fantasybit.Peer everyone = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 242)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_everyone(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<242>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* MsgIntro::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:fantasybit.MsgIntro)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .fantasybit.WirePeer iam = 10;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::iam(this), target, stream);
  }

  // optional .fantasybit.WirePeer youare = 20;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        20, _Internal::youare(this), target, stream);
  }

  // repeated .fantasybit.Peer everyone = 30;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_everyone_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(30, this->_internal_everyone(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:fantasybit.MsgIntro)
  return target;
}

size_t MsgIntro::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:fantasybit.MsgIntro)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .fantasybit.Peer everyone = 30;
  total_size += 2UL * this->_internal_everyone_size();
  for (const auto& msg : this->everyone_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .fantasybit.WirePeer iam = 10;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *iam_);
    }

    // optional .fantasybit.WirePeer youare = 20;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *youare_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MsgIntro::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:fantasybit.MsgIntro)
  GOOGLE_DCHECK_NE(&from, this);
  const MsgIntro* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<MsgIntro>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:fantasybit.MsgIntro)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:fantasybit.MsgIntro)
    MergeFrom(*source);
  }
}

void MsgIntro::MergeFrom(const MsgIntro& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:fantasybit.MsgIntro)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  everyone_.MergeFrom(from.everyone_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_iam()->::fantasybit::WirePeer::MergeFrom(from._internal_iam());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_youare()->::fantasybit::WirePeer::MergeFrom(from._internal_youare());
    }
  }
}

void MsgIntro::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:fantasybit.MsgIntro)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MsgIntro::CopyFrom(const MsgIntro& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:fantasybit.MsgIntro)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgIntro::IsInitialized() const {
  return true;
}

void MsgIntro::InternalSwap(MsgIntro* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  everyone_.InternalSwap(&other->everyone_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MsgIntro, youare_)
      + sizeof(MsgIntro::youare_)
      - PROTOBUF_FIELD_OFFSET(MsgIntro, iam_)>(
          reinterpret_cast<char*>(&iam_),
          reinterpret_cast<char*>(&other->iam_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MsgIntro::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void ChainHead::InitAsDefaultInstance() {
}
class ChainHead::_Internal {
 public:
  using HasBits = decltype(std::declval<ChainHead>()._has_bits_);
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_weight(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ChainHead::ChainHead(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:fantasybit.ChainHead)
}
ChainHead::ChainHead(const ChainHead& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_id()) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_id(),
      GetArena());
  }
  ::memcpy(&height_, &from.height_,
    static_cast<size_t>(reinterpret_cast<char*>(&weight_) -
    reinterpret_cast<char*>(&height_)) + sizeof(weight_));
  // @@protoc_insertion_point(copy_constructor:fantasybit.ChainHead)
}

void ChainHead::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ChainHead_P2PData_2eproto.base);
  id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&height_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&weight_) -
      reinterpret_cast<char*>(&height_)) + sizeof(weight_));
}

ChainHead::~ChainHead() {
  // @@protoc_insertion_point(destructor:fantasybit.ChainHead)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void ChainHead::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ChainHead::ArenaDtor(void* object) {
  ChainHead* _this = reinterpret_cast< ChainHead* >(object);
  (void)_this;
}
void ChainHead::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ChainHead::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ChainHead& ChainHead::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ChainHead_P2PData_2eproto.base);
  return *internal_default_instance();
}


void ChainHead::Clear() {
// @@protoc_insertion_point(message_clear_start:fantasybit.ChainHead)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    id_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&height_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&weight_) -
        reinterpret_cast<char*>(&height_)) + sizeof(weight_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ChainHead::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional int32 height = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_height(&has_bits);
          height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 weight = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 160)) {
          _Internal::set_has_weight(&has_bits);
          weight_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes id = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 242)) {
          auto str = _internal_mutable_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ChainHead::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:fantasybit.ChainHead)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 height = 10;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(10, this->_internal_height(), target);
  }

  // optional int32 weight = 20;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(20, this->_internal_weight(), target);
  }

  // optional bytes id = 30;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        30, this->_internal_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:fantasybit.ChainHead)
  return target;
}

size_t ChainHead::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:fantasybit.ChainHead)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes id = 30;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_id());
    }

    // optional int32 height = 10;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_height());
    }

    // optional int32 weight = 20;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_weight());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ChainHead::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:fantasybit.ChainHead)
  GOOGLE_DCHECK_NE(&from, this);
  const ChainHead* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ChainHead>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:fantasybit.ChainHead)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:fantasybit.ChainHead)
    MergeFrom(*source);
  }
}

void ChainHead::MergeFrom(const ChainHead& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:fantasybit.ChainHead)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_id(from._internal_id());
    }
    if (cached_has_bits & 0x00000002u) {
      height_ = from.height_;
    }
    if (cached_has_bits & 0x00000004u) {
      weight_ = from.weight_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ChainHead::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:fantasybit.ChainHead)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ChainHead::CopyFrom(const ChainHead& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:fantasybit.ChainHead)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChainHead::IsInitialized() const {
  return true;
}

void ChainHead::InternalSwap(ChainHead* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  id_.Swap(&other->id_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ChainHead, weight_)
      + sizeof(ChainHead::weight_)
      - PROTOBUF_FIELD_OFFSET(ChainHead, height_)>(
          reinterpret_cast<char*>(&height_),
          reinterpret_cast<char*>(&other->height_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ChainHead::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void PeerChainStatus::InitAsDefaultInstance() {
  ::fantasybit::_PeerChainStatus_default_instance_._instance.get_mutable()->last_dea_ = const_cast< ::fantasybit::ChainHead*>(
      ::fantasybit::ChainHead::internal_default_instance());
  ::fantasybit::_PeerChainStatus_default_instance_._instance.get_mutable()->last_irreversible_ = const_cast< ::fantasybit::ChainHead*>(
      ::fantasybit::ChainHead::internal_default_instance());
}
class PeerChainStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<PeerChainStatus>()._has_bits_);
  static void set_has_chain_state(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::fantasybit::ChainHead& last_dea(const PeerChainStatus* msg);
  static void set_has_last_dea(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::fantasybit::ChainHead& last_irreversible(const PeerChainStatus* msg);
  static void set_has_last_irreversible(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_mempool_count(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_mempool_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_last_block_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_last_tx_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::fantasybit::ChainHead&
PeerChainStatus::_Internal::last_dea(const PeerChainStatus* msg) {
  return *msg->last_dea_;
}
const ::fantasybit::ChainHead&
PeerChainStatus::_Internal::last_irreversible(const PeerChainStatus* msg) {
  return *msg->last_irreversible_;
}
PeerChainStatus::PeerChainStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:fantasybit.PeerChainStatus)
}
PeerChainStatus::PeerChainStatus(const PeerChainStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_last_dea()) {
    last_dea_ = new ::fantasybit::ChainHead(*from.last_dea_);
  } else {
    last_dea_ = nullptr;
  }
  if (from._internal_has_last_irreversible()) {
    last_irreversible_ = new ::fantasybit::ChainHead(*from.last_irreversible_);
  } else {
    last_irreversible_ = nullptr;
  }
  ::memcpy(&mempool_size_, &from.mempool_size_,
    static_cast<size_t>(reinterpret_cast<char*>(&last_tx_timestamp_) -
    reinterpret_cast<char*>(&mempool_size_)) + sizeof(last_tx_timestamp_));
  // @@protoc_insertion_point(copy_constructor:fantasybit.PeerChainStatus)
}

void PeerChainStatus::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_PeerChainStatus_P2PData_2eproto.base);
  ::memset(&last_dea_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&last_tx_timestamp_) -
      reinterpret_cast<char*>(&last_dea_)) + sizeof(last_tx_timestamp_));
}

PeerChainStatus::~PeerChainStatus() {
  // @@protoc_insertion_point(destructor:fantasybit.PeerChainStatus)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void PeerChainStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete last_dea_;
  if (this != internal_default_instance()) delete last_irreversible_;
}

void PeerChainStatus::ArenaDtor(void* object) {
  PeerChainStatus* _this = reinterpret_cast< PeerChainStatus* >(object);
  (void)_this;
}
void PeerChainStatus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PeerChainStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const PeerChainStatus& PeerChainStatus::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_PeerChainStatus_P2PData_2eproto.base);
  return *internal_default_instance();
}


void PeerChainStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:fantasybit.PeerChainStatus)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(last_dea_ != nullptr);
      last_dea_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(last_irreversible_ != nullptr);
      last_irreversible_->Clear();
    }
  }
  if (cached_has_bits & 0x0000007cu) {
    ::memset(&mempool_size_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&last_tx_timestamp_) -
        reinterpret_cast<char*>(&mempool_size_)) + sizeof(last_tx_timestamp_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PeerChainStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .fantasybit.PeerChainStatus.ChainState chain_state = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::fantasybit::PeerChainStatus_ChainState_IsValid(val))) {
            _internal_set_chain_state(static_cast<::fantasybit::PeerChainStatus_ChainState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .fantasybit.ChainHead last_dea = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_last_dea(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .fantasybit.ChainHead last_irreversible = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_last_irreversible(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 mempool_count = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 240)) {
          _Internal::set_has_mempool_count(&has_bits);
          mempool_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 mempool_size = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_mempool_size(&has_bits);
          mempool_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 last_block_timestamp = 50;
      case 50:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 144)) {
          _Internal::set_has_last_block_timestamp(&has_bits);
          last_block_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 last_tx_timestamp = 60;
      case 60:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 224)) {
          _Internal::set_has_last_tx_timestamp(&has_bits);
          last_tx_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* PeerChainStatus::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:fantasybit.PeerChainStatus)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .fantasybit.PeerChainStatus.ChainState chain_state = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_chain_state(), target);
  }

  // optional .fantasybit.ChainHead last_dea = 10;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::last_dea(this), target, stream);
  }

  // optional .fantasybit.ChainHead last_irreversible = 20;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        20, _Internal::last_irreversible(this), target, stream);
  }

  // optional uint32 mempool_count = 30;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(30, this->_internal_mempool_count(), target);
  }

  // optional uint32 mempool_size = 40;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(40, this->_internal_mempool_size(), target);
  }

  // optional uint64 last_block_timestamp = 50;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(50, this->_internal_last_block_timestamp(), target);
  }

  // optional uint64 last_tx_timestamp = 60;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(60, this->_internal_last_tx_timestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:fantasybit.PeerChainStatus)
  return target;
}

size_t PeerChainStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:fantasybit.PeerChainStatus)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional .fantasybit.ChainHead last_dea = 10;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *last_dea_);
    }

    // optional .fantasybit.ChainHead last_irreversible = 20;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *last_irreversible_);
    }

    // optional uint32 mempool_size = 40;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_mempool_size());
    }

    // optional .fantasybit.PeerChainStatus.ChainState chain_state = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_chain_state());
    }

    // optional uint32 mempool_count = 30;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_mempool_count());
    }

    // optional uint64 last_block_timestamp = 50;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_last_block_timestamp());
    }

    // optional uint64 last_tx_timestamp = 60;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_last_tx_timestamp());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PeerChainStatus::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:fantasybit.PeerChainStatus)
  GOOGLE_DCHECK_NE(&from, this);
  const PeerChainStatus* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<PeerChainStatus>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:fantasybit.PeerChainStatus)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:fantasybit.PeerChainStatus)
    MergeFrom(*source);
  }
}

void PeerChainStatus::MergeFrom(const PeerChainStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:fantasybit.PeerChainStatus)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_last_dea()->::fantasybit::ChainHead::MergeFrom(from._internal_last_dea());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_last_irreversible()->::fantasybit::ChainHead::MergeFrom(from._internal_last_irreversible());
    }
    if (cached_has_bits & 0x00000004u) {
      mempool_size_ = from.mempool_size_;
    }
    if (cached_has_bits & 0x00000008u) {
      chain_state_ = from.chain_state_;
    }
    if (cached_has_bits & 0x00000010u) {
      mempool_count_ = from.mempool_count_;
    }
    if (cached_has_bits & 0x00000020u) {
      last_block_timestamp_ = from.last_block_timestamp_;
    }
    if (cached_has_bits & 0x00000040u) {
      last_tx_timestamp_ = from.last_tx_timestamp_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void PeerChainStatus::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:fantasybit.PeerChainStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PeerChainStatus::CopyFrom(const PeerChainStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:fantasybit.PeerChainStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PeerChainStatus::IsInitialized() const {
  return true;
}

void PeerChainStatus::InternalSwap(PeerChainStatus* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PeerChainStatus, last_tx_timestamp_)
      + sizeof(PeerChainStatus::last_tx_timestamp_)
      - PROTOBUF_FIELD_OFFSET(PeerChainStatus, last_dea_)>(
          reinterpret_cast<char*>(&last_dea_),
          reinterpret_cast<char*>(&other->last_dea_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PeerChainStatus::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void MsgAlive::InitAsDefaultInstance() {
  ::fantasybit::_MsgAlive_default_instance_._instance.get_mutable()->peer_status_ = const_cast< ::fantasybit::PeerChainStatus*>(
      ::fantasybit::PeerChainStatus::internal_default_instance());
}
class MsgAlive::_Internal {
 public:
  using HasBits = decltype(std::declval<MsgAlive>()._has_bits_);
  static const ::fantasybit::PeerChainStatus& peer_status(const MsgAlive* msg);
  static void set_has_peer_status(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::fantasybit::PeerChainStatus&
MsgAlive::_Internal::peer_status(const MsgAlive* msg) {
  return *msg->peer_status_;
}
MsgAlive::MsgAlive(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:fantasybit.MsgAlive)
}
MsgAlive::MsgAlive(const MsgAlive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_peer_status()) {
    peer_status_ = new ::fantasybit::PeerChainStatus(*from.peer_status_);
  } else {
    peer_status_ = nullptr;
  }
  timestamp_ = from.timestamp_;
  // @@protoc_insertion_point(copy_constructor:fantasybit.MsgAlive)
}

void MsgAlive::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_MsgAlive_P2PData_2eproto.base);
  ::memset(&peer_status_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&timestamp_) -
      reinterpret_cast<char*>(&peer_status_)) + sizeof(timestamp_));
}

MsgAlive::~MsgAlive() {
  // @@protoc_insertion_point(destructor:fantasybit.MsgAlive)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void MsgAlive::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete peer_status_;
}

void MsgAlive::ArenaDtor(void* object) {
  MsgAlive* _this = reinterpret_cast< MsgAlive* >(object);
  (void)_this;
}
void MsgAlive::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MsgAlive::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MsgAlive& MsgAlive::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_MsgAlive_P2PData_2eproto.base);
  return *internal_default_instance();
}


void MsgAlive::Clear() {
// @@protoc_insertion_point(message_clear_start:fantasybit.MsgAlive)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(peer_status_ != nullptr);
    peer_status_->Clear();
  }
  timestamp_ = PROTOBUF_ULONGLONG(0);
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MsgAlive::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .fantasybit.PeerChainStatus peer_status = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 242)) {
          ptr = ctx->ParseMessage(_internal_mutable_peer_status(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 timestamp = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_timestamp(&has_bits);
          timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* MsgAlive::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:fantasybit.MsgAlive)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .fantasybit.PeerChainStatus peer_status = 30;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        30, _Internal::peer_status(this), target, stream);
  }

  // optional uint64 timestamp = 40;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(40, this->_internal_timestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:fantasybit.MsgAlive)
  return target;
}

size_t MsgAlive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:fantasybit.MsgAlive)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .fantasybit.PeerChainStatus peer_status = 30;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *peer_status_);
    }

    // optional uint64 timestamp = 40;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_timestamp());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MsgAlive::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:fantasybit.MsgAlive)
  GOOGLE_DCHECK_NE(&from, this);
  const MsgAlive* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<MsgAlive>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:fantasybit.MsgAlive)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:fantasybit.MsgAlive)
    MergeFrom(*source);
  }
}

void MsgAlive::MergeFrom(const MsgAlive& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:fantasybit.MsgAlive)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_peer_status()->::fantasybit::PeerChainStatus::MergeFrom(from._internal_peer_status());
    }
    if (cached_has_bits & 0x00000002u) {
      timestamp_ = from.timestamp_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void MsgAlive::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:fantasybit.MsgAlive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MsgAlive::CopyFrom(const MsgAlive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:fantasybit.MsgAlive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgAlive::IsInitialized() const {
  return true;
}

void MsgAlive::InternalSwap(MsgAlive* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MsgAlive, timestamp_)
      + sizeof(MsgAlive::timestamp_)
      - PROTOBUF_FIELD_OFFSET(MsgAlive, peer_status_)>(
          reinterpret_cast<char*>(&peer_status_),
          reinterpret_cast<char*>(&other->peer_status_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MsgAlive::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void MsgHello::InitAsDefaultInstance() {
  ::fantasybit::_MsgHello_default_instance_._instance.get_mutable()->update_ = const_cast< ::fantasybit::MsgIntro*>(
      ::fantasybit::MsgIntro::internal_default_instance());
}
class MsgHello::_Internal {
 public:
  using HasBits = decltype(std::declval<MsgHello>()._has_bits_);
  static const ::fantasybit::MsgIntro& update(const MsgHello* msg);
  static void set_has_update(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::fantasybit::MsgIntro&
MsgHello::_Internal::update(const MsgHello* msg) {
  return *msg->update_;
}
MsgHello::MsgHello(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  connections_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:fantasybit.MsgHello)
}
MsgHello::MsgHello(const MsgHello& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      connections_(from.connections_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_update()) {
    update_ = new ::fantasybit::MsgIntro(*from.update_);
  } else {
    update_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:fantasybit.MsgHello)
}

void MsgHello::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_MsgHello_P2PData_2eproto.base);
  update_ = nullptr;
}

MsgHello::~MsgHello() {
  // @@protoc_insertion_point(destructor:fantasybit.MsgHello)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void MsgHello::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete update_;
}

void MsgHello::ArenaDtor(void* object) {
  MsgHello* _this = reinterpret_cast< MsgHello* >(object);
  (void)_this;
}
void MsgHello::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MsgHello::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MsgHello& MsgHello::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_MsgHello_P2PData_2eproto.base);
  return *internal_default_instance();
}


void MsgHello::Clear() {
// @@protoc_insertion_point(message_clear_start:fantasybit.MsgHello)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  connections_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(update_ != nullptr);
    update_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MsgHello::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .fantasybit.MsgIntro update = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_update(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .fantasybit.WirePeer connections = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 162)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_connections(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<162>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* MsgHello::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:fantasybit.MsgHello)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .fantasybit.MsgIntro update = 10;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::update(this), target, stream);
  }

  // repeated .fantasybit.WirePeer connections = 20;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_connections_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(20, this->_internal_connections(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:fantasybit.MsgHello)
  return target;
}

size_t MsgHello::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:fantasybit.MsgHello)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .fantasybit.WirePeer connections = 20;
  total_size += 2UL * this->_internal_connections_size();
  for (const auto& msg : this->connections_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .fantasybit.MsgIntro update = 10;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *update_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MsgHello::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:fantasybit.MsgHello)
  GOOGLE_DCHECK_NE(&from, this);
  const MsgHello* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<MsgHello>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:fantasybit.MsgHello)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:fantasybit.MsgHello)
    MergeFrom(*source);
  }
}

void MsgHello::MergeFrom(const MsgHello& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:fantasybit.MsgHello)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  connections_.MergeFrom(from.connections_);
  if (from._internal_has_update()) {
    _internal_mutable_update()->::fantasybit::MsgIntro::MergeFrom(from._internal_update());
  }
}

void MsgHello::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:fantasybit.MsgHello)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MsgHello::CopyFrom(const MsgHello& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:fantasybit.MsgHello)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgHello::IsInitialized() const {
  return true;
}

void MsgHello::InternalSwap(MsgHello* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  connections_.InternalSwap(&other->connections_);
  swap(update_, other->update_);
}

::PROTOBUF_NAMESPACE_ID::Metadata MsgHello::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void WireMsg::InitAsDefaultInstance() {
  ::fantasybit::_WireMsg_default_instance_._instance.get_mutable()->intro_ = const_cast< ::fantasybit::MsgIntro*>(
      ::fantasybit::MsgIntro::internal_default_instance());
  ::fantasybit::_WireMsg_default_instance_._instance.get_mutable()->hello_ = const_cast< ::fantasybit::MsgHello*>(
      ::fantasybit::MsgHello::internal_default_instance());
  ::fantasybit::_WireMsg_default_instance_._instance.get_mutable()->alive_ = const_cast< ::fantasybit::MsgAlive*>(
      ::fantasybit::MsgAlive::internal_default_instance());
}
class WireMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<WireMsg>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::fantasybit::MsgIntro& intro(const WireMsg* msg);
  static void set_has_intro(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::fantasybit::MsgHello& hello(const WireMsg* msg);
  static void set_has_hello(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::fantasybit::MsgAlive& alive(const WireMsg* msg);
  static void set_has_alive(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::fantasybit::MsgIntro&
WireMsg::_Internal::intro(const WireMsg* msg) {
  return *msg->intro_;
}
const ::fantasybit::MsgHello&
WireMsg::_Internal::hello(const WireMsg* msg) {
  return *msg->hello_;
}
const ::fantasybit::MsgAlive&
WireMsg::_Internal::alive(const WireMsg* msg) {
  return *msg->alive_;
}
WireMsg::WireMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:fantasybit.WireMsg)
}
WireMsg::WireMsg(const WireMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_intro()) {
    intro_ = new ::fantasybit::MsgIntro(*from.intro_);
  } else {
    intro_ = nullptr;
  }
  if (from._internal_has_hello()) {
    hello_ = new ::fantasybit::MsgHello(*from.hello_);
  } else {
    hello_ = nullptr;
  }
  if (from._internal_has_alive()) {
    alive_ = new ::fantasybit::MsgAlive(*from.alive_);
  } else {
    alive_ = nullptr;
  }
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:fantasybit.WireMsg)
}

void WireMsg::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_WireMsg_P2PData_2eproto.base);
  ::memset(&intro_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&type_) -
      reinterpret_cast<char*>(&intro_)) + sizeof(type_));
}

WireMsg::~WireMsg() {
  // @@protoc_insertion_point(destructor:fantasybit.WireMsg)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void WireMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete intro_;
  if (this != internal_default_instance()) delete hello_;
  if (this != internal_default_instance()) delete alive_;
}

void WireMsg::ArenaDtor(void* object) {
  WireMsg* _this = reinterpret_cast< WireMsg* >(object);
  (void)_this;
}
void WireMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void WireMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const WireMsg& WireMsg::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_WireMsg_P2PData_2eproto.base);
  return *internal_default_instance();
}


void WireMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:fantasybit.WireMsg)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(intro_ != nullptr);
      intro_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(hello_ != nullptr);
      hello_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(alive_ != nullptr);
      alive_->Clear();
    }
  }
  type_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WireMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .fantasybit.MsgType type = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::fantasybit::MsgType_IsValid(val))) {
            _internal_set_type(static_cast<::fantasybit::MsgType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(10, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .fantasybit.MsgIntro intro = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_intro(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .fantasybit.MsgHello hello = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 242)) {
          ptr = ctx->ParseMessage(_internal_mutable_hello(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .fantasybit.MsgAlive alive = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_alive(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* WireMsg::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:fantasybit.WireMsg)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .fantasybit.MsgType type = 10;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      10, this->_internal_type(), target);
  }

  // optional .fantasybit.MsgIntro intro = 20;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        20, _Internal::intro(this), target, stream);
  }

  // optional .fantasybit.MsgHello hello = 30;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        30, _Internal::hello(this), target, stream);
  }

  // optional .fantasybit.MsgAlive alive = 40;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        40, _Internal::alive(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:fantasybit.WireMsg)
  return target;
}

size_t WireMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:fantasybit.WireMsg)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .fantasybit.MsgIntro intro = 20;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *intro_);
    }

    // optional .fantasybit.MsgHello hello = 30;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *hello_);
    }

    // optional .fantasybit.MsgAlive alive = 40;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *alive_);
    }

    // optional .fantasybit.MsgType type = 10;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void WireMsg::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:fantasybit.WireMsg)
  GOOGLE_DCHECK_NE(&from, this);
  const WireMsg* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<WireMsg>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:fantasybit.WireMsg)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:fantasybit.WireMsg)
    MergeFrom(*source);
  }
}

void WireMsg::MergeFrom(const WireMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:fantasybit.WireMsg)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_intro()->::fantasybit::MsgIntro::MergeFrom(from._internal_intro());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_hello()->::fantasybit::MsgHello::MergeFrom(from._internal_hello());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_alive()->::fantasybit::MsgAlive::MergeFrom(from._internal_alive());
    }
    if (cached_has_bits & 0x00000008u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void WireMsg::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:fantasybit.WireMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WireMsg::CopyFrom(const WireMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:fantasybit.WireMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WireMsg::IsInitialized() const {
  return true;
}

void WireMsg::InternalSwap(WireMsg* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(WireMsg, type_)
      + sizeof(WireMsg::type_)
      - PROTOBUF_FIELD_OFFSET(WireMsg, intro_)>(
          reinterpret_cast<char*>(&intro_),
          reinterpret_cast<char*>(&other->intro_));
}

::PROTOBUF_NAMESPACE_ID::Metadata WireMsg::GetMetadata() const {
  return GetMetadataStatic();
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace fantasybit
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::fantasybit::Peer* Arena::CreateMaybeMessage< ::fantasybit::Peer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::fantasybit::Peer >(arena);
}
template<> PROTOBUF_NOINLINE ::fantasybit::SessionId* Arena::CreateMaybeMessage< ::fantasybit::SessionId >(Arena* arena) {
  return Arena::CreateMessageInternal< ::fantasybit::SessionId >(arena);
}
template<> PROTOBUF_NOINLINE ::fantasybit::WirePeer* Arena::CreateMaybeMessage< ::fantasybit::WirePeer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::fantasybit::WirePeer >(arena);
}
template<> PROTOBUF_NOINLINE ::fantasybit::MsgIntro* Arena::CreateMaybeMessage< ::fantasybit::MsgIntro >(Arena* arena) {
  return Arena::CreateMessageInternal< ::fantasybit::MsgIntro >(arena);
}
template<> PROTOBUF_NOINLINE ::fantasybit::ChainHead* Arena::CreateMaybeMessage< ::fantasybit::ChainHead >(Arena* arena) {
  return Arena::CreateMessageInternal< ::fantasybit::ChainHead >(arena);
}
template<> PROTOBUF_NOINLINE ::fantasybit::PeerChainStatus* Arena::CreateMaybeMessage< ::fantasybit::PeerChainStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::fantasybit::PeerChainStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::fantasybit::MsgAlive* Arena::CreateMaybeMessage< ::fantasybit::MsgAlive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::fantasybit::MsgAlive >(arena);
}
template<> PROTOBUF_NOINLINE ::fantasybit::MsgHello* Arena::CreateMaybeMessage< ::fantasybit::MsgHello >(Arena* arena) {
  return Arena::CreateMessageInternal< ::fantasybit::MsgHello >(arena);
}
template<> PROTOBUF_NOINLINE ::fantasybit::WireMsg* Arena::CreateMaybeMessage< ::fantasybit::WireMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::fantasybit::WireMsg >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
