// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ProtoData.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ProtoData_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ProtoData_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "StaticData.pb.h"
#include "StatusData.pb.h"
#include "ExData.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ProtoData_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ProtoData_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[46]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ProtoData_2eproto;
namespace fantasybit {
class Bitcoin_UTXO;
class Bitcoin_UTXODefaultTypeInternal;
extern Bitcoin_UTXODefaultTypeInternal _Bitcoin_UTXO_default_instance_;
class Bitcoin_UTXOS;
class Bitcoin_UTXOSDefaultTypeInternal;
extern Bitcoin_UTXOSDefaultTypeInternal _Bitcoin_UTXOS_default_instance_;
class Block;
class BlockDefaultTypeInternal;
extern BlockDefaultTypeInternal _Block_default_instance_;
class BlockHeader;
class BlockHeaderDefaultTypeInternal;
extern BlockHeaderDefaultTypeInternal _BlockHeader_default_instance_;
class Data;
class DataDefaultTypeInternal;
extern DataDefaultTypeInternal _Data_default_instance_;
class DataTransition;
class DataTransitionDefaultTypeInternal;
extern DataTransitionDefaultTypeInternal _DataTransition_default_instance_;
class DeltaData;
class DeltaDataDefaultTypeInternal;
extern DeltaDataDefaultTypeInternal _DeltaData_default_instance_;
class ExchangeOrder;
class ExchangeOrderDefaultTypeInternal;
extern ExchangeOrderDefaultTypeInternal _ExchangeOrder_default_instance_;
class FantasyPlayer;
class FantasyPlayerDefaultTypeInternal;
extern FantasyPlayerDefaultTypeInternal _FantasyPlayer_default_instance_;
class FantasyPlayerPoints;
class FantasyPlayerPointsDefaultTypeInternal;
extern FantasyPlayerPointsDefaultTypeInternal _FantasyPlayerPoints_default_instance_;
class GameData;
class GameDataDefaultTypeInternal;
extern GameDataDefaultTypeInternal _GameData_default_instance_;
class InData;
class InDataDefaultTypeInternal;
extern InDataDefaultTypeInternal _InData_default_instance_;
class InsideUnique;
class InsideUniqueDefaultTypeInternal;
extern InsideUniqueDefaultTypeInternal _InsideUnique_default_instance_;
class MasterProof;
class MasterProofDefaultTypeInternal;
extern MasterProofDefaultTypeInternal _MasterProof_default_instance_;
class MessageData;
class MessageDataDefaultTypeInternal;
extern MessageDataDefaultTypeInternal _MessageData_default_instance_;
class MyFantasyName;
class MyFantasyNameDefaultTypeInternal;
extern MyFantasyNameDefaultTypeInternal _MyFantasyName_default_instance_;
class NameProof;
class NameProofDefaultTypeInternal;
extern NameProofDefaultTypeInternal _NameProof_default_instance_;
class NameTrans;
class NameTransDefaultTypeInternal;
extern NameTransDefaultTypeInternal _NameTrans_default_instance_;
class NodeReply;
class NodeReplyDefaultTypeInternal;
extern NodeReplyDefaultTypeInternal _NodeReply_default_instance_;
class NodeRequest;
class NodeRequestDefaultTypeInternal;
extern NodeRequestDefaultTypeInternal _NodeRequest_default_instance_;
class OrderDeets;
class OrderDeetsDefaultTypeInternal;
extern OrderDeetsDefaultTypeInternal _OrderDeets_default_instance_;
class OrderUnique;
class OrderUniqueDefaultTypeInternal;
extern OrderUniqueDefaultTypeInternal _OrderUnique_default_instance_;
class OutData;
class OutDataDefaultTypeInternal;
extern OutDataDefaultTypeInternal _OutData_default_instance_;
class PlayerData;
class PlayerDataDefaultTypeInternal;
extern PlayerDataDefaultTypeInternal _PlayerData_default_instance_;
class PlayerPoints;
class PlayerPointsDefaultTypeInternal;
extern PlayerPointsDefaultTypeInternal _PlayerPoints_default_instance_;
class ProjectionTrans;
class ProjectionTransDefaultTypeInternal;
extern ProjectionTransDefaultTypeInternal _ProjectionTrans_default_instance_;
class ProjectionTransBlock;
class ProjectionTransBlockDefaultTypeInternal;
extern ProjectionTransBlockDefaultTypeInternal _ProjectionTransBlock_default_instance_;
class ProofOfDoubleSpend;
class ProofOfDoubleSpendDefaultTypeInternal;
extern ProofOfDoubleSpendDefaultTypeInternal _ProofOfDoubleSpend_default_instance_;
class ResultData;
class ResultDataDefaultTypeInternal;
extern ResultDataDefaultTypeInternal _ResultData_default_instance_;
class ScheduleData;
class ScheduleDataDefaultTypeInternal;
extern ScheduleDataDefaultTypeInternal _ScheduleData_default_instance_;
class Secret;
class SecretDefaultTypeInternal;
extern SecretDefaultTypeInternal _Secret_default_instance_;
class Secret2;
class Secret2DefaultTypeInternal;
extern Secret2DefaultTypeInternal _Secret2_default_instance_;
class Secret3;
class Secret3DefaultTypeInternal;
extern Secret3DefaultTypeInternal _Secret3_default_instance_;
class SignedBlockHeader;
class SignedBlockHeaderDefaultTypeInternal;
extern SignedBlockHeaderDefaultTypeInternal _SignedBlockHeader_default_instance_;
class SignedTransaction;
class SignedTransactionDefaultTypeInternal;
extern SignedTransactionDefaultTypeInternal _SignedTransaction_default_instance_;
class StampedTrans;
class StampedTransDefaultTypeInternal;
extern StampedTransDefaultTypeInternal _StampedTrans_default_instance_;
class SwapAsk;
class SwapAskDefaultTypeInternal;
extern SwapAskDefaultTypeInternal _SwapAsk_default_instance_;
class SwapBid;
class SwapBidDefaultTypeInternal;
extern SwapBidDefaultTypeInternal _SwapBid_default_instance_;
class SwapFill;
class SwapFillDefaultTypeInternal;
extern SwapFillDefaultTypeInternal _SwapFill_default_instance_;
class SwapSent;
class SwapSentDefaultTypeInternal;
extern SwapSentDefaultTypeInternal _SwapSent_default_instance_;
class SwapSentAck;
class SwapSentAckDefaultTypeInternal;
extern SwapSentAckDefaultTypeInternal _SwapSentAck_default_instance_;
class TeamState;
class TeamStateDefaultTypeInternal;
extern TeamStateDefaultTypeInternal _TeamState_default_instance_;
class TimeTransition;
class TimeTransitionDefaultTypeInternal;
extern TimeTransitionDefaultTypeInternal _TimeTransition_default_instance_;
class Transaction;
class TransactionDefaultTypeInternal;
extern TransactionDefaultTypeInternal _Transaction_default_instance_;
class TransferTrans;
class TransferTransDefaultTypeInternal;
extern TransferTransDefaultTypeInternal _TransferTrans_default_instance_;
class TweetProof;
class TweetProofDefaultTypeInternal;
extern TweetProofDefaultTypeInternal _TweetProof_default_instance_;
}  // namespace fantasybit
PROTOBUF_NAMESPACE_OPEN
template<> ::fantasybit::Bitcoin_UTXO* Arena::CreateMaybeMessage<::fantasybit::Bitcoin_UTXO>(Arena*);
template<> ::fantasybit::Bitcoin_UTXOS* Arena::CreateMaybeMessage<::fantasybit::Bitcoin_UTXOS>(Arena*);
template<> ::fantasybit::Block* Arena::CreateMaybeMessage<::fantasybit::Block>(Arena*);
template<> ::fantasybit::BlockHeader* Arena::CreateMaybeMessage<::fantasybit::BlockHeader>(Arena*);
template<> ::fantasybit::Data* Arena::CreateMaybeMessage<::fantasybit::Data>(Arena*);
template<> ::fantasybit::DataTransition* Arena::CreateMaybeMessage<::fantasybit::DataTransition>(Arena*);
template<> ::fantasybit::DeltaData* Arena::CreateMaybeMessage<::fantasybit::DeltaData>(Arena*);
template<> ::fantasybit::ExchangeOrder* Arena::CreateMaybeMessage<::fantasybit::ExchangeOrder>(Arena*);
template<> ::fantasybit::FantasyPlayer* Arena::CreateMaybeMessage<::fantasybit::FantasyPlayer>(Arena*);
template<> ::fantasybit::FantasyPlayerPoints* Arena::CreateMaybeMessage<::fantasybit::FantasyPlayerPoints>(Arena*);
template<> ::fantasybit::GameData* Arena::CreateMaybeMessage<::fantasybit::GameData>(Arena*);
template<> ::fantasybit::InData* Arena::CreateMaybeMessage<::fantasybit::InData>(Arena*);
template<> ::fantasybit::InsideUnique* Arena::CreateMaybeMessage<::fantasybit::InsideUnique>(Arena*);
template<> ::fantasybit::MasterProof* Arena::CreateMaybeMessage<::fantasybit::MasterProof>(Arena*);
template<> ::fantasybit::MessageData* Arena::CreateMaybeMessage<::fantasybit::MessageData>(Arena*);
template<> ::fantasybit::MyFantasyName* Arena::CreateMaybeMessage<::fantasybit::MyFantasyName>(Arena*);
template<> ::fantasybit::NameProof* Arena::CreateMaybeMessage<::fantasybit::NameProof>(Arena*);
template<> ::fantasybit::NameTrans* Arena::CreateMaybeMessage<::fantasybit::NameTrans>(Arena*);
template<> ::fantasybit::NodeReply* Arena::CreateMaybeMessage<::fantasybit::NodeReply>(Arena*);
template<> ::fantasybit::NodeRequest* Arena::CreateMaybeMessage<::fantasybit::NodeRequest>(Arena*);
template<> ::fantasybit::OrderDeets* Arena::CreateMaybeMessage<::fantasybit::OrderDeets>(Arena*);
template<> ::fantasybit::OrderUnique* Arena::CreateMaybeMessage<::fantasybit::OrderUnique>(Arena*);
template<> ::fantasybit::OutData* Arena::CreateMaybeMessage<::fantasybit::OutData>(Arena*);
template<> ::fantasybit::PlayerData* Arena::CreateMaybeMessage<::fantasybit::PlayerData>(Arena*);
template<> ::fantasybit::PlayerPoints* Arena::CreateMaybeMessage<::fantasybit::PlayerPoints>(Arena*);
template<> ::fantasybit::ProjectionTrans* Arena::CreateMaybeMessage<::fantasybit::ProjectionTrans>(Arena*);
template<> ::fantasybit::ProjectionTransBlock* Arena::CreateMaybeMessage<::fantasybit::ProjectionTransBlock>(Arena*);
template<> ::fantasybit::ProofOfDoubleSpend* Arena::CreateMaybeMessage<::fantasybit::ProofOfDoubleSpend>(Arena*);
template<> ::fantasybit::ResultData* Arena::CreateMaybeMessage<::fantasybit::ResultData>(Arena*);
template<> ::fantasybit::ScheduleData* Arena::CreateMaybeMessage<::fantasybit::ScheduleData>(Arena*);
template<> ::fantasybit::Secret* Arena::CreateMaybeMessage<::fantasybit::Secret>(Arena*);
template<> ::fantasybit::Secret2* Arena::CreateMaybeMessage<::fantasybit::Secret2>(Arena*);
template<> ::fantasybit::Secret3* Arena::CreateMaybeMessage<::fantasybit::Secret3>(Arena*);
template<> ::fantasybit::SignedBlockHeader* Arena::CreateMaybeMessage<::fantasybit::SignedBlockHeader>(Arena*);
template<> ::fantasybit::SignedTransaction* Arena::CreateMaybeMessage<::fantasybit::SignedTransaction>(Arena*);
template<> ::fantasybit::StampedTrans* Arena::CreateMaybeMessage<::fantasybit::StampedTrans>(Arena*);
template<> ::fantasybit::SwapAsk* Arena::CreateMaybeMessage<::fantasybit::SwapAsk>(Arena*);
template<> ::fantasybit::SwapBid* Arena::CreateMaybeMessage<::fantasybit::SwapBid>(Arena*);
template<> ::fantasybit::SwapFill* Arena::CreateMaybeMessage<::fantasybit::SwapFill>(Arena*);
template<> ::fantasybit::SwapSent* Arena::CreateMaybeMessage<::fantasybit::SwapSent>(Arena*);
template<> ::fantasybit::SwapSentAck* Arena::CreateMaybeMessage<::fantasybit::SwapSentAck>(Arena*);
template<> ::fantasybit::TeamState* Arena::CreateMaybeMessage<::fantasybit::TeamState>(Arena*);
template<> ::fantasybit::TimeTransition* Arena::CreateMaybeMessage<::fantasybit::TimeTransition>(Arena*);
template<> ::fantasybit::Transaction* Arena::CreateMaybeMessage<::fantasybit::Transaction>(Arena*);
template<> ::fantasybit::TransferTrans* Arena::CreateMaybeMessage<::fantasybit::TransferTrans>(Arena*);
template<> ::fantasybit::TweetProof* Arena::CreateMaybeMessage<::fantasybit::TweetProof>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace fantasybit {

enum OutData_Type : int {
  OutData_Type_MYFANTASYNAME = 1,
  OutData_Type_SNAPSHOT = 2,
  OutData_Type_HEARTBEAT = 3
};
bool OutData_Type_IsValid(int value);
constexpr OutData_Type OutData_Type_Type_MIN = OutData_Type_MYFANTASYNAME;
constexpr OutData_Type OutData_Type_Type_MAX = OutData_Type_HEARTBEAT;
constexpr int OutData_Type_Type_ARRAYSIZE = OutData_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OutData_Type_descriptor();
template<typename T>
inline const std::string& OutData_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OutData_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OutData_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OutData_Type_descriptor(), enum_t_value);
}
inline bool OutData_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OutData_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OutData_Type>(
    OutData_Type_descriptor(), name, value);
}
enum InData_Type : int {
  InData_Type_MINENAME = 1,
  InData_Type_QUIT = 2,
  InData_Type_HEARTBEAT = 3,
  InData_Type_CONNECT = 4,
  InData_Type_MAKE_BLOCK = 5,
  InData_Type_NEWNAME = 6,
  InData_Type_PROJ = 7,
  InData_Type_DATA = 8
};
bool InData_Type_IsValid(int value);
constexpr InData_Type InData_Type_Type_MIN = InData_Type_MINENAME;
constexpr InData_Type InData_Type_Type_MAX = InData_Type_DATA;
constexpr int InData_Type_Type_ARRAYSIZE = InData_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* InData_Type_descriptor();
template<typename T>
inline const std::string& InData_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, InData_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function InData_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    InData_Type_descriptor(), enum_t_value);
}
inline bool InData_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, InData_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<InData_Type>(
    InData_Type_descriptor(), name, value);
}
enum NameProof_Type : int {
  NameProof_Type_POW = 1,
  NameProof_Type_TWEET = 2,
  NameProof_Type_ORACLE = 3,
  NameProof_Type_MASTER = 4
};
bool NameProof_Type_IsValid(int value);
constexpr NameProof_Type NameProof_Type_Type_MIN = NameProof_Type_POW;
constexpr NameProof_Type NameProof_Type_Type_MAX = NameProof_Type_MASTER;
constexpr int NameProof_Type_Type_ARRAYSIZE = NameProof_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NameProof_Type_descriptor();
template<typename T>
inline const std::string& NameProof_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NameProof_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NameProof_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NameProof_Type_descriptor(), enum_t_value);
}
inline bool NameProof_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NameProof_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NameProof_Type>(
    NameProof_Type_descriptor(), name, value);
}
enum BlockHeader_Type : int {
  BlockHeader_Type_NORMAL = 1,
  BlockHeader_Type_DATA = 2
};
bool BlockHeader_Type_IsValid(int value);
constexpr BlockHeader_Type BlockHeader_Type_Type_MIN = BlockHeader_Type_NORMAL;
constexpr BlockHeader_Type BlockHeader_Type_Type_MAX = BlockHeader_Type_DATA;
constexpr int BlockHeader_Type_Type_ARRAYSIZE = BlockHeader_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BlockHeader_Type_descriptor();
template<typename T>
inline const std::string& BlockHeader_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BlockHeader_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BlockHeader_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BlockHeader_Type_descriptor(), enum_t_value);
}
inline bool BlockHeader_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BlockHeader_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BlockHeader_Type>(
    BlockHeader_Type_descriptor(), name, value);
}
enum NodeRequest_Type : int {
  NodeRequest_Type_HANDSHAKE = 1,
  NodeRequest_Type_BLOCK_REQUEST = 2,
  NodeRequest_Type_HIGHT_REQUEST = 3,
  NodeRequest_Type_NAT_TEST = 4
};
bool NodeRequest_Type_IsValid(int value);
constexpr NodeRequest_Type NodeRequest_Type_Type_MIN = NodeRequest_Type_HANDSHAKE;
constexpr NodeRequest_Type NodeRequest_Type_Type_MAX = NodeRequest_Type_NAT_TEST;
constexpr int NodeRequest_Type_Type_ARRAYSIZE = NodeRequest_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NodeRequest_Type_descriptor();
template<typename T>
inline const std::string& NodeRequest_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NodeRequest_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NodeRequest_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NodeRequest_Type_descriptor(), enum_t_value);
}
inline bool NodeRequest_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NodeRequest_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NodeRequest_Type>(
    NodeRequest_Type_descriptor(), name, value);
}
enum Data_Type : int {
  Data_Type_SCHEDULE = 0,
  Data_Type_PLAYER = 1,
  Data_Type_GAME = 2,
  Data_Type_RESULT = 3,
  Data_Type_MESSAGE = 4
};
bool Data_Type_IsValid(int value);
constexpr Data_Type Data_Type_Type_MIN = Data_Type_SCHEDULE;
constexpr Data_Type Data_Type_Type_MAX = Data_Type_MESSAGE;
constexpr int Data_Type_Type_ARRAYSIZE = Data_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Data_Type_descriptor();
template<typename T>
inline const std::string& Data_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Data_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Data_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Data_Type_descriptor(), enum_t_value);
}
inline bool Data_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Data_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Data_Type>(
    Data_Type_descriptor(), name, value);
}
enum TeamState_State : int {
  TeamState_State_PREGAME = 1,
  TeamState_State_INGAME = 2
};
bool TeamState_State_IsValid(int value);
constexpr TeamState_State TeamState_State_State_MIN = TeamState_State_PREGAME;
constexpr TeamState_State TeamState_State_State_MAX = TeamState_State_INGAME;
constexpr int TeamState_State_State_ARRAYSIZE = TeamState_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TeamState_State_descriptor();
template<typename T>
inline const std::string& TeamState_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TeamState_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TeamState_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TeamState_State_descriptor(), enum_t_value);
}
inline bool TeamState_State_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TeamState_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TeamState_State>(
    TeamState_State_descriptor(), name, value);
}
enum DeltaData_Type : int {
  DeltaData_Type_SNAPSHOT = 2,
  DeltaData_Type_HEARTBEAT = 3
};
bool DeltaData_Type_IsValid(int value);
constexpr DeltaData_Type DeltaData_Type_Type_MIN = DeltaData_Type_SNAPSHOT;
constexpr DeltaData_Type DeltaData_Type_Type_MAX = DeltaData_Type_HEARTBEAT;
constexpr int DeltaData_Type_Type_ARRAYSIZE = DeltaData_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DeltaData_Type_descriptor();
template<typename T>
inline const std::string& DeltaData_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeltaData_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeltaData_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DeltaData_Type_descriptor(), enum_t_value);
}
inline bool DeltaData_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeltaData_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DeltaData_Type>(
    DeltaData_Type_descriptor(), name, value);
}
enum ExchangeOrder_Type : int {
  ExchangeOrder_Type_NEW = 1,
  ExchangeOrder_Type_CANCEL = 2,
  ExchangeOrder_Type_REPLACE = 3
};
bool ExchangeOrder_Type_IsValid(int value);
constexpr ExchangeOrder_Type ExchangeOrder_Type_Type_MIN = ExchangeOrder_Type_NEW;
constexpr ExchangeOrder_Type ExchangeOrder_Type_Type_MAX = ExchangeOrder_Type_REPLACE;
constexpr int ExchangeOrder_Type_Type_ARRAYSIZE = ExchangeOrder_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ExchangeOrder_Type_descriptor();
template<typename T>
inline const std::string& ExchangeOrder_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ExchangeOrder_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ExchangeOrder_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ExchangeOrder_Type_descriptor(), enum_t_value);
}
inline bool ExchangeOrder_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExchangeOrder_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ExchangeOrder_Type>(
    ExchangeOrder_Type_descriptor(), name, value);
}
enum TimeTransition_Type : int {
  TimeTransition_Type_TRADEOPEN = 2,
  TimeTransition_Type_TRADECLOSE = 3
};
bool TimeTransition_Type_IsValid(int value);
constexpr TimeTransition_Type TimeTransition_Type_Type_MIN = TimeTransition_Type_TRADEOPEN;
constexpr TimeTransition_Type TimeTransition_Type_Type_MAX = TimeTransition_Type_TRADECLOSE;
constexpr int TimeTransition_Type_Type_ARRAYSIZE = TimeTransition_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TimeTransition_Type_descriptor();
template<typename T>
inline const std::string& TimeTransition_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TimeTransition_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TimeTransition_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TimeTransition_Type_descriptor(), enum_t_value);
}
inline bool TimeTransition_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TimeTransition_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TimeTransition_Type>(
    TimeTransition_Type_descriptor(), name, value);
}
enum MyNameStatus : int {
  none = 1,
  notavil = 2,
  requested = 5,
  transaction_sent = 15,
  confirmed = 20
};
bool MyNameStatus_IsValid(int value);
constexpr MyNameStatus MyNameStatus_MIN = none;
constexpr MyNameStatus MyNameStatus_MAX = confirmed;
constexpr int MyNameStatus_ARRAYSIZE = MyNameStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MyNameStatus_descriptor();
template<typename T>
inline const std::string& MyNameStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MyNameStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MyNameStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MyNameStatus_descriptor(), enum_t_value);
}
inline bool MyNameStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MyNameStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MyNameStatus>(
    MyNameStatus_descriptor(), name, value);
}
enum TransType : int {
  NAME = 0,
  PROJECTION = 1,
  RESULT = 2,
  DATA = 3,
  PROJECTION_BLOCK = 4,
  MASTER_NAME = 5,
  TIME = 6,
  STAMPED = 7,
  EXCHANGE = 8,
  EXCHANGE_BLOCK = 9,
  TRANSFER = 10,
  SWAPASK = 11,
  SWAPBID = 12,
  SWAPFIL = 13,
  SWAPSENT = 14,
  PODP = 15,
  SWAPSENTACK = 16
};
bool TransType_IsValid(int value);
constexpr TransType TransType_MIN = NAME;
constexpr TransType TransType_MAX = SWAPSENTACK;
constexpr int TransType_ARRAYSIZE = TransType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TransType_descriptor();
template<typename T>
inline const std::string& TransType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TransType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TransType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TransType_descriptor(), enum_t_value);
}
inline bool TransType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TransType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TransType>(
    TransType_descriptor(), name, value);
}
enum TrType : int {
  SEASONSTART = 2,
  SEASONEND = 3,
  HEARTBEAT = 5,
  GAMESTART = 6,
  WEEKOVER = 7,
  TRADESESSIONSTART = 8,
  TRADESESSIONCLOSEANDPREOPEN = 9,
  PLAYOFFSTART = 10,
  SUPERBOWLEND = 12
};
bool TrType_IsValid(int value);
constexpr TrType TrType_MIN = SEASONSTART;
constexpr TrType TrType_MAX = SUPERBOWLEND;
constexpr int TrType_ARRAYSIZE = TrType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrType_descriptor();
template<typename T>
inline const std::string& TrType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TrType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TrType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TrType_descriptor(), enum_t_value);
}
inline bool TrType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TrType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TrType>(
    TrType_descriptor(), name, value);
}
// ===================================================================

class MyFantasyName PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.MyFantasyName) */ {
 public:
  inline MyFantasyName() : MyFantasyName(nullptr) {};
  virtual ~MyFantasyName();

  MyFantasyName(const MyFantasyName& from);
  MyFantasyName(MyFantasyName&& from) noexcept
    : MyFantasyName() {
    *this = ::std::move(from);
  }

  inline MyFantasyName& operator=(const MyFantasyName& from) {
    CopyFrom(from);
    return *this;
  }
  inline MyFantasyName& operator=(MyFantasyName&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MyFantasyName& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MyFantasyName* internal_default_instance() {
    return reinterpret_cast<const MyFantasyName*>(
               &_MyFantasyName_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MyFantasyName& a, MyFantasyName& b) {
    a.Swap(&b);
  }
  inline void Swap(MyFantasyName* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MyFantasyName* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MyFantasyName* New() const final {
    return CreateMaybeMessage<MyFantasyName>(nullptr);
  }

  MyFantasyName* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MyFantasyName>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MyFantasyName& from);
  void MergeFrom(const MyFantasyName& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MyFantasyName* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.MyFantasyName";
  }
  protected:
  explicit MyFantasyName(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ProtoData_2eproto);
    return ::descriptor_table_ProtoData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional .fantasybit.MyNameStatus status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::fantasybit::MyNameStatus status() const;
  void set_status(::fantasybit::MyNameStatus value);
  private:
  ::fantasybit::MyNameStatus _internal_status() const;
  void _internal_set_status(::fantasybit::MyNameStatus value);
  public:

  // @@protoc_insertion_point(class_scope:fantasybit.MyFantasyName)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  int status_;
  friend struct ::TableStruct_ProtoData_2eproto;
};
// -------------------------------------------------------------------

class FantasyPlayer PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.FantasyPlayer) */ {
 public:
  inline FantasyPlayer() : FantasyPlayer(nullptr) {};
  virtual ~FantasyPlayer();

  FantasyPlayer(const FantasyPlayer& from);
  FantasyPlayer(FantasyPlayer&& from) noexcept
    : FantasyPlayer() {
    *this = ::std::move(from);
  }

  inline FantasyPlayer& operator=(const FantasyPlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline FantasyPlayer& operator=(FantasyPlayer&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FantasyPlayer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FantasyPlayer* internal_default_instance() {
    return reinterpret_cast<const FantasyPlayer*>(
               &_FantasyPlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(FantasyPlayer& a, FantasyPlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(FantasyPlayer* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FantasyPlayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FantasyPlayer* New() const final {
    return CreateMaybeMessage<FantasyPlayer>(nullptr);
  }

  FantasyPlayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FantasyPlayer>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FantasyPlayer& from);
  void MergeFrom(const FantasyPlayer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FantasyPlayer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.FantasyPlayer";
  }
  protected:
  explicit FantasyPlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ProtoData_2eproto);
    return ::descriptor_table_ProtoData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 10,
    kBitsFieldNumber = 20,
  };
  // optional string name = 10;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional uint64 bits = 20;
  bool has_bits() const;
  private:
  bool _internal_has_bits() const;
  public:
  void clear_bits();
  ::PROTOBUF_NAMESPACE_ID::uint64 bits() const;
  void set_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_bits() const;
  void _internal_set_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:fantasybit.FantasyPlayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::uint64 bits_;
  friend struct ::TableStruct_ProtoData_2eproto;
};
// -------------------------------------------------------------------

class Secret PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.Secret) */ {
 public:
  inline Secret() : Secret(nullptr) {};
  virtual ~Secret();

  Secret(const Secret& from);
  Secret(Secret&& from) noexcept
    : Secret() {
    *this = ::std::move(from);
  }

  inline Secret& operator=(const Secret& from) {
    CopyFrom(from);
    return *this;
  }
  inline Secret& operator=(Secret&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Secret& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Secret* internal_default_instance() {
    return reinterpret_cast<const Secret*>(
               &_Secret_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Secret& a, Secret& b) {
    a.Swap(&b);
  }
  inline void Swap(Secret* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Secret* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Secret* New() const final {
    return CreateMaybeMessage<Secret>(nullptr);
  }

  Secret* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Secret>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Secret& from);
  void MergeFrom(const Secret& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Secret* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.Secret";
  }
  protected:
  explicit Secret(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ProtoData_2eproto);
    return ::descriptor_table_ProtoData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrivateKeyFieldNumber = 1,
    kMyfantasynameFieldNumber = 2,
    kNametranFieldNumber = 10,
  };
  // required string private_key = 1;
  bool has_private_key() const;
  private:
  bool _internal_has_private_key() const;
  public:
  void clear_private_key();
  const std::string& private_key() const;
  void set_private_key(const std::string& value);
  void set_private_key(std::string&& value);
  void set_private_key(const char* value);
  void set_private_key(const char* value, size_t size);
  std::string* mutable_private_key();
  std::string* release_private_key();
  void set_allocated_private_key(std::string* private_key);
  private:
  const std::string& _internal_private_key() const;
  void _internal_set_private_key(const std::string& value);
  std::string* _internal_mutable_private_key();
  public:

  // optional .fantasybit.MyFantasyName myfantasyname = 2;
  bool has_myfantasyname() const;
  private:
  bool _internal_has_myfantasyname() const;
  public:
  void clear_myfantasyname();
  const ::fantasybit::MyFantasyName& myfantasyname() const;
  ::fantasybit::MyFantasyName* release_myfantasyname();
  ::fantasybit::MyFantasyName* mutable_myfantasyname();
  void set_allocated_myfantasyname(::fantasybit::MyFantasyName* myfantasyname);
  private:
  const ::fantasybit::MyFantasyName& _internal_myfantasyname() const;
  ::fantasybit::MyFantasyName* _internal_mutable_myfantasyname();
  public:
  void unsafe_arena_set_allocated_myfantasyname(
      ::fantasybit::MyFantasyName* myfantasyname);
  ::fantasybit::MyFantasyName* unsafe_arena_release_myfantasyname();

  // optional .fantasybit.NameTrans nametran = 10;
  bool has_nametran() const;
  private:
  bool _internal_has_nametran() const;
  public:
  void clear_nametran();
  const ::fantasybit::NameTrans& nametran() const;
  ::fantasybit::NameTrans* release_nametran();
  ::fantasybit::NameTrans* mutable_nametran();
  void set_allocated_nametran(::fantasybit::NameTrans* nametran);
  private:
  const ::fantasybit::NameTrans& _internal_nametran() const;
  ::fantasybit::NameTrans* _internal_mutable_nametran();
  public:
  void unsafe_arena_set_allocated_nametran(
      ::fantasybit::NameTrans* nametran);
  ::fantasybit::NameTrans* unsafe_arena_release_nametran();

  // @@protoc_insertion_point(class_scope:fantasybit.Secret)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr private_key_;
  ::fantasybit::MyFantasyName* myfantasyname_;
  ::fantasybit::NameTrans* nametran_;
  friend struct ::TableStruct_ProtoData_2eproto;
};
// -------------------------------------------------------------------

class Secret2 PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.Secret2) */ {
 public:
  inline Secret2() : Secret2(nullptr) {};
  virtual ~Secret2();

  Secret2(const Secret2& from);
  Secret2(Secret2&& from) noexcept
    : Secret2() {
    *this = ::std::move(from);
  }

  inline Secret2& operator=(const Secret2& from) {
    CopyFrom(from);
    return *this;
  }
  inline Secret2& operator=(Secret2&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Secret2& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Secret2* internal_default_instance() {
    return reinterpret_cast<const Secret2*>(
               &_Secret2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Secret2& a, Secret2& b) {
    a.Swap(&b);
  }
  inline void Swap(Secret2* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Secret2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Secret2* New() const final {
    return CreateMaybeMessage<Secret2>(nullptr);
  }

  Secret2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Secret2>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Secret2& from);
  void MergeFrom(const Secret2& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Secret2* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.Secret2";
  }
  protected:
  explicit Secret2(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ProtoData_2eproto);
    return ::descriptor_table_ProtoData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrivateKeyFieldNumber = 1,
    kFantasyNameFieldNumber = 20,
    kPublicKeyFieldNumber = 30,
  };
  // optional string private_key = 1;
  bool has_private_key() const;
  private:
  bool _internal_has_private_key() const;
  public:
  void clear_private_key();
  const std::string& private_key() const;
  void set_private_key(const std::string& value);
  void set_private_key(std::string&& value);
  void set_private_key(const char* value);
  void set_private_key(const char* value, size_t size);
  std::string* mutable_private_key();
  std::string* release_private_key();
  void set_allocated_private_key(std::string* private_key);
  private:
  const std::string& _internal_private_key() const;
  void _internal_set_private_key(const std::string& value);
  std::string* _internal_mutable_private_key();
  public:

  // optional string fantasy_name = 20;
  bool has_fantasy_name() const;
  private:
  bool _internal_has_fantasy_name() const;
  public:
  void clear_fantasy_name();
  const std::string& fantasy_name() const;
  void set_fantasy_name(const std::string& value);
  void set_fantasy_name(std::string&& value);
  void set_fantasy_name(const char* value);
  void set_fantasy_name(const char* value, size_t size);
  std::string* mutable_fantasy_name();
  std::string* release_fantasy_name();
  void set_allocated_fantasy_name(std::string* fantasy_name);
  private:
  const std::string& _internal_fantasy_name() const;
  void _internal_set_fantasy_name(const std::string& value);
  std::string* _internal_mutable_fantasy_name();
  public:

  // optional string public_key = 30;
  bool has_public_key() const;
  private:
  bool _internal_has_public_key() const;
  public:
  void clear_public_key();
  const std::string& public_key() const;
  void set_public_key(const std::string& value);
  void set_public_key(std::string&& value);
  void set_public_key(const char* value);
  void set_public_key(const char* value, size_t size);
  std::string* mutable_public_key();
  std::string* release_public_key();
  void set_allocated_public_key(std::string* public_key);
  private:
  const std::string& _internal_public_key() const;
  void _internal_set_public_key(const std::string& value);
  std::string* _internal_mutable_public_key();
  public:

  // @@protoc_insertion_point(class_scope:fantasybit.Secret2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr private_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fantasy_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_;
  friend struct ::TableStruct_ProtoData_2eproto;
};
// -------------------------------------------------------------------

class Secret3 PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.Secret3) */ {
 public:
  inline Secret3() : Secret3(nullptr) {};
  virtual ~Secret3();

  Secret3(const Secret3& from);
  Secret3(Secret3&& from) noexcept
    : Secret3() {
    *this = ::std::move(from);
  }

  inline Secret3& operator=(const Secret3& from) {
    CopyFrom(from);
    return *this;
  }
  inline Secret3& operator=(Secret3&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Secret3& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Secret3* internal_default_instance() {
    return reinterpret_cast<const Secret3*>(
               &_Secret3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Secret3& a, Secret3& b) {
    a.Swap(&b);
  }
  inline void Swap(Secret3* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Secret3* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Secret3* New() const final {
    return CreateMaybeMessage<Secret3>(nullptr);
  }

  Secret3* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Secret3>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Secret3& from);
  void MergeFrom(const Secret3& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Secret3* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.Secret3";
  }
  protected:
  explicit Secret3(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ProtoData_2eproto);
    return ::descriptor_table_ProtoData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrivateKeyFieldNumber = 1,
    kMnemonicKeyFieldNumber = 3,
    kFantasyNameFieldNumber = 20,
    kPublicKeyFieldNumber = 30,
  };
  // optional string private_key = 1;
  bool has_private_key() const;
  private:
  bool _internal_has_private_key() const;
  public:
  void clear_private_key();
  const std::string& private_key() const;
  void set_private_key(const std::string& value);
  void set_private_key(std::string&& value);
  void set_private_key(const char* value);
  void set_private_key(const char* value, size_t size);
  std::string* mutable_private_key();
  std::string* release_private_key();
  void set_allocated_private_key(std::string* private_key);
  private:
  const std::string& _internal_private_key() const;
  void _internal_set_private_key(const std::string& value);
  std::string* _internal_mutable_private_key();
  public:

  // optional string mnemonic_key = 3;
  bool has_mnemonic_key() const;
  private:
  bool _internal_has_mnemonic_key() const;
  public:
  void clear_mnemonic_key();
  const std::string& mnemonic_key() const;
  void set_mnemonic_key(const std::string& value);
  void set_mnemonic_key(std::string&& value);
  void set_mnemonic_key(const char* value);
  void set_mnemonic_key(const char* value, size_t size);
  std::string* mutable_mnemonic_key();
  std::string* release_mnemonic_key();
  void set_allocated_mnemonic_key(std::string* mnemonic_key);
  private:
  const std::string& _internal_mnemonic_key() const;
  void _internal_set_mnemonic_key(const std::string& value);
  std::string* _internal_mutable_mnemonic_key();
  public:

  // optional string fantasy_name = 20;
  bool has_fantasy_name() const;
  private:
  bool _internal_has_fantasy_name() const;
  public:
  void clear_fantasy_name();
  const std::string& fantasy_name() const;
  void set_fantasy_name(const std::string& value);
  void set_fantasy_name(std::string&& value);
  void set_fantasy_name(const char* value);
  void set_fantasy_name(const char* value, size_t size);
  std::string* mutable_fantasy_name();
  std::string* release_fantasy_name();
  void set_allocated_fantasy_name(std::string* fantasy_name);
  private:
  const std::string& _internal_fantasy_name() const;
  void _internal_set_fantasy_name(const std::string& value);
  std::string* _internal_mutable_fantasy_name();
  public:

  // optional string public_key = 30;
  bool has_public_key() const;
  private:
  bool _internal_has_public_key() const;
  public:
  void clear_public_key();
  const std::string& public_key() const;
  void set_public_key(const std::string& value);
  void set_public_key(std::string&& value);
  void set_public_key(const char* value);
  void set_public_key(const char* value, size_t size);
  std::string* mutable_public_key();
  std::string* release_public_key();
  void set_allocated_public_key(std::string* public_key);
  private:
  const std::string& _internal_public_key() const;
  void _internal_set_public_key(const std::string& value);
  std::string* _internal_mutable_public_key();
  public:

  // @@protoc_insertion_point(class_scope:fantasybit.Secret3)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr private_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mnemonic_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fantasy_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_;
  friend struct ::TableStruct_ProtoData_2eproto;
};
// -------------------------------------------------------------------

class OutData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.OutData) */ {
 public:
  inline OutData() : OutData(nullptr) {};
  virtual ~OutData();

  OutData(const OutData& from);
  OutData(OutData&& from) noexcept
    : OutData() {
    *this = ::std::move(from);
  }

  inline OutData& operator=(const OutData& from) {
    CopyFrom(from);
    return *this;
  }
  inline OutData& operator=(OutData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OutData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OutData* internal_default_instance() {
    return reinterpret_cast<const OutData*>(
               &_OutData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(OutData& a, OutData& b) {
    a.Swap(&b);
  }
  inline void Swap(OutData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OutData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OutData* New() const final {
    return CreateMaybeMessage<OutData>(nullptr);
  }

  OutData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OutData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OutData& from);
  void MergeFrom(const OutData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OutData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.OutData";
  }
  protected:
  explicit OutData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ProtoData_2eproto);
    return ::descriptor_table_ProtoData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef OutData_Type Type;
  static constexpr Type MYFANTASYNAME =
    OutData_Type_MYFANTASYNAME;
  static constexpr Type SNAPSHOT =
    OutData_Type_SNAPSHOT;
  static constexpr Type HEARTBEAT =
    OutData_Type_HEARTBEAT;
  static inline bool Type_IsValid(int value) {
    return OutData_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    OutData_Type_Type_MIN;
  static constexpr Type Type_MAX =
    OutData_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    OutData_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return OutData_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return OutData_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return OutData_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMyfantasynameFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // optional .fantasybit.MyFantasyName myfantasyname = 2;
  bool has_myfantasyname() const;
  private:
  bool _internal_has_myfantasyname() const;
  public:
  void clear_myfantasyname();
  const ::fantasybit::MyFantasyName& myfantasyname() const;
  ::fantasybit::MyFantasyName* release_myfantasyname();
  ::fantasybit::MyFantasyName* mutable_myfantasyname();
  void set_allocated_myfantasyname(::fantasybit::MyFantasyName* myfantasyname);
  private:
  const ::fantasybit::MyFantasyName& _internal_myfantasyname() const;
  ::fantasybit::MyFantasyName* _internal_mutable_myfantasyname();
  public:
  void unsafe_arena_set_allocated_myfantasyname(
      ::fantasybit::MyFantasyName* myfantasyname);
  ::fantasybit::MyFantasyName* unsafe_arena_release_myfantasyname();

  // required .fantasybit.OutData.Type type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::fantasybit::OutData_Type type() const;
  void set_type(::fantasybit::OutData_Type value);
  private:
  ::fantasybit::OutData_Type _internal_type() const;
  void _internal_set_type(::fantasybit::OutData_Type value);
  public:

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(OutData)
  // @@protoc_insertion_point(class_scope:fantasybit.OutData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::fantasybit::MyFantasyName* myfantasyname_;
  int type_;
  friend struct ::TableStruct_ProtoData_2eproto;
};
// -------------------------------------------------------------------

class InData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.InData) */ {
 public:
  inline InData() : InData(nullptr) {};
  virtual ~InData();

  InData(const InData& from);
  InData(InData&& from) noexcept
    : InData() {
    *this = ::std::move(from);
  }

  inline InData& operator=(const InData& from) {
    CopyFrom(from);
    return *this;
  }
  inline InData& operator=(InData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InData* internal_default_instance() {
    return reinterpret_cast<const InData*>(
               &_InData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(InData& a, InData& b) {
    a.Swap(&b);
  }
  inline void Swap(InData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InData* New() const final {
    return CreateMaybeMessage<InData>(nullptr);
  }

  InData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InData& from);
  void MergeFrom(const InData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.InData";
  }
  protected:
  explicit InData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ProtoData_2eproto);
    return ::descriptor_table_ProtoData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef InData_Type Type;
  static constexpr Type MINENAME =
    InData_Type_MINENAME;
  static constexpr Type QUIT =
    InData_Type_QUIT;
  static constexpr Type HEARTBEAT =
    InData_Type_HEARTBEAT;
  static constexpr Type CONNECT =
    InData_Type_CONNECT;
  static constexpr Type MAKE_BLOCK =
    InData_Type_MAKE_BLOCK;
  static constexpr Type NEWNAME =
    InData_Type_NEWNAME;
  static constexpr Type PROJ =
    InData_Type_PROJ;
  static constexpr Type DATA =
    InData_Type_DATA;
  static inline bool Type_IsValid(int value) {
    return InData_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    InData_Type_Type_MIN;
  static constexpr Type Type_MAX =
    InData_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    InData_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return InData_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return InData_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return InData_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kData2FieldNumber = 3,
    kDataTransFieldNumber = 5,
    kNumFieldNumber = 4,
    kTypeFieldNumber = 1,
  };
  // optional string data = 2;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  void set_data(const std::string& value);
  void set_data(std::string&& value);
  void set_data(const char* value);
  void set_data(const char* value, size_t size);
  std::string* mutable_data();
  std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // optional string data2 = 3;
  bool has_data2() const;
  private:
  bool _internal_has_data2() const;
  public:
  void clear_data2();
  const std::string& data2() const;
  void set_data2(const std::string& value);
  void set_data2(std::string&& value);
  void set_data2(const char* value);
  void set_data2(const char* value, size_t size);
  std::string* mutable_data2();
  std::string* release_data2();
  void set_allocated_data2(std::string* data2);
  private:
  const std::string& _internal_data2() const;
  void _internal_set_data2(const std::string& value);
  std::string* _internal_mutable_data2();
  public:

  // optional .fantasybit.DataTransition data_trans = 5;
  bool has_data_trans() const;
  private:
  bool _internal_has_data_trans() const;
  public:
  void clear_data_trans();
  const ::fantasybit::DataTransition& data_trans() const;
  ::fantasybit::DataTransition* release_data_trans();
  ::fantasybit::DataTransition* mutable_data_trans();
  void set_allocated_data_trans(::fantasybit::DataTransition* data_trans);
  private:
  const ::fantasybit::DataTransition& _internal_data_trans() const;
  ::fantasybit::DataTransition* _internal_mutable_data_trans();
  public:
  void unsafe_arena_set_allocated_data_trans(
      ::fantasybit::DataTransition* data_trans);
  ::fantasybit::DataTransition* unsafe_arena_release_data_trans();

  // optional int32 num = 4;
  bool has_num() const;
  private:
  bool _internal_has_num() const;
  public:
  void clear_num();
  ::PROTOBUF_NAMESPACE_ID::int32 num() const;
  void set_num(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num() const;
  void _internal_set_num(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required .fantasybit.InData.Type type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::fantasybit::InData_Type type() const;
  void set_type(::fantasybit::InData_Type value);
  private:
  ::fantasybit::InData_Type _internal_type() const;
  void _internal_set_type(::fantasybit::InData_Type value);
  public:

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(InData)
  // @@protoc_insertion_point(class_scope:fantasybit.InData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data2_;
  ::fantasybit::DataTransition* data_trans_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_;
  int type_;
  friend struct ::TableStruct_ProtoData_2eproto;
};
// -------------------------------------------------------------------

class NameProof PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.NameProof) */ {
 public:
  inline NameProof() : NameProof(nullptr) {};
  virtual ~NameProof();

  NameProof(const NameProof& from);
  NameProof(NameProof&& from) noexcept
    : NameProof() {
    *this = ::std::move(from);
  }

  inline NameProof& operator=(const NameProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline NameProof& operator=(NameProof&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NameProof& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NameProof* internal_default_instance() {
    return reinterpret_cast<const NameProof*>(
               &_NameProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(NameProof& a, NameProof& b) {
    a.Swap(&b);
  }
  inline void Swap(NameProof* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NameProof* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NameProof* New() const final {
    return CreateMaybeMessage<NameProof>(nullptr);
  }

  NameProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NameProof>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NameProof& from);
  void MergeFrom(const NameProof& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NameProof* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.NameProof";
  }
  protected:
  explicit NameProof(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ProtoData_2eproto);
    return ::descriptor_table_ProtoData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef NameProof_Type Type;
  static constexpr Type POW =
    NameProof_Type_POW;
  static constexpr Type TWEET =
    NameProof_Type_TWEET;
  static constexpr Type ORACLE =
    NameProof_Type_ORACLE;
  static constexpr Type MASTER =
    NameProof_Type_MASTER;
  static inline bool Type_IsValid(int value) {
    return NameProof_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    NameProof_Type_Type_MIN;
  static constexpr Type Type_MAX =
    NameProof_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    NameProof_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return NameProof_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return NameProof_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return NameProof_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // optional .fantasybit.NameProof.Type type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::fantasybit::NameProof_Type type() const;
  void set_type(::fantasybit::NameProof_Type value);
  private:
  ::fantasybit::NameProof_Type _internal_type() const;
  void _internal_set_type(::fantasybit::NameProof_Type value);
  public:

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(NameProof)
  // @@protoc_insertion_point(class_scope:fantasybit.NameProof)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int type_;
  friend struct ::TableStruct_ProtoData_2eproto;
};
// -------------------------------------------------------------------

class TweetProof PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.TweetProof) */ {
 public:
  inline TweetProof() : TweetProof(nullptr) {};
  virtual ~TweetProof();

  TweetProof(const TweetProof& from);
  TweetProof(TweetProof&& from) noexcept
    : TweetProof() {
    *this = ::std::move(from);
  }

  inline TweetProof& operator=(const TweetProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline TweetProof& operator=(TweetProof&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TweetProof& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TweetProof* internal_default_instance() {
    return reinterpret_cast<const TweetProof*>(
               &_TweetProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TweetProof& a, TweetProof& b) {
    a.Swap(&b);
  }
  inline void Swap(TweetProof* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TweetProof* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TweetProof* New() const final {
    return CreateMaybeMessage<TweetProof>(nullptr);
  }

  TweetProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TweetProof>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TweetProof& from);
  void MergeFrom(const TweetProof& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TweetProof* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.TweetProof";
  }
  protected:
  explicit TweetProof(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ProtoData_2eproto);
    return ::descriptor_table_ProtoData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTweetFieldNumber = 10,
  };
  // optional string tweet = 10;
  bool has_tweet() const;
  private:
  bool _internal_has_tweet() const;
  public:
  void clear_tweet();
  const std::string& tweet() const;
  void set_tweet(const std::string& value);
  void set_tweet(std::string&& value);
  void set_tweet(const char* value);
  void set_tweet(const char* value, size_t size);
  std::string* mutable_tweet();
  std::string* release_tweet();
  void set_allocated_tweet(std::string* tweet);
  private:
  const std::string& _internal_tweet() const;
  void _internal_set_tweet(const std::string& value);
  std::string* _internal_mutable_tweet();
  public:

  static const int kTweetProofFieldNumber = 201;
  static ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::fantasybit::NameProof,
      ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::fantasybit::TweetProof >, 11, false >
    tweet_proof;
  // @@protoc_insertion_point(class_scope:fantasybit.TweetProof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tweet_;
  friend struct ::TableStruct_ProtoData_2eproto;
};
// -------------------------------------------------------------------

class MasterProof PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.MasterProof) */ {
 public:
  inline MasterProof() : MasterProof(nullptr) {};
  virtual ~MasterProof();

  MasterProof(const MasterProof& from);
  MasterProof(MasterProof&& from) noexcept
    : MasterProof() {
    *this = ::std::move(from);
  }

  inline MasterProof& operator=(const MasterProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline MasterProof& operator=(MasterProof&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MasterProof& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MasterProof* internal_default_instance() {
    return reinterpret_cast<const MasterProof*>(
               &_MasterProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(MasterProof& a, MasterProof& b) {
    a.Swap(&b);
  }
  inline void Swap(MasterProof* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MasterProof* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MasterProof* New() const final {
    return CreateMaybeMessage<MasterProof>(nullptr);
  }

  MasterProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MasterProof>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MasterProof& from);
  void MergeFrom(const MasterProof& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MasterProof* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.MasterProof";
  }
  protected:
  explicit MasterProof(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ProtoData_2eproto);
    return ::descriptor_table_ProtoData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSeasonFieldNumber = 10,
    kNewOracleNameFieldNumber = 66,
    kWeekFieldNumber = 20,
    kTimestampFieldNumber = 21,
  };
  // optional string season = 10;
  bool has_season() const;
  private:
  bool _internal_has_season() const;
  public:
  void clear_season();
  const std::string& season() const;
  void set_season(const std::string& value);
  void set_season(std::string&& value);
  void set_season(const char* value);
  void set_season(const char* value, size_t size);
  std::string* mutable_season();
  std::string* release_season();
  void set_allocated_season(std::string* season);
  private:
  const std::string& _internal_season() const;
  void _internal_set_season(const std::string& value);
  std::string* _internal_mutable_season();
  public:

  // optional .fantasybit.SignedTransaction new_oracle_name = 66;
  bool has_new_oracle_name() const;
  private:
  bool _internal_has_new_oracle_name() const;
  public:
  void clear_new_oracle_name();
  const ::fantasybit::SignedTransaction& new_oracle_name() const;
  ::fantasybit::SignedTransaction* release_new_oracle_name();
  ::fantasybit::SignedTransaction* mutable_new_oracle_name();
  void set_allocated_new_oracle_name(::fantasybit::SignedTransaction* new_oracle_name);
  private:
  const ::fantasybit::SignedTransaction& _internal_new_oracle_name() const;
  ::fantasybit::SignedTransaction* _internal_mutable_new_oracle_name();
  public:
  void unsafe_arena_set_allocated_new_oracle_name(
      ::fantasybit::SignedTransaction* new_oracle_name);
  ::fantasybit::SignedTransaction* unsafe_arena_release_new_oracle_name();

  // optional int32 week = 20;
  bool has_week() const;
  private:
  bool _internal_has_week() const;
  public:
  void clear_week();
  ::PROTOBUF_NAMESPACE_ID::int32 week() const;
  void set_week(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_week() const;
  void _internal_set_week(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 timestamp = 21;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int32 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  static const int kMasterProofFieldNumber = 401;
  static ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::fantasybit::NameProof,
      ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::fantasybit::MasterProof >, 11, false >
    master_proof;
  // @@protoc_insertion_point(class_scope:fantasybit.MasterProof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr season_;
  ::fantasybit::SignedTransaction* new_oracle_name_;
  ::PROTOBUF_NAMESPACE_ID::int32 week_;
  ::PROTOBUF_NAMESPACE_ID::int32 timestamp_;
  friend struct ::TableStruct_ProtoData_2eproto;
};
// -------------------------------------------------------------------

class Transaction PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.Transaction) */ {
 public:
  inline Transaction() : Transaction(nullptr) {};
  virtual ~Transaction();

  Transaction(const Transaction& from);
  Transaction(Transaction&& from) noexcept
    : Transaction() {
    *this = ::std::move(from);
  }

  inline Transaction& operator=(const Transaction& from) {
    CopyFrom(from);
    return *this;
  }
  inline Transaction& operator=(Transaction&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Transaction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Transaction* internal_default_instance() {
    return reinterpret_cast<const Transaction*>(
               &_Transaction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Transaction& a, Transaction& b) {
    a.Swap(&b);
  }
  inline void Swap(Transaction* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Transaction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Transaction* New() const final {
    return CreateMaybeMessage<Transaction>(nullptr);
  }

  Transaction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Transaction>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Transaction& from);
  void MergeFrom(const Transaction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Transaction* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.Transaction";
  }
  protected:
  explicit Transaction(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ProtoData_2eproto);
    return ::descriptor_table_ProtoData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kTypeFieldNumber = 2,
    kNonceFieldNumber = 10,
  };
  // optional int32 version = 1;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::int32 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_version() const;
  void _internal_set_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional .fantasybit.TransType type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::fantasybit::TransType type() const;
  void set_type(::fantasybit::TransType value);
  private:
  ::fantasybit::TransType _internal_type() const;
  void _internal_set_type(::fantasybit::TransType value);
  public:

  // optional uint64 nonce = 10;
  bool has_nonce() const;
  private:
  bool _internal_has_nonce() const;
  public:
  void clear_nonce();
  ::PROTOBUF_NAMESPACE_ID::uint64 nonce() const;
  void set_nonce(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_nonce() const;
  void _internal_set_nonce(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(Transaction)
  // @@protoc_insertion_point(class_scope:fantasybit.Transaction)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 version_;
  int type_;
  ::PROTOBUF_NAMESPACE_ID::uint64 nonce_;
  friend struct ::TableStruct_ProtoData_2eproto;
};
// -------------------------------------------------------------------

class NameTrans PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.NameTrans) */ {
 public:
  inline NameTrans() : NameTrans(nullptr) {};
  virtual ~NameTrans();

  NameTrans(const NameTrans& from);
  NameTrans(NameTrans&& from) noexcept
    : NameTrans() {
    *this = ::std::move(from);
  }

  inline NameTrans& operator=(const NameTrans& from) {
    CopyFrom(from);
    return *this;
  }
  inline NameTrans& operator=(NameTrans&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NameTrans& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NameTrans* internal_default_instance() {
    return reinterpret_cast<const NameTrans*>(
               &_NameTrans_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(NameTrans& a, NameTrans& b) {
    a.Swap(&b);
  }
  inline void Swap(NameTrans* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NameTrans* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NameTrans* New() const final {
    return CreateMaybeMessage<NameTrans>(nullptr);
  }

  NameTrans* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NameTrans>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NameTrans& from);
  void MergeFrom(const NameTrans& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NameTrans* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.NameTrans";
  }
  protected:
  explicit NameTrans(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ProtoData_2eproto);
    return ::descriptor_table_ProtoData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFantasyNameFieldNumber = 10,
    kPublicKeyFieldNumber = 20,
    kRecoveryKeyFieldNumber = 40,
    kMyAgentFieldNumber = 60,
    kProofFieldNumber = 30,
    kAmAgentFieldNumber = 50,
  };
  // optional string fantasy_name = 10;
  bool has_fantasy_name() const;
  private:
  bool _internal_has_fantasy_name() const;
  public:
  void clear_fantasy_name();
  const std::string& fantasy_name() const;
  void set_fantasy_name(const std::string& value);
  void set_fantasy_name(std::string&& value);
  void set_fantasy_name(const char* value);
  void set_fantasy_name(const char* value, size_t size);
  std::string* mutable_fantasy_name();
  std::string* release_fantasy_name();
  void set_allocated_fantasy_name(std::string* fantasy_name);
  private:
  const std::string& _internal_fantasy_name() const;
  void _internal_set_fantasy_name(const std::string& value);
  std::string* _internal_mutable_fantasy_name();
  public:

  // optional bytes public_key = 20;
  bool has_public_key() const;
  private:
  bool _internal_has_public_key() const;
  public:
  void clear_public_key();
  const std::string& public_key() const;
  void set_public_key(const std::string& value);
  void set_public_key(std::string&& value);
  void set_public_key(const char* value);
  void set_public_key(const void* value, size_t size);
  std::string* mutable_public_key();
  std::string* release_public_key();
  void set_allocated_public_key(std::string* public_key);
  private:
  const std::string& _internal_public_key() const;
  void _internal_set_public_key(const std::string& value);
  std::string* _internal_mutable_public_key();
  public:

  // optional bytes recovery_key = 40;
  bool has_recovery_key() const;
  private:
  bool _internal_has_recovery_key() const;
  public:
  void clear_recovery_key();
  const std::string& recovery_key() const;
  void set_recovery_key(const std::string& value);
  void set_recovery_key(std::string&& value);
  void set_recovery_key(const char* value);
  void set_recovery_key(const void* value, size_t size);
  std::string* mutable_recovery_key();
  std::string* release_recovery_key();
  void set_allocated_recovery_key(std::string* recovery_key);
  private:
  const std::string& _internal_recovery_key() const;
  void _internal_set_recovery_key(const std::string& value);
  std::string* _internal_mutable_recovery_key();
  public:

  // optional string my_agent = 60;
  bool has_my_agent() const;
  private:
  bool _internal_has_my_agent() const;
  public:
  void clear_my_agent();
  const std::string& my_agent() const;
  void set_my_agent(const std::string& value);
  void set_my_agent(std::string&& value);
  void set_my_agent(const char* value);
  void set_my_agent(const char* value, size_t size);
  std::string* mutable_my_agent();
  std::string* release_my_agent();
  void set_allocated_my_agent(std::string* my_agent);
  private:
  const std::string& _internal_my_agent() const;
  void _internal_set_my_agent(const std::string& value);
  std::string* _internal_mutable_my_agent();
  public:

  // optional .fantasybit.NameProof proof = 30;
  bool has_proof() const;
  private:
  bool _internal_has_proof() const;
  public:
  void clear_proof();
  const ::fantasybit::NameProof& proof() const;
  ::fantasybit::NameProof* release_proof();
  ::fantasybit::NameProof* mutable_proof();
  void set_allocated_proof(::fantasybit::NameProof* proof);
  private:
  const ::fantasybit::NameProof& _internal_proof() const;
  ::fantasybit::NameProof* _internal_mutable_proof();
  public:
  void unsafe_arena_set_allocated_proof(
      ::fantasybit::NameProof* proof);
  ::fantasybit::NameProof* unsafe_arena_release_proof();

  // optional bool am_agent = 50;
  bool has_am_agent() const;
  private:
  bool _internal_has_am_agent() const;
  public:
  void clear_am_agent();
  bool am_agent() const;
  void set_am_agent(bool value);
  private:
  bool _internal_am_agent() const;
  void _internal_set_am_agent(bool value);
  public:

  static const int kNameTransFieldNumber = 200;
  static ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::fantasybit::Transaction,
      ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::fantasybit::NameTrans >, 11, false >
    name_trans;
  // @@protoc_insertion_point(class_scope:fantasybit.NameTrans)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fantasy_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr recovery_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr my_agent_;
  ::fantasybit::NameProof* proof_;
  bool am_agent_;
  friend struct ::TableStruct_ProtoData_2eproto;
};
// -------------------------------------------------------------------

class TransferTrans PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.TransferTrans) */ {
 public:
  inline TransferTrans() : TransferTrans(nullptr) {};
  virtual ~TransferTrans();

  TransferTrans(const TransferTrans& from);
  TransferTrans(TransferTrans&& from) noexcept
    : TransferTrans() {
    *this = ::std::move(from);
  }

  inline TransferTrans& operator=(const TransferTrans& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransferTrans& operator=(TransferTrans&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TransferTrans& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransferTrans* internal_default_instance() {
    return reinterpret_cast<const TransferTrans*>(
               &_TransferTrans_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(TransferTrans& a, TransferTrans& b) {
    a.Swap(&b);
  }
  inline void Swap(TransferTrans* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransferTrans* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TransferTrans* New() const final {
    return CreateMaybeMessage<TransferTrans>(nullptr);
  }

  TransferTrans* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransferTrans>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TransferTrans& from);
  void MergeFrom(const TransferTrans& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransferTrans* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.TransferTrans";
  }
  protected:
  explicit TransferTrans(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ProtoData_2eproto);
    return ::descriptor_table_ProtoData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromFieldNumber = 10,
    kToFieldNumber = 20,
    kAmountFieldNumber = 30,
  };
  // optional string from = 10;
  bool has_from() const;
  private:
  bool _internal_has_from() const;
  public:
  void clear_from();
  const std::string& from() const;
  void set_from(const std::string& value);
  void set_from(std::string&& value);
  void set_from(const char* value);
  void set_from(const char* value, size_t size);
  std::string* mutable_from();
  std::string* release_from();
  void set_allocated_from(std::string* from);
  private:
  const std::string& _internal_from() const;
  void _internal_set_from(const std::string& value);
  std::string* _internal_mutable_from();
  public:

  // optional string to = 20;
  bool has_to() const;
  private:
  bool _internal_has_to() const;
  public:
  void clear_to();
  const std::string& to() const;
  void set_to(const std::string& value);
  void set_to(std::string&& value);
  void set_to(const char* value);
  void set_to(const char* value, size_t size);
  std::string* mutable_to();
  std::string* release_to();
  void set_allocated_to(std::string* to);
  private:
  const std::string& _internal_to() const;
  void _internal_set_to(const std::string& value);
  std::string* _internal_mutable_to();
  public:

  // optional uint64 amount = 30;
  bool has_amount() const;
  private:
  bool _internal_has_amount() const;
  public:
  void clear_amount();
  ::PROTOBUF_NAMESPACE_ID::uint64 amount() const;
  void set_amount(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_amount() const;
  void _internal_set_amount(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  static const int kTransferTranFieldNumber = 400;
  static ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::fantasybit::Transaction,
      ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::fantasybit::TransferTrans >, 11, false >
    transfer_tran;
  // @@protoc_insertion_point(class_scope:fantasybit.TransferTrans)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_;
  ::PROTOBUF_NAMESPACE_ID::uint64 amount_;
  friend struct ::TableStruct_ProtoData_2eproto;
};
// -------------------------------------------------------------------

class SignedTransaction PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.SignedTransaction) */ {
 public:
  inline SignedTransaction() : SignedTransaction(nullptr) {};
  virtual ~SignedTransaction();

  SignedTransaction(const SignedTransaction& from);
  SignedTransaction(SignedTransaction&& from) noexcept
    : SignedTransaction() {
    *this = ::std::move(from);
  }

  inline SignedTransaction& operator=(const SignedTransaction& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignedTransaction& operator=(SignedTransaction&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SignedTransaction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SignedTransaction* internal_default_instance() {
    return reinterpret_cast<const SignedTransaction*>(
               &_SignedTransaction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SignedTransaction& a, SignedTransaction& b) {
    a.Swap(&b);
  }
  inline void Swap(SignedTransaction* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignedTransaction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SignedTransaction* New() const final {
    return CreateMaybeMessage<SignedTransaction>(nullptr);
  }

  SignedTransaction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SignedTransaction>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SignedTransaction& from);
  void MergeFrom(const SignedTransaction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignedTransaction* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.SignedTransaction";
  }
  protected:
  explicit SignedTransaction(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ProtoData_2eproto);
    return ::descriptor_table_ProtoData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 20,
    kSigFieldNumber = 30,
    kFantasyNameFieldNumber = 40,
    kTransFieldNumber = 10,
  };
  // optional bytes id = 20;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const void* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional bytes sig = 30;
  bool has_sig() const;
  private:
  bool _internal_has_sig() const;
  public:
  void clear_sig();
  const std::string& sig() const;
  void set_sig(const std::string& value);
  void set_sig(std::string&& value);
  void set_sig(const char* value);
  void set_sig(const void* value, size_t size);
  std::string* mutable_sig();
  std::string* release_sig();
  void set_allocated_sig(std::string* sig);
  private:
  const std::string& _internal_sig() const;
  void _internal_set_sig(const std::string& value);
  std::string* _internal_mutable_sig();
  public:

  // optional string fantasy_name = 40;
  bool has_fantasy_name() const;
  private:
  bool _internal_has_fantasy_name() const;
  public:
  void clear_fantasy_name();
  const std::string& fantasy_name() const;
  void set_fantasy_name(const std::string& value);
  void set_fantasy_name(std::string&& value);
  void set_fantasy_name(const char* value);
  void set_fantasy_name(const char* value, size_t size);
  std::string* mutable_fantasy_name();
  std::string* release_fantasy_name();
  void set_allocated_fantasy_name(std::string* fantasy_name);
  private:
  const std::string& _internal_fantasy_name() const;
  void _internal_set_fantasy_name(const std::string& value);
  std::string* _internal_mutable_fantasy_name();
  public:

  // optional .fantasybit.Transaction trans = 10;
  bool has_trans() const;
  private:
  bool _internal_has_trans() const;
  public:
  void clear_trans();
  const ::fantasybit::Transaction& trans() const;
  ::fantasybit::Transaction* release_trans();
  ::fantasybit::Transaction* mutable_trans();
  void set_allocated_trans(::fantasybit::Transaction* trans);
  private:
  const ::fantasybit::Transaction& _internal_trans() const;
  ::fantasybit::Transaction* _internal_mutable_trans();
  public:
  void unsafe_arena_set_allocated_trans(
      ::fantasybit::Transaction* trans);
  ::fantasybit::Transaction* unsafe_arena_release_trans();

  // @@protoc_insertion_point(class_scope:fantasybit.SignedTransaction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sig_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fantasy_name_;
  ::fantasybit::Transaction* trans_;
  friend struct ::TableStruct_ProtoData_2eproto;
};
// -------------------------------------------------------------------

class BlockHeader PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.BlockHeader) */ {
 public:
  inline BlockHeader() : BlockHeader(nullptr) {};
  virtual ~BlockHeader();

  BlockHeader(const BlockHeader& from);
  BlockHeader(BlockHeader&& from) noexcept
    : BlockHeader() {
    *this = ::std::move(from);
  }

  inline BlockHeader& operator=(const BlockHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockHeader& operator=(BlockHeader&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BlockHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlockHeader* internal_default_instance() {
    return reinterpret_cast<const BlockHeader*>(
               &_BlockHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(BlockHeader& a, BlockHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockHeader* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BlockHeader* New() const final {
    return CreateMaybeMessage<BlockHeader>(nullptr);
  }

  BlockHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BlockHeader>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BlockHeader& from);
  void MergeFrom(const BlockHeader& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockHeader* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.BlockHeader";
  }
  protected:
  explicit BlockHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ProtoData_2eproto);
    return ::descriptor_table_ProtoData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef BlockHeader_Type Type;
  static constexpr Type NORMAL =
    BlockHeader_Type_NORMAL;
  static constexpr Type DATA =
    BlockHeader_Type_DATA;
  static inline bool Type_IsValid(int value) {
    return BlockHeader_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    BlockHeader_Type_Type_MIN;
  static constexpr Type Type_MAX =
    BlockHeader_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    BlockHeader_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return BlockHeader_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return BlockHeader_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return BlockHeader_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPrevIdFieldNumber = 20,
    kGeneratorPkFieldNumber = 30,
    kGeneratingSigFieldNumber = 40,
    kTransactionIdFieldNumber = 70,
    kVersionFieldNumber = 1,
    kNumFieldNumber = 10,
    kTimestampFieldNumber = 21,
    kBasetargetFieldNumber = 50,
    kBlocktypeFieldNumber = 60,
  };
  // optional bytes prev_id = 20;
  bool has_prev_id() const;
  private:
  bool _internal_has_prev_id() const;
  public:
  void clear_prev_id();
  const std::string& prev_id() const;
  void set_prev_id(const std::string& value);
  void set_prev_id(std::string&& value);
  void set_prev_id(const char* value);
  void set_prev_id(const void* value, size_t size);
  std::string* mutable_prev_id();
  std::string* release_prev_id();
  void set_allocated_prev_id(std::string* prev_id);
  private:
  const std::string& _internal_prev_id() const;
  void _internal_set_prev_id(const std::string& value);
  std::string* _internal_mutable_prev_id();
  public:

  // optional bytes generator_pk = 30;
  bool has_generator_pk() const;
  private:
  bool _internal_has_generator_pk() const;
  public:
  void clear_generator_pk();
  const std::string& generator_pk() const;
  void set_generator_pk(const std::string& value);
  void set_generator_pk(std::string&& value);
  void set_generator_pk(const char* value);
  void set_generator_pk(const void* value, size_t size);
  std::string* mutable_generator_pk();
  std::string* release_generator_pk();
  void set_allocated_generator_pk(std::string* generator_pk);
  private:
  const std::string& _internal_generator_pk() const;
  void _internal_set_generator_pk(const std::string& value);
  std::string* _internal_mutable_generator_pk();
  public:

  // optional bytes generating_sig = 40;
  bool has_generating_sig() const;
  private:
  bool _internal_has_generating_sig() const;
  public:
  void clear_generating_sig();
  const std::string& generating_sig() const;
  void set_generating_sig(const std::string& value);
  void set_generating_sig(std::string&& value);
  void set_generating_sig(const char* value);
  void set_generating_sig(const void* value, size_t size);
  std::string* mutable_generating_sig();
  std::string* release_generating_sig();
  void set_allocated_generating_sig(std::string* generating_sig);
  private:
  const std::string& _internal_generating_sig() const;
  void _internal_set_generating_sig(const std::string& value);
  std::string* _internal_mutable_generating_sig();
  public:

  // optional bytes transaction_id = 70;
  bool has_transaction_id() const;
  private:
  bool _internal_has_transaction_id() const;
  public:
  void clear_transaction_id();
  const std::string& transaction_id() const;
  void set_transaction_id(const std::string& value);
  void set_transaction_id(std::string&& value);
  void set_transaction_id(const char* value);
  void set_transaction_id(const void* value, size_t size);
  std::string* mutable_transaction_id();
  std::string* release_transaction_id();
  void set_allocated_transaction_id(std::string* transaction_id);
  private:
  const std::string& _internal_transaction_id() const;
  void _internal_set_transaction_id(const std::string& value);
  std::string* _internal_mutable_transaction_id();
  public:

  // optional int32 version = 1;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::int32 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_version() const;
  void _internal_set_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 num = 10;
  bool has_num() const;
  private:
  bool _internal_has_num() const;
  public:
  void clear_num();
  ::PROTOBUF_NAMESPACE_ID::int32 num() const;
  void set_num(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num() const;
  void _internal_set_num(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 timestamp = 21;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int32 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional uint64 basetarget = 50;
  bool has_basetarget() const;
  private:
  bool _internal_has_basetarget() const;
  public:
  void clear_basetarget();
  ::PROTOBUF_NAMESPACE_ID::uint64 basetarget() const;
  void set_basetarget(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_basetarget() const;
  void _internal_set_basetarget(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional .fantasybit.BlockHeader.Type blocktype = 60;
  bool has_blocktype() const;
  private:
  bool _internal_has_blocktype() const;
  public:
  void clear_blocktype();
  ::fantasybit::BlockHeader_Type blocktype() const;
  void set_blocktype(::fantasybit::BlockHeader_Type value);
  private:
  ::fantasybit::BlockHeader_Type _internal_blocktype() const;
  void _internal_set_blocktype(::fantasybit::BlockHeader_Type value);
  public:

  // @@protoc_insertion_point(class_scope:fantasybit.BlockHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prev_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr generator_pk_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr generating_sig_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transaction_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 version_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_;
  ::PROTOBUF_NAMESPACE_ID::int32 timestamp_;
  ::PROTOBUF_NAMESPACE_ID::uint64 basetarget_;
  int blocktype_;
  friend struct ::TableStruct_ProtoData_2eproto;
};
// -------------------------------------------------------------------

class SignedBlockHeader PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.SignedBlockHeader) */ {
 public:
  inline SignedBlockHeader() : SignedBlockHeader(nullptr) {};
  virtual ~SignedBlockHeader();

  SignedBlockHeader(const SignedBlockHeader& from);
  SignedBlockHeader(SignedBlockHeader&& from) noexcept
    : SignedBlockHeader() {
    *this = ::std::move(from);
  }

  inline SignedBlockHeader& operator=(const SignedBlockHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignedBlockHeader& operator=(SignedBlockHeader&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SignedBlockHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SignedBlockHeader* internal_default_instance() {
    return reinterpret_cast<const SignedBlockHeader*>(
               &_SignedBlockHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SignedBlockHeader& a, SignedBlockHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(SignedBlockHeader* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignedBlockHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SignedBlockHeader* New() const final {
    return CreateMaybeMessage<SignedBlockHeader>(nullptr);
  }

  SignedBlockHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SignedBlockHeader>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SignedBlockHeader& from);
  void MergeFrom(const SignedBlockHeader& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignedBlockHeader* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.SignedBlockHeader";
  }
  protected:
  explicit SignedBlockHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ProtoData_2eproto);
    return ::descriptor_table_ProtoData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSigFieldNumber = 30,
    kHeadFieldNumber = 10,
  };
  // optional string sig = 30;
  bool has_sig() const;
  private:
  bool _internal_has_sig() const;
  public:
  void clear_sig();
  const std::string& sig() const;
  void set_sig(const std::string& value);
  void set_sig(std::string&& value);
  void set_sig(const char* value);
  void set_sig(const char* value, size_t size);
  std::string* mutable_sig();
  std::string* release_sig();
  void set_allocated_sig(std::string* sig);
  private:
  const std::string& _internal_sig() const;
  void _internal_set_sig(const std::string& value);
  std::string* _internal_mutable_sig();
  public:

  // optional .fantasybit.BlockHeader head = 10;
  bool has_head() const;
  private:
  bool _internal_has_head() const;
  public:
  void clear_head();
  const ::fantasybit::BlockHeader& head() const;
  ::fantasybit::BlockHeader* release_head();
  ::fantasybit::BlockHeader* mutable_head();
  void set_allocated_head(::fantasybit::BlockHeader* head);
  private:
  const ::fantasybit::BlockHeader& _internal_head() const;
  ::fantasybit::BlockHeader* _internal_mutable_head();
  public:
  void unsafe_arena_set_allocated_head(
      ::fantasybit::BlockHeader* head);
  ::fantasybit::BlockHeader* unsafe_arena_release_head();

  // @@protoc_insertion_point(class_scope:fantasybit.SignedBlockHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sig_;
  ::fantasybit::BlockHeader* head_;
  friend struct ::TableStruct_ProtoData_2eproto;
};
// -------------------------------------------------------------------

class Block PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.Block) */ {
 public:
  inline Block() : Block(nullptr) {};
  virtual ~Block();

  Block(const Block& from);
  Block(Block&& from) noexcept
    : Block() {
    *this = ::std::move(from);
  }

  inline Block& operator=(const Block& from) {
    CopyFrom(from);
    return *this;
  }
  inline Block& operator=(Block&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Block& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Block* internal_default_instance() {
    return reinterpret_cast<const Block*>(
               &_Block_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Block& a, Block& b) {
    a.Swap(&b);
  }
  inline void Swap(Block* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Block* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Block* New() const final {
    return CreateMaybeMessage<Block>(nullptr);
  }

  Block* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Block>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Block& from);
  void MergeFrom(const Block& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Block* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.Block";
  }
  protected:
  explicit Block(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ProtoData_2eproto);
    return ::descriptor_table_ProtoData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignedTransactionsFieldNumber = 20,
    kSignedheadFieldNumber = 10,
  };
  // repeated .fantasybit.SignedTransaction signed_transactions = 20;
  int signed_transactions_size() const;
  private:
  int _internal_signed_transactions_size() const;
  public:
  void clear_signed_transactions();
  ::fantasybit::SignedTransaction* mutable_signed_transactions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fantasybit::SignedTransaction >*
      mutable_signed_transactions();
  private:
  const ::fantasybit::SignedTransaction& _internal_signed_transactions(int index) const;
  ::fantasybit::SignedTransaction* _internal_add_signed_transactions();
  public:
  const ::fantasybit::SignedTransaction& signed_transactions(int index) const;
  ::fantasybit::SignedTransaction* add_signed_transactions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fantasybit::SignedTransaction >&
      signed_transactions() const;

  // optional .fantasybit.SignedBlockHeader signedhead = 10;
  bool has_signedhead() const;
  private:
  bool _internal_has_signedhead() const;
  public:
  void clear_signedhead();
  const ::fantasybit::SignedBlockHeader& signedhead() const;
  ::fantasybit::SignedBlockHeader* release_signedhead();
  ::fantasybit::SignedBlockHeader* mutable_signedhead();
  void set_allocated_signedhead(::fantasybit::SignedBlockHeader* signedhead);
  private:
  const ::fantasybit::SignedBlockHeader& _internal_signedhead() const;
  ::fantasybit::SignedBlockHeader* _internal_mutable_signedhead();
  public:
  void unsafe_arena_set_allocated_signedhead(
      ::fantasybit::SignedBlockHeader* signedhead);
  ::fantasybit::SignedBlockHeader* unsafe_arena_release_signedhead();

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(Block)
  // @@protoc_insertion_point(class_scope:fantasybit.Block)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fantasybit::SignedTransaction > signed_transactions_;
  ::fantasybit::SignedBlockHeader* signedhead_;
  friend struct ::TableStruct_ProtoData_2eproto;
};
// -------------------------------------------------------------------

class NodeRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.NodeRequest) */ {
 public:
  inline NodeRequest() : NodeRequest(nullptr) {};
  virtual ~NodeRequest();

  NodeRequest(const NodeRequest& from);
  NodeRequest(NodeRequest&& from) noexcept
    : NodeRequest() {
    *this = ::std::move(from);
  }

  inline NodeRequest& operator=(const NodeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeRequest& operator=(NodeRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NodeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeRequest* internal_default_instance() {
    return reinterpret_cast<const NodeRequest*>(
               &_NodeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(NodeRequest& a, NodeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NodeRequest* New() const final {
    return CreateMaybeMessage<NodeRequest>(nullptr);
  }

  NodeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NodeRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NodeRequest& from);
  void MergeFrom(const NodeRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.NodeRequest";
  }
  protected:
  explicit NodeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ProtoData_2eproto);
    return ::descriptor_table_ProtoData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef NodeRequest_Type Type;
  static constexpr Type HANDSHAKE =
    NodeRequest_Type_HANDSHAKE;
  static constexpr Type BLOCK_REQUEST =
    NodeRequest_Type_BLOCK_REQUEST;
  static constexpr Type HIGHT_REQUEST =
    NodeRequest_Type_HIGHT_REQUEST;
  static constexpr Type NAT_TEST =
    NodeRequest_Type_NAT_TEST;
  static inline bool Type_IsValid(int value) {
    return NodeRequest_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    NodeRequest_Type_Type_MIN;
  static constexpr Type Type_MAX =
    NodeRequest_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    NodeRequest_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return NodeRequest_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return NodeRequest_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return NodeRequest_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMyipFieldNumber = 20,
    kMyhostFieldNumber = 40,
    kNumFieldNumber = 30,
    kTypeFieldNumber = 10,
  };
  // optional string myip = 20;
  bool has_myip() const;
  private:
  bool _internal_has_myip() const;
  public:
  void clear_myip();
  const std::string& myip() const;
  void set_myip(const std::string& value);
  void set_myip(std::string&& value);
  void set_myip(const char* value);
  void set_myip(const char* value, size_t size);
  std::string* mutable_myip();
  std::string* release_myip();
  void set_allocated_myip(std::string* myip);
  private:
  const std::string& _internal_myip() const;
  void _internal_set_myip(const std::string& value);
  std::string* _internal_mutable_myip();
  public:

  // optional string myhost = 40;
  bool has_myhost() const;
  private:
  bool _internal_has_myhost() const;
  public:
  void clear_myhost();
  const std::string& myhost() const;
  void set_myhost(const std::string& value);
  void set_myhost(std::string&& value);
  void set_myhost(const char* value);
  void set_myhost(const char* value, size_t size);
  std::string* mutable_myhost();
  std::string* release_myhost();
  void set_allocated_myhost(std::string* myhost);
  private:
  const std::string& _internal_myhost() const;
  void _internal_set_myhost(const std::string& value);
  std::string* _internal_mutable_myhost();
  public:

  // optional int32 num = 30;
  bool has_num() const;
  private:
  bool _internal_has_num() const;
  public:
  void clear_num();
  ::PROTOBUF_NAMESPACE_ID::int32 num() const;
  void set_num(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num() const;
  void _internal_set_num(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional .fantasybit.NodeRequest.Type type = 10;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::fantasybit::NodeRequest_Type type() const;
  void set_type(::fantasybit::NodeRequest_Type value);
  private:
  ::fantasybit::NodeRequest_Type _internal_type() const;
  void _internal_set_type(::fantasybit::NodeRequest_Type value);
  public:

  // @@protoc_insertion_point(class_scope:fantasybit.NodeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr myip_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr myhost_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_;
  int type_;
  friend struct ::TableStruct_ProtoData_2eproto;
};
// -------------------------------------------------------------------

class NodeReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.NodeReply) */ {
 public:
  inline NodeReply() : NodeReply(nullptr) {};
  virtual ~NodeReply();

  NodeReply(const NodeReply& from);
  NodeReply(NodeReply&& from) noexcept
    : NodeReply() {
    *this = ::std::move(from);
  }

  inline NodeReply& operator=(const NodeReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeReply& operator=(NodeReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NodeReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeReply* internal_default_instance() {
    return reinterpret_cast<const NodeReply*>(
               &_NodeReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(NodeReply& a, NodeReply& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NodeReply* New() const final {
    return CreateMaybeMessage<NodeReply>(nullptr);
  }

  NodeReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NodeReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NodeReply& from);
  void MergeFrom(const NodeReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.NodeReply";
  }
  protected:
  explicit NodeReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ProtoData_2eproto);
    return ::descriptor_table_ProtoData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpsFieldNumber = 20,
    kHightFieldNumber = 10,
  };
  // repeated string ips = 20;
  int ips_size() const;
  private:
  int _internal_ips_size() const;
  public:
  void clear_ips();
  const std::string& ips(int index) const;
  std::string* mutable_ips(int index);
  void set_ips(int index, const std::string& value);
  void set_ips(int index, std::string&& value);
  void set_ips(int index, const char* value);
  void set_ips(int index, const char* value, size_t size);
  std::string* add_ips();
  void add_ips(const std::string& value);
  void add_ips(std::string&& value);
  void add_ips(const char* value);
  void add_ips(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& ips() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_ips();
  private:
  const std::string& _internal_ips(int index) const;
  std::string* _internal_add_ips();
  public:

  // optional int32 hight = 10;
  bool has_hight() const;
  private:
  bool _internal_has_hight() const;
  public:
  void clear_hight();
  ::PROTOBUF_NAMESPACE_ID::int32 hight() const;
  void set_hight(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_hight() const;
  void _internal_set_hight(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:fantasybit.NodeReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> ips_;
  ::PROTOBUF_NAMESPACE_ID::int32 hight_;
  friend struct ::TableStruct_ProtoData_2eproto;
};
// -------------------------------------------------------------------

class FantasyPlayerPoints PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.FantasyPlayerPoints) */ {
 public:
  inline FantasyPlayerPoints() : FantasyPlayerPoints(nullptr) {};
  virtual ~FantasyPlayerPoints();

  FantasyPlayerPoints(const FantasyPlayerPoints& from);
  FantasyPlayerPoints(FantasyPlayerPoints&& from) noexcept
    : FantasyPlayerPoints() {
    *this = ::std::move(from);
  }

  inline FantasyPlayerPoints& operator=(const FantasyPlayerPoints& from) {
    CopyFrom(from);
    return *this;
  }
  inline FantasyPlayerPoints& operator=(FantasyPlayerPoints&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FantasyPlayerPoints& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FantasyPlayerPoints* internal_default_instance() {
    return reinterpret_cast<const FantasyPlayerPoints*>(
               &_FantasyPlayerPoints_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(FantasyPlayerPoints& a, FantasyPlayerPoints& b) {
    a.Swap(&b);
  }
  inline void Swap(FantasyPlayerPoints* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FantasyPlayerPoints* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FantasyPlayerPoints* New() const final {
    return CreateMaybeMessage<FantasyPlayerPoints>(nullptr);
  }

  FantasyPlayerPoints* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FantasyPlayerPoints>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FantasyPlayerPoints& from);
  void MergeFrom(const FantasyPlayerPoints& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FantasyPlayerPoints* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.FantasyPlayerPoints";
  }
  protected:
  explicit FantasyPlayerPoints(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ProtoData_2eproto);
    return ::descriptor_table_ProtoData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayeridFieldNumber = 30,
    kSeasonFieldNumber = 10,
    kWeekFieldNumber = 20,
    kPointsFieldNumber = 40,
    kResultFieldNumber = 50,
  };
  // optional string playerid = 30;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  const std::string& playerid() const;
  void set_playerid(const std::string& value);
  void set_playerid(std::string&& value);
  void set_playerid(const char* value);
  void set_playerid(const char* value, size_t size);
  std::string* mutable_playerid();
  std::string* release_playerid();
  void set_allocated_playerid(std::string* playerid);
  private:
  const std::string& _internal_playerid() const;
  void _internal_set_playerid(const std::string& value);
  std::string* _internal_mutable_playerid();
  public:

  // optional uint32 season = 10;
  bool has_season() const;
  private:
  bool _internal_has_season() const;
  public:
  void clear_season();
  ::PROTOBUF_NAMESPACE_ID::uint32 season() const;
  void set_season(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_season() const;
  void _internal_set_season(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 week = 20;
  bool has_week() const;
  private:
  bool _internal_has_week() const;
  public:
  void clear_week();
  ::PROTOBUF_NAMESPACE_ID::uint32 week() const;
  void set_week(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_week() const;
  void _internal_set_week(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional int32 points = 40;
  bool has_points() const;
  private:
  bool _internal_has_points() const;
  public:
  void clear_points();
  ::PROTOBUF_NAMESPACE_ID::int32 points() const;
  void set_points(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_points() const;
  void _internal_set_points(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional float result = 50;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  float result() const;
  void set_result(float value);
  private:
  float _internal_result() const;
  void _internal_set_result(float value);
  public:

  // @@protoc_insertion_point(class_scope:fantasybit.FantasyPlayerPoints)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr playerid_;
  ::PROTOBUF_NAMESPACE_ID::uint32 season_;
  ::PROTOBUF_NAMESPACE_ID::uint32 week_;
  ::PROTOBUF_NAMESPACE_ID::int32 points_;
  float result_;
  friend struct ::TableStruct_ProtoData_2eproto;
};
// -------------------------------------------------------------------

class ProjectionTrans PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.ProjectionTrans) */ {
 public:
  inline ProjectionTrans() : ProjectionTrans(nullptr) {};
  virtual ~ProjectionTrans();

  ProjectionTrans(const ProjectionTrans& from);
  ProjectionTrans(ProjectionTrans&& from) noexcept
    : ProjectionTrans() {
    *this = ::std::move(from);
  }

  inline ProjectionTrans& operator=(const ProjectionTrans& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProjectionTrans& operator=(ProjectionTrans&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ProjectionTrans& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProjectionTrans* internal_default_instance() {
    return reinterpret_cast<const ProjectionTrans*>(
               &_ProjectionTrans_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ProjectionTrans& a, ProjectionTrans& b) {
    a.Swap(&b);
  }
  inline void Swap(ProjectionTrans* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProjectionTrans* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProjectionTrans* New() const final {
    return CreateMaybeMessage<ProjectionTrans>(nullptr);
  }

  ProjectionTrans* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProjectionTrans>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ProjectionTrans& from);
  void MergeFrom(const ProjectionTrans& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProjectionTrans* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.ProjectionTrans";
  }
  protected:
  explicit ProjectionTrans(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ProtoData_2eproto);
    return ::descriptor_table_ProtoData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayeridFieldNumber = 30,
    kPointsFieldNumber = 40,
    kSeasonFieldNumber = 10,
    kWeekFieldNumber = 20,
  };
  // optional string playerid = 30;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  const std::string& playerid() const;
  void set_playerid(const std::string& value);
  void set_playerid(std::string&& value);
  void set_playerid(const char* value);
  void set_playerid(const char* value, size_t size);
  std::string* mutable_playerid();
  std::string* release_playerid();
  void set_allocated_playerid(std::string* playerid);
  private:
  const std::string& _internal_playerid() const;
  void _internal_set_playerid(const std::string& value);
  std::string* _internal_mutable_playerid();
  public:

  // optional int32 points = 40;
  bool has_points() const;
  private:
  bool _internal_has_points() const;
  public:
  void clear_points();
  ::PROTOBUF_NAMESPACE_ID::int32 points() const;
  void set_points(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_points() const;
  void _internal_set_points(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional uint32 season = 10;
  bool has_season() const;
  private:
  bool _internal_has_season() const;
  public:
  void clear_season();
  ::PROTOBUF_NAMESPACE_ID::uint32 season() const;
  void set_season(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_season() const;
  void _internal_set_season(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 week = 20;
  bool has_week() const;
  private:
  bool _internal_has_week() const;
  public:
  void clear_week();
  ::PROTOBUF_NAMESPACE_ID::uint32 week() const;
  void set_week(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_week() const;
  void _internal_set_week(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  static const int kProjTransFieldNumber = 201;
  static ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::fantasybit::Transaction,
      ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::fantasybit::ProjectionTrans >, 11, false >
    proj_trans;
  // @@protoc_insertion_point(class_scope:fantasybit.ProjectionTrans)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr playerid_;
  ::PROTOBUF_NAMESPACE_ID::int32 points_;
  ::PROTOBUF_NAMESPACE_ID::uint32 season_;
  ::PROTOBUF_NAMESPACE_ID::uint32 week_;
  friend struct ::TableStruct_ProtoData_2eproto;
};
// -------------------------------------------------------------------

class PlayerPoints PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.PlayerPoints) */ {
 public:
  inline PlayerPoints() : PlayerPoints(nullptr) {};
  virtual ~PlayerPoints();

  PlayerPoints(const PlayerPoints& from);
  PlayerPoints(PlayerPoints&& from) noexcept
    : PlayerPoints() {
    *this = ::std::move(from);
  }

  inline PlayerPoints& operator=(const PlayerPoints& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerPoints& operator=(PlayerPoints&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlayerPoints& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerPoints* internal_default_instance() {
    return reinterpret_cast<const PlayerPoints*>(
               &_PlayerPoints_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(PlayerPoints& a, PlayerPoints& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerPoints* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerPoints* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayerPoints* New() const final {
    return CreateMaybeMessage<PlayerPoints>(nullptr);
  }

  PlayerPoints* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayerPoints>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlayerPoints& from);
  void MergeFrom(const PlayerPoints& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerPoints* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.PlayerPoints";
  }
  protected:
  explicit PlayerPoints(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ProtoData_2eproto);
    return ::descriptor_table_ProtoData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayeridFieldNumber = 30,
    kPointsFieldNumber = 40,
  };
  // optional string playerid = 30;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  const std::string& playerid() const;
  void set_playerid(const std::string& value);
  void set_playerid(std::string&& value);
  void set_playerid(const char* value);
  void set_playerid(const char* value, size_t size);
  std::string* mutable_playerid();
  std::string* release_playerid();
  void set_allocated_playerid(std::string* playerid);
  private:
  const std::string& _internal_playerid() const;
  void _internal_set_playerid(const std::string& value);
  std::string* _internal_mutable_playerid();
  public:

  // optional int32 points = 40;
  bool has_points() const;
  private:
  bool _internal_has_points() const;
  public:
  void clear_points();
  ::PROTOBUF_NAMESPACE_ID::int32 points() const;
  void set_points(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_points() const;
  void _internal_set_points(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:fantasybit.PlayerPoints)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr playerid_;
  ::PROTOBUF_NAMESPACE_ID::int32 points_;
  friend struct ::TableStruct_ProtoData_2eproto;
};
// -------------------------------------------------------------------

class ProjectionTransBlock PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.ProjectionTransBlock) */ {
 public:
  inline ProjectionTransBlock() : ProjectionTransBlock(nullptr) {};
  virtual ~ProjectionTransBlock();

  ProjectionTransBlock(const ProjectionTransBlock& from);
  ProjectionTransBlock(ProjectionTransBlock&& from) noexcept
    : ProjectionTransBlock() {
    *this = ::std::move(from);
  }

  inline ProjectionTransBlock& operator=(const ProjectionTransBlock& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProjectionTransBlock& operator=(ProjectionTransBlock&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ProjectionTransBlock& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProjectionTransBlock* internal_default_instance() {
    return reinterpret_cast<const ProjectionTransBlock*>(
               &_ProjectionTransBlock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ProjectionTransBlock& a, ProjectionTransBlock& b) {
    a.Swap(&b);
  }
  inline void Swap(ProjectionTransBlock* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProjectionTransBlock* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProjectionTransBlock* New() const final {
    return CreateMaybeMessage<ProjectionTransBlock>(nullptr);
  }

  ProjectionTransBlock* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProjectionTransBlock>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ProjectionTransBlock& from);
  void MergeFrom(const ProjectionTransBlock& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProjectionTransBlock* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.ProjectionTransBlock";
  }
  protected:
  explicit ProjectionTransBlock(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ProtoData_2eproto);
    return ::descriptor_table_ProtoData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerPointsFieldNumber = 30,
    kSeasonFieldNumber = 10,
    kWeekFieldNumber = 20,
  };
  // repeated .fantasybit.PlayerPoints player_points = 30;
  int player_points_size() const;
  private:
  int _internal_player_points_size() const;
  public:
  void clear_player_points();
  ::fantasybit::PlayerPoints* mutable_player_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fantasybit::PlayerPoints >*
      mutable_player_points();
  private:
  const ::fantasybit::PlayerPoints& _internal_player_points(int index) const;
  ::fantasybit::PlayerPoints* _internal_add_player_points();
  public:
  const ::fantasybit::PlayerPoints& player_points(int index) const;
  ::fantasybit::PlayerPoints* add_player_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fantasybit::PlayerPoints >&
      player_points() const;

  // optional uint32 season = 10;
  bool has_season() const;
  private:
  bool _internal_has_season() const;
  public:
  void clear_season();
  ::PROTOBUF_NAMESPACE_ID::uint32 season() const;
  void set_season(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_season() const;
  void _internal_set_season(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 week = 20;
  bool has_week() const;
  private:
  bool _internal_has_week() const;
  public:
  void clear_week();
  ::PROTOBUF_NAMESPACE_ID::uint32 week() const;
  void set_week(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_week() const;
  void _internal_set_week(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  static const int kProjTransBlockFieldNumber = 211;
  static ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::fantasybit::Transaction,
      ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::fantasybit::ProjectionTransBlock >, 11, false >
    proj_trans_block;
  // @@protoc_insertion_point(class_scope:fantasybit.ProjectionTransBlock)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fantasybit::PlayerPoints > player_points_;
  ::PROTOBUF_NAMESPACE_ID::uint32 season_;
  ::PROTOBUF_NAMESPACE_ID::uint32 week_;
  friend struct ::TableStruct_ProtoData_2eproto;
};
// -------------------------------------------------------------------

class Data PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.Data) */ {
 public:
  inline Data() : Data(nullptr) {};
  virtual ~Data();

  Data(const Data& from);
  Data(Data&& from) noexcept
    : Data() {
    *this = ::std::move(from);
  }

  inline Data& operator=(const Data& from) {
    CopyFrom(from);
    return *this;
  }
  inline Data& operator=(Data&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Data& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Data* internal_default_instance() {
    return reinterpret_cast<const Data*>(
               &_Data_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(Data& a, Data& b) {
    a.Swap(&b);
  }
  inline void Swap(Data* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Data* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Data* New() const final {
    return CreateMaybeMessage<Data>(nullptr);
  }

  Data* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Data>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Data& from);
  void MergeFrom(const Data& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Data* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.Data";
  }
  protected:
  explicit Data(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ProtoData_2eproto);
    return ::descriptor_table_ProtoData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Data_Type Type;
  static constexpr Type SCHEDULE =
    Data_Type_SCHEDULE;
  static constexpr Type PLAYER =
    Data_Type_PLAYER;
  static constexpr Type GAME =
    Data_Type_GAME;
  static constexpr Type RESULT =
    Data_Type_RESULT;
  static constexpr Type MESSAGE =
    Data_Type_MESSAGE;
  static inline bool Type_IsValid(int value) {
    return Data_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    Data_Type_Type_MIN;
  static constexpr Type Type_MAX =
    Data_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    Data_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return Data_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return Data_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return Data_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 10,
    kTypeFieldNumber = 20,
  };
  // optional int32 version = 10;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::int32 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_version() const;
  void _internal_set_version(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional .fantasybit.Data.Type type = 20;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::fantasybit::Data_Type type() const;
  void set_type(::fantasybit::Data_Type value);
  private:
  ::fantasybit::Data_Type _internal_type() const;
  void _internal_set_type(::fantasybit::Data_Type value);
  public:

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(Data)
  // @@protoc_insertion_point(class_scope:fantasybit.Data)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 version_;
  int type_;
  friend struct ::TableStruct_ProtoData_2eproto;
};
// -------------------------------------------------------------------

class PlayerData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.PlayerData) */ {
 public:
  inline PlayerData() : PlayerData(nullptr) {};
  virtual ~PlayerData();

  PlayerData(const PlayerData& from);
  PlayerData(PlayerData&& from) noexcept
    : PlayerData() {
    *this = ::std::move(from);
  }

  inline PlayerData& operator=(const PlayerData& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerData& operator=(PlayerData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlayerData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerData* internal_default_instance() {
    return reinterpret_cast<const PlayerData*>(
               &_PlayerData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(PlayerData& a, PlayerData& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayerData* New() const final {
    return CreateMaybeMessage<PlayerData>(nullptr);
  }

  PlayerData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayerData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlayerData& from);
  void MergeFrom(const PlayerData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.PlayerData";
  }
  protected:
  explicit PlayerData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ProtoData_2eproto);
    return ::descriptor_table_ProtoData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayeridFieldNumber = 10,
    kPlayerBaseFieldNumber = 20,
    kPlayerStatusFieldNumber = 30,
    kPlayerGameStatusFieldNumber = 40,
  };
  // optional string playerid = 10;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  const std::string& playerid() const;
  void set_playerid(const std::string& value);
  void set_playerid(std::string&& value);
  void set_playerid(const char* value);
  void set_playerid(const char* value, size_t size);
  std::string* mutable_playerid();
  std::string* release_playerid();
  void set_allocated_playerid(std::string* playerid);
  private:
  const std::string& _internal_playerid() const;
  void _internal_set_playerid(const std::string& value);
  std::string* _internal_mutable_playerid();
  public:

  // optional .fantasybit.PlayerBase player_base = 20;
  bool has_player_base() const;
  private:
  bool _internal_has_player_base() const;
  public:
  void clear_player_base();
  const ::fantasybit::PlayerBase& player_base() const;
  ::fantasybit::PlayerBase* release_player_base();
  ::fantasybit::PlayerBase* mutable_player_base();
  void set_allocated_player_base(::fantasybit::PlayerBase* player_base);
  private:
  const ::fantasybit::PlayerBase& _internal_player_base() const;
  ::fantasybit::PlayerBase* _internal_mutable_player_base();
  public:
  void unsafe_arena_set_allocated_player_base(
      ::fantasybit::PlayerBase* player_base);
  ::fantasybit::PlayerBase* unsafe_arena_release_player_base();

  // optional .fantasybit.PlayerStatus player_status = 30;
  bool has_player_status() const;
  private:
  bool _internal_has_player_status() const;
  public:
  void clear_player_status();
  const ::fantasybit::PlayerStatus& player_status() const;
  ::fantasybit::PlayerStatus* release_player_status();
  ::fantasybit::PlayerStatus* mutable_player_status();
  void set_allocated_player_status(::fantasybit::PlayerStatus* player_status);
  private:
  const ::fantasybit::PlayerStatus& _internal_player_status() const;
  ::fantasybit::PlayerStatus* _internal_mutable_player_status();
  public:
  void unsafe_arena_set_allocated_player_status(
      ::fantasybit::PlayerStatus* player_status);
  ::fantasybit::PlayerStatus* unsafe_arena_release_player_status();

  // optional .fantasybit.PlayerGameStatus player_game_status = 40;
  bool has_player_game_status() const;
  private:
  bool _internal_has_player_game_status() const;
  public:
  void clear_player_game_status();
  ::fantasybit::PlayerGameStatus player_game_status() const;
  void set_player_game_status(::fantasybit::PlayerGameStatus value);
  private:
  ::fantasybit::PlayerGameStatus _internal_player_game_status() const;
  void _internal_set_player_game_status(::fantasybit::PlayerGameStatus value);
  public:

  static const int kPlayerDataFieldNumber = 101;
  static ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::fantasybit::Data,
      ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::fantasybit::PlayerData >, 11, false >
    player_data;
  // @@protoc_insertion_point(class_scope:fantasybit.PlayerData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr playerid_;
  ::fantasybit::PlayerBase* player_base_;
  ::fantasybit::PlayerStatus* player_status_;
  int player_game_status_;
  friend struct ::TableStruct_ProtoData_2eproto;
};
// -------------------------------------------------------------------

class GameData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.GameData) */ {
 public:
  inline GameData() : GameData(nullptr) {};
  virtual ~GameData();

  GameData(const GameData& from);
  GameData(GameData&& from) noexcept
    : GameData() {
    *this = ::std::move(from);
  }

  inline GameData& operator=(const GameData& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameData& operator=(GameData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameData* internal_default_instance() {
    return reinterpret_cast<const GameData*>(
               &_GameData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(GameData& a, GameData& b) {
    a.Swap(&b);
  }
  inline void Swap(GameData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameData* New() const final {
    return CreateMaybeMessage<GameData>(nullptr);
  }

  GameData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameData& from);
  void MergeFrom(const GameData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.GameData";
  }
  protected:
  explicit GameData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ProtoData_2eproto);
    return ::descriptor_table_ProtoData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameidFieldNumber = 10,
    kStatusFieldNumber = 20,
  };
  // optional string gameid = 10;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  const std::string& gameid() const;
  void set_gameid(const std::string& value);
  void set_gameid(std::string&& value);
  void set_gameid(const char* value);
  void set_gameid(const char* value, size_t size);
  std::string* mutable_gameid();
  std::string* release_gameid();
  void set_allocated_gameid(std::string* gameid);
  private:
  const std::string& _internal_gameid() const;
  void _internal_set_gameid(const std::string& value);
  std::string* _internal_mutable_gameid();
  public:

  // optional .fantasybit.GameStatus status = 20;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::fantasybit::GameStatus& status() const;
  ::fantasybit::GameStatus* release_status();
  ::fantasybit::GameStatus* mutable_status();
  void set_allocated_status(::fantasybit::GameStatus* status);
  private:
  const ::fantasybit::GameStatus& _internal_status() const;
  ::fantasybit::GameStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::fantasybit::GameStatus* status);
  ::fantasybit::GameStatus* unsafe_arena_release_status();

  static const int kGameDataFieldNumber = 111;
  static ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::fantasybit::Data,
      ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::fantasybit::GameData >, 11, false >
    game_data;
  // @@protoc_insertion_point(class_scope:fantasybit.GameData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gameid_;
  ::fantasybit::GameStatus* status_;
  friend struct ::TableStruct_ProtoData_2eproto;
};
// -------------------------------------------------------------------

class ResultData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.ResultData) */ {
 public:
  inline ResultData() : ResultData(nullptr) {};
  virtual ~ResultData();

  ResultData(const ResultData& from);
  ResultData(ResultData&& from) noexcept
    : ResultData() {
    *this = ::std::move(from);
  }

  inline ResultData& operator=(const ResultData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResultData& operator=(ResultData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ResultData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResultData* internal_default_instance() {
    return reinterpret_cast<const ResultData*>(
               &_ResultData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(ResultData& a, ResultData& b) {
    a.Swap(&b);
  }
  inline void Swap(ResultData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResultData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResultData* New() const final {
    return CreateMaybeMessage<ResultData>(nullptr);
  }

  ResultData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResultData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResultData& from);
  void MergeFrom(const ResultData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResultData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.ResultData";
  }
  protected:
  explicit ResultData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ProtoData_2eproto);
    return ::descriptor_table_ProtoData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameResultFieldNumber = 10,
  };
  // optional .fantasybit.GameResult game_result = 10;
  bool has_game_result() const;
  private:
  bool _internal_has_game_result() const;
  public:
  void clear_game_result();
  const ::fantasybit::GameResult& game_result() const;
  ::fantasybit::GameResult* release_game_result();
  ::fantasybit::GameResult* mutable_game_result();
  void set_allocated_game_result(::fantasybit::GameResult* game_result);
  private:
  const ::fantasybit::GameResult& _internal_game_result() const;
  ::fantasybit::GameResult* _internal_mutable_game_result();
  public:
  void unsafe_arena_set_allocated_game_result(
      ::fantasybit::GameResult* game_result);
  ::fantasybit::GameResult* unsafe_arena_release_game_result();

  static const int kResultDataFieldNumber = 202;
  static ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::fantasybit::Data,
      ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::fantasybit::ResultData >, 11, false >
    result_data;
  // @@protoc_insertion_point(class_scope:fantasybit.ResultData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::fantasybit::GameResult* game_result_;
  friend struct ::TableStruct_ProtoData_2eproto;
};
// -------------------------------------------------------------------

class ScheduleData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.ScheduleData) */ {
 public:
  inline ScheduleData() : ScheduleData(nullptr) {};
  virtual ~ScheduleData();

  ScheduleData(const ScheduleData& from);
  ScheduleData(ScheduleData&& from) noexcept
    : ScheduleData() {
    *this = ::std::move(from);
  }

  inline ScheduleData& operator=(const ScheduleData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScheduleData& operator=(ScheduleData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ScheduleData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScheduleData* internal_default_instance() {
    return reinterpret_cast<const ScheduleData*>(
               &_ScheduleData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ScheduleData& a, ScheduleData& b) {
    a.Swap(&b);
  }
  inline void Swap(ScheduleData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScheduleData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ScheduleData* New() const final {
    return CreateMaybeMessage<ScheduleData>(nullptr);
  }

  ScheduleData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ScheduleData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ScheduleData& from);
  void MergeFrom(const ScheduleData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScheduleData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.ScheduleData";
  }
  protected:
  explicit ScheduleData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ProtoData_2eproto);
    return ::descriptor_table_ProtoData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWeeklyFieldNumber = 10,
    kWeekFieldNumber = 1,
  };
  // optional .fantasybit.WeeklySchedule weekly = 10;
  bool has_weekly() const;
  private:
  bool _internal_has_weekly() const;
  public:
  void clear_weekly();
  const ::fantasybit::WeeklySchedule& weekly() const;
  ::fantasybit::WeeklySchedule* release_weekly();
  ::fantasybit::WeeklySchedule* mutable_weekly();
  void set_allocated_weekly(::fantasybit::WeeklySchedule* weekly);
  private:
  const ::fantasybit::WeeklySchedule& _internal_weekly() const;
  ::fantasybit::WeeklySchedule* _internal_mutable_weekly();
  public:
  void unsafe_arena_set_allocated_weekly(
      ::fantasybit::WeeklySchedule* weekly);
  ::fantasybit::WeeklySchedule* unsafe_arena_release_weekly();

  // optional int32 week = 1;
  bool has_week() const;
  private:
  bool _internal_has_week() const;
  public:
  void clear_week();
  ::PROTOBUF_NAMESPACE_ID::int32 week() const;
  void set_week(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_week() const;
  void _internal_set_week(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  static const int kScheduleDataFieldNumber = 302;
  static ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::fantasybit::Data,
      ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::fantasybit::ScheduleData >, 11, false >
    schedule_data;
  // @@protoc_insertion_point(class_scope:fantasybit.ScheduleData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::fantasybit::WeeklySchedule* weekly_;
  ::PROTOBUF_NAMESPACE_ID::int32 week_;
  friend struct ::TableStruct_ProtoData_2eproto;
};
// -------------------------------------------------------------------

class DataTransition PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.DataTransition) */ {
 public:
  inline DataTransition() : DataTransition(nullptr) {};
  virtual ~DataTransition();

  DataTransition(const DataTransition& from);
  DataTransition(DataTransition&& from) noexcept
    : DataTransition() {
    *this = ::std::move(from);
  }

  inline DataTransition& operator=(const DataTransition& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataTransition& operator=(DataTransition&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DataTransition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DataTransition* internal_default_instance() {
    return reinterpret_cast<const DataTransition*>(
               &_DataTransition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(DataTransition& a, DataTransition& b) {
    a.Swap(&b);
  }
  inline void Swap(DataTransition* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataTransition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DataTransition* New() const final {
    return CreateMaybeMessage<DataTransition>(nullptr);
  }

  DataTransition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DataTransition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DataTransition& from);
  void MergeFrom(const DataTransition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataTransition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.DataTransition";
  }
  protected:
  explicit DataTransition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ProtoData_2eproto);
    return ::descriptor_table_ProtoData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGamedataFieldNumber = 30,
    kDataFieldNumber = 40,
    kSeasonFieldNumber = 10,
    kWeekFieldNumber = 20,
    kTypeFieldNumber = 1,
  };
  // repeated .fantasybit.GameData gamedata = 30;
  int gamedata_size() const;
  private:
  int _internal_gamedata_size() const;
  public:
  void clear_gamedata();
  ::fantasybit::GameData* mutable_gamedata(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fantasybit::GameData >*
      mutable_gamedata();
  private:
  const ::fantasybit::GameData& _internal_gamedata(int index) const;
  ::fantasybit::GameData* _internal_add_gamedata();
  public:
  const ::fantasybit::GameData& gamedata(int index) const;
  ::fantasybit::GameData* add_gamedata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fantasybit::GameData >&
      gamedata() const;

  // repeated .fantasybit.Data data = 40;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  ::fantasybit::Data* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fantasybit::Data >*
      mutable_data();
  private:
  const ::fantasybit::Data& _internal_data(int index) const;
  ::fantasybit::Data* _internal_add_data();
  public:
  const ::fantasybit::Data& data(int index) const;
  ::fantasybit::Data* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fantasybit::Data >&
      data() const;

  // optional uint32 season = 10;
  bool has_season() const;
  private:
  bool _internal_has_season() const;
  public:
  void clear_season();
  ::PROTOBUF_NAMESPACE_ID::uint32 season() const;
  void set_season(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_season() const;
  void _internal_set_season(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 week = 20;
  bool has_week() const;
  private:
  bool _internal_has_week() const;
  public:
  void clear_week();
  ::PROTOBUF_NAMESPACE_ID::uint32 week() const;
  void set_week(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_week() const;
  void _internal_set_week(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional .fantasybit.TrType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::fantasybit::TrType type() const;
  void set_type(::fantasybit::TrType value);
  private:
  ::fantasybit::TrType _internal_type() const;
  void _internal_set_type(::fantasybit::TrType value);
  public:

  static const int kDataTransFieldNumber = 203;
  static ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::fantasybit::Transaction,
      ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::fantasybit::DataTransition >, 11, false >
    data_trans;
  // @@protoc_insertion_point(class_scope:fantasybit.DataTransition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fantasybit::GameData > gamedata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fantasybit::Data > data_;
  ::PROTOBUF_NAMESPACE_ID::uint32 season_;
  ::PROTOBUF_NAMESPACE_ID::uint32 week_;
  int type_;
  friend struct ::TableStruct_ProtoData_2eproto;
};
// -------------------------------------------------------------------

class TeamState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.TeamState) */ {
 public:
  inline TeamState() : TeamState(nullptr) {};
  virtual ~TeamState();

  TeamState(const TeamState& from);
  TeamState(TeamState&& from) noexcept
    : TeamState() {
    *this = ::std::move(from);
  }

  inline TeamState& operator=(const TeamState& from) {
    CopyFrom(from);
    return *this;
  }
  inline TeamState& operator=(TeamState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TeamState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TeamState* internal_default_instance() {
    return reinterpret_cast<const TeamState*>(
               &_TeamState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(TeamState& a, TeamState& b) {
    a.Swap(&b);
  }
  inline void Swap(TeamState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TeamState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TeamState* New() const final {
    return CreateMaybeMessage<TeamState>(nullptr);
  }

  TeamState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TeamState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TeamState& from);
  void MergeFrom(const TeamState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TeamState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.TeamState";
  }
  protected:
  explicit TeamState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ProtoData_2eproto);
    return ::descriptor_table_ProtoData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef TeamState_State State;
  static constexpr State PREGAME =
    TeamState_State_PREGAME;
  static constexpr State INGAME =
    TeamState_State_INGAME;
  static inline bool State_IsValid(int value) {
    return TeamState_State_IsValid(value);
  }
  static constexpr State State_MIN =
    TeamState_State_State_MIN;
  static constexpr State State_MAX =
    TeamState_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    TeamState_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return TeamState_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return TeamState_State_Name(enum_t_value);
  }
  static inline bool State_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      State* value) {
    return TeamState_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTeamidFieldNumber = 20,
    kWeekFieldNumber = 10,
    kStateFieldNumber = 1,
  };
  // optional string teamid = 20;
  bool has_teamid() const;
  private:
  bool _internal_has_teamid() const;
  public:
  void clear_teamid();
  const std::string& teamid() const;
  void set_teamid(const std::string& value);
  void set_teamid(std::string&& value);
  void set_teamid(const char* value);
  void set_teamid(const char* value, size_t size);
  std::string* mutable_teamid();
  std::string* release_teamid();
  void set_allocated_teamid(std::string* teamid);
  private:
  const std::string& _internal_teamid() const;
  void _internal_set_teamid(const std::string& value);
  std::string* _internal_mutable_teamid();
  public:

  // optional uint32 week = 10;
  bool has_week() const;
  private:
  bool _internal_has_week() const;
  public:
  void clear_week();
  ::PROTOBUF_NAMESPACE_ID::uint32 week() const;
  void set_week(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_week() const;
  void _internal_set_week(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional .fantasybit.TeamState.State state = 1;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  ::fantasybit::TeamState_State state() const;
  void set_state(::fantasybit::TeamState_State value);
  private:
  ::fantasybit::TeamState_State _internal_state() const;
  void _internal_set_state(::fantasybit::TeamState_State value);
  public:

  // @@protoc_insertion_point(class_scope:fantasybit.TeamState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr teamid_;
  ::PROTOBUF_NAMESPACE_ID::uint32 week_;
  int state_;
  friend struct ::TableStruct_ProtoData_2eproto;
};
// -------------------------------------------------------------------

class DeltaData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.DeltaData) */ {
 public:
  inline DeltaData() : DeltaData(nullptr) {};
  virtual ~DeltaData();

  DeltaData(const DeltaData& from);
  DeltaData(DeltaData&& from) noexcept
    : DeltaData() {
    *this = ::std::move(from);
  }

  inline DeltaData& operator=(const DeltaData& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeltaData& operator=(DeltaData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DeltaData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeltaData* internal_default_instance() {
    return reinterpret_cast<const DeltaData*>(
               &_DeltaData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(DeltaData& a, DeltaData& b) {
    a.Swap(&b);
  }
  inline void Swap(DeltaData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeltaData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeltaData* New() const final {
    return CreateMaybeMessage<DeltaData>(nullptr);
  }

  DeltaData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeltaData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DeltaData& from);
  void MergeFrom(const DeltaData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeltaData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.DeltaData";
  }
  protected:
  explicit DeltaData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ProtoData_2eproto);
    return ::descriptor_table_ProtoData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef DeltaData_Type Type;
  static constexpr Type SNAPSHOT =
    DeltaData_Type_SNAPSHOT;
  static constexpr Type HEARTBEAT =
    DeltaData_Type_HEARTBEAT;
  static inline bool Type_IsValid(int value) {
    return DeltaData_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    DeltaData_Type_Type_MIN;
  static constexpr Type Type_MAX =
    DeltaData_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    DeltaData_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return DeltaData_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return DeltaData_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return DeltaData_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMyfantasynameFieldNumber = 2,
    kTeamstatesFieldNumber = 20,
    kDatasFieldNumber = 30,
    kPlayersFieldNumber = 40,
    kGlobalstateFieldNumber = 10,
    kTypeFieldNumber = 1,
  };
  // repeated .fantasybit.MyFantasyName myfantasyname = 2;
  int myfantasyname_size() const;
  private:
  int _internal_myfantasyname_size() const;
  public:
  void clear_myfantasyname();
  ::fantasybit::MyFantasyName* mutable_myfantasyname(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fantasybit::MyFantasyName >*
      mutable_myfantasyname();
  private:
  const ::fantasybit::MyFantasyName& _internal_myfantasyname(int index) const;
  ::fantasybit::MyFantasyName* _internal_add_myfantasyname();
  public:
  const ::fantasybit::MyFantasyName& myfantasyname(int index) const;
  ::fantasybit::MyFantasyName* add_myfantasyname();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fantasybit::MyFantasyName >&
      myfantasyname() const;

  // repeated .fantasybit.TeamState teamstates = 20;
  int teamstates_size() const;
  private:
  int _internal_teamstates_size() const;
  public:
  void clear_teamstates();
  ::fantasybit::TeamState* mutable_teamstates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fantasybit::TeamState >*
      mutable_teamstates();
  private:
  const ::fantasybit::TeamState& _internal_teamstates(int index) const;
  ::fantasybit::TeamState* _internal_add_teamstates();
  public:
  const ::fantasybit::TeamState& teamstates(int index) const;
  ::fantasybit::TeamState* add_teamstates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fantasybit::TeamState >&
      teamstates() const;

  // repeated .fantasybit.Data datas = 30;
  int datas_size() const;
  private:
  int _internal_datas_size() const;
  public:
  void clear_datas();
  ::fantasybit::Data* mutable_datas(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fantasybit::Data >*
      mutable_datas();
  private:
  const ::fantasybit::Data& _internal_datas(int index) const;
  ::fantasybit::Data* _internal_add_datas();
  public:
  const ::fantasybit::Data& datas(int index) const;
  ::fantasybit::Data* add_datas();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fantasybit::Data >&
      datas() const;

  // repeated .fantasybit.FantasyPlayer players = 40;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::fantasybit::FantasyPlayer* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fantasybit::FantasyPlayer >*
      mutable_players();
  private:
  const ::fantasybit::FantasyPlayer& _internal_players(int index) const;
  ::fantasybit::FantasyPlayer* _internal_add_players();
  public:
  const ::fantasybit::FantasyPlayer& players(int index) const;
  ::fantasybit::FantasyPlayer* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fantasybit::FantasyPlayer >&
      players() const;

  // optional .fantasybit.GlobalState globalstate = 10;
  bool has_globalstate() const;
  private:
  bool _internal_has_globalstate() const;
  public:
  void clear_globalstate();
  const ::fantasybit::GlobalState& globalstate() const;
  ::fantasybit::GlobalState* release_globalstate();
  ::fantasybit::GlobalState* mutable_globalstate();
  void set_allocated_globalstate(::fantasybit::GlobalState* globalstate);
  private:
  const ::fantasybit::GlobalState& _internal_globalstate() const;
  ::fantasybit::GlobalState* _internal_mutable_globalstate();
  public:
  void unsafe_arena_set_allocated_globalstate(
      ::fantasybit::GlobalState* globalstate);
  ::fantasybit::GlobalState* unsafe_arena_release_globalstate();

  // optional .fantasybit.DeltaData.Type type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::fantasybit::DeltaData_Type type() const;
  void set_type(::fantasybit::DeltaData_Type value);
  private:
  ::fantasybit::DeltaData_Type _internal_type() const;
  void _internal_set_type(::fantasybit::DeltaData_Type value);
  public:

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(DeltaData)
  // @@protoc_insertion_point(class_scope:fantasybit.DeltaData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fantasybit::MyFantasyName > myfantasyname_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fantasybit::TeamState > teamstates_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fantasybit::Data > datas_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fantasybit::FantasyPlayer > players_;
  ::fantasybit::GlobalState* globalstate_;
  int type_;
  friend struct ::TableStruct_ProtoData_2eproto;
};
// -------------------------------------------------------------------

class MessageData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.MessageData) */ {
 public:
  inline MessageData() : MessageData(nullptr) {};
  virtual ~MessageData();

  MessageData(const MessageData& from);
  MessageData(MessageData&& from) noexcept
    : MessageData() {
    *this = ::std::move(from);
  }

  inline MessageData& operator=(const MessageData& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageData& operator=(MessageData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MessageData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MessageData* internal_default_instance() {
    return reinterpret_cast<const MessageData*>(
               &_MessageData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(MessageData& a, MessageData& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MessageData* New() const final {
    return CreateMaybeMessage<MessageData>(nullptr);
  }

  MessageData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MessageData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MessageData& from);
  void MergeFrom(const MessageData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.MessageData";
  }
  protected:
  explicit MessageData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ProtoData_2eproto);
    return ::descriptor_table_ProtoData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 10,
    kGtFieldNumber = 20,
    kLtFieldNumber = 30,
  };
  // optional string msg = 10;
  bool has_msg() const;
  private:
  bool _internal_has_msg() const;
  public:
  void clear_msg();
  const std::string& msg() const;
  void set_msg(const std::string& value);
  void set_msg(std::string&& value);
  void set_msg(const char* value);
  void set_msg(const char* value, size_t size);
  std::string* mutable_msg();
  std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // optional int32 gt = 20;
  bool has_gt() const;
  private:
  bool _internal_has_gt() const;
  public:
  void clear_gt();
  ::PROTOBUF_NAMESPACE_ID::int32 gt() const;
  void set_gt(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_gt() const;
  void _internal_set_gt(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 lt = 30;
  bool has_lt() const;
  private:
  bool _internal_has_lt() const;
  public:
  void clear_lt();
  ::PROTOBUF_NAMESPACE_ID::int32 lt() const;
  void set_lt(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_lt() const;
  void _internal_set_lt(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  static const int kMessageDataFieldNumber = 404;
  static ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::fantasybit::Data,
      ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::fantasybit::MessageData >, 11, false >
    message_data;
  // @@protoc_insertion_point(class_scope:fantasybit.MessageData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  ::PROTOBUF_NAMESPACE_ID::int32 gt_;
  ::PROTOBUF_NAMESPACE_ID::int32 lt_;
  friend struct ::TableStruct_ProtoData_2eproto;
};
// -------------------------------------------------------------------

class StampedTrans PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.StampedTrans) */ {
 public:
  inline StampedTrans() : StampedTrans(nullptr) {};
  virtual ~StampedTrans();

  StampedTrans(const StampedTrans& from);
  StampedTrans(StampedTrans&& from) noexcept
    : StampedTrans() {
    *this = ::std::move(from);
  }

  inline StampedTrans& operator=(const StampedTrans& from) {
    CopyFrom(from);
    return *this;
  }
  inline StampedTrans& operator=(StampedTrans&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StampedTrans& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StampedTrans* internal_default_instance() {
    return reinterpret_cast<const StampedTrans*>(
               &_StampedTrans_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(StampedTrans& a, StampedTrans& b) {
    a.Swap(&b);
  }
  inline void Swap(StampedTrans* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StampedTrans* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StampedTrans* New() const final {
    return CreateMaybeMessage<StampedTrans>(nullptr);
  }

  StampedTrans* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StampedTrans>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StampedTrans& from);
  void MergeFrom(const StampedTrans& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StampedTrans* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.StampedTrans";
  }
  protected:
  explicit StampedTrans(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ProtoData_2eproto);
    return ::descriptor_table_ProtoData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignedOrigFieldNumber = 30,
    kTimestampFieldNumber = 10,
    kSeqnumFieldNumber = 20,
    kPrevseqFieldNumber = 21,
  };
  // optional .fantasybit.SignedTransaction signed_orig = 30;
  bool has_signed_orig() const;
  private:
  bool _internal_has_signed_orig() const;
  public:
  void clear_signed_orig();
  const ::fantasybit::SignedTransaction& signed_orig() const;
  ::fantasybit::SignedTransaction* release_signed_orig();
  ::fantasybit::SignedTransaction* mutable_signed_orig();
  void set_allocated_signed_orig(::fantasybit::SignedTransaction* signed_orig);
  private:
  const ::fantasybit::SignedTransaction& _internal_signed_orig() const;
  ::fantasybit::SignedTransaction* _internal_mutable_signed_orig();
  public:
  void unsafe_arena_set_allocated_signed_orig(
      ::fantasybit::SignedTransaction* signed_orig);
  ::fantasybit::SignedTransaction* unsafe_arena_release_signed_orig();

  // optional uint64 timestamp = 10;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional int32 seqnum = 20;
  bool has_seqnum() const;
  private:
  bool _internal_has_seqnum() const;
  public:
  void clear_seqnum();
  ::PROTOBUF_NAMESPACE_ID::int32 seqnum() const;
  void set_seqnum(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_seqnum() const;
  void _internal_set_seqnum(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 prevseq = 21;
  bool has_prevseq() const;
  private:
  bool _internal_has_prevseq() const;
  public:
  void clear_prevseq();
  ::PROTOBUF_NAMESPACE_ID::int32 prevseq() const;
  void set_prevseq(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_prevseq() const;
  void _internal_set_prevseq(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  static const int kStampedTransFieldNumber = 300;
  static ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::fantasybit::Transaction,
      ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::fantasybit::StampedTrans >, 11, false >
    stamped_trans;
  // @@protoc_insertion_point(class_scope:fantasybit.StampedTrans)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::fantasybit::SignedTransaction* signed_orig_;
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp_;
  ::PROTOBUF_NAMESPACE_ID::int32 seqnum_;
  ::PROTOBUF_NAMESPACE_ID::int32 prevseq_;
  friend struct ::TableStruct_ProtoData_2eproto;
};
// -------------------------------------------------------------------

class ExchangeOrder PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.ExchangeOrder) */ {
 public:
  inline ExchangeOrder() : ExchangeOrder(nullptr) {};
  virtual ~ExchangeOrder();

  ExchangeOrder(const ExchangeOrder& from);
  ExchangeOrder(ExchangeOrder&& from) noexcept
    : ExchangeOrder() {
    *this = ::std::move(from);
  }

  inline ExchangeOrder& operator=(const ExchangeOrder& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExchangeOrder& operator=(ExchangeOrder&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ExchangeOrder& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExchangeOrder* internal_default_instance() {
    return reinterpret_cast<const ExchangeOrder*>(
               &_ExchangeOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(ExchangeOrder& a, ExchangeOrder& b) {
    a.Swap(&b);
  }
  inline void Swap(ExchangeOrder* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExchangeOrder* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExchangeOrder* New() const final {
    return CreateMaybeMessage<ExchangeOrder>(nullptr);
  }

  ExchangeOrder* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExchangeOrder>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ExchangeOrder& from);
  void MergeFrom(const ExchangeOrder& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExchangeOrder* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.ExchangeOrder";
  }
  protected:
  explicit ExchangeOrder(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ProtoData_2eproto);
    return ::descriptor_table_ProtoData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ExchangeOrder_Type Type;
  static constexpr Type NEW =
    ExchangeOrder_Type_NEW;
  static constexpr Type CANCEL =
    ExchangeOrder_Type_CANCEL;
  static constexpr Type REPLACE =
    ExchangeOrder_Type_REPLACE;
  static inline bool Type_IsValid(int value) {
    return ExchangeOrder_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    ExchangeOrder_Type_Type_MIN;
  static constexpr Type Type_MAX =
    ExchangeOrder_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    ExchangeOrder_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return ExchangeOrder_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return ExchangeOrder_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return ExchangeOrder_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPlayeridFieldNumber = 40,
    kSymbolFieldNumber = 120,
    kCoreFieldNumber = 50,
    kFutcontractFieldNumber = 110,
    kCancelOrefFieldNumber = 100,
    kTypeFieldNumber = 10,
  };
  // optional string playerid = 40;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  const std::string& playerid() const;
  void set_playerid(const std::string& value);
  void set_playerid(std::string&& value);
  void set_playerid(const char* value);
  void set_playerid(const char* value, size_t size);
  std::string* mutable_playerid();
  std::string* release_playerid();
  void set_allocated_playerid(std::string* playerid);
  private:
  const std::string& _internal_playerid() const;
  void _internal_set_playerid(const std::string& value);
  std::string* _internal_mutable_playerid();
  public:

  // optional string symbol = 120;
  bool has_symbol() const;
  private:
  bool _internal_has_symbol() const;
  public:
  void clear_symbol();
  const std::string& symbol() const;
  void set_symbol(const std::string& value);
  void set_symbol(std::string&& value);
  void set_symbol(const char* value);
  void set_symbol(const char* value, size_t size);
  std::string* mutable_symbol();
  std::string* release_symbol();
  void set_allocated_symbol(std::string* symbol);
  private:
  const std::string& _internal_symbol() const;
  void _internal_set_symbol(const std::string& value);
  std::string* _internal_mutable_symbol();
  public:

  // optional .fantasybit.OrderCore core = 50;
  bool has_core() const;
  private:
  bool _internal_has_core() const;
  public:
  void clear_core();
  const ::fantasybit::OrderCore& core() const;
  ::fantasybit::OrderCore* release_core();
  ::fantasybit::OrderCore* mutable_core();
  void set_allocated_core(::fantasybit::OrderCore* core);
  private:
  const ::fantasybit::OrderCore& _internal_core() const;
  ::fantasybit::OrderCore* _internal_mutable_core();
  public:
  void unsafe_arena_set_allocated_core(
      ::fantasybit::OrderCore* core);
  ::fantasybit::OrderCore* unsafe_arena_release_core();

  // optional .fantasybit.FutContract futcontract = 110;
  bool has_futcontract() const;
  private:
  bool _internal_has_futcontract() const;
  public:
  void clear_futcontract();
  const ::fantasybit::FutContract& futcontract() const;
  ::fantasybit::FutContract* release_futcontract();
  ::fantasybit::FutContract* mutable_futcontract();
  void set_allocated_futcontract(::fantasybit::FutContract* futcontract);
  private:
  const ::fantasybit::FutContract& _internal_futcontract() const;
  ::fantasybit::FutContract* _internal_mutable_futcontract();
  public:
  void unsafe_arena_set_allocated_futcontract(
      ::fantasybit::FutContract* futcontract);
  ::fantasybit::FutContract* unsafe_arena_release_futcontract();

  // optional int32 cancel_oref = 100;
  bool has_cancel_oref() const;
  private:
  bool _internal_has_cancel_oref() const;
  public:
  void clear_cancel_oref();
  ::PROTOBUF_NAMESPACE_ID::int32 cancel_oref() const;
  void set_cancel_oref(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_cancel_oref() const;
  void _internal_set_cancel_oref(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional .fantasybit.ExchangeOrder.Type type = 10;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::fantasybit::ExchangeOrder_Type type() const;
  void set_type(::fantasybit::ExchangeOrder_Type value);
  private:
  ::fantasybit::ExchangeOrder_Type _internal_type() const;
  void _internal_set_type(::fantasybit::ExchangeOrder_Type value);
  public:

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(ExchangeOrder)
  static const int kExchangeOrderFieldNumber = 310;
  static ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::fantasybit::Transaction,
      ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::fantasybit::ExchangeOrder >, 11, false >
    exchange_order;
  // @@protoc_insertion_point(class_scope:fantasybit.ExchangeOrder)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr playerid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr symbol_;
  ::fantasybit::OrderCore* core_;
  ::fantasybit::FutContract* futcontract_;
  ::PROTOBUF_NAMESPACE_ID::int32 cancel_oref_;
  int type_;
  friend struct ::TableStruct_ProtoData_2eproto;
};
// -------------------------------------------------------------------

class OrderUnique PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.OrderUnique) */ {
 public:
  inline OrderUnique() : OrderUnique(nullptr) {};
  virtual ~OrderUnique();

  OrderUnique(const OrderUnique& from);
  OrderUnique(OrderUnique&& from) noexcept
    : OrderUnique() {
    *this = ::std::move(from);
  }

  inline OrderUnique& operator=(const OrderUnique& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderUnique& operator=(OrderUnique&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OrderUnique& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OrderUnique* internal_default_instance() {
    return reinterpret_cast<const OrderUnique*>(
               &_OrderUnique_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(OrderUnique& a, OrderUnique& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderUnique* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderUnique* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OrderUnique* New() const final {
    return CreateMaybeMessage<OrderUnique>(nullptr);
  }

  OrderUnique* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OrderUnique>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OrderUnique& from);
  void MergeFrom(const OrderUnique& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderUnique* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.OrderUnique";
  }
  protected:
  explicit OrderUnique(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ProtoData_2eproto);
    return ::descriptor_table_ProtoData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicKeyFieldNumber = 10,
    kPlayeridFieldNumber = 50,
    kSeasonFieldNumber = 20,
    kWeekFieldNumber = 30,
    kBuysideFieldNumber = 40,
    kPriceFieldNumber = 70,
  };
  // optional string public_key = 10;
  bool has_public_key() const;
  private:
  bool _internal_has_public_key() const;
  public:
  void clear_public_key();
  const std::string& public_key() const;
  void set_public_key(const std::string& value);
  void set_public_key(std::string&& value);
  void set_public_key(const char* value);
  void set_public_key(const char* value, size_t size);
  std::string* mutable_public_key();
  std::string* release_public_key();
  void set_allocated_public_key(std::string* public_key);
  private:
  const std::string& _internal_public_key() const;
  void _internal_set_public_key(const std::string& value);
  std::string* _internal_mutable_public_key();
  public:

  // optional string playerid = 50;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  const std::string& playerid() const;
  void set_playerid(const std::string& value);
  void set_playerid(std::string&& value);
  void set_playerid(const char* value);
  void set_playerid(const char* value, size_t size);
  std::string* mutable_playerid();
  std::string* release_playerid();
  void set_allocated_playerid(std::string* playerid);
  private:
  const std::string& _internal_playerid() const;
  void _internal_set_playerid(const std::string& value);
  std::string* _internal_mutable_playerid();
  public:

  // optional uint32 season = 20;
  bool has_season() const;
  private:
  bool _internal_has_season() const;
  public:
  void clear_season();
  ::PROTOBUF_NAMESPACE_ID::uint32 season() const;
  void set_season(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_season() const;
  void _internal_set_season(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 week = 30;
  bool has_week() const;
  private:
  bool _internal_has_week() const;
  public:
  void clear_week();
  ::PROTOBUF_NAMESPACE_ID::uint32 week() const;
  void set_week(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_week() const;
  void _internal_set_week(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional bool buyside = 40;
  bool has_buyside() const;
  private:
  bool _internal_has_buyside() const;
  public:
  void clear_buyside();
  bool buyside() const;
  void set_buyside(bool value);
  private:
  bool _internal_buyside() const;
  void _internal_set_buyside(bool value);
  public:

  // optional int32 price = 70;
  bool has_price() const;
  private:
  bool _internal_has_price() const;
  public:
  void clear_price();
  ::PROTOBUF_NAMESPACE_ID::int32 price() const;
  void set_price(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_price() const;
  void _internal_set_price(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:fantasybit.OrderUnique)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr playerid_;
  ::PROTOBUF_NAMESPACE_ID::uint32 season_;
  ::PROTOBUF_NAMESPACE_ID::uint32 week_;
  bool buyside_;
  ::PROTOBUF_NAMESPACE_ID::int32 price_;
  friend struct ::TableStruct_ProtoData_2eproto;
};
// -------------------------------------------------------------------

class OrderDeets PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.OrderDeets) */ {
 public:
  inline OrderDeets() : OrderDeets(nullptr) {};
  virtual ~OrderDeets();

  OrderDeets(const OrderDeets& from);
  OrderDeets(OrderDeets&& from) noexcept
    : OrderDeets() {
    *this = ::std::move(from);
  }

  inline OrderDeets& operator=(const OrderDeets& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderDeets& operator=(OrderDeets&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OrderDeets& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OrderDeets* internal_default_instance() {
    return reinterpret_cast<const OrderDeets*>(
               &_OrderDeets_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(OrderDeets& a, OrderDeets& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderDeets* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderDeets* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OrderDeets* New() const final {
    return CreateMaybeMessage<OrderDeets>(nullptr);
  }

  OrderDeets* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OrderDeets>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OrderDeets& from);
  void MergeFrom(const OrderDeets& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderDeets* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.OrderDeets";
  }
  protected:
  explicit OrderDeets(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ProtoData_2eproto);
    return ::descriptor_table_ProtoData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOidFieldNumber = 10,
    kOrderFieldNumber = 20,
    kSizeFieldNumber = 30,
  };
  // optional bytes oid = 10;
  bool has_oid() const;
  private:
  bool _internal_has_oid() const;
  public:
  void clear_oid();
  const std::string& oid() const;
  void set_oid(const std::string& value);
  void set_oid(std::string&& value);
  void set_oid(const char* value);
  void set_oid(const void* value, size_t size);
  std::string* mutable_oid();
  std::string* release_oid();
  void set_allocated_oid(std::string* oid);
  private:
  const std::string& _internal_oid() const;
  void _internal_set_oid(const std::string& value);
  std::string* _internal_mutable_oid();
  public:

  // optional .fantasybit.OrderUnique order = 20;
  bool has_order() const;
  private:
  bool _internal_has_order() const;
  public:
  void clear_order();
  const ::fantasybit::OrderUnique& order() const;
  ::fantasybit::OrderUnique* release_order();
  ::fantasybit::OrderUnique* mutable_order();
  void set_allocated_order(::fantasybit::OrderUnique* order);
  private:
  const ::fantasybit::OrderUnique& _internal_order() const;
  ::fantasybit::OrderUnique* _internal_mutable_order();
  public:
  void unsafe_arena_set_allocated_order(
      ::fantasybit::OrderUnique* order);
  ::fantasybit::OrderUnique* unsafe_arena_release_order();

  // optional int32 size = 30;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::int32 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_size() const;
  void _internal_set_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:fantasybit.OrderDeets)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oid_;
  ::fantasybit::OrderUnique* order_;
  ::PROTOBUF_NAMESPACE_ID::int32 size_;
  friend struct ::TableStruct_ProtoData_2eproto;
};
// -------------------------------------------------------------------

class InsideUnique PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.InsideUnique) */ {
 public:
  inline InsideUnique() : InsideUnique(nullptr) {};
  virtual ~InsideUnique();

  InsideUnique(const InsideUnique& from);
  InsideUnique(InsideUnique&& from) noexcept
    : InsideUnique() {
    *this = ::std::move(from);
  }

  inline InsideUnique& operator=(const InsideUnique& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsideUnique& operator=(InsideUnique&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InsideUnique& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InsideUnique* internal_default_instance() {
    return reinterpret_cast<const InsideUnique*>(
               &_InsideUnique_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(InsideUnique& a, InsideUnique& b) {
    a.Swap(&b);
  }
  inline void Swap(InsideUnique* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsideUnique* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InsideUnique* New() const final {
    return CreateMaybeMessage<InsideUnique>(nullptr);
  }

  InsideUnique* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InsideUnique>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InsideUnique& from);
  void MergeFrom(const InsideUnique& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsideUnique* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.InsideUnique";
  }
  protected:
  explicit InsideUnique(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ProtoData_2eproto);
    return ::descriptor_table_ProtoData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicKeyFieldNumber = 10,
    kOidFieldNumber = 11,
    kPlayeridFieldNumber = 50,
    kOrderFieldNumber = 20,
    kPriceFieldNumber = 70,
    kSizeFieldNumber = 30,
    kBuysideFieldNumber = 40,
  };
  // optional string public_key = 10;
  bool has_public_key() const;
  private:
  bool _internal_has_public_key() const;
  public:
  void clear_public_key();
  const std::string& public_key() const;
  void set_public_key(const std::string& value);
  void set_public_key(std::string&& value);
  void set_public_key(const char* value);
  void set_public_key(const char* value, size_t size);
  std::string* mutable_public_key();
  std::string* release_public_key();
  void set_allocated_public_key(std::string* public_key);
  private:
  const std::string& _internal_public_key() const;
  void _internal_set_public_key(const std::string& value);
  std::string* _internal_mutable_public_key();
  public:

  // optional bytes oid = 11;
  bool has_oid() const;
  private:
  bool _internal_has_oid() const;
  public:
  void clear_oid();
  const std::string& oid() const;
  void set_oid(const std::string& value);
  void set_oid(std::string&& value);
  void set_oid(const char* value);
  void set_oid(const void* value, size_t size);
  std::string* mutable_oid();
  std::string* release_oid();
  void set_allocated_oid(std::string* oid);
  private:
  const std::string& _internal_oid() const;
  void _internal_set_oid(const std::string& value);
  std::string* _internal_mutable_oid();
  public:

  // optional string playerid = 50;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  const std::string& playerid() const;
  void set_playerid(const std::string& value);
  void set_playerid(std::string&& value);
  void set_playerid(const char* value);
  void set_playerid(const char* value, size_t size);
  std::string* mutable_playerid();
  std::string* release_playerid();
  void set_allocated_playerid(std::string* playerid);
  private:
  const std::string& _internal_playerid() const;
  void _internal_set_playerid(const std::string& value);
  std::string* _internal_mutable_playerid();
  public:

  // optional .fantasybit.OrderUnique order = 20;
  bool has_order() const;
  private:
  bool _internal_has_order() const;
  public:
  void clear_order();
  const ::fantasybit::OrderUnique& order() const;
  ::fantasybit::OrderUnique* release_order();
  ::fantasybit::OrderUnique* mutable_order();
  void set_allocated_order(::fantasybit::OrderUnique* order);
  private:
  const ::fantasybit::OrderUnique& _internal_order() const;
  ::fantasybit::OrderUnique* _internal_mutable_order();
  public:
  void unsafe_arena_set_allocated_order(
      ::fantasybit::OrderUnique* order);
  ::fantasybit::OrderUnique* unsafe_arena_release_order();

  // optional int32 price = 70;
  bool has_price() const;
  private:
  bool _internal_has_price() const;
  public:
  void clear_price();
  ::PROTOBUF_NAMESPACE_ID::int32 price() const;
  void set_price(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_price() const;
  void _internal_set_price(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 size = 30;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::int32 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_size() const;
  void _internal_set_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional bool buyside = 40;
  bool has_buyside() const;
  private:
  bool _internal_has_buyside() const;
  public:
  void clear_buyside();
  bool buyside() const;
  void set_buyside(bool value);
  private:
  bool _internal_buyside() const;
  void _internal_set_buyside(bool value);
  public:

  // @@protoc_insertion_point(class_scope:fantasybit.InsideUnique)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr playerid_;
  ::fantasybit::OrderUnique* order_;
  ::PROTOBUF_NAMESPACE_ID::int32 price_;
  ::PROTOBUF_NAMESPACE_ID::int32 size_;
  bool buyside_;
  friend struct ::TableStruct_ProtoData_2eproto;
};
// -------------------------------------------------------------------

class TimeTransition PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.TimeTransition) */ {
 public:
  inline TimeTransition() : TimeTransition(nullptr) {};
  virtual ~TimeTransition();

  TimeTransition(const TimeTransition& from);
  TimeTransition(TimeTransition&& from) noexcept
    : TimeTransition() {
    *this = ::std::move(from);
  }

  inline TimeTransition& operator=(const TimeTransition& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimeTransition& operator=(TimeTransition&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TimeTransition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TimeTransition* internal_default_instance() {
    return reinterpret_cast<const TimeTransition*>(
               &_TimeTransition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(TimeTransition& a, TimeTransition& b) {
    a.Swap(&b);
  }
  inline void Swap(TimeTransition* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimeTransition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TimeTransition* New() const final {
    return CreateMaybeMessage<TimeTransition>(nullptr);
  }

  TimeTransition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TimeTransition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TimeTransition& from);
  void MergeFrom(const TimeTransition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimeTransition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.TimeTransition";
  }
  protected:
  explicit TimeTransition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ProtoData_2eproto);
    return ::descriptor_table_ProtoData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef TimeTransition_Type Type;
  static constexpr Type TRADEOPEN =
    TimeTransition_Type_TRADEOPEN;
  static constexpr Type TRADECLOSE =
    TimeTransition_Type_TRADECLOSE;
  static inline bool Type_IsValid(int value) {
    return TimeTransition_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    TimeTransition_Type_Type_MIN;
  static constexpr Type Type_MAX =
    TimeTransition_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    TimeTransition_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return TimeTransition_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return TimeTransition_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return TimeTransition_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSeasonFieldNumber = 10,
    kWeekFieldNumber = 20,
    kTypeFieldNumber = 1,
  };
  // optional uint32 season = 10;
  bool has_season() const;
  private:
  bool _internal_has_season() const;
  public:
  void clear_season();
  ::PROTOBUF_NAMESPACE_ID::uint32 season() const;
  void set_season(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_season() const;
  void _internal_set_season(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 week = 20;
  bool has_week() const;
  private:
  bool _internal_has_week() const;
  public:
  void clear_week();
  ::PROTOBUF_NAMESPACE_ID::uint32 week() const;
  void set_week(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_week() const;
  void _internal_set_week(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional .fantasybit.TimeTransition.Type type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::fantasybit::TimeTransition_Type type() const;
  void set_type(::fantasybit::TimeTransition_Type value);
  private:
  ::fantasybit::TimeTransition_Type _internal_type() const;
  void _internal_set_type(::fantasybit::TimeTransition_Type value);
  public:

  static const int kTimeTransFieldNumber = 303;
  static ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::fantasybit::Transaction,
      ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::fantasybit::TimeTransition >, 11, false >
    time_trans;
  // @@protoc_insertion_point(class_scope:fantasybit.TimeTransition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 season_;
  ::PROTOBUF_NAMESPACE_ID::uint32 week_;
  int type_;
  friend struct ::TableStruct_ProtoData_2eproto;
};
// -------------------------------------------------------------------

class Bitcoin_UTXO PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.Bitcoin_UTXO) */ {
 public:
  inline Bitcoin_UTXO() : Bitcoin_UTXO(nullptr) {};
  virtual ~Bitcoin_UTXO();

  Bitcoin_UTXO(const Bitcoin_UTXO& from);
  Bitcoin_UTXO(Bitcoin_UTXO&& from) noexcept
    : Bitcoin_UTXO() {
    *this = ::std::move(from);
  }

  inline Bitcoin_UTXO& operator=(const Bitcoin_UTXO& from) {
    CopyFrom(from);
    return *this;
  }
  inline Bitcoin_UTXO& operator=(Bitcoin_UTXO&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Bitcoin_UTXO& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Bitcoin_UTXO* internal_default_instance() {
    return reinterpret_cast<const Bitcoin_UTXO*>(
               &_Bitcoin_UTXO_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(Bitcoin_UTXO& a, Bitcoin_UTXO& b) {
    a.Swap(&b);
  }
  inline void Swap(Bitcoin_UTXO* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Bitcoin_UTXO* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Bitcoin_UTXO* New() const final {
    return CreateMaybeMessage<Bitcoin_UTXO>(nullptr);
  }

  Bitcoin_UTXO* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Bitcoin_UTXO>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Bitcoin_UTXO& from);
  void MergeFrom(const Bitcoin_UTXO& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Bitcoin_UTXO* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.Bitcoin_UTXO";
  }
  protected:
  explicit Bitcoin_UTXO(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ProtoData_2eproto);
    return ::descriptor_table_ProtoData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxidFieldNumber = 10,
    kLockingScriptFieldNumber = 40,
    kTxOutputNFieldNumber = 20,
    kInValueFieldNumber = 30,
  };
  // optional bytes txid = 10;
  bool has_txid() const;
  private:
  bool _internal_has_txid() const;
  public:
  void clear_txid();
  const std::string& txid() const;
  void set_txid(const std::string& value);
  void set_txid(std::string&& value);
  void set_txid(const char* value);
  void set_txid(const void* value, size_t size);
  std::string* mutable_txid();
  std::string* release_txid();
  void set_allocated_txid(std::string* txid);
  private:
  const std::string& _internal_txid() const;
  void _internal_set_txid(const std::string& value);
  std::string* _internal_mutable_txid();
  public:

  // optional bytes locking_script = 40;
  bool has_locking_script() const;
  private:
  bool _internal_has_locking_script() const;
  public:
  void clear_locking_script();
  const std::string& locking_script() const;
  void set_locking_script(const std::string& value);
  void set_locking_script(std::string&& value);
  void set_locking_script(const char* value);
  void set_locking_script(const void* value, size_t size);
  std::string* mutable_locking_script();
  std::string* release_locking_script();
  void set_allocated_locking_script(std::string* locking_script);
  private:
  const std::string& _internal_locking_script() const;
  void _internal_set_locking_script(const std::string& value);
  std::string* _internal_mutable_locking_script();
  public:

  // optional uint32 tx_output_n = 20;
  bool has_tx_output_n() const;
  private:
  bool _internal_has_tx_output_n() const;
  public:
  void clear_tx_output_n();
  ::PROTOBUF_NAMESPACE_ID::uint32 tx_output_n() const;
  void set_tx_output_n(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_tx_output_n() const;
  void _internal_set_tx_output_n(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint64 in_value = 30;
  bool has_in_value() const;
  private:
  bool _internal_has_in_value() const;
  public:
  void clear_in_value();
  ::PROTOBUF_NAMESPACE_ID::uint64 in_value() const;
  void set_in_value(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_in_value() const;
  void _internal_set_in_value(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:fantasybit.Bitcoin_UTXO)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr txid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr locking_script_;
  ::PROTOBUF_NAMESPACE_ID::uint32 tx_output_n_;
  ::PROTOBUF_NAMESPACE_ID::uint64 in_value_;
  friend struct ::TableStruct_ProtoData_2eproto;
};
// -------------------------------------------------------------------

class Bitcoin_UTXOS PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.Bitcoin_UTXOS) */ {
 public:
  inline Bitcoin_UTXOS() : Bitcoin_UTXOS(nullptr) {};
  virtual ~Bitcoin_UTXOS();

  Bitcoin_UTXOS(const Bitcoin_UTXOS& from);
  Bitcoin_UTXOS(Bitcoin_UTXOS&& from) noexcept
    : Bitcoin_UTXOS() {
    *this = ::std::move(from);
  }

  inline Bitcoin_UTXOS& operator=(const Bitcoin_UTXOS& from) {
    CopyFrom(from);
    return *this;
  }
  inline Bitcoin_UTXOS& operator=(Bitcoin_UTXOS&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Bitcoin_UTXOS& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Bitcoin_UTXOS* internal_default_instance() {
    return reinterpret_cast<const Bitcoin_UTXOS*>(
               &_Bitcoin_UTXOS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(Bitcoin_UTXOS& a, Bitcoin_UTXOS& b) {
    a.Swap(&b);
  }
  inline void Swap(Bitcoin_UTXOS* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Bitcoin_UTXOS* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Bitcoin_UTXOS* New() const final {
    return CreateMaybeMessage<Bitcoin_UTXOS>(nullptr);
  }

  Bitcoin_UTXOS* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Bitcoin_UTXOS>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Bitcoin_UTXOS& from);
  void MergeFrom(const Bitcoin_UTXOS& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Bitcoin_UTXOS* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.Bitcoin_UTXOS";
  }
  protected:
  explicit Bitcoin_UTXOS(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ProtoData_2eproto);
    return ::descriptor_table_ProtoData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUtxoFieldNumber = 20,
    kTotalValueFieldNumber = 10,
  };
  // repeated .fantasybit.Bitcoin_UTXO utxo = 20;
  int utxo_size() const;
  private:
  int _internal_utxo_size() const;
  public:
  void clear_utxo();
  ::fantasybit::Bitcoin_UTXO* mutable_utxo(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fantasybit::Bitcoin_UTXO >*
      mutable_utxo();
  private:
  const ::fantasybit::Bitcoin_UTXO& _internal_utxo(int index) const;
  ::fantasybit::Bitcoin_UTXO* _internal_add_utxo();
  public:
  const ::fantasybit::Bitcoin_UTXO& utxo(int index) const;
  ::fantasybit::Bitcoin_UTXO* add_utxo();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fantasybit::Bitcoin_UTXO >&
      utxo() const;

  // optional uint64 total_value = 10;
  bool has_total_value() const;
  private:
  bool _internal_has_total_value() const;
  public:
  void clear_total_value();
  ::PROTOBUF_NAMESPACE_ID::uint64 total_value() const;
  void set_total_value(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_total_value() const;
  void _internal_set_total_value(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:fantasybit.Bitcoin_UTXOS)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fantasybit::Bitcoin_UTXO > utxo_;
  ::PROTOBUF_NAMESPACE_ID::uint64 total_value_;
  friend struct ::TableStruct_ProtoData_2eproto;
};
// -------------------------------------------------------------------

class SwapAsk PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.SwapAsk) */ {
 public:
  inline SwapAsk() : SwapAsk(nullptr) {};
  virtual ~SwapAsk();

  SwapAsk(const SwapAsk& from);
  SwapAsk(SwapAsk&& from) noexcept
    : SwapAsk() {
    *this = ::std::move(from);
  }

  inline SwapAsk& operator=(const SwapAsk& from) {
    CopyFrom(from);
    return *this;
  }
  inline SwapAsk& operator=(SwapAsk&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SwapAsk& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SwapAsk* internal_default_instance() {
    return reinterpret_cast<const SwapAsk*>(
               &_SwapAsk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(SwapAsk& a, SwapAsk& b) {
    a.Swap(&b);
  }
  inline void Swap(SwapAsk* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SwapAsk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SwapAsk* New() const final {
    return CreateMaybeMessage<SwapAsk>(nullptr);
  }

  SwapAsk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SwapAsk>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SwapAsk& from);
  void MergeFrom(const SwapAsk& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwapAsk* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.SwapAsk";
  }
  protected:
  explicit SwapAsk(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ProtoData_2eproto);
    return ::descriptor_table_ProtoData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSatoshiMinFieldNumber = 10,
    kSatoshiMaxFieldNumber = 11,
    kRateFieldNumber = 20,
    kFbQtyFieldNumber = 30,
  };
  // optional uint64 satoshi_min = 10;
  bool has_satoshi_min() const;
  private:
  bool _internal_has_satoshi_min() const;
  public:
  void clear_satoshi_min();
  ::PROTOBUF_NAMESPACE_ID::uint64 satoshi_min() const;
  void set_satoshi_min(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_satoshi_min() const;
  void _internal_set_satoshi_min(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 satoshi_max = 11;
  bool has_satoshi_max() const;
  private:
  bool _internal_has_satoshi_max() const;
  public:
  void clear_satoshi_max();
  ::PROTOBUF_NAMESPACE_ID::uint64 satoshi_max() const;
  void set_satoshi_max(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_satoshi_max() const;
  void _internal_set_satoshi_max(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 rate = 20;
  bool has_rate() const;
  private:
  bool _internal_has_rate() const;
  public:
  void clear_rate();
  ::PROTOBUF_NAMESPACE_ID::uint64 rate() const;
  void set_rate(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_rate() const;
  void _internal_set_rate(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 fb_qty = 30;
  bool has_fb_qty() const;
  private:
  bool _internal_has_fb_qty() const;
  public:
  void clear_fb_qty();
  ::PROTOBUF_NAMESPACE_ID::uint64 fb_qty() const;
  void set_fb_qty(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_fb_qty() const;
  void _internal_set_fb_qty(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  static const int kSwapaskTranFieldNumber = 450;
  static ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::fantasybit::Transaction,
      ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::fantasybit::SwapAsk >, 11, false >
    swapask_tran;
  // @@protoc_insertion_point(class_scope:fantasybit.SwapAsk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 satoshi_min_;
  ::PROTOBUF_NAMESPACE_ID::uint64 satoshi_max_;
  ::PROTOBUF_NAMESPACE_ID::uint64 rate_;
  ::PROTOBUF_NAMESPACE_ID::uint64 fb_qty_;
  friend struct ::TableStruct_ProtoData_2eproto;
};
// -------------------------------------------------------------------

class SwapBid PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.SwapBid) */ {
 public:
  inline SwapBid() : SwapBid(nullptr) {};
  virtual ~SwapBid();

  SwapBid(const SwapBid& from);
  SwapBid(SwapBid&& from) noexcept
    : SwapBid() {
    *this = ::std::move(from);
  }

  inline SwapBid& operator=(const SwapBid& from) {
    CopyFrom(from);
    return *this;
  }
  inline SwapBid& operator=(SwapBid&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SwapBid& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SwapBid* internal_default_instance() {
    return reinterpret_cast<const SwapBid*>(
               &_SwapBid_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(SwapBid& a, SwapBid& b) {
    a.Swap(&b);
  }
  inline void Swap(SwapBid* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SwapBid* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SwapBid* New() const final {
    return CreateMaybeMessage<SwapBid>(nullptr);
  }

  SwapBid* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SwapBid>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SwapBid& from);
  void MergeFrom(const SwapBid& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwapBid* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.SwapBid";
  }
  protected:
  explicit SwapBid(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ProtoData_2eproto);
    return ::descriptor_table_ProtoData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChangeAddrFieldNumber = 40,
    kCounterofferFieldNumber = 60,
    kUtxosFieldNumber = 30,
    kThisOfferFieldNumber = 50,
    kSatoshiMinFieldNumber = 10,
    kSatoshiMaxFieldNumber = 11,
    kRateFieldNumber = 20,
  };
  // optional bytes change_addr = 40;
  bool has_change_addr() const;
  private:
  bool _internal_has_change_addr() const;
  public:
  void clear_change_addr();
  const std::string& change_addr() const;
  void set_change_addr(const std::string& value);
  void set_change_addr(std::string&& value);
  void set_change_addr(const char* value);
  void set_change_addr(const void* value, size_t size);
  std::string* mutable_change_addr();
  std::string* release_change_addr();
  void set_allocated_change_addr(std::string* change_addr);
  private:
  const std::string& _internal_change_addr() const;
  void _internal_set_change_addr(const std::string& value);
  std::string* _internal_mutable_change_addr();
  public:

  // optional string counteroffer = 60;
  bool has_counteroffer() const;
  private:
  bool _internal_has_counteroffer() const;
  public:
  void clear_counteroffer();
  const std::string& counteroffer() const;
  void set_counteroffer(const std::string& value);
  void set_counteroffer(std::string&& value);
  void set_counteroffer(const char* value);
  void set_counteroffer(const char* value, size_t size);
  std::string* mutable_counteroffer();
  std::string* release_counteroffer();
  void set_allocated_counteroffer(std::string* counteroffer);
  private:
  const std::string& _internal_counteroffer() const;
  void _internal_set_counteroffer(const std::string& value);
  std::string* _internal_mutable_counteroffer();
  public:

  // optional .fantasybit.Bitcoin_UTXOS utxos = 30;
  bool has_utxos() const;
  private:
  bool _internal_has_utxos() const;
  public:
  void clear_utxos();
  const ::fantasybit::Bitcoin_UTXOS& utxos() const;
  ::fantasybit::Bitcoin_UTXOS* release_utxos();
  ::fantasybit::Bitcoin_UTXOS* mutable_utxos();
  void set_allocated_utxos(::fantasybit::Bitcoin_UTXOS* utxos);
  private:
  const ::fantasybit::Bitcoin_UTXOS& _internal_utxos() const;
  ::fantasybit::Bitcoin_UTXOS* _internal_mutable_utxos();
  public:
  void unsafe_arena_set_allocated_utxos(
      ::fantasybit::Bitcoin_UTXOS* utxos);
  ::fantasybit::Bitcoin_UTXOS* unsafe_arena_release_utxos();

  // optional .fantasybit.SwapAsk this_offer = 50;
  bool has_this_offer() const;
  private:
  bool _internal_has_this_offer() const;
  public:
  void clear_this_offer();
  const ::fantasybit::SwapAsk& this_offer() const;
  ::fantasybit::SwapAsk* release_this_offer();
  ::fantasybit::SwapAsk* mutable_this_offer();
  void set_allocated_this_offer(::fantasybit::SwapAsk* this_offer);
  private:
  const ::fantasybit::SwapAsk& _internal_this_offer() const;
  ::fantasybit::SwapAsk* _internal_mutable_this_offer();
  public:
  void unsafe_arena_set_allocated_this_offer(
      ::fantasybit::SwapAsk* this_offer);
  ::fantasybit::SwapAsk* unsafe_arena_release_this_offer();

  // optional uint64 satoshi_min = 10;
  bool has_satoshi_min() const;
  private:
  bool _internal_has_satoshi_min() const;
  public:
  void clear_satoshi_min();
  ::PROTOBUF_NAMESPACE_ID::uint64 satoshi_min() const;
  void set_satoshi_min(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_satoshi_min() const;
  void _internal_set_satoshi_min(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 satoshi_max = 11;
  bool has_satoshi_max() const;
  private:
  bool _internal_has_satoshi_max() const;
  public:
  void clear_satoshi_max();
  ::PROTOBUF_NAMESPACE_ID::uint64 satoshi_max() const;
  void set_satoshi_max(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_satoshi_max() const;
  void _internal_set_satoshi_max(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 rate = 20;
  bool has_rate() const;
  private:
  bool _internal_has_rate() const;
  public:
  void clear_rate();
  ::PROTOBUF_NAMESPACE_ID::uint64 rate() const;
  void set_rate(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_rate() const;
  void _internal_set_rate(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  static const int kSwapbidTranFieldNumber = 500;
  static ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::fantasybit::Transaction,
      ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::fantasybit::SwapBid >, 11, false >
    swapbid_tran;
  // @@protoc_insertion_point(class_scope:fantasybit.SwapBid)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr change_addr_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr counteroffer_;
  ::fantasybit::Bitcoin_UTXOS* utxos_;
  ::fantasybit::SwapAsk* this_offer_;
  ::PROTOBUF_NAMESPACE_ID::uint64 satoshi_min_;
  ::PROTOBUF_NAMESPACE_ID::uint64 satoshi_max_;
  ::PROTOBUF_NAMESPACE_ID::uint64 rate_;
  friend struct ::TableStruct_ProtoData_2eproto;
};
// -------------------------------------------------------------------

class SwapFill PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.SwapFill) */ {
 public:
  inline SwapFill() : SwapFill(nullptr) {};
  virtual ~SwapFill();

  SwapFill(const SwapFill& from);
  SwapFill(SwapFill&& from) noexcept
    : SwapFill() {
    *this = ::std::move(from);
  }

  inline SwapFill& operator=(const SwapFill& from) {
    CopyFrom(from);
    return *this;
  }
  inline SwapFill& operator=(SwapFill&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SwapFill& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SwapFill* internal_default_instance() {
    return reinterpret_cast<const SwapFill*>(
               &_SwapFill_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(SwapFill& a, SwapFill& b) {
    a.Swap(&b);
  }
  inline void Swap(SwapFill* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SwapFill* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SwapFill* New() const final {
    return CreateMaybeMessage<SwapFill>(nullptr);
  }

  SwapFill* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SwapFill>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SwapFill& from);
  void MergeFrom(const SwapFill& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwapFill* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.SwapFill";
  }
  protected:
  explicit SwapFill(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ProtoData_2eproto);
    return ::descriptor_table_ProtoData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashToSignFieldNumber = 20,
    kCounterpartyFieldNumber = 50,
    kSwapbidFieldNumber = 10,
    kSatoshiFeeFieldNumber = 30,
    kFbQtyFieldNumber = 40,
  };
  // optional bytes hash_to_sign = 20;
  bool has_hash_to_sign() const;
  private:
  bool _internal_has_hash_to_sign() const;
  public:
  void clear_hash_to_sign();
  const std::string& hash_to_sign() const;
  void set_hash_to_sign(const std::string& value);
  void set_hash_to_sign(std::string&& value);
  void set_hash_to_sign(const char* value);
  void set_hash_to_sign(const void* value, size_t size);
  std::string* mutable_hash_to_sign();
  std::string* release_hash_to_sign();
  void set_allocated_hash_to_sign(std::string* hash_to_sign);
  private:
  const std::string& _internal_hash_to_sign() const;
  void _internal_set_hash_to_sign(const std::string& value);
  std::string* _internal_mutable_hash_to_sign();
  public:

  // optional string counterparty = 50;
  bool has_counterparty() const;
  private:
  bool _internal_has_counterparty() const;
  public:
  void clear_counterparty();
  const std::string& counterparty() const;
  void set_counterparty(const std::string& value);
  void set_counterparty(std::string&& value);
  void set_counterparty(const char* value);
  void set_counterparty(const char* value, size_t size);
  std::string* mutable_counterparty();
  std::string* release_counterparty();
  void set_allocated_counterparty(std::string* counterparty);
  private:
  const std::string& _internal_counterparty() const;
  void _internal_set_counterparty(const std::string& value);
  std::string* _internal_mutable_counterparty();
  public:

  // optional .fantasybit.SwapBid swapbid = 10;
  bool has_swapbid() const;
  private:
  bool _internal_has_swapbid() const;
  public:
  void clear_swapbid();
  const ::fantasybit::SwapBid& swapbid() const;
  ::fantasybit::SwapBid* release_swapbid();
  ::fantasybit::SwapBid* mutable_swapbid();
  void set_allocated_swapbid(::fantasybit::SwapBid* swapbid);
  private:
  const ::fantasybit::SwapBid& _internal_swapbid() const;
  ::fantasybit::SwapBid* _internal_mutable_swapbid();
  public:
  void unsafe_arena_set_allocated_swapbid(
      ::fantasybit::SwapBid* swapbid);
  ::fantasybit::SwapBid* unsafe_arena_release_swapbid();

  // optional uint64 satoshi_fee = 30;
  bool has_satoshi_fee() const;
  private:
  bool _internal_has_satoshi_fee() const;
  public:
  void clear_satoshi_fee();
  ::PROTOBUF_NAMESPACE_ID::uint64 satoshi_fee() const;
  void set_satoshi_fee(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_satoshi_fee() const;
  void _internal_set_satoshi_fee(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 fb_qty = 40;
  bool has_fb_qty() const;
  private:
  bool _internal_has_fb_qty() const;
  public:
  void clear_fb_qty();
  ::PROTOBUF_NAMESPACE_ID::uint64 fb_qty() const;
  void set_fb_qty(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_fb_qty() const;
  void _internal_set_fb_qty(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  static const int kSwapfilTranFieldNumber = 600;
  static ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::fantasybit::Transaction,
      ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::fantasybit::SwapFill >, 11, false >
    swapfil_tran;
  // @@protoc_insertion_point(class_scope:fantasybit.SwapFill)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_to_sign_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr counterparty_;
  ::fantasybit::SwapBid* swapbid_;
  ::PROTOBUF_NAMESPACE_ID::uint64 satoshi_fee_;
  ::PROTOBUF_NAMESPACE_ID::uint64 fb_qty_;
  friend struct ::TableStruct_ProtoData_2eproto;
};
// -------------------------------------------------------------------

class SwapSent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.SwapSent) */ {
 public:
  inline SwapSent() : SwapSent(nullptr) {};
  virtual ~SwapSent();

  SwapSent(const SwapSent& from);
  SwapSent(SwapSent&& from) noexcept
    : SwapSent() {
    *this = ::std::move(from);
  }

  inline SwapSent& operator=(const SwapSent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SwapSent& operator=(SwapSent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SwapSent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SwapSent* internal_default_instance() {
    return reinterpret_cast<const SwapSent*>(
               &_SwapSent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(SwapSent& a, SwapSent& b) {
    a.Swap(&b);
  }
  inline void Swap(SwapSent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SwapSent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SwapSent* New() const final {
    return CreateMaybeMessage<SwapSent>(nullptr);
  }

  SwapSent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SwapSent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SwapSent& from);
  void MergeFrom(const SwapSent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwapSent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.SwapSent";
  }
  protected:
  explicit SwapSent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ProtoData_2eproto);
    return ::descriptor_table_ProtoData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSigFieldNumber = 20,
    kSwapfillFieldNumber = 10,
  };
  // optional bytes sig = 20;
  bool has_sig() const;
  private:
  bool _internal_has_sig() const;
  public:
  void clear_sig();
  const std::string& sig() const;
  void set_sig(const std::string& value);
  void set_sig(std::string&& value);
  void set_sig(const char* value);
  void set_sig(const void* value, size_t size);
  std::string* mutable_sig();
  std::string* release_sig();
  void set_allocated_sig(std::string* sig);
  private:
  const std::string& _internal_sig() const;
  void _internal_set_sig(const std::string& value);
  std::string* _internal_mutable_sig();
  public:

  // optional .fantasybit.SwapFill swapfill = 10;
  bool has_swapfill() const;
  private:
  bool _internal_has_swapfill() const;
  public:
  void clear_swapfill();
  const ::fantasybit::SwapFill& swapfill() const;
  ::fantasybit::SwapFill* release_swapfill();
  ::fantasybit::SwapFill* mutable_swapfill();
  void set_allocated_swapfill(::fantasybit::SwapFill* swapfill);
  private:
  const ::fantasybit::SwapFill& _internal_swapfill() const;
  ::fantasybit::SwapFill* _internal_mutable_swapfill();
  public:
  void unsafe_arena_set_allocated_swapfill(
      ::fantasybit::SwapFill* swapfill);
  ::fantasybit::SwapFill* unsafe_arena_release_swapfill();

  static const int kSwapsentTranFieldNumber = 700;
  static ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::fantasybit::Transaction,
      ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::fantasybit::SwapSent >, 11, false >
    swapsent_tran;
  // @@protoc_insertion_point(class_scope:fantasybit.SwapSent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sig_;
  ::fantasybit::SwapFill* swapfill_;
  friend struct ::TableStruct_ProtoData_2eproto;
};
// -------------------------------------------------------------------

class ProofOfDoubleSpend PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.ProofOfDoubleSpend) */ {
 public:
  inline ProofOfDoubleSpend() : ProofOfDoubleSpend(nullptr) {};
  virtual ~ProofOfDoubleSpend();

  ProofOfDoubleSpend(const ProofOfDoubleSpend& from);
  ProofOfDoubleSpend(ProofOfDoubleSpend&& from) noexcept
    : ProofOfDoubleSpend() {
    *this = ::std::move(from);
  }

  inline ProofOfDoubleSpend& operator=(const ProofOfDoubleSpend& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProofOfDoubleSpend& operator=(ProofOfDoubleSpend&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ProofOfDoubleSpend& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProofOfDoubleSpend* internal_default_instance() {
    return reinterpret_cast<const ProofOfDoubleSpend*>(
               &_ProofOfDoubleSpend_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(ProofOfDoubleSpend& a, ProofOfDoubleSpend& b) {
    a.Swap(&b);
  }
  inline void Swap(ProofOfDoubleSpend* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProofOfDoubleSpend* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProofOfDoubleSpend* New() const final {
    return CreateMaybeMessage<ProofOfDoubleSpend>(nullptr);
  }

  ProofOfDoubleSpend* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProofOfDoubleSpend>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ProofOfDoubleSpend& from);
  void MergeFrom(const ProofOfDoubleSpend& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProofOfDoubleSpend* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.ProofOfDoubleSpend";
  }
  protected:
  explicit ProofOfDoubleSpend(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ProtoData_2eproto);
    return ::descriptor_table_ProtoData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPreFieldNumber = 30,
    kPostFieldNumber = 40,
    kSigFieldNumber = 50,
    kSwapsentFieldNumber = 10,
    kUtxoFieldNumber = 20,
  };
  // optional bytes pre = 30;
  bool has_pre() const;
  private:
  bool _internal_has_pre() const;
  public:
  void clear_pre();
  const std::string& pre() const;
  void set_pre(const std::string& value);
  void set_pre(std::string&& value);
  void set_pre(const char* value);
  void set_pre(const void* value, size_t size);
  std::string* mutable_pre();
  std::string* release_pre();
  void set_allocated_pre(std::string* pre);
  private:
  const std::string& _internal_pre() const;
  void _internal_set_pre(const std::string& value);
  std::string* _internal_mutable_pre();
  public:

  // optional bytes post = 40;
  bool has_post() const;
  private:
  bool _internal_has_post() const;
  public:
  void clear_post();
  const std::string& post() const;
  void set_post(const std::string& value);
  void set_post(std::string&& value);
  void set_post(const char* value);
  void set_post(const void* value, size_t size);
  std::string* mutable_post();
  std::string* release_post();
  void set_allocated_post(std::string* post);
  private:
  const std::string& _internal_post() const;
  void _internal_set_post(const std::string& value);
  std::string* _internal_mutable_post();
  public:

  // optional bytes sig = 50;
  bool has_sig() const;
  private:
  bool _internal_has_sig() const;
  public:
  void clear_sig();
  const std::string& sig() const;
  void set_sig(const std::string& value);
  void set_sig(std::string&& value);
  void set_sig(const char* value);
  void set_sig(const void* value, size_t size);
  std::string* mutable_sig();
  std::string* release_sig();
  void set_allocated_sig(std::string* sig);
  private:
  const std::string& _internal_sig() const;
  void _internal_set_sig(const std::string& value);
  std::string* _internal_mutable_sig();
  public:

  // optional .fantasybit.SwapSent swapsent = 10;
  bool has_swapsent() const;
  private:
  bool _internal_has_swapsent() const;
  public:
  void clear_swapsent();
  const ::fantasybit::SwapSent& swapsent() const;
  ::fantasybit::SwapSent* release_swapsent();
  ::fantasybit::SwapSent* mutable_swapsent();
  void set_allocated_swapsent(::fantasybit::SwapSent* swapsent);
  private:
  const ::fantasybit::SwapSent& _internal_swapsent() const;
  ::fantasybit::SwapSent* _internal_mutable_swapsent();
  public:
  void unsafe_arena_set_allocated_swapsent(
      ::fantasybit::SwapSent* swapsent);
  ::fantasybit::SwapSent* unsafe_arena_release_swapsent();

  // optional .fantasybit.Bitcoin_UTXO utxo = 20;
  bool has_utxo() const;
  private:
  bool _internal_has_utxo() const;
  public:
  void clear_utxo();
  const ::fantasybit::Bitcoin_UTXO& utxo() const;
  ::fantasybit::Bitcoin_UTXO* release_utxo();
  ::fantasybit::Bitcoin_UTXO* mutable_utxo();
  void set_allocated_utxo(::fantasybit::Bitcoin_UTXO* utxo);
  private:
  const ::fantasybit::Bitcoin_UTXO& _internal_utxo() const;
  ::fantasybit::Bitcoin_UTXO* _internal_mutable_utxo();
  public:
  void unsafe_arena_set_allocated_utxo(
      ::fantasybit::Bitcoin_UTXO* utxo);
  ::fantasybit::Bitcoin_UTXO* unsafe_arena_release_utxo();

  static const int kPodpTranFieldNumber = 800;
  static ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::fantasybit::Transaction,
      ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::fantasybit::ProofOfDoubleSpend >, 11, false >
    podp_tran;
  // @@protoc_insertion_point(class_scope:fantasybit.ProofOfDoubleSpend)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pre_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr post_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sig_;
  ::fantasybit::SwapSent* swapsent_;
  ::fantasybit::Bitcoin_UTXO* utxo_;
  friend struct ::TableStruct_ProtoData_2eproto;
};
// -------------------------------------------------------------------

class SwapSentAck PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.SwapSentAck) */ {
 public:
  inline SwapSentAck() : SwapSentAck(nullptr) {};
  virtual ~SwapSentAck();

  SwapSentAck(const SwapSentAck& from);
  SwapSentAck(SwapSentAck&& from) noexcept
    : SwapSentAck() {
    *this = ::std::move(from);
  }

  inline SwapSentAck& operator=(const SwapSentAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline SwapSentAck& operator=(SwapSentAck&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SwapSentAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SwapSentAck* internal_default_instance() {
    return reinterpret_cast<const SwapSentAck*>(
               &_SwapSentAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(SwapSentAck& a, SwapSentAck& b) {
    a.Swap(&b);
  }
  inline void Swap(SwapSentAck* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SwapSentAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SwapSentAck* New() const final {
    return CreateMaybeMessage<SwapSentAck>(nullptr);
  }

  SwapSentAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SwapSentAck>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SwapSentAck& from);
  void MergeFrom(const SwapSentAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwapSentAck* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.SwapSentAck";
  }
  protected:
  explicit SwapSentAck(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ProtoData_2eproto);
    return ::descriptor_table_ProtoData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSwapsentFieldNumber = 10,
  };
  // optional .fantasybit.SwapSent swapsent = 10;
  bool has_swapsent() const;
  private:
  bool _internal_has_swapsent() const;
  public:
  void clear_swapsent();
  const ::fantasybit::SwapSent& swapsent() const;
  ::fantasybit::SwapSent* release_swapsent();
  ::fantasybit::SwapSent* mutable_swapsent();
  void set_allocated_swapsent(::fantasybit::SwapSent* swapsent);
  private:
  const ::fantasybit::SwapSent& _internal_swapsent() const;
  ::fantasybit::SwapSent* _internal_mutable_swapsent();
  public:
  void unsafe_arena_set_allocated_swapsent(
      ::fantasybit::SwapSent* swapsent);
  ::fantasybit::SwapSent* unsafe_arena_release_swapsent();

  static const int kSwapsentackTranFieldNumber = 810;
  static ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::fantasybit::Transaction,
      ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::fantasybit::SwapSentAck >, 11, false >
    swapsentack_tran;
  // @@protoc_insertion_point(class_scope:fantasybit.SwapSentAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::fantasybit::SwapSent* swapsent_;
  friend struct ::TableStruct_ProtoData_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MyFantasyName

// optional string name = 1;
inline bool MyFantasyName::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MyFantasyName::has_name() const {
  return _internal_has_name();
}
inline void MyFantasyName::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MyFantasyName::name() const {
  // @@protoc_insertion_point(field_get:fantasybit.MyFantasyName.name)
  return _internal_name();
}
inline void MyFantasyName::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:fantasybit.MyFantasyName.name)
}
inline std::string* MyFantasyName::mutable_name() {
  // @@protoc_insertion_point(field_mutable:fantasybit.MyFantasyName.name)
  return _internal_mutable_name();
}
inline const std::string& MyFantasyName::_internal_name() const {
  return name_.Get();
}
inline void MyFantasyName::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void MyFantasyName::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.MyFantasyName.name)
}
inline void MyFantasyName::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.MyFantasyName.name)
}
inline void MyFantasyName::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.MyFantasyName.name)
}
inline std::string* MyFantasyName::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* MyFantasyName::release_name() {
  // @@protoc_insertion_point(field_release:fantasybit.MyFantasyName.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MyFantasyName::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.MyFantasyName.name)
}

// optional .fantasybit.MyNameStatus status = 2;
inline bool MyFantasyName::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MyFantasyName::has_status() const {
  return _internal_has_status();
}
inline void MyFantasyName::clear_status() {
  status_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::fantasybit::MyNameStatus MyFantasyName::_internal_status() const {
  return static_cast< ::fantasybit::MyNameStatus >(status_);
}
inline ::fantasybit::MyNameStatus MyFantasyName::status() const {
  // @@protoc_insertion_point(field_get:fantasybit.MyFantasyName.status)
  return _internal_status();
}
inline void MyFantasyName::_internal_set_status(::fantasybit::MyNameStatus value) {
  assert(::fantasybit::MyNameStatus_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  status_ = value;
}
inline void MyFantasyName::set_status(::fantasybit::MyNameStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:fantasybit.MyFantasyName.status)
}

// -------------------------------------------------------------------

// FantasyPlayer

// optional string name = 10;
inline bool FantasyPlayer::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FantasyPlayer::has_name() const {
  return _internal_has_name();
}
inline void FantasyPlayer::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FantasyPlayer::name() const {
  // @@protoc_insertion_point(field_get:fantasybit.FantasyPlayer.name)
  return _internal_name();
}
inline void FantasyPlayer::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:fantasybit.FantasyPlayer.name)
}
inline std::string* FantasyPlayer::mutable_name() {
  // @@protoc_insertion_point(field_mutable:fantasybit.FantasyPlayer.name)
  return _internal_mutable_name();
}
inline const std::string& FantasyPlayer::_internal_name() const {
  return name_.Get();
}
inline void FantasyPlayer::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void FantasyPlayer::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.FantasyPlayer.name)
}
inline void FantasyPlayer::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.FantasyPlayer.name)
}
inline void FantasyPlayer::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.FantasyPlayer.name)
}
inline std::string* FantasyPlayer::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* FantasyPlayer::release_name() {
  // @@protoc_insertion_point(field_release:fantasybit.FantasyPlayer.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FantasyPlayer::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.FantasyPlayer.name)
}

// optional uint64 bits = 20;
inline bool FantasyPlayer::_internal_has_bits() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FantasyPlayer::has_bits() const {
  return _internal_has_bits();
}
inline void FantasyPlayer::clear_bits() {
  bits_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 FantasyPlayer::_internal_bits() const {
  return bits_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 FantasyPlayer::bits() const {
  // @@protoc_insertion_point(field_get:fantasybit.FantasyPlayer.bits)
  return _internal_bits();
}
inline void FantasyPlayer::_internal_set_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  bits_ = value;
}
inline void FantasyPlayer::set_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_bits(value);
  // @@protoc_insertion_point(field_set:fantasybit.FantasyPlayer.bits)
}

// -------------------------------------------------------------------

// Secret

// required string private_key = 1;
inline bool Secret::_internal_has_private_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Secret::has_private_key() const {
  return _internal_has_private_key();
}
inline void Secret::clear_private_key() {
  private_key_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Secret::private_key() const {
  // @@protoc_insertion_point(field_get:fantasybit.Secret.private_key)
  return _internal_private_key();
}
inline void Secret::set_private_key(const std::string& value) {
  _internal_set_private_key(value);
  // @@protoc_insertion_point(field_set:fantasybit.Secret.private_key)
}
inline std::string* Secret::mutable_private_key() {
  // @@protoc_insertion_point(field_mutable:fantasybit.Secret.private_key)
  return _internal_mutable_private_key();
}
inline const std::string& Secret::_internal_private_key() const {
  return private_key_.Get();
}
inline void Secret::_internal_set_private_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  private_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Secret::set_private_key(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  private_key_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.Secret.private_key)
}
inline void Secret::set_private_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  private_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.Secret.private_key)
}
inline void Secret::set_private_key(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  private_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.Secret.private_key)
}
inline std::string* Secret::_internal_mutable_private_key() {
  _has_bits_[0] |= 0x00000001u;
  return private_key_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Secret::release_private_key() {
  // @@protoc_insertion_point(field_release:fantasybit.Secret.private_key)
  if (!_internal_has_private_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return private_key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Secret::set_allocated_private_key(std::string* private_key) {
  if (private_key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  private_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), private_key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.Secret.private_key)
}

// optional .fantasybit.MyFantasyName myfantasyname = 2;
inline bool Secret::_internal_has_myfantasyname() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || myfantasyname_ != nullptr);
  return value;
}
inline bool Secret::has_myfantasyname() const {
  return _internal_has_myfantasyname();
}
inline void Secret::clear_myfantasyname() {
  if (myfantasyname_ != nullptr) myfantasyname_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::fantasybit::MyFantasyName& Secret::_internal_myfantasyname() const {
  const ::fantasybit::MyFantasyName* p = myfantasyname_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fantasybit::MyFantasyName*>(
      &::fantasybit::_MyFantasyName_default_instance_);
}
inline const ::fantasybit::MyFantasyName& Secret::myfantasyname() const {
  // @@protoc_insertion_point(field_get:fantasybit.Secret.myfantasyname)
  return _internal_myfantasyname();
}
inline void Secret::unsafe_arena_set_allocated_myfantasyname(
    ::fantasybit::MyFantasyName* myfantasyname) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(myfantasyname_);
  }
  myfantasyname_ = myfantasyname;
  if (myfantasyname) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fantasybit.Secret.myfantasyname)
}
inline ::fantasybit::MyFantasyName* Secret::release_myfantasyname() {
  _has_bits_[0] &= ~0x00000002u;
  ::fantasybit::MyFantasyName* temp = myfantasyname_;
  myfantasyname_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fantasybit::MyFantasyName* Secret::unsafe_arena_release_myfantasyname() {
  // @@protoc_insertion_point(field_release:fantasybit.Secret.myfantasyname)
  _has_bits_[0] &= ~0x00000002u;
  ::fantasybit::MyFantasyName* temp = myfantasyname_;
  myfantasyname_ = nullptr;
  return temp;
}
inline ::fantasybit::MyFantasyName* Secret::_internal_mutable_myfantasyname() {
  _has_bits_[0] |= 0x00000002u;
  if (myfantasyname_ == nullptr) {
    auto* p = CreateMaybeMessage<::fantasybit::MyFantasyName>(GetArena());
    myfantasyname_ = p;
  }
  return myfantasyname_;
}
inline ::fantasybit::MyFantasyName* Secret::mutable_myfantasyname() {
  // @@protoc_insertion_point(field_mutable:fantasybit.Secret.myfantasyname)
  return _internal_mutable_myfantasyname();
}
inline void Secret::set_allocated_myfantasyname(::fantasybit::MyFantasyName* myfantasyname) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete myfantasyname_;
  }
  if (myfantasyname) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(myfantasyname);
    if (message_arena != submessage_arena) {
      myfantasyname = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, myfantasyname, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  myfantasyname_ = myfantasyname;
  // @@protoc_insertion_point(field_set_allocated:fantasybit.Secret.myfantasyname)
}

// optional .fantasybit.NameTrans nametran = 10;
inline bool Secret::_internal_has_nametran() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || nametran_ != nullptr);
  return value;
}
inline bool Secret::has_nametran() const {
  return _internal_has_nametran();
}
inline void Secret::clear_nametran() {
  if (nametran_ != nullptr) nametran_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::fantasybit::NameTrans& Secret::_internal_nametran() const {
  const ::fantasybit::NameTrans* p = nametran_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fantasybit::NameTrans*>(
      &::fantasybit::_NameTrans_default_instance_);
}
inline const ::fantasybit::NameTrans& Secret::nametran() const {
  // @@protoc_insertion_point(field_get:fantasybit.Secret.nametran)
  return _internal_nametran();
}
inline void Secret::unsafe_arena_set_allocated_nametran(
    ::fantasybit::NameTrans* nametran) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nametran_);
  }
  nametran_ = nametran;
  if (nametran) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fantasybit.Secret.nametran)
}
inline ::fantasybit::NameTrans* Secret::release_nametran() {
  _has_bits_[0] &= ~0x00000004u;
  ::fantasybit::NameTrans* temp = nametran_;
  nametran_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fantasybit::NameTrans* Secret::unsafe_arena_release_nametran() {
  // @@protoc_insertion_point(field_release:fantasybit.Secret.nametran)
  _has_bits_[0] &= ~0x00000004u;
  ::fantasybit::NameTrans* temp = nametran_;
  nametran_ = nullptr;
  return temp;
}
inline ::fantasybit::NameTrans* Secret::_internal_mutable_nametran() {
  _has_bits_[0] |= 0x00000004u;
  if (nametran_ == nullptr) {
    auto* p = CreateMaybeMessage<::fantasybit::NameTrans>(GetArena());
    nametran_ = p;
  }
  return nametran_;
}
inline ::fantasybit::NameTrans* Secret::mutable_nametran() {
  // @@protoc_insertion_point(field_mutable:fantasybit.Secret.nametran)
  return _internal_mutable_nametran();
}
inline void Secret::set_allocated_nametran(::fantasybit::NameTrans* nametran) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete nametran_;
  }
  if (nametran) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(nametran);
    if (message_arena != submessage_arena) {
      nametran = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nametran, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  nametran_ = nametran;
  // @@protoc_insertion_point(field_set_allocated:fantasybit.Secret.nametran)
}

// -------------------------------------------------------------------

// Secret2

// optional string private_key = 1;
inline bool Secret2::_internal_has_private_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Secret2::has_private_key() const {
  return _internal_has_private_key();
}
inline void Secret2::clear_private_key() {
  private_key_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Secret2::private_key() const {
  // @@protoc_insertion_point(field_get:fantasybit.Secret2.private_key)
  return _internal_private_key();
}
inline void Secret2::set_private_key(const std::string& value) {
  _internal_set_private_key(value);
  // @@protoc_insertion_point(field_set:fantasybit.Secret2.private_key)
}
inline std::string* Secret2::mutable_private_key() {
  // @@protoc_insertion_point(field_mutable:fantasybit.Secret2.private_key)
  return _internal_mutable_private_key();
}
inline const std::string& Secret2::_internal_private_key() const {
  return private_key_.Get();
}
inline void Secret2::_internal_set_private_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  private_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Secret2::set_private_key(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  private_key_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.Secret2.private_key)
}
inline void Secret2::set_private_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  private_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.Secret2.private_key)
}
inline void Secret2::set_private_key(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  private_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.Secret2.private_key)
}
inline std::string* Secret2::_internal_mutable_private_key() {
  _has_bits_[0] |= 0x00000001u;
  return private_key_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Secret2::release_private_key() {
  // @@protoc_insertion_point(field_release:fantasybit.Secret2.private_key)
  if (!_internal_has_private_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return private_key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Secret2::set_allocated_private_key(std::string* private_key) {
  if (private_key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  private_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), private_key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.Secret2.private_key)
}

// optional string fantasy_name = 20;
inline bool Secret2::_internal_has_fantasy_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Secret2::has_fantasy_name() const {
  return _internal_has_fantasy_name();
}
inline void Secret2::clear_fantasy_name() {
  fantasy_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Secret2::fantasy_name() const {
  // @@protoc_insertion_point(field_get:fantasybit.Secret2.fantasy_name)
  return _internal_fantasy_name();
}
inline void Secret2::set_fantasy_name(const std::string& value) {
  _internal_set_fantasy_name(value);
  // @@protoc_insertion_point(field_set:fantasybit.Secret2.fantasy_name)
}
inline std::string* Secret2::mutable_fantasy_name() {
  // @@protoc_insertion_point(field_mutable:fantasybit.Secret2.fantasy_name)
  return _internal_mutable_fantasy_name();
}
inline const std::string& Secret2::_internal_fantasy_name() const {
  return fantasy_name_.Get();
}
inline void Secret2::_internal_set_fantasy_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  fantasy_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Secret2::set_fantasy_name(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  fantasy_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.Secret2.fantasy_name)
}
inline void Secret2::set_fantasy_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  fantasy_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.Secret2.fantasy_name)
}
inline void Secret2::set_fantasy_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  fantasy_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.Secret2.fantasy_name)
}
inline std::string* Secret2::_internal_mutable_fantasy_name() {
  _has_bits_[0] |= 0x00000002u;
  return fantasy_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Secret2::release_fantasy_name() {
  // @@protoc_insertion_point(field_release:fantasybit.Secret2.fantasy_name)
  if (!_internal_has_fantasy_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return fantasy_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Secret2::set_allocated_fantasy_name(std::string* fantasy_name) {
  if (fantasy_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  fantasy_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fantasy_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.Secret2.fantasy_name)
}

// optional string public_key = 30;
inline bool Secret2::_internal_has_public_key() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Secret2::has_public_key() const {
  return _internal_has_public_key();
}
inline void Secret2::clear_public_key() {
  public_key_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Secret2::public_key() const {
  // @@protoc_insertion_point(field_get:fantasybit.Secret2.public_key)
  return _internal_public_key();
}
inline void Secret2::set_public_key(const std::string& value) {
  _internal_set_public_key(value);
  // @@protoc_insertion_point(field_set:fantasybit.Secret2.public_key)
}
inline std::string* Secret2::mutable_public_key() {
  // @@protoc_insertion_point(field_mutable:fantasybit.Secret2.public_key)
  return _internal_mutable_public_key();
}
inline const std::string& Secret2::_internal_public_key() const {
  return public_key_.Get();
}
inline void Secret2::_internal_set_public_key(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  public_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Secret2::set_public_key(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  public_key_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.Secret2.public_key)
}
inline void Secret2::set_public_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  public_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.Secret2.public_key)
}
inline void Secret2::set_public_key(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  public_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.Secret2.public_key)
}
inline std::string* Secret2::_internal_mutable_public_key() {
  _has_bits_[0] |= 0x00000004u;
  return public_key_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Secret2::release_public_key() {
  // @@protoc_insertion_point(field_release:fantasybit.Secret2.public_key)
  if (!_internal_has_public_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return public_key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Secret2::set_allocated_public_key(std::string* public_key) {
  if (public_key != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  public_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), public_key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.Secret2.public_key)
}

// -------------------------------------------------------------------

// Secret3

// optional string private_key = 1;
inline bool Secret3::_internal_has_private_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Secret3::has_private_key() const {
  return _internal_has_private_key();
}
inline void Secret3::clear_private_key() {
  private_key_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Secret3::private_key() const {
  // @@protoc_insertion_point(field_get:fantasybit.Secret3.private_key)
  return _internal_private_key();
}
inline void Secret3::set_private_key(const std::string& value) {
  _internal_set_private_key(value);
  // @@protoc_insertion_point(field_set:fantasybit.Secret3.private_key)
}
inline std::string* Secret3::mutable_private_key() {
  // @@protoc_insertion_point(field_mutable:fantasybit.Secret3.private_key)
  return _internal_mutable_private_key();
}
inline const std::string& Secret3::_internal_private_key() const {
  return private_key_.Get();
}
inline void Secret3::_internal_set_private_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  private_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Secret3::set_private_key(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  private_key_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.Secret3.private_key)
}
inline void Secret3::set_private_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  private_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.Secret3.private_key)
}
inline void Secret3::set_private_key(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  private_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.Secret3.private_key)
}
inline std::string* Secret3::_internal_mutable_private_key() {
  _has_bits_[0] |= 0x00000001u;
  return private_key_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Secret3::release_private_key() {
  // @@protoc_insertion_point(field_release:fantasybit.Secret3.private_key)
  if (!_internal_has_private_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return private_key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Secret3::set_allocated_private_key(std::string* private_key) {
  if (private_key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  private_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), private_key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.Secret3.private_key)
}

// optional string mnemonic_key = 3;
inline bool Secret3::_internal_has_mnemonic_key() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Secret3::has_mnemonic_key() const {
  return _internal_has_mnemonic_key();
}
inline void Secret3::clear_mnemonic_key() {
  mnemonic_key_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Secret3::mnemonic_key() const {
  // @@protoc_insertion_point(field_get:fantasybit.Secret3.mnemonic_key)
  return _internal_mnemonic_key();
}
inline void Secret3::set_mnemonic_key(const std::string& value) {
  _internal_set_mnemonic_key(value);
  // @@protoc_insertion_point(field_set:fantasybit.Secret3.mnemonic_key)
}
inline std::string* Secret3::mutable_mnemonic_key() {
  // @@protoc_insertion_point(field_mutable:fantasybit.Secret3.mnemonic_key)
  return _internal_mutable_mnemonic_key();
}
inline const std::string& Secret3::_internal_mnemonic_key() const {
  return mnemonic_key_.Get();
}
inline void Secret3::_internal_set_mnemonic_key(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  mnemonic_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Secret3::set_mnemonic_key(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  mnemonic_key_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.Secret3.mnemonic_key)
}
inline void Secret3::set_mnemonic_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  mnemonic_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.Secret3.mnemonic_key)
}
inline void Secret3::set_mnemonic_key(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  mnemonic_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.Secret3.mnemonic_key)
}
inline std::string* Secret3::_internal_mutable_mnemonic_key() {
  _has_bits_[0] |= 0x00000002u;
  return mnemonic_key_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Secret3::release_mnemonic_key() {
  // @@protoc_insertion_point(field_release:fantasybit.Secret3.mnemonic_key)
  if (!_internal_has_mnemonic_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return mnemonic_key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Secret3::set_allocated_mnemonic_key(std::string* mnemonic_key) {
  if (mnemonic_key != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  mnemonic_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mnemonic_key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.Secret3.mnemonic_key)
}

// optional string fantasy_name = 20;
inline bool Secret3::_internal_has_fantasy_name() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Secret3::has_fantasy_name() const {
  return _internal_has_fantasy_name();
}
inline void Secret3::clear_fantasy_name() {
  fantasy_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Secret3::fantasy_name() const {
  // @@protoc_insertion_point(field_get:fantasybit.Secret3.fantasy_name)
  return _internal_fantasy_name();
}
inline void Secret3::set_fantasy_name(const std::string& value) {
  _internal_set_fantasy_name(value);
  // @@protoc_insertion_point(field_set:fantasybit.Secret3.fantasy_name)
}
inline std::string* Secret3::mutable_fantasy_name() {
  // @@protoc_insertion_point(field_mutable:fantasybit.Secret3.fantasy_name)
  return _internal_mutable_fantasy_name();
}
inline const std::string& Secret3::_internal_fantasy_name() const {
  return fantasy_name_.Get();
}
inline void Secret3::_internal_set_fantasy_name(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  fantasy_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Secret3::set_fantasy_name(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  fantasy_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.Secret3.fantasy_name)
}
inline void Secret3::set_fantasy_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  fantasy_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.Secret3.fantasy_name)
}
inline void Secret3::set_fantasy_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  fantasy_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.Secret3.fantasy_name)
}
inline std::string* Secret3::_internal_mutable_fantasy_name() {
  _has_bits_[0] |= 0x00000004u;
  return fantasy_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Secret3::release_fantasy_name() {
  // @@protoc_insertion_point(field_release:fantasybit.Secret3.fantasy_name)
  if (!_internal_has_fantasy_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return fantasy_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Secret3::set_allocated_fantasy_name(std::string* fantasy_name) {
  if (fantasy_name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  fantasy_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fantasy_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.Secret3.fantasy_name)
}

// optional string public_key = 30;
inline bool Secret3::_internal_has_public_key() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Secret3::has_public_key() const {
  return _internal_has_public_key();
}
inline void Secret3::clear_public_key() {
  public_key_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Secret3::public_key() const {
  // @@protoc_insertion_point(field_get:fantasybit.Secret3.public_key)
  return _internal_public_key();
}
inline void Secret3::set_public_key(const std::string& value) {
  _internal_set_public_key(value);
  // @@protoc_insertion_point(field_set:fantasybit.Secret3.public_key)
}
inline std::string* Secret3::mutable_public_key() {
  // @@protoc_insertion_point(field_mutable:fantasybit.Secret3.public_key)
  return _internal_mutable_public_key();
}
inline const std::string& Secret3::_internal_public_key() const {
  return public_key_.Get();
}
inline void Secret3::_internal_set_public_key(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  public_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Secret3::set_public_key(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  public_key_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.Secret3.public_key)
}
inline void Secret3::set_public_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  public_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.Secret3.public_key)
}
inline void Secret3::set_public_key(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000008u;
  public_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.Secret3.public_key)
}
inline std::string* Secret3::_internal_mutable_public_key() {
  _has_bits_[0] |= 0x00000008u;
  return public_key_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Secret3::release_public_key() {
  // @@protoc_insertion_point(field_release:fantasybit.Secret3.public_key)
  if (!_internal_has_public_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return public_key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Secret3::set_allocated_public_key(std::string* public_key) {
  if (public_key != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  public_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), public_key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.Secret3.public_key)
}

// -------------------------------------------------------------------

// OutData

// required .fantasybit.OutData.Type type = 1;
inline bool OutData::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OutData::has_type() const {
  return _internal_has_type();
}
inline void OutData::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::fantasybit::OutData_Type OutData::_internal_type() const {
  return static_cast< ::fantasybit::OutData_Type >(type_);
}
inline ::fantasybit::OutData_Type OutData::type() const {
  // @@protoc_insertion_point(field_get:fantasybit.OutData.type)
  return _internal_type();
}
inline void OutData::_internal_set_type(::fantasybit::OutData_Type value) {
  assert(::fantasybit::OutData_Type_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
}
inline void OutData::set_type(::fantasybit::OutData_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:fantasybit.OutData.type)
}

// optional .fantasybit.MyFantasyName myfantasyname = 2;
inline bool OutData::_internal_has_myfantasyname() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || myfantasyname_ != nullptr);
  return value;
}
inline bool OutData::has_myfantasyname() const {
  return _internal_has_myfantasyname();
}
inline void OutData::clear_myfantasyname() {
  if (myfantasyname_ != nullptr) myfantasyname_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::fantasybit::MyFantasyName& OutData::_internal_myfantasyname() const {
  const ::fantasybit::MyFantasyName* p = myfantasyname_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fantasybit::MyFantasyName*>(
      &::fantasybit::_MyFantasyName_default_instance_);
}
inline const ::fantasybit::MyFantasyName& OutData::myfantasyname() const {
  // @@protoc_insertion_point(field_get:fantasybit.OutData.myfantasyname)
  return _internal_myfantasyname();
}
inline void OutData::unsafe_arena_set_allocated_myfantasyname(
    ::fantasybit::MyFantasyName* myfantasyname) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(myfantasyname_);
  }
  myfantasyname_ = myfantasyname;
  if (myfantasyname) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fantasybit.OutData.myfantasyname)
}
inline ::fantasybit::MyFantasyName* OutData::release_myfantasyname() {
  _has_bits_[0] &= ~0x00000001u;
  ::fantasybit::MyFantasyName* temp = myfantasyname_;
  myfantasyname_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fantasybit::MyFantasyName* OutData::unsafe_arena_release_myfantasyname() {
  // @@protoc_insertion_point(field_release:fantasybit.OutData.myfantasyname)
  _has_bits_[0] &= ~0x00000001u;
  ::fantasybit::MyFantasyName* temp = myfantasyname_;
  myfantasyname_ = nullptr;
  return temp;
}
inline ::fantasybit::MyFantasyName* OutData::_internal_mutable_myfantasyname() {
  _has_bits_[0] |= 0x00000001u;
  if (myfantasyname_ == nullptr) {
    auto* p = CreateMaybeMessage<::fantasybit::MyFantasyName>(GetArena());
    myfantasyname_ = p;
  }
  return myfantasyname_;
}
inline ::fantasybit::MyFantasyName* OutData::mutable_myfantasyname() {
  // @@protoc_insertion_point(field_mutable:fantasybit.OutData.myfantasyname)
  return _internal_mutable_myfantasyname();
}
inline void OutData::set_allocated_myfantasyname(::fantasybit::MyFantasyName* myfantasyname) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete myfantasyname_;
  }
  if (myfantasyname) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(myfantasyname);
    if (message_arena != submessage_arena) {
      myfantasyname = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, myfantasyname, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  myfantasyname_ = myfantasyname;
  // @@protoc_insertion_point(field_set_allocated:fantasybit.OutData.myfantasyname)
}

// -------------------------------------------------------------------

// InData

// required .fantasybit.InData.Type type = 1;
inline bool InData::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool InData::has_type() const {
  return _internal_has_type();
}
inline void InData::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::fantasybit::InData_Type InData::_internal_type() const {
  return static_cast< ::fantasybit::InData_Type >(type_);
}
inline ::fantasybit::InData_Type InData::type() const {
  // @@protoc_insertion_point(field_get:fantasybit.InData.type)
  return _internal_type();
}
inline void InData::_internal_set_type(::fantasybit::InData_Type value) {
  assert(::fantasybit::InData_Type_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  type_ = value;
}
inline void InData::set_type(::fantasybit::InData_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:fantasybit.InData.type)
}

// optional string data = 2;
inline bool InData::_internal_has_data() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InData::has_data() const {
  return _internal_has_data();
}
inline void InData::clear_data() {
  data_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InData::data() const {
  // @@protoc_insertion_point(field_get:fantasybit.InData.data)
  return _internal_data();
}
inline void InData::set_data(const std::string& value) {
  _internal_set_data(value);
  // @@protoc_insertion_point(field_set:fantasybit.InData.data)
}
inline std::string* InData::mutable_data() {
  // @@protoc_insertion_point(field_mutable:fantasybit.InData.data)
  return _internal_mutable_data();
}
inline const std::string& InData::_internal_data() const {
  return data_.Get();
}
inline void InData::_internal_set_data(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void InData::set_data(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  data_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.InData.data)
}
inline void InData::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.InData.data)
}
inline void InData::set_data(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.InData.data)
}
inline std::string* InData::_internal_mutable_data() {
  _has_bits_[0] |= 0x00000001u;
  return data_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* InData::release_data() {
  // @@protoc_insertion_point(field_release:fantasybit.InData.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return data_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void InData::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.InData.data)
}

// optional string data2 = 3;
inline bool InData::_internal_has_data2() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool InData::has_data2() const {
  return _internal_has_data2();
}
inline void InData::clear_data2() {
  data2_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& InData::data2() const {
  // @@protoc_insertion_point(field_get:fantasybit.InData.data2)
  return _internal_data2();
}
inline void InData::set_data2(const std::string& value) {
  _internal_set_data2(value);
  // @@protoc_insertion_point(field_set:fantasybit.InData.data2)
}
inline std::string* InData::mutable_data2() {
  // @@protoc_insertion_point(field_mutable:fantasybit.InData.data2)
  return _internal_mutable_data2();
}
inline const std::string& InData::_internal_data2() const {
  return data2_.Get();
}
inline void InData::_internal_set_data2(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  data2_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void InData::set_data2(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  data2_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.InData.data2)
}
inline void InData::set_data2(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  data2_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.InData.data2)
}
inline void InData::set_data2(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  data2_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.InData.data2)
}
inline std::string* InData::_internal_mutable_data2() {
  _has_bits_[0] |= 0x00000002u;
  return data2_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* InData::release_data2() {
  // @@protoc_insertion_point(field_release:fantasybit.InData.data2)
  if (!_internal_has_data2()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return data2_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void InData::set_allocated_data2(std::string* data2) {
  if (data2 != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  data2_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data2,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.InData.data2)
}

// optional int32 num = 4;
inline bool InData::_internal_has_num() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool InData::has_num() const {
  return _internal_has_num();
}
inline void InData::clear_num() {
  num_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InData::_internal_num() const {
  return num_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InData::num() const {
  // @@protoc_insertion_point(field_get:fantasybit.InData.num)
  return _internal_num();
}
inline void InData::_internal_set_num(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  num_ = value;
}
inline void InData::set_num(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num(value);
  // @@protoc_insertion_point(field_set:fantasybit.InData.num)
}

// optional .fantasybit.DataTransition data_trans = 5;
inline bool InData::_internal_has_data_trans() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || data_trans_ != nullptr);
  return value;
}
inline bool InData::has_data_trans() const {
  return _internal_has_data_trans();
}
inline void InData::clear_data_trans() {
  if (data_trans_ != nullptr) data_trans_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::fantasybit::DataTransition& InData::_internal_data_trans() const {
  const ::fantasybit::DataTransition* p = data_trans_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fantasybit::DataTransition*>(
      &::fantasybit::_DataTransition_default_instance_);
}
inline const ::fantasybit::DataTransition& InData::data_trans() const {
  // @@protoc_insertion_point(field_get:fantasybit.InData.data_trans)
  return _internal_data_trans();
}
inline void InData::unsafe_arena_set_allocated_data_trans(
    ::fantasybit::DataTransition* data_trans) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_trans_);
  }
  data_trans_ = data_trans;
  if (data_trans) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fantasybit.InData.data_trans)
}
inline ::fantasybit::DataTransition* InData::release_data_trans() {
  _has_bits_[0] &= ~0x00000004u;
  ::fantasybit::DataTransition* temp = data_trans_;
  data_trans_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fantasybit::DataTransition* InData::unsafe_arena_release_data_trans() {
  // @@protoc_insertion_point(field_release:fantasybit.InData.data_trans)
  _has_bits_[0] &= ~0x00000004u;
  ::fantasybit::DataTransition* temp = data_trans_;
  data_trans_ = nullptr;
  return temp;
}
inline ::fantasybit::DataTransition* InData::_internal_mutable_data_trans() {
  _has_bits_[0] |= 0x00000004u;
  if (data_trans_ == nullptr) {
    auto* p = CreateMaybeMessage<::fantasybit::DataTransition>(GetArena());
    data_trans_ = p;
  }
  return data_trans_;
}
inline ::fantasybit::DataTransition* InData::mutable_data_trans() {
  // @@protoc_insertion_point(field_mutable:fantasybit.InData.data_trans)
  return _internal_mutable_data_trans();
}
inline void InData::set_allocated_data_trans(::fantasybit::DataTransition* data_trans) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete data_trans_;
  }
  if (data_trans) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(data_trans);
    if (message_arena != submessage_arena) {
      data_trans = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data_trans, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  data_trans_ = data_trans;
  // @@protoc_insertion_point(field_set_allocated:fantasybit.InData.data_trans)
}

// -------------------------------------------------------------------

// NameProof

// optional .fantasybit.NameProof.Type type = 1;
inline bool NameProof::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NameProof::has_type() const {
  return _internal_has_type();
}
inline void NameProof::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::fantasybit::NameProof_Type NameProof::_internal_type() const {
  return static_cast< ::fantasybit::NameProof_Type >(type_);
}
inline ::fantasybit::NameProof_Type NameProof::type() const {
  // @@protoc_insertion_point(field_get:fantasybit.NameProof.type)
  return _internal_type();
}
inline void NameProof::_internal_set_type(::fantasybit::NameProof_Type value) {
  assert(::fantasybit::NameProof_Type_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  type_ = value;
}
inline void NameProof::set_type(::fantasybit::NameProof_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:fantasybit.NameProof.type)
}

// -------------------------------------------------------------------

// TweetProof

// optional string tweet = 10;
inline bool TweetProof::_internal_has_tweet() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TweetProof::has_tweet() const {
  return _internal_has_tweet();
}
inline void TweetProof::clear_tweet() {
  tweet_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TweetProof::tweet() const {
  // @@protoc_insertion_point(field_get:fantasybit.TweetProof.tweet)
  return _internal_tweet();
}
inline void TweetProof::set_tweet(const std::string& value) {
  _internal_set_tweet(value);
  // @@protoc_insertion_point(field_set:fantasybit.TweetProof.tweet)
}
inline std::string* TweetProof::mutable_tweet() {
  // @@protoc_insertion_point(field_mutable:fantasybit.TweetProof.tweet)
  return _internal_mutable_tweet();
}
inline const std::string& TweetProof::_internal_tweet() const {
  return tweet_.Get();
}
inline void TweetProof::_internal_set_tweet(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  tweet_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TweetProof::set_tweet(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  tweet_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.TweetProof.tweet)
}
inline void TweetProof::set_tweet(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  tweet_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.TweetProof.tweet)
}
inline void TweetProof::set_tweet(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  tweet_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.TweetProof.tweet)
}
inline std::string* TweetProof::_internal_mutable_tweet() {
  _has_bits_[0] |= 0x00000001u;
  return tweet_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TweetProof::release_tweet() {
  // @@protoc_insertion_point(field_release:fantasybit.TweetProof.tweet)
  if (!_internal_has_tweet()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return tweet_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TweetProof::set_allocated_tweet(std::string* tweet) {
  if (tweet != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  tweet_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tweet,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.TweetProof.tweet)
}

// -------------------------------------------------------------------

// MasterProof

// optional string season = 10;
inline bool MasterProof::_internal_has_season() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MasterProof::has_season() const {
  return _internal_has_season();
}
inline void MasterProof::clear_season() {
  season_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MasterProof::season() const {
  // @@protoc_insertion_point(field_get:fantasybit.MasterProof.season)
  return _internal_season();
}
inline void MasterProof::set_season(const std::string& value) {
  _internal_set_season(value);
  // @@protoc_insertion_point(field_set:fantasybit.MasterProof.season)
}
inline std::string* MasterProof::mutable_season() {
  // @@protoc_insertion_point(field_mutable:fantasybit.MasterProof.season)
  return _internal_mutable_season();
}
inline const std::string& MasterProof::_internal_season() const {
  return season_.Get();
}
inline void MasterProof::_internal_set_season(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  season_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void MasterProof::set_season(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  season_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.MasterProof.season)
}
inline void MasterProof::set_season(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  season_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.MasterProof.season)
}
inline void MasterProof::set_season(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  season_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.MasterProof.season)
}
inline std::string* MasterProof::_internal_mutable_season() {
  _has_bits_[0] |= 0x00000001u;
  return season_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* MasterProof::release_season() {
  // @@protoc_insertion_point(field_release:fantasybit.MasterProof.season)
  if (!_internal_has_season()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return season_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MasterProof::set_allocated_season(std::string* season) {
  if (season != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  season_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), season,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.MasterProof.season)
}

// optional int32 week = 20;
inline bool MasterProof::_internal_has_week() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MasterProof::has_week() const {
  return _internal_has_week();
}
inline void MasterProof::clear_week() {
  week_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MasterProof::_internal_week() const {
  return week_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MasterProof::week() const {
  // @@protoc_insertion_point(field_get:fantasybit.MasterProof.week)
  return _internal_week();
}
inline void MasterProof::_internal_set_week(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  week_ = value;
}
inline void MasterProof::set_week(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_week(value);
  // @@protoc_insertion_point(field_set:fantasybit.MasterProof.week)
}

// optional int32 timestamp = 21;
inline bool MasterProof::_internal_has_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MasterProof::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void MasterProof::clear_timestamp() {
  timestamp_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MasterProof::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MasterProof::timestamp() const {
  // @@protoc_insertion_point(field_get:fantasybit.MasterProof.timestamp)
  return _internal_timestamp();
}
inline void MasterProof::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  timestamp_ = value;
}
inline void MasterProof::set_timestamp(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:fantasybit.MasterProof.timestamp)
}

// optional .fantasybit.SignedTransaction new_oracle_name = 66;
inline bool MasterProof::_internal_has_new_oracle_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || new_oracle_name_ != nullptr);
  return value;
}
inline bool MasterProof::has_new_oracle_name() const {
  return _internal_has_new_oracle_name();
}
inline void MasterProof::clear_new_oracle_name() {
  if (new_oracle_name_ != nullptr) new_oracle_name_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::fantasybit::SignedTransaction& MasterProof::_internal_new_oracle_name() const {
  const ::fantasybit::SignedTransaction* p = new_oracle_name_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fantasybit::SignedTransaction*>(
      &::fantasybit::_SignedTransaction_default_instance_);
}
inline const ::fantasybit::SignedTransaction& MasterProof::new_oracle_name() const {
  // @@protoc_insertion_point(field_get:fantasybit.MasterProof.new_oracle_name)
  return _internal_new_oracle_name();
}
inline void MasterProof::unsafe_arena_set_allocated_new_oracle_name(
    ::fantasybit::SignedTransaction* new_oracle_name) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(new_oracle_name_);
  }
  new_oracle_name_ = new_oracle_name;
  if (new_oracle_name) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fantasybit.MasterProof.new_oracle_name)
}
inline ::fantasybit::SignedTransaction* MasterProof::release_new_oracle_name() {
  _has_bits_[0] &= ~0x00000002u;
  ::fantasybit::SignedTransaction* temp = new_oracle_name_;
  new_oracle_name_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fantasybit::SignedTransaction* MasterProof::unsafe_arena_release_new_oracle_name() {
  // @@protoc_insertion_point(field_release:fantasybit.MasterProof.new_oracle_name)
  _has_bits_[0] &= ~0x00000002u;
  ::fantasybit::SignedTransaction* temp = new_oracle_name_;
  new_oracle_name_ = nullptr;
  return temp;
}
inline ::fantasybit::SignedTransaction* MasterProof::_internal_mutable_new_oracle_name() {
  _has_bits_[0] |= 0x00000002u;
  if (new_oracle_name_ == nullptr) {
    auto* p = CreateMaybeMessage<::fantasybit::SignedTransaction>(GetArena());
    new_oracle_name_ = p;
  }
  return new_oracle_name_;
}
inline ::fantasybit::SignedTransaction* MasterProof::mutable_new_oracle_name() {
  // @@protoc_insertion_point(field_mutable:fantasybit.MasterProof.new_oracle_name)
  return _internal_mutable_new_oracle_name();
}
inline void MasterProof::set_allocated_new_oracle_name(::fantasybit::SignedTransaction* new_oracle_name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete new_oracle_name_;
  }
  if (new_oracle_name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(new_oracle_name);
    if (message_arena != submessage_arena) {
      new_oracle_name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, new_oracle_name, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  new_oracle_name_ = new_oracle_name;
  // @@protoc_insertion_point(field_set_allocated:fantasybit.MasterProof.new_oracle_name)
}

// -------------------------------------------------------------------

// Transaction

// optional int32 version = 1;
inline bool Transaction::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Transaction::has_version() const {
  return _internal_has_version();
}
inline void Transaction::clear_version() {
  version_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Transaction::_internal_version() const {
  return version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Transaction::version() const {
  // @@protoc_insertion_point(field_get:fantasybit.Transaction.version)
  return _internal_version();
}
inline void Transaction::_internal_set_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  version_ = value;
}
inline void Transaction::set_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:fantasybit.Transaction.version)
}

// optional .fantasybit.TransType type = 2;
inline bool Transaction::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Transaction::has_type() const {
  return _internal_has_type();
}
inline void Transaction::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::fantasybit::TransType Transaction::_internal_type() const {
  return static_cast< ::fantasybit::TransType >(type_);
}
inline ::fantasybit::TransType Transaction::type() const {
  // @@protoc_insertion_point(field_get:fantasybit.Transaction.type)
  return _internal_type();
}
inline void Transaction::_internal_set_type(::fantasybit::TransType value) {
  assert(::fantasybit::TransType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
}
inline void Transaction::set_type(::fantasybit::TransType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:fantasybit.Transaction.type)
}

// optional uint64 nonce = 10;
inline bool Transaction::_internal_has_nonce() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Transaction::has_nonce() const {
  return _internal_has_nonce();
}
inline void Transaction::clear_nonce() {
  nonce_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Transaction::_internal_nonce() const {
  return nonce_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Transaction::nonce() const {
  // @@protoc_insertion_point(field_get:fantasybit.Transaction.nonce)
  return _internal_nonce();
}
inline void Transaction::_internal_set_nonce(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  nonce_ = value;
}
inline void Transaction::set_nonce(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:fantasybit.Transaction.nonce)
}

// -------------------------------------------------------------------

// NameTrans

// optional string fantasy_name = 10;
inline bool NameTrans::_internal_has_fantasy_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NameTrans::has_fantasy_name() const {
  return _internal_has_fantasy_name();
}
inline void NameTrans::clear_fantasy_name() {
  fantasy_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NameTrans::fantasy_name() const {
  // @@protoc_insertion_point(field_get:fantasybit.NameTrans.fantasy_name)
  return _internal_fantasy_name();
}
inline void NameTrans::set_fantasy_name(const std::string& value) {
  _internal_set_fantasy_name(value);
  // @@protoc_insertion_point(field_set:fantasybit.NameTrans.fantasy_name)
}
inline std::string* NameTrans::mutable_fantasy_name() {
  // @@protoc_insertion_point(field_mutable:fantasybit.NameTrans.fantasy_name)
  return _internal_mutable_fantasy_name();
}
inline const std::string& NameTrans::_internal_fantasy_name() const {
  return fantasy_name_.Get();
}
inline void NameTrans::_internal_set_fantasy_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  fantasy_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void NameTrans::set_fantasy_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  fantasy_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.NameTrans.fantasy_name)
}
inline void NameTrans::set_fantasy_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  fantasy_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.NameTrans.fantasy_name)
}
inline void NameTrans::set_fantasy_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  fantasy_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.NameTrans.fantasy_name)
}
inline std::string* NameTrans::_internal_mutable_fantasy_name() {
  _has_bits_[0] |= 0x00000001u;
  return fantasy_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* NameTrans::release_fantasy_name() {
  // @@protoc_insertion_point(field_release:fantasybit.NameTrans.fantasy_name)
  if (!_internal_has_fantasy_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return fantasy_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NameTrans::set_allocated_fantasy_name(std::string* fantasy_name) {
  if (fantasy_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  fantasy_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fantasy_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.NameTrans.fantasy_name)
}

// optional bytes public_key = 20;
inline bool NameTrans::_internal_has_public_key() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool NameTrans::has_public_key() const {
  return _internal_has_public_key();
}
inline void NameTrans::clear_public_key() {
  public_key_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& NameTrans::public_key() const {
  // @@protoc_insertion_point(field_get:fantasybit.NameTrans.public_key)
  return _internal_public_key();
}
inline void NameTrans::set_public_key(const std::string& value) {
  _internal_set_public_key(value);
  // @@protoc_insertion_point(field_set:fantasybit.NameTrans.public_key)
}
inline std::string* NameTrans::mutable_public_key() {
  // @@protoc_insertion_point(field_mutable:fantasybit.NameTrans.public_key)
  return _internal_mutable_public_key();
}
inline const std::string& NameTrans::_internal_public_key() const {
  return public_key_.Get();
}
inline void NameTrans::_internal_set_public_key(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  public_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void NameTrans::set_public_key(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  public_key_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.NameTrans.public_key)
}
inline void NameTrans::set_public_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  public_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.NameTrans.public_key)
}
inline void NameTrans::set_public_key(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  public_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.NameTrans.public_key)
}
inline std::string* NameTrans::_internal_mutable_public_key() {
  _has_bits_[0] |= 0x00000002u;
  return public_key_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* NameTrans::release_public_key() {
  // @@protoc_insertion_point(field_release:fantasybit.NameTrans.public_key)
  if (!_internal_has_public_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return public_key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NameTrans::set_allocated_public_key(std::string* public_key) {
  if (public_key != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  public_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), public_key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.NameTrans.public_key)
}

// optional .fantasybit.NameProof proof = 30;
inline bool NameTrans::_internal_has_proof() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || proof_ != nullptr);
  return value;
}
inline bool NameTrans::has_proof() const {
  return _internal_has_proof();
}
inline void NameTrans::clear_proof() {
  if (proof_ != nullptr) proof_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::fantasybit::NameProof& NameTrans::_internal_proof() const {
  const ::fantasybit::NameProof* p = proof_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fantasybit::NameProof*>(
      &::fantasybit::_NameProof_default_instance_);
}
inline const ::fantasybit::NameProof& NameTrans::proof() const {
  // @@protoc_insertion_point(field_get:fantasybit.NameTrans.proof)
  return _internal_proof();
}
inline void NameTrans::unsafe_arena_set_allocated_proof(
    ::fantasybit::NameProof* proof) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(proof_);
  }
  proof_ = proof;
  if (proof) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fantasybit.NameTrans.proof)
}
inline ::fantasybit::NameProof* NameTrans::release_proof() {
  _has_bits_[0] &= ~0x00000010u;
  ::fantasybit::NameProof* temp = proof_;
  proof_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fantasybit::NameProof* NameTrans::unsafe_arena_release_proof() {
  // @@protoc_insertion_point(field_release:fantasybit.NameTrans.proof)
  _has_bits_[0] &= ~0x00000010u;
  ::fantasybit::NameProof* temp = proof_;
  proof_ = nullptr;
  return temp;
}
inline ::fantasybit::NameProof* NameTrans::_internal_mutable_proof() {
  _has_bits_[0] |= 0x00000010u;
  if (proof_ == nullptr) {
    auto* p = CreateMaybeMessage<::fantasybit::NameProof>(GetArena());
    proof_ = p;
  }
  return proof_;
}
inline ::fantasybit::NameProof* NameTrans::mutable_proof() {
  // @@protoc_insertion_point(field_mutable:fantasybit.NameTrans.proof)
  return _internal_mutable_proof();
}
inline void NameTrans::set_allocated_proof(::fantasybit::NameProof* proof) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete proof_;
  }
  if (proof) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(proof);
    if (message_arena != submessage_arena) {
      proof = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, proof, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  proof_ = proof;
  // @@protoc_insertion_point(field_set_allocated:fantasybit.NameTrans.proof)
}

// optional bytes recovery_key = 40;
inline bool NameTrans::_internal_has_recovery_key() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool NameTrans::has_recovery_key() const {
  return _internal_has_recovery_key();
}
inline void NameTrans::clear_recovery_key() {
  recovery_key_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& NameTrans::recovery_key() const {
  // @@protoc_insertion_point(field_get:fantasybit.NameTrans.recovery_key)
  return _internal_recovery_key();
}
inline void NameTrans::set_recovery_key(const std::string& value) {
  _internal_set_recovery_key(value);
  // @@protoc_insertion_point(field_set:fantasybit.NameTrans.recovery_key)
}
inline std::string* NameTrans::mutable_recovery_key() {
  // @@protoc_insertion_point(field_mutable:fantasybit.NameTrans.recovery_key)
  return _internal_mutable_recovery_key();
}
inline const std::string& NameTrans::_internal_recovery_key() const {
  return recovery_key_.Get();
}
inline void NameTrans::_internal_set_recovery_key(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  recovery_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void NameTrans::set_recovery_key(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  recovery_key_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.NameTrans.recovery_key)
}
inline void NameTrans::set_recovery_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  recovery_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.NameTrans.recovery_key)
}
inline void NameTrans::set_recovery_key(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  recovery_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.NameTrans.recovery_key)
}
inline std::string* NameTrans::_internal_mutable_recovery_key() {
  _has_bits_[0] |= 0x00000004u;
  return recovery_key_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* NameTrans::release_recovery_key() {
  // @@protoc_insertion_point(field_release:fantasybit.NameTrans.recovery_key)
  if (!_internal_has_recovery_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return recovery_key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NameTrans::set_allocated_recovery_key(std::string* recovery_key) {
  if (recovery_key != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  recovery_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), recovery_key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.NameTrans.recovery_key)
}

// optional bool am_agent = 50;
inline bool NameTrans::_internal_has_am_agent() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool NameTrans::has_am_agent() const {
  return _internal_has_am_agent();
}
inline void NameTrans::clear_am_agent() {
  am_agent_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool NameTrans::_internal_am_agent() const {
  return am_agent_;
}
inline bool NameTrans::am_agent() const {
  // @@protoc_insertion_point(field_get:fantasybit.NameTrans.am_agent)
  return _internal_am_agent();
}
inline void NameTrans::_internal_set_am_agent(bool value) {
  _has_bits_[0] |= 0x00000020u;
  am_agent_ = value;
}
inline void NameTrans::set_am_agent(bool value) {
  _internal_set_am_agent(value);
  // @@protoc_insertion_point(field_set:fantasybit.NameTrans.am_agent)
}

// optional string my_agent = 60;
inline bool NameTrans::_internal_has_my_agent() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool NameTrans::has_my_agent() const {
  return _internal_has_my_agent();
}
inline void NameTrans::clear_my_agent() {
  my_agent_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& NameTrans::my_agent() const {
  // @@protoc_insertion_point(field_get:fantasybit.NameTrans.my_agent)
  return _internal_my_agent();
}
inline void NameTrans::set_my_agent(const std::string& value) {
  _internal_set_my_agent(value);
  // @@protoc_insertion_point(field_set:fantasybit.NameTrans.my_agent)
}
inline std::string* NameTrans::mutable_my_agent() {
  // @@protoc_insertion_point(field_mutable:fantasybit.NameTrans.my_agent)
  return _internal_mutable_my_agent();
}
inline const std::string& NameTrans::_internal_my_agent() const {
  return my_agent_.Get();
}
inline void NameTrans::_internal_set_my_agent(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  my_agent_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void NameTrans::set_my_agent(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  my_agent_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.NameTrans.my_agent)
}
inline void NameTrans::set_my_agent(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  my_agent_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.NameTrans.my_agent)
}
inline void NameTrans::set_my_agent(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000008u;
  my_agent_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.NameTrans.my_agent)
}
inline std::string* NameTrans::_internal_mutable_my_agent() {
  _has_bits_[0] |= 0x00000008u;
  return my_agent_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* NameTrans::release_my_agent() {
  // @@protoc_insertion_point(field_release:fantasybit.NameTrans.my_agent)
  if (!_internal_has_my_agent()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return my_agent_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NameTrans::set_allocated_my_agent(std::string* my_agent) {
  if (my_agent != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  my_agent_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), my_agent,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.NameTrans.my_agent)
}

// -------------------------------------------------------------------

// TransferTrans

// optional string from = 10;
inline bool TransferTrans::_internal_has_from() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TransferTrans::has_from() const {
  return _internal_has_from();
}
inline void TransferTrans::clear_from() {
  from_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TransferTrans::from() const {
  // @@protoc_insertion_point(field_get:fantasybit.TransferTrans.from)
  return _internal_from();
}
inline void TransferTrans::set_from(const std::string& value) {
  _internal_set_from(value);
  // @@protoc_insertion_point(field_set:fantasybit.TransferTrans.from)
}
inline std::string* TransferTrans::mutable_from() {
  // @@protoc_insertion_point(field_mutable:fantasybit.TransferTrans.from)
  return _internal_mutable_from();
}
inline const std::string& TransferTrans::_internal_from() const {
  return from_.Get();
}
inline void TransferTrans::_internal_set_from(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  from_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TransferTrans::set_from(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  from_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.TransferTrans.from)
}
inline void TransferTrans::set_from(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  from_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.TransferTrans.from)
}
inline void TransferTrans::set_from(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  from_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.TransferTrans.from)
}
inline std::string* TransferTrans::_internal_mutable_from() {
  _has_bits_[0] |= 0x00000001u;
  return from_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TransferTrans::release_from() {
  // @@protoc_insertion_point(field_release:fantasybit.TransferTrans.from)
  if (!_internal_has_from()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return from_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TransferTrans::set_allocated_from(std::string* from) {
  if (from != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  from_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.TransferTrans.from)
}

// optional string to = 20;
inline bool TransferTrans::_internal_has_to() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TransferTrans::has_to() const {
  return _internal_has_to();
}
inline void TransferTrans::clear_to() {
  to_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TransferTrans::to() const {
  // @@protoc_insertion_point(field_get:fantasybit.TransferTrans.to)
  return _internal_to();
}
inline void TransferTrans::set_to(const std::string& value) {
  _internal_set_to(value);
  // @@protoc_insertion_point(field_set:fantasybit.TransferTrans.to)
}
inline std::string* TransferTrans::mutable_to() {
  // @@protoc_insertion_point(field_mutable:fantasybit.TransferTrans.to)
  return _internal_mutable_to();
}
inline const std::string& TransferTrans::_internal_to() const {
  return to_.Get();
}
inline void TransferTrans::_internal_set_to(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  to_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TransferTrans::set_to(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  to_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.TransferTrans.to)
}
inline void TransferTrans::set_to(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  to_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.TransferTrans.to)
}
inline void TransferTrans::set_to(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  to_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.TransferTrans.to)
}
inline std::string* TransferTrans::_internal_mutable_to() {
  _has_bits_[0] |= 0x00000002u;
  return to_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TransferTrans::release_to() {
  // @@protoc_insertion_point(field_release:fantasybit.TransferTrans.to)
  if (!_internal_has_to()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return to_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TransferTrans::set_allocated_to(std::string* to) {
  if (to != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  to_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), to,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.TransferTrans.to)
}

// optional uint64 amount = 30;
inline bool TransferTrans::_internal_has_amount() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TransferTrans::has_amount() const {
  return _internal_has_amount();
}
inline void TransferTrans::clear_amount() {
  amount_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TransferTrans::_internal_amount() const {
  return amount_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TransferTrans::amount() const {
  // @@protoc_insertion_point(field_get:fantasybit.TransferTrans.amount)
  return _internal_amount();
}
inline void TransferTrans::_internal_set_amount(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  amount_ = value;
}
inline void TransferTrans::set_amount(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:fantasybit.TransferTrans.amount)
}

// -------------------------------------------------------------------

// SignedTransaction

// optional .fantasybit.Transaction trans = 10;
inline bool SignedTransaction::_internal_has_trans() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || trans_ != nullptr);
  return value;
}
inline bool SignedTransaction::has_trans() const {
  return _internal_has_trans();
}
inline void SignedTransaction::clear_trans() {
  if (trans_ != nullptr) trans_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::fantasybit::Transaction& SignedTransaction::_internal_trans() const {
  const ::fantasybit::Transaction* p = trans_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fantasybit::Transaction*>(
      &::fantasybit::_Transaction_default_instance_);
}
inline const ::fantasybit::Transaction& SignedTransaction::trans() const {
  // @@protoc_insertion_point(field_get:fantasybit.SignedTransaction.trans)
  return _internal_trans();
}
inline void SignedTransaction::unsafe_arena_set_allocated_trans(
    ::fantasybit::Transaction* trans) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(trans_);
  }
  trans_ = trans;
  if (trans) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fantasybit.SignedTransaction.trans)
}
inline ::fantasybit::Transaction* SignedTransaction::release_trans() {
  _has_bits_[0] &= ~0x00000008u;
  ::fantasybit::Transaction* temp = trans_;
  trans_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fantasybit::Transaction* SignedTransaction::unsafe_arena_release_trans() {
  // @@protoc_insertion_point(field_release:fantasybit.SignedTransaction.trans)
  _has_bits_[0] &= ~0x00000008u;
  ::fantasybit::Transaction* temp = trans_;
  trans_ = nullptr;
  return temp;
}
inline ::fantasybit::Transaction* SignedTransaction::_internal_mutable_trans() {
  _has_bits_[0] |= 0x00000008u;
  if (trans_ == nullptr) {
    auto* p = CreateMaybeMessage<::fantasybit::Transaction>(GetArena());
    trans_ = p;
  }
  return trans_;
}
inline ::fantasybit::Transaction* SignedTransaction::mutable_trans() {
  // @@protoc_insertion_point(field_mutable:fantasybit.SignedTransaction.trans)
  return _internal_mutable_trans();
}
inline void SignedTransaction::set_allocated_trans(::fantasybit::Transaction* trans) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete trans_;
  }
  if (trans) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(trans);
    if (message_arena != submessage_arena) {
      trans = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trans, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  trans_ = trans;
  // @@protoc_insertion_point(field_set_allocated:fantasybit.SignedTransaction.trans)
}

// optional bytes id = 20;
inline bool SignedTransaction::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SignedTransaction::has_id() const {
  return _internal_has_id();
}
inline void SignedTransaction::clear_id() {
  id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SignedTransaction::id() const {
  // @@protoc_insertion_point(field_get:fantasybit.SignedTransaction.id)
  return _internal_id();
}
inline void SignedTransaction::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:fantasybit.SignedTransaction.id)
}
inline std::string* SignedTransaction::mutable_id() {
  // @@protoc_insertion_point(field_mutable:fantasybit.SignedTransaction.id)
  return _internal_mutable_id();
}
inline const std::string& SignedTransaction::_internal_id() const {
  return id_.Get();
}
inline void SignedTransaction::_internal_set_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SignedTransaction::set_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.SignedTransaction.id)
}
inline void SignedTransaction::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.SignedTransaction.id)
}
inline void SignedTransaction::set_id(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.SignedTransaction.id)
}
inline std::string* SignedTransaction::_internal_mutable_id() {
  _has_bits_[0] |= 0x00000001u;
  return id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SignedTransaction::release_id() {
  // @@protoc_insertion_point(field_release:fantasybit.SignedTransaction.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SignedTransaction::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.SignedTransaction.id)
}

// optional bytes sig = 30;
inline bool SignedTransaction::_internal_has_sig() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SignedTransaction::has_sig() const {
  return _internal_has_sig();
}
inline void SignedTransaction::clear_sig() {
  sig_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SignedTransaction::sig() const {
  // @@protoc_insertion_point(field_get:fantasybit.SignedTransaction.sig)
  return _internal_sig();
}
inline void SignedTransaction::set_sig(const std::string& value) {
  _internal_set_sig(value);
  // @@protoc_insertion_point(field_set:fantasybit.SignedTransaction.sig)
}
inline std::string* SignedTransaction::mutable_sig() {
  // @@protoc_insertion_point(field_mutable:fantasybit.SignedTransaction.sig)
  return _internal_mutable_sig();
}
inline const std::string& SignedTransaction::_internal_sig() const {
  return sig_.Get();
}
inline void SignedTransaction::_internal_set_sig(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  sig_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SignedTransaction::set_sig(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  sig_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.SignedTransaction.sig)
}
inline void SignedTransaction::set_sig(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  sig_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.SignedTransaction.sig)
}
inline void SignedTransaction::set_sig(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  sig_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.SignedTransaction.sig)
}
inline std::string* SignedTransaction::_internal_mutable_sig() {
  _has_bits_[0] |= 0x00000002u;
  return sig_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SignedTransaction::release_sig() {
  // @@protoc_insertion_point(field_release:fantasybit.SignedTransaction.sig)
  if (!_internal_has_sig()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return sig_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SignedTransaction::set_allocated_sig(std::string* sig) {
  if (sig != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  sig_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sig,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.SignedTransaction.sig)
}

// optional string fantasy_name = 40;
inline bool SignedTransaction::_internal_has_fantasy_name() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SignedTransaction::has_fantasy_name() const {
  return _internal_has_fantasy_name();
}
inline void SignedTransaction::clear_fantasy_name() {
  fantasy_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SignedTransaction::fantasy_name() const {
  // @@protoc_insertion_point(field_get:fantasybit.SignedTransaction.fantasy_name)
  return _internal_fantasy_name();
}
inline void SignedTransaction::set_fantasy_name(const std::string& value) {
  _internal_set_fantasy_name(value);
  // @@protoc_insertion_point(field_set:fantasybit.SignedTransaction.fantasy_name)
}
inline std::string* SignedTransaction::mutable_fantasy_name() {
  // @@protoc_insertion_point(field_mutable:fantasybit.SignedTransaction.fantasy_name)
  return _internal_mutable_fantasy_name();
}
inline const std::string& SignedTransaction::_internal_fantasy_name() const {
  return fantasy_name_.Get();
}
inline void SignedTransaction::_internal_set_fantasy_name(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  fantasy_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SignedTransaction::set_fantasy_name(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  fantasy_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.SignedTransaction.fantasy_name)
}
inline void SignedTransaction::set_fantasy_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  fantasy_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.SignedTransaction.fantasy_name)
}
inline void SignedTransaction::set_fantasy_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  fantasy_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.SignedTransaction.fantasy_name)
}
inline std::string* SignedTransaction::_internal_mutable_fantasy_name() {
  _has_bits_[0] |= 0x00000004u;
  return fantasy_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SignedTransaction::release_fantasy_name() {
  // @@protoc_insertion_point(field_release:fantasybit.SignedTransaction.fantasy_name)
  if (!_internal_has_fantasy_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return fantasy_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SignedTransaction::set_allocated_fantasy_name(std::string* fantasy_name) {
  if (fantasy_name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  fantasy_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fantasy_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.SignedTransaction.fantasy_name)
}

// -------------------------------------------------------------------

// BlockHeader

// optional int32 version = 1;
inline bool BlockHeader::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool BlockHeader::has_version() const {
  return _internal_has_version();
}
inline void BlockHeader::clear_version() {
  version_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BlockHeader::_internal_version() const {
  return version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BlockHeader::version() const {
  // @@protoc_insertion_point(field_get:fantasybit.BlockHeader.version)
  return _internal_version();
}
inline void BlockHeader::_internal_set_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  version_ = value;
}
inline void BlockHeader::set_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:fantasybit.BlockHeader.version)
}

// optional int32 num = 10;
inline bool BlockHeader::_internal_has_num() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool BlockHeader::has_num() const {
  return _internal_has_num();
}
inline void BlockHeader::clear_num() {
  num_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BlockHeader::_internal_num() const {
  return num_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BlockHeader::num() const {
  // @@protoc_insertion_point(field_get:fantasybit.BlockHeader.num)
  return _internal_num();
}
inline void BlockHeader::_internal_set_num(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  num_ = value;
}
inline void BlockHeader::set_num(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num(value);
  // @@protoc_insertion_point(field_set:fantasybit.BlockHeader.num)
}

// optional bytes prev_id = 20;
inline bool BlockHeader::_internal_has_prev_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BlockHeader::has_prev_id() const {
  return _internal_has_prev_id();
}
inline void BlockHeader::clear_prev_id() {
  prev_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BlockHeader::prev_id() const {
  // @@protoc_insertion_point(field_get:fantasybit.BlockHeader.prev_id)
  return _internal_prev_id();
}
inline void BlockHeader::set_prev_id(const std::string& value) {
  _internal_set_prev_id(value);
  // @@protoc_insertion_point(field_set:fantasybit.BlockHeader.prev_id)
}
inline std::string* BlockHeader::mutable_prev_id() {
  // @@protoc_insertion_point(field_mutable:fantasybit.BlockHeader.prev_id)
  return _internal_mutable_prev_id();
}
inline const std::string& BlockHeader::_internal_prev_id() const {
  return prev_id_.Get();
}
inline void BlockHeader::_internal_set_prev_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  prev_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BlockHeader::set_prev_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  prev_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.BlockHeader.prev_id)
}
inline void BlockHeader::set_prev_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  prev_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.BlockHeader.prev_id)
}
inline void BlockHeader::set_prev_id(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  prev_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.BlockHeader.prev_id)
}
inline std::string* BlockHeader::_internal_mutable_prev_id() {
  _has_bits_[0] |= 0x00000001u;
  return prev_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BlockHeader::release_prev_id() {
  // @@protoc_insertion_point(field_release:fantasybit.BlockHeader.prev_id)
  if (!_internal_has_prev_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return prev_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BlockHeader::set_allocated_prev_id(std::string* prev_id) {
  if (prev_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  prev_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), prev_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.BlockHeader.prev_id)
}

// optional int32 timestamp = 21;
inline bool BlockHeader::_internal_has_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool BlockHeader::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void BlockHeader::clear_timestamp() {
  timestamp_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BlockHeader::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BlockHeader::timestamp() const {
  // @@protoc_insertion_point(field_get:fantasybit.BlockHeader.timestamp)
  return _internal_timestamp();
}
inline void BlockHeader::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  timestamp_ = value;
}
inline void BlockHeader::set_timestamp(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:fantasybit.BlockHeader.timestamp)
}

// optional bytes generator_pk = 30;
inline bool BlockHeader::_internal_has_generator_pk() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BlockHeader::has_generator_pk() const {
  return _internal_has_generator_pk();
}
inline void BlockHeader::clear_generator_pk() {
  generator_pk_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BlockHeader::generator_pk() const {
  // @@protoc_insertion_point(field_get:fantasybit.BlockHeader.generator_pk)
  return _internal_generator_pk();
}
inline void BlockHeader::set_generator_pk(const std::string& value) {
  _internal_set_generator_pk(value);
  // @@protoc_insertion_point(field_set:fantasybit.BlockHeader.generator_pk)
}
inline std::string* BlockHeader::mutable_generator_pk() {
  // @@protoc_insertion_point(field_mutable:fantasybit.BlockHeader.generator_pk)
  return _internal_mutable_generator_pk();
}
inline const std::string& BlockHeader::_internal_generator_pk() const {
  return generator_pk_.Get();
}
inline void BlockHeader::_internal_set_generator_pk(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  generator_pk_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BlockHeader::set_generator_pk(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  generator_pk_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.BlockHeader.generator_pk)
}
inline void BlockHeader::set_generator_pk(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  generator_pk_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.BlockHeader.generator_pk)
}
inline void BlockHeader::set_generator_pk(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  generator_pk_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.BlockHeader.generator_pk)
}
inline std::string* BlockHeader::_internal_mutable_generator_pk() {
  _has_bits_[0] |= 0x00000002u;
  return generator_pk_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BlockHeader::release_generator_pk() {
  // @@protoc_insertion_point(field_release:fantasybit.BlockHeader.generator_pk)
  if (!_internal_has_generator_pk()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return generator_pk_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BlockHeader::set_allocated_generator_pk(std::string* generator_pk) {
  if (generator_pk != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  generator_pk_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), generator_pk,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.BlockHeader.generator_pk)
}

// optional bytes generating_sig = 40;
inline bool BlockHeader::_internal_has_generating_sig() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BlockHeader::has_generating_sig() const {
  return _internal_has_generating_sig();
}
inline void BlockHeader::clear_generating_sig() {
  generating_sig_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& BlockHeader::generating_sig() const {
  // @@protoc_insertion_point(field_get:fantasybit.BlockHeader.generating_sig)
  return _internal_generating_sig();
}
inline void BlockHeader::set_generating_sig(const std::string& value) {
  _internal_set_generating_sig(value);
  // @@protoc_insertion_point(field_set:fantasybit.BlockHeader.generating_sig)
}
inline std::string* BlockHeader::mutable_generating_sig() {
  // @@protoc_insertion_point(field_mutable:fantasybit.BlockHeader.generating_sig)
  return _internal_mutable_generating_sig();
}
inline const std::string& BlockHeader::_internal_generating_sig() const {
  return generating_sig_.Get();
}
inline void BlockHeader::_internal_set_generating_sig(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  generating_sig_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BlockHeader::set_generating_sig(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  generating_sig_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.BlockHeader.generating_sig)
}
inline void BlockHeader::set_generating_sig(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  generating_sig_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.BlockHeader.generating_sig)
}
inline void BlockHeader::set_generating_sig(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  generating_sig_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.BlockHeader.generating_sig)
}
inline std::string* BlockHeader::_internal_mutable_generating_sig() {
  _has_bits_[0] |= 0x00000004u;
  return generating_sig_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BlockHeader::release_generating_sig() {
  // @@protoc_insertion_point(field_release:fantasybit.BlockHeader.generating_sig)
  if (!_internal_has_generating_sig()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return generating_sig_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BlockHeader::set_allocated_generating_sig(std::string* generating_sig) {
  if (generating_sig != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  generating_sig_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), generating_sig,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.BlockHeader.generating_sig)
}

// optional uint64 basetarget = 50;
inline bool BlockHeader::_internal_has_basetarget() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool BlockHeader::has_basetarget() const {
  return _internal_has_basetarget();
}
inline void BlockHeader::clear_basetarget() {
  basetarget_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BlockHeader::_internal_basetarget() const {
  return basetarget_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BlockHeader::basetarget() const {
  // @@protoc_insertion_point(field_get:fantasybit.BlockHeader.basetarget)
  return _internal_basetarget();
}
inline void BlockHeader::_internal_set_basetarget(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000080u;
  basetarget_ = value;
}
inline void BlockHeader::set_basetarget(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_basetarget(value);
  // @@protoc_insertion_point(field_set:fantasybit.BlockHeader.basetarget)
}

// optional .fantasybit.BlockHeader.Type blocktype = 60;
inline bool BlockHeader::_internal_has_blocktype() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool BlockHeader::has_blocktype() const {
  return _internal_has_blocktype();
}
inline void BlockHeader::clear_blocktype() {
  blocktype_ = 1;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::fantasybit::BlockHeader_Type BlockHeader::_internal_blocktype() const {
  return static_cast< ::fantasybit::BlockHeader_Type >(blocktype_);
}
inline ::fantasybit::BlockHeader_Type BlockHeader::blocktype() const {
  // @@protoc_insertion_point(field_get:fantasybit.BlockHeader.blocktype)
  return _internal_blocktype();
}
inline void BlockHeader::_internal_set_blocktype(::fantasybit::BlockHeader_Type value) {
  assert(::fantasybit::BlockHeader_Type_IsValid(value));
  _has_bits_[0] |= 0x00000100u;
  blocktype_ = value;
}
inline void BlockHeader::set_blocktype(::fantasybit::BlockHeader_Type value) {
  _internal_set_blocktype(value);
  // @@protoc_insertion_point(field_set:fantasybit.BlockHeader.blocktype)
}

// optional bytes transaction_id = 70;
inline bool BlockHeader::_internal_has_transaction_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool BlockHeader::has_transaction_id() const {
  return _internal_has_transaction_id();
}
inline void BlockHeader::clear_transaction_id() {
  transaction_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& BlockHeader::transaction_id() const {
  // @@protoc_insertion_point(field_get:fantasybit.BlockHeader.transaction_id)
  return _internal_transaction_id();
}
inline void BlockHeader::set_transaction_id(const std::string& value) {
  _internal_set_transaction_id(value);
  // @@protoc_insertion_point(field_set:fantasybit.BlockHeader.transaction_id)
}
inline std::string* BlockHeader::mutable_transaction_id() {
  // @@protoc_insertion_point(field_mutable:fantasybit.BlockHeader.transaction_id)
  return _internal_mutable_transaction_id();
}
inline const std::string& BlockHeader::_internal_transaction_id() const {
  return transaction_id_.Get();
}
inline void BlockHeader::_internal_set_transaction_id(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  transaction_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void BlockHeader::set_transaction_id(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  transaction_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.BlockHeader.transaction_id)
}
inline void BlockHeader::set_transaction_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  transaction_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.BlockHeader.transaction_id)
}
inline void BlockHeader::set_transaction_id(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000008u;
  transaction_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.BlockHeader.transaction_id)
}
inline std::string* BlockHeader::_internal_mutable_transaction_id() {
  _has_bits_[0] |= 0x00000008u;
  return transaction_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* BlockHeader::release_transaction_id() {
  // @@protoc_insertion_point(field_release:fantasybit.BlockHeader.transaction_id)
  if (!_internal_has_transaction_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return transaction_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BlockHeader::set_allocated_transaction_id(std::string* transaction_id) {
  if (transaction_id != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  transaction_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), transaction_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.BlockHeader.transaction_id)
}

// -------------------------------------------------------------------

// SignedBlockHeader

// optional .fantasybit.BlockHeader head = 10;
inline bool SignedBlockHeader::_internal_has_head() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || head_ != nullptr);
  return value;
}
inline bool SignedBlockHeader::has_head() const {
  return _internal_has_head();
}
inline void SignedBlockHeader::clear_head() {
  if (head_ != nullptr) head_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::fantasybit::BlockHeader& SignedBlockHeader::_internal_head() const {
  const ::fantasybit::BlockHeader* p = head_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fantasybit::BlockHeader*>(
      &::fantasybit::_BlockHeader_default_instance_);
}
inline const ::fantasybit::BlockHeader& SignedBlockHeader::head() const {
  // @@protoc_insertion_point(field_get:fantasybit.SignedBlockHeader.head)
  return _internal_head();
}
inline void SignedBlockHeader::unsafe_arena_set_allocated_head(
    ::fantasybit::BlockHeader* head) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(head_);
  }
  head_ = head;
  if (head) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fantasybit.SignedBlockHeader.head)
}
inline ::fantasybit::BlockHeader* SignedBlockHeader::release_head() {
  _has_bits_[0] &= ~0x00000002u;
  ::fantasybit::BlockHeader* temp = head_;
  head_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fantasybit::BlockHeader* SignedBlockHeader::unsafe_arena_release_head() {
  // @@protoc_insertion_point(field_release:fantasybit.SignedBlockHeader.head)
  _has_bits_[0] &= ~0x00000002u;
  ::fantasybit::BlockHeader* temp = head_;
  head_ = nullptr;
  return temp;
}
inline ::fantasybit::BlockHeader* SignedBlockHeader::_internal_mutable_head() {
  _has_bits_[0] |= 0x00000002u;
  if (head_ == nullptr) {
    auto* p = CreateMaybeMessage<::fantasybit::BlockHeader>(GetArena());
    head_ = p;
  }
  return head_;
}
inline ::fantasybit::BlockHeader* SignedBlockHeader::mutable_head() {
  // @@protoc_insertion_point(field_mutable:fantasybit.SignedBlockHeader.head)
  return _internal_mutable_head();
}
inline void SignedBlockHeader::set_allocated_head(::fantasybit::BlockHeader* head) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete head_;
  }
  if (head) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(head);
    if (message_arena != submessage_arena) {
      head = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, head, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  head_ = head;
  // @@protoc_insertion_point(field_set_allocated:fantasybit.SignedBlockHeader.head)
}

// optional string sig = 30;
inline bool SignedBlockHeader::_internal_has_sig() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SignedBlockHeader::has_sig() const {
  return _internal_has_sig();
}
inline void SignedBlockHeader::clear_sig() {
  sig_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SignedBlockHeader::sig() const {
  // @@protoc_insertion_point(field_get:fantasybit.SignedBlockHeader.sig)
  return _internal_sig();
}
inline void SignedBlockHeader::set_sig(const std::string& value) {
  _internal_set_sig(value);
  // @@protoc_insertion_point(field_set:fantasybit.SignedBlockHeader.sig)
}
inline std::string* SignedBlockHeader::mutable_sig() {
  // @@protoc_insertion_point(field_mutable:fantasybit.SignedBlockHeader.sig)
  return _internal_mutable_sig();
}
inline const std::string& SignedBlockHeader::_internal_sig() const {
  return sig_.Get();
}
inline void SignedBlockHeader::_internal_set_sig(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  sig_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SignedBlockHeader::set_sig(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  sig_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.SignedBlockHeader.sig)
}
inline void SignedBlockHeader::set_sig(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  sig_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.SignedBlockHeader.sig)
}
inline void SignedBlockHeader::set_sig(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  sig_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.SignedBlockHeader.sig)
}
inline std::string* SignedBlockHeader::_internal_mutable_sig() {
  _has_bits_[0] |= 0x00000001u;
  return sig_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SignedBlockHeader::release_sig() {
  // @@protoc_insertion_point(field_release:fantasybit.SignedBlockHeader.sig)
  if (!_internal_has_sig()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return sig_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SignedBlockHeader::set_allocated_sig(std::string* sig) {
  if (sig != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  sig_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sig,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.SignedBlockHeader.sig)
}

// -------------------------------------------------------------------

// Block

// optional .fantasybit.SignedBlockHeader signedhead = 10;
inline bool Block::_internal_has_signedhead() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || signedhead_ != nullptr);
  return value;
}
inline bool Block::has_signedhead() const {
  return _internal_has_signedhead();
}
inline void Block::clear_signedhead() {
  if (signedhead_ != nullptr) signedhead_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::fantasybit::SignedBlockHeader& Block::_internal_signedhead() const {
  const ::fantasybit::SignedBlockHeader* p = signedhead_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fantasybit::SignedBlockHeader*>(
      &::fantasybit::_SignedBlockHeader_default_instance_);
}
inline const ::fantasybit::SignedBlockHeader& Block::signedhead() const {
  // @@protoc_insertion_point(field_get:fantasybit.Block.signedhead)
  return _internal_signedhead();
}
inline void Block::unsafe_arena_set_allocated_signedhead(
    ::fantasybit::SignedBlockHeader* signedhead) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(signedhead_);
  }
  signedhead_ = signedhead;
  if (signedhead) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fantasybit.Block.signedhead)
}
inline ::fantasybit::SignedBlockHeader* Block::release_signedhead() {
  _has_bits_[0] &= ~0x00000001u;
  ::fantasybit::SignedBlockHeader* temp = signedhead_;
  signedhead_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fantasybit::SignedBlockHeader* Block::unsafe_arena_release_signedhead() {
  // @@protoc_insertion_point(field_release:fantasybit.Block.signedhead)
  _has_bits_[0] &= ~0x00000001u;
  ::fantasybit::SignedBlockHeader* temp = signedhead_;
  signedhead_ = nullptr;
  return temp;
}
inline ::fantasybit::SignedBlockHeader* Block::_internal_mutable_signedhead() {
  _has_bits_[0] |= 0x00000001u;
  if (signedhead_ == nullptr) {
    auto* p = CreateMaybeMessage<::fantasybit::SignedBlockHeader>(GetArena());
    signedhead_ = p;
  }
  return signedhead_;
}
inline ::fantasybit::SignedBlockHeader* Block::mutable_signedhead() {
  // @@protoc_insertion_point(field_mutable:fantasybit.Block.signedhead)
  return _internal_mutable_signedhead();
}
inline void Block::set_allocated_signedhead(::fantasybit::SignedBlockHeader* signedhead) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete signedhead_;
  }
  if (signedhead) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(signedhead);
    if (message_arena != submessage_arena) {
      signedhead = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signedhead, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  signedhead_ = signedhead;
  // @@protoc_insertion_point(field_set_allocated:fantasybit.Block.signedhead)
}

// repeated .fantasybit.SignedTransaction signed_transactions = 20;
inline int Block::_internal_signed_transactions_size() const {
  return signed_transactions_.size();
}
inline int Block::signed_transactions_size() const {
  return _internal_signed_transactions_size();
}
inline void Block::clear_signed_transactions() {
  signed_transactions_.Clear();
}
inline ::fantasybit::SignedTransaction* Block::mutable_signed_transactions(int index) {
  // @@protoc_insertion_point(field_mutable:fantasybit.Block.signed_transactions)
  return signed_transactions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fantasybit::SignedTransaction >*
Block::mutable_signed_transactions() {
  // @@protoc_insertion_point(field_mutable_list:fantasybit.Block.signed_transactions)
  return &signed_transactions_;
}
inline const ::fantasybit::SignedTransaction& Block::_internal_signed_transactions(int index) const {
  return signed_transactions_.Get(index);
}
inline const ::fantasybit::SignedTransaction& Block::signed_transactions(int index) const {
  // @@protoc_insertion_point(field_get:fantasybit.Block.signed_transactions)
  return _internal_signed_transactions(index);
}
inline ::fantasybit::SignedTransaction* Block::_internal_add_signed_transactions() {
  return signed_transactions_.Add();
}
inline ::fantasybit::SignedTransaction* Block::add_signed_transactions() {
  // @@protoc_insertion_point(field_add:fantasybit.Block.signed_transactions)
  return _internal_add_signed_transactions();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fantasybit::SignedTransaction >&
Block::signed_transactions() const {
  // @@protoc_insertion_point(field_list:fantasybit.Block.signed_transactions)
  return signed_transactions_;
}

// -------------------------------------------------------------------

// NodeRequest

// optional .fantasybit.NodeRequest.Type type = 10;
inline bool NodeRequest::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool NodeRequest::has_type() const {
  return _internal_has_type();
}
inline void NodeRequest::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::fantasybit::NodeRequest_Type NodeRequest::_internal_type() const {
  return static_cast< ::fantasybit::NodeRequest_Type >(type_);
}
inline ::fantasybit::NodeRequest_Type NodeRequest::type() const {
  // @@protoc_insertion_point(field_get:fantasybit.NodeRequest.type)
  return _internal_type();
}
inline void NodeRequest::_internal_set_type(::fantasybit::NodeRequest_Type value) {
  assert(::fantasybit::NodeRequest_Type_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  type_ = value;
}
inline void NodeRequest::set_type(::fantasybit::NodeRequest_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:fantasybit.NodeRequest.type)
}

// optional string myip = 20;
inline bool NodeRequest::_internal_has_myip() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NodeRequest::has_myip() const {
  return _internal_has_myip();
}
inline void NodeRequest::clear_myip() {
  myip_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NodeRequest::myip() const {
  // @@protoc_insertion_point(field_get:fantasybit.NodeRequest.myip)
  return _internal_myip();
}
inline void NodeRequest::set_myip(const std::string& value) {
  _internal_set_myip(value);
  // @@protoc_insertion_point(field_set:fantasybit.NodeRequest.myip)
}
inline std::string* NodeRequest::mutable_myip() {
  // @@protoc_insertion_point(field_mutable:fantasybit.NodeRequest.myip)
  return _internal_mutable_myip();
}
inline const std::string& NodeRequest::_internal_myip() const {
  return myip_.Get();
}
inline void NodeRequest::_internal_set_myip(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  myip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void NodeRequest::set_myip(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  myip_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.NodeRequest.myip)
}
inline void NodeRequest::set_myip(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  myip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.NodeRequest.myip)
}
inline void NodeRequest::set_myip(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  myip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.NodeRequest.myip)
}
inline std::string* NodeRequest::_internal_mutable_myip() {
  _has_bits_[0] |= 0x00000001u;
  return myip_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* NodeRequest::release_myip() {
  // @@protoc_insertion_point(field_release:fantasybit.NodeRequest.myip)
  if (!_internal_has_myip()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return myip_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NodeRequest::set_allocated_myip(std::string* myip) {
  if (myip != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  myip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), myip,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.NodeRequest.myip)
}

// optional int32 num = 30;
inline bool NodeRequest::_internal_has_num() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool NodeRequest::has_num() const {
  return _internal_has_num();
}
inline void NodeRequest::clear_num() {
  num_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NodeRequest::_internal_num() const {
  return num_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NodeRequest::num() const {
  // @@protoc_insertion_point(field_get:fantasybit.NodeRequest.num)
  return _internal_num();
}
inline void NodeRequest::_internal_set_num(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  num_ = value;
}
inline void NodeRequest::set_num(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num(value);
  // @@protoc_insertion_point(field_set:fantasybit.NodeRequest.num)
}

// optional string myhost = 40;
inline bool NodeRequest::_internal_has_myhost() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool NodeRequest::has_myhost() const {
  return _internal_has_myhost();
}
inline void NodeRequest::clear_myhost() {
  myhost_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& NodeRequest::myhost() const {
  // @@protoc_insertion_point(field_get:fantasybit.NodeRequest.myhost)
  return _internal_myhost();
}
inline void NodeRequest::set_myhost(const std::string& value) {
  _internal_set_myhost(value);
  // @@protoc_insertion_point(field_set:fantasybit.NodeRequest.myhost)
}
inline std::string* NodeRequest::mutable_myhost() {
  // @@protoc_insertion_point(field_mutable:fantasybit.NodeRequest.myhost)
  return _internal_mutable_myhost();
}
inline const std::string& NodeRequest::_internal_myhost() const {
  return myhost_.Get();
}
inline void NodeRequest::_internal_set_myhost(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  myhost_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void NodeRequest::set_myhost(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  myhost_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.NodeRequest.myhost)
}
inline void NodeRequest::set_myhost(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  myhost_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.NodeRequest.myhost)
}
inline void NodeRequest::set_myhost(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  myhost_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.NodeRequest.myhost)
}
inline std::string* NodeRequest::_internal_mutable_myhost() {
  _has_bits_[0] |= 0x00000002u;
  return myhost_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* NodeRequest::release_myhost() {
  // @@protoc_insertion_point(field_release:fantasybit.NodeRequest.myhost)
  if (!_internal_has_myhost()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return myhost_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NodeRequest::set_allocated_myhost(std::string* myhost) {
  if (myhost != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  myhost_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), myhost,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.NodeRequest.myhost)
}

// -------------------------------------------------------------------

// NodeReply

// optional int32 hight = 10;
inline bool NodeReply::_internal_has_hight() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NodeReply::has_hight() const {
  return _internal_has_hight();
}
inline void NodeReply::clear_hight() {
  hight_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NodeReply::_internal_hight() const {
  return hight_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NodeReply::hight() const {
  // @@protoc_insertion_point(field_get:fantasybit.NodeReply.hight)
  return _internal_hight();
}
inline void NodeReply::_internal_set_hight(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  hight_ = value;
}
inline void NodeReply::set_hight(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_hight(value);
  // @@protoc_insertion_point(field_set:fantasybit.NodeReply.hight)
}

// repeated string ips = 20;
inline int NodeReply::_internal_ips_size() const {
  return ips_.size();
}
inline int NodeReply::ips_size() const {
  return _internal_ips_size();
}
inline void NodeReply::clear_ips() {
  ips_.Clear();
}
inline std::string* NodeReply::add_ips() {
  // @@protoc_insertion_point(field_add_mutable:fantasybit.NodeReply.ips)
  return _internal_add_ips();
}
inline const std::string& NodeReply::_internal_ips(int index) const {
  return ips_.Get(index);
}
inline const std::string& NodeReply::ips(int index) const {
  // @@protoc_insertion_point(field_get:fantasybit.NodeReply.ips)
  return _internal_ips(index);
}
inline std::string* NodeReply::mutable_ips(int index) {
  // @@protoc_insertion_point(field_mutable:fantasybit.NodeReply.ips)
  return ips_.Mutable(index);
}
inline void NodeReply::set_ips(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:fantasybit.NodeReply.ips)
  ips_.Mutable(index)->assign(value);
}
inline void NodeReply::set_ips(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:fantasybit.NodeReply.ips)
  ips_.Mutable(index)->assign(std::move(value));
}
inline void NodeReply::set_ips(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  ips_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:fantasybit.NodeReply.ips)
}
inline void NodeReply::set_ips(int index, const char* value, size_t size) {
  ips_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fantasybit.NodeReply.ips)
}
inline std::string* NodeReply::_internal_add_ips() {
  return ips_.Add();
}
inline void NodeReply::add_ips(const std::string& value) {
  ips_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:fantasybit.NodeReply.ips)
}
inline void NodeReply::add_ips(std::string&& value) {
  ips_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:fantasybit.NodeReply.ips)
}
inline void NodeReply::add_ips(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  ips_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:fantasybit.NodeReply.ips)
}
inline void NodeReply::add_ips(const char* value, size_t size) {
  ips_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:fantasybit.NodeReply.ips)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
NodeReply::ips() const {
  // @@protoc_insertion_point(field_list:fantasybit.NodeReply.ips)
  return ips_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
NodeReply::mutable_ips() {
  // @@protoc_insertion_point(field_mutable_list:fantasybit.NodeReply.ips)
  return &ips_;
}

// -------------------------------------------------------------------

// FantasyPlayerPoints

// optional uint32 season = 10;
inline bool FantasyPlayerPoints::_internal_has_season() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FantasyPlayerPoints::has_season() const {
  return _internal_has_season();
}
inline void FantasyPlayerPoints::clear_season() {
  season_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FantasyPlayerPoints::_internal_season() const {
  return season_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FantasyPlayerPoints::season() const {
  // @@protoc_insertion_point(field_get:fantasybit.FantasyPlayerPoints.season)
  return _internal_season();
}
inline void FantasyPlayerPoints::_internal_set_season(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  season_ = value;
}
inline void FantasyPlayerPoints::set_season(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_season(value);
  // @@protoc_insertion_point(field_set:fantasybit.FantasyPlayerPoints.season)
}

// optional uint32 week = 20;
inline bool FantasyPlayerPoints::_internal_has_week() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool FantasyPlayerPoints::has_week() const {
  return _internal_has_week();
}
inline void FantasyPlayerPoints::clear_week() {
  week_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FantasyPlayerPoints::_internal_week() const {
  return week_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FantasyPlayerPoints::week() const {
  // @@protoc_insertion_point(field_get:fantasybit.FantasyPlayerPoints.week)
  return _internal_week();
}
inline void FantasyPlayerPoints::_internal_set_week(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  week_ = value;
}
inline void FantasyPlayerPoints::set_week(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_week(value);
  // @@protoc_insertion_point(field_set:fantasybit.FantasyPlayerPoints.week)
}

// optional string playerid = 30;
inline bool FantasyPlayerPoints::_internal_has_playerid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FantasyPlayerPoints::has_playerid() const {
  return _internal_has_playerid();
}
inline void FantasyPlayerPoints::clear_playerid() {
  playerid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FantasyPlayerPoints::playerid() const {
  // @@protoc_insertion_point(field_get:fantasybit.FantasyPlayerPoints.playerid)
  return _internal_playerid();
}
inline void FantasyPlayerPoints::set_playerid(const std::string& value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:fantasybit.FantasyPlayerPoints.playerid)
}
inline std::string* FantasyPlayerPoints::mutable_playerid() {
  // @@protoc_insertion_point(field_mutable:fantasybit.FantasyPlayerPoints.playerid)
  return _internal_mutable_playerid();
}
inline const std::string& FantasyPlayerPoints::_internal_playerid() const {
  return playerid_.Get();
}
inline void FantasyPlayerPoints::_internal_set_playerid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  playerid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void FantasyPlayerPoints::set_playerid(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  playerid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.FantasyPlayerPoints.playerid)
}
inline void FantasyPlayerPoints::set_playerid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  playerid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.FantasyPlayerPoints.playerid)
}
inline void FantasyPlayerPoints::set_playerid(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  playerid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.FantasyPlayerPoints.playerid)
}
inline std::string* FantasyPlayerPoints::_internal_mutable_playerid() {
  _has_bits_[0] |= 0x00000001u;
  return playerid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* FantasyPlayerPoints::release_playerid() {
  // @@protoc_insertion_point(field_release:fantasybit.FantasyPlayerPoints.playerid)
  if (!_internal_has_playerid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return playerid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FantasyPlayerPoints::set_allocated_playerid(std::string* playerid) {
  if (playerid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  playerid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), playerid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.FantasyPlayerPoints.playerid)
}

// optional int32 points = 40;
inline bool FantasyPlayerPoints::_internal_has_points() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool FantasyPlayerPoints::has_points() const {
  return _internal_has_points();
}
inline void FantasyPlayerPoints::clear_points() {
  points_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FantasyPlayerPoints::_internal_points() const {
  return points_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FantasyPlayerPoints::points() const {
  // @@protoc_insertion_point(field_get:fantasybit.FantasyPlayerPoints.points)
  return _internal_points();
}
inline void FantasyPlayerPoints::_internal_set_points(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  points_ = value;
}
inline void FantasyPlayerPoints::set_points(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_points(value);
  // @@protoc_insertion_point(field_set:fantasybit.FantasyPlayerPoints.points)
}

// optional float result = 50;
inline bool FantasyPlayerPoints::_internal_has_result() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool FantasyPlayerPoints::has_result() const {
  return _internal_has_result();
}
inline void FantasyPlayerPoints::clear_result() {
  result_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float FantasyPlayerPoints::_internal_result() const {
  return result_;
}
inline float FantasyPlayerPoints::result() const {
  // @@protoc_insertion_point(field_get:fantasybit.FantasyPlayerPoints.result)
  return _internal_result();
}
inline void FantasyPlayerPoints::_internal_set_result(float value) {
  _has_bits_[0] |= 0x00000010u;
  result_ = value;
}
inline void FantasyPlayerPoints::set_result(float value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:fantasybit.FantasyPlayerPoints.result)
}

// -------------------------------------------------------------------

// ProjectionTrans

// optional uint32 season = 10;
inline bool ProjectionTrans::_internal_has_season() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ProjectionTrans::has_season() const {
  return _internal_has_season();
}
inline void ProjectionTrans::clear_season() {
  season_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ProjectionTrans::_internal_season() const {
  return season_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ProjectionTrans::season() const {
  // @@protoc_insertion_point(field_get:fantasybit.ProjectionTrans.season)
  return _internal_season();
}
inline void ProjectionTrans::_internal_set_season(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  season_ = value;
}
inline void ProjectionTrans::set_season(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_season(value);
  // @@protoc_insertion_point(field_set:fantasybit.ProjectionTrans.season)
}

// optional uint32 week = 20;
inline bool ProjectionTrans::_internal_has_week() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ProjectionTrans::has_week() const {
  return _internal_has_week();
}
inline void ProjectionTrans::clear_week() {
  week_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ProjectionTrans::_internal_week() const {
  return week_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ProjectionTrans::week() const {
  // @@protoc_insertion_point(field_get:fantasybit.ProjectionTrans.week)
  return _internal_week();
}
inline void ProjectionTrans::_internal_set_week(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  week_ = value;
}
inline void ProjectionTrans::set_week(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_week(value);
  // @@protoc_insertion_point(field_set:fantasybit.ProjectionTrans.week)
}

// optional string playerid = 30;
inline bool ProjectionTrans::_internal_has_playerid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ProjectionTrans::has_playerid() const {
  return _internal_has_playerid();
}
inline void ProjectionTrans::clear_playerid() {
  playerid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ProjectionTrans::playerid() const {
  // @@protoc_insertion_point(field_get:fantasybit.ProjectionTrans.playerid)
  return _internal_playerid();
}
inline void ProjectionTrans::set_playerid(const std::string& value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:fantasybit.ProjectionTrans.playerid)
}
inline std::string* ProjectionTrans::mutable_playerid() {
  // @@protoc_insertion_point(field_mutable:fantasybit.ProjectionTrans.playerid)
  return _internal_mutable_playerid();
}
inline const std::string& ProjectionTrans::_internal_playerid() const {
  return playerid_.Get();
}
inline void ProjectionTrans::_internal_set_playerid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  playerid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ProjectionTrans::set_playerid(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  playerid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.ProjectionTrans.playerid)
}
inline void ProjectionTrans::set_playerid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  playerid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.ProjectionTrans.playerid)
}
inline void ProjectionTrans::set_playerid(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  playerid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.ProjectionTrans.playerid)
}
inline std::string* ProjectionTrans::_internal_mutable_playerid() {
  _has_bits_[0] |= 0x00000001u;
  return playerid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ProjectionTrans::release_playerid() {
  // @@protoc_insertion_point(field_release:fantasybit.ProjectionTrans.playerid)
  if (!_internal_has_playerid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return playerid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ProjectionTrans::set_allocated_playerid(std::string* playerid) {
  if (playerid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  playerid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), playerid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.ProjectionTrans.playerid)
}

// optional int32 points = 40;
inline bool ProjectionTrans::_internal_has_points() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ProjectionTrans::has_points() const {
  return _internal_has_points();
}
inline void ProjectionTrans::clear_points() {
  points_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ProjectionTrans::_internal_points() const {
  return points_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ProjectionTrans::points() const {
  // @@protoc_insertion_point(field_get:fantasybit.ProjectionTrans.points)
  return _internal_points();
}
inline void ProjectionTrans::_internal_set_points(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  points_ = value;
}
inline void ProjectionTrans::set_points(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_points(value);
  // @@protoc_insertion_point(field_set:fantasybit.ProjectionTrans.points)
}

// -------------------------------------------------------------------

// PlayerPoints

// optional string playerid = 30;
inline bool PlayerPoints::_internal_has_playerid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PlayerPoints::has_playerid() const {
  return _internal_has_playerid();
}
inline void PlayerPoints::clear_playerid() {
  playerid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PlayerPoints::playerid() const {
  // @@protoc_insertion_point(field_get:fantasybit.PlayerPoints.playerid)
  return _internal_playerid();
}
inline void PlayerPoints::set_playerid(const std::string& value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:fantasybit.PlayerPoints.playerid)
}
inline std::string* PlayerPoints::mutable_playerid() {
  // @@protoc_insertion_point(field_mutable:fantasybit.PlayerPoints.playerid)
  return _internal_mutable_playerid();
}
inline const std::string& PlayerPoints::_internal_playerid() const {
  return playerid_.Get();
}
inline void PlayerPoints::_internal_set_playerid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  playerid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void PlayerPoints::set_playerid(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  playerid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.PlayerPoints.playerid)
}
inline void PlayerPoints::set_playerid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  playerid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.PlayerPoints.playerid)
}
inline void PlayerPoints::set_playerid(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  playerid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.PlayerPoints.playerid)
}
inline std::string* PlayerPoints::_internal_mutable_playerid() {
  _has_bits_[0] |= 0x00000001u;
  return playerid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* PlayerPoints::release_playerid() {
  // @@protoc_insertion_point(field_release:fantasybit.PlayerPoints.playerid)
  if (!_internal_has_playerid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return playerid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PlayerPoints::set_allocated_playerid(std::string* playerid) {
  if (playerid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  playerid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), playerid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.PlayerPoints.playerid)
}

// optional int32 points = 40;
inline bool PlayerPoints::_internal_has_points() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PlayerPoints::has_points() const {
  return _internal_has_points();
}
inline void PlayerPoints::clear_points() {
  points_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayerPoints::_internal_points() const {
  return points_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayerPoints::points() const {
  // @@protoc_insertion_point(field_get:fantasybit.PlayerPoints.points)
  return _internal_points();
}
inline void PlayerPoints::_internal_set_points(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  points_ = value;
}
inline void PlayerPoints::set_points(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_points(value);
  // @@protoc_insertion_point(field_set:fantasybit.PlayerPoints.points)
}

// -------------------------------------------------------------------

// ProjectionTransBlock

// optional uint32 season = 10;
inline bool ProjectionTransBlock::_internal_has_season() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ProjectionTransBlock::has_season() const {
  return _internal_has_season();
}
inline void ProjectionTransBlock::clear_season() {
  season_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ProjectionTransBlock::_internal_season() const {
  return season_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ProjectionTransBlock::season() const {
  // @@protoc_insertion_point(field_get:fantasybit.ProjectionTransBlock.season)
  return _internal_season();
}
inline void ProjectionTransBlock::_internal_set_season(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  season_ = value;
}
inline void ProjectionTransBlock::set_season(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_season(value);
  // @@protoc_insertion_point(field_set:fantasybit.ProjectionTransBlock.season)
}

// optional uint32 week = 20;
inline bool ProjectionTransBlock::_internal_has_week() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ProjectionTransBlock::has_week() const {
  return _internal_has_week();
}
inline void ProjectionTransBlock::clear_week() {
  week_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ProjectionTransBlock::_internal_week() const {
  return week_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ProjectionTransBlock::week() const {
  // @@protoc_insertion_point(field_get:fantasybit.ProjectionTransBlock.week)
  return _internal_week();
}
inline void ProjectionTransBlock::_internal_set_week(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  week_ = value;
}
inline void ProjectionTransBlock::set_week(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_week(value);
  // @@protoc_insertion_point(field_set:fantasybit.ProjectionTransBlock.week)
}

// repeated .fantasybit.PlayerPoints player_points = 30;
inline int ProjectionTransBlock::_internal_player_points_size() const {
  return player_points_.size();
}
inline int ProjectionTransBlock::player_points_size() const {
  return _internal_player_points_size();
}
inline void ProjectionTransBlock::clear_player_points() {
  player_points_.Clear();
}
inline ::fantasybit::PlayerPoints* ProjectionTransBlock::mutable_player_points(int index) {
  // @@protoc_insertion_point(field_mutable:fantasybit.ProjectionTransBlock.player_points)
  return player_points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fantasybit::PlayerPoints >*
ProjectionTransBlock::mutable_player_points() {
  // @@protoc_insertion_point(field_mutable_list:fantasybit.ProjectionTransBlock.player_points)
  return &player_points_;
}
inline const ::fantasybit::PlayerPoints& ProjectionTransBlock::_internal_player_points(int index) const {
  return player_points_.Get(index);
}
inline const ::fantasybit::PlayerPoints& ProjectionTransBlock::player_points(int index) const {
  // @@protoc_insertion_point(field_get:fantasybit.ProjectionTransBlock.player_points)
  return _internal_player_points(index);
}
inline ::fantasybit::PlayerPoints* ProjectionTransBlock::_internal_add_player_points() {
  return player_points_.Add();
}
inline ::fantasybit::PlayerPoints* ProjectionTransBlock::add_player_points() {
  // @@protoc_insertion_point(field_add:fantasybit.ProjectionTransBlock.player_points)
  return _internal_add_player_points();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fantasybit::PlayerPoints >&
ProjectionTransBlock::player_points() const {
  // @@protoc_insertion_point(field_list:fantasybit.ProjectionTransBlock.player_points)
  return player_points_;
}

// -------------------------------------------------------------------

// Data

// optional int32 version = 10;
inline bool Data::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Data::has_version() const {
  return _internal_has_version();
}
inline void Data::clear_version() {
  version_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Data::_internal_version() const {
  return version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Data::version() const {
  // @@protoc_insertion_point(field_get:fantasybit.Data.version)
  return _internal_version();
}
inline void Data::_internal_set_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  version_ = value;
}
inline void Data::set_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:fantasybit.Data.version)
}

// optional .fantasybit.Data.Type type = 20;
inline bool Data::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Data::has_type() const {
  return _internal_has_type();
}
inline void Data::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::fantasybit::Data_Type Data::_internal_type() const {
  return static_cast< ::fantasybit::Data_Type >(type_);
}
inline ::fantasybit::Data_Type Data::type() const {
  // @@protoc_insertion_point(field_get:fantasybit.Data.type)
  return _internal_type();
}
inline void Data::_internal_set_type(::fantasybit::Data_Type value) {
  assert(::fantasybit::Data_Type_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
}
inline void Data::set_type(::fantasybit::Data_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:fantasybit.Data.type)
}

// -------------------------------------------------------------------

// PlayerData

// optional string playerid = 10;
inline bool PlayerData::_internal_has_playerid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PlayerData::has_playerid() const {
  return _internal_has_playerid();
}
inline void PlayerData::clear_playerid() {
  playerid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PlayerData::playerid() const {
  // @@protoc_insertion_point(field_get:fantasybit.PlayerData.playerid)
  return _internal_playerid();
}
inline void PlayerData::set_playerid(const std::string& value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:fantasybit.PlayerData.playerid)
}
inline std::string* PlayerData::mutable_playerid() {
  // @@protoc_insertion_point(field_mutable:fantasybit.PlayerData.playerid)
  return _internal_mutable_playerid();
}
inline const std::string& PlayerData::_internal_playerid() const {
  return playerid_.Get();
}
inline void PlayerData::_internal_set_playerid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  playerid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void PlayerData::set_playerid(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  playerid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.PlayerData.playerid)
}
inline void PlayerData::set_playerid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  playerid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.PlayerData.playerid)
}
inline void PlayerData::set_playerid(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  playerid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.PlayerData.playerid)
}
inline std::string* PlayerData::_internal_mutable_playerid() {
  _has_bits_[0] |= 0x00000001u;
  return playerid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* PlayerData::release_playerid() {
  // @@protoc_insertion_point(field_release:fantasybit.PlayerData.playerid)
  if (!_internal_has_playerid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return playerid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PlayerData::set_allocated_playerid(std::string* playerid) {
  if (playerid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  playerid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), playerid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.PlayerData.playerid)
}

// optional .fantasybit.PlayerBase player_base = 20;
inline bool PlayerData::_internal_has_player_base() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || player_base_ != nullptr);
  return value;
}
inline bool PlayerData::has_player_base() const {
  return _internal_has_player_base();
}
inline const ::fantasybit::PlayerBase& PlayerData::_internal_player_base() const {
  const ::fantasybit::PlayerBase* p = player_base_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fantasybit::PlayerBase*>(
      &::fantasybit::_PlayerBase_default_instance_);
}
inline const ::fantasybit::PlayerBase& PlayerData::player_base() const {
  // @@protoc_insertion_point(field_get:fantasybit.PlayerData.player_base)
  return _internal_player_base();
}
inline void PlayerData::unsafe_arena_set_allocated_player_base(
    ::fantasybit::PlayerBase* player_base) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_base_);
  }
  player_base_ = player_base;
  if (player_base) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fantasybit.PlayerData.player_base)
}
inline ::fantasybit::PlayerBase* PlayerData::release_player_base() {
  _has_bits_[0] &= ~0x00000002u;
  ::fantasybit::PlayerBase* temp = player_base_;
  player_base_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fantasybit::PlayerBase* PlayerData::unsafe_arena_release_player_base() {
  // @@protoc_insertion_point(field_release:fantasybit.PlayerData.player_base)
  _has_bits_[0] &= ~0x00000002u;
  ::fantasybit::PlayerBase* temp = player_base_;
  player_base_ = nullptr;
  return temp;
}
inline ::fantasybit::PlayerBase* PlayerData::_internal_mutable_player_base() {
  _has_bits_[0] |= 0x00000002u;
  if (player_base_ == nullptr) {
    auto* p = CreateMaybeMessage<::fantasybit::PlayerBase>(GetArena());
    player_base_ = p;
  }
  return player_base_;
}
inline ::fantasybit::PlayerBase* PlayerData::mutable_player_base() {
  // @@protoc_insertion_point(field_mutable:fantasybit.PlayerData.player_base)
  return _internal_mutable_player_base();
}
inline void PlayerData::set_allocated_player_base(::fantasybit::PlayerBase* player_base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_base_);
  }
  if (player_base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_base)->GetArena();
    if (message_arena != submessage_arena) {
      player_base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player_base, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  player_base_ = player_base;
  // @@protoc_insertion_point(field_set_allocated:fantasybit.PlayerData.player_base)
}

// optional .fantasybit.PlayerStatus player_status = 30;
inline bool PlayerData::_internal_has_player_status() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || player_status_ != nullptr);
  return value;
}
inline bool PlayerData::has_player_status() const {
  return _internal_has_player_status();
}
inline const ::fantasybit::PlayerStatus& PlayerData::_internal_player_status() const {
  const ::fantasybit::PlayerStatus* p = player_status_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fantasybit::PlayerStatus*>(
      &::fantasybit::_PlayerStatus_default_instance_);
}
inline const ::fantasybit::PlayerStatus& PlayerData::player_status() const {
  // @@protoc_insertion_point(field_get:fantasybit.PlayerData.player_status)
  return _internal_player_status();
}
inline void PlayerData::unsafe_arena_set_allocated_player_status(
    ::fantasybit::PlayerStatus* player_status) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_status_);
  }
  player_status_ = player_status;
  if (player_status) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fantasybit.PlayerData.player_status)
}
inline ::fantasybit::PlayerStatus* PlayerData::release_player_status() {
  _has_bits_[0] &= ~0x00000004u;
  ::fantasybit::PlayerStatus* temp = player_status_;
  player_status_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fantasybit::PlayerStatus* PlayerData::unsafe_arena_release_player_status() {
  // @@protoc_insertion_point(field_release:fantasybit.PlayerData.player_status)
  _has_bits_[0] &= ~0x00000004u;
  ::fantasybit::PlayerStatus* temp = player_status_;
  player_status_ = nullptr;
  return temp;
}
inline ::fantasybit::PlayerStatus* PlayerData::_internal_mutable_player_status() {
  _has_bits_[0] |= 0x00000004u;
  if (player_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::fantasybit::PlayerStatus>(GetArena());
    player_status_ = p;
  }
  return player_status_;
}
inline ::fantasybit::PlayerStatus* PlayerData::mutable_player_status() {
  // @@protoc_insertion_point(field_mutable:fantasybit.PlayerData.player_status)
  return _internal_mutable_player_status();
}
inline void PlayerData::set_allocated_player_status(::fantasybit::PlayerStatus* player_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_status_);
  }
  if (player_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_status)->GetArena();
    if (message_arena != submessage_arena) {
      player_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player_status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  player_status_ = player_status;
  // @@protoc_insertion_point(field_set_allocated:fantasybit.PlayerData.player_status)
}

// optional .fantasybit.PlayerGameStatus player_game_status = 40;
inline bool PlayerData::_internal_has_player_game_status() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PlayerData::has_player_game_status() const {
  return _internal_has_player_game_status();
}
inline void PlayerData::clear_player_game_status() {
  player_game_status_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::fantasybit::PlayerGameStatus PlayerData::_internal_player_game_status() const {
  return static_cast< ::fantasybit::PlayerGameStatus >(player_game_status_);
}
inline ::fantasybit::PlayerGameStatus PlayerData::player_game_status() const {
  // @@protoc_insertion_point(field_get:fantasybit.PlayerData.player_game_status)
  return _internal_player_game_status();
}
inline void PlayerData::_internal_set_player_game_status(::fantasybit::PlayerGameStatus value) {
  assert(::fantasybit::PlayerGameStatus_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  player_game_status_ = value;
}
inline void PlayerData::set_player_game_status(::fantasybit::PlayerGameStatus value) {
  _internal_set_player_game_status(value);
  // @@protoc_insertion_point(field_set:fantasybit.PlayerData.player_game_status)
}

// -------------------------------------------------------------------

// GameData

// optional string gameid = 10;
inline bool GameData::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GameData::has_gameid() const {
  return _internal_has_gameid();
}
inline void GameData::clear_gameid() {
  gameid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GameData::gameid() const {
  // @@protoc_insertion_point(field_get:fantasybit.GameData.gameid)
  return _internal_gameid();
}
inline void GameData::set_gameid(const std::string& value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:fantasybit.GameData.gameid)
}
inline std::string* GameData::mutable_gameid() {
  // @@protoc_insertion_point(field_mutable:fantasybit.GameData.gameid)
  return _internal_mutable_gameid();
}
inline const std::string& GameData::_internal_gameid() const {
  return gameid_.Get();
}
inline void GameData::_internal_set_gameid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GameData::set_gameid(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  gameid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.GameData.gameid)
}
inline void GameData::set_gameid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  gameid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.GameData.gameid)
}
inline void GameData::set_gameid(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  gameid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.GameData.gameid)
}
inline std::string* GameData::_internal_mutable_gameid() {
  _has_bits_[0] |= 0x00000001u;
  return gameid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GameData::release_gameid() {
  // @@protoc_insertion_point(field_release:fantasybit.GameData.gameid)
  if (!_internal_has_gameid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return gameid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GameData::set_allocated_gameid(std::string* gameid) {
  if (gameid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  gameid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gameid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.GameData.gameid)
}

// optional .fantasybit.GameStatus status = 20;
inline bool GameData::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || status_ != nullptr);
  return value;
}
inline bool GameData::has_status() const {
  return _internal_has_status();
}
inline const ::fantasybit::GameStatus& GameData::_internal_status() const {
  const ::fantasybit::GameStatus* p = status_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fantasybit::GameStatus*>(
      &::fantasybit::_GameStatus_default_instance_);
}
inline const ::fantasybit::GameStatus& GameData::status() const {
  // @@protoc_insertion_point(field_get:fantasybit.GameData.status)
  return _internal_status();
}
inline void GameData::unsafe_arena_set_allocated_status(
    ::fantasybit::GameStatus* status) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fantasybit.GameData.status)
}
inline ::fantasybit::GameStatus* GameData::release_status() {
  _has_bits_[0] &= ~0x00000002u;
  ::fantasybit::GameStatus* temp = status_;
  status_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fantasybit::GameStatus* GameData::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:fantasybit.GameData.status)
  _has_bits_[0] &= ~0x00000002u;
  ::fantasybit::GameStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::fantasybit::GameStatus* GameData::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000002u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::fantasybit::GameStatus>(GetArena());
    status_ = p;
  }
  return status_;
}
inline ::fantasybit::GameStatus* GameData::mutable_status() {
  // @@protoc_insertion_point(field_mutable:fantasybit.GameData.status)
  return _internal_mutable_status();
}
inline void GameData::set_allocated_status(::fantasybit::GameStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status)->GetArena();
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:fantasybit.GameData.status)
}

// -------------------------------------------------------------------

// ResultData

// optional .fantasybit.GameResult game_result = 10;
inline bool ResultData::_internal_has_game_result() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || game_result_ != nullptr);
  return value;
}
inline bool ResultData::has_game_result() const {
  return _internal_has_game_result();
}
inline const ::fantasybit::GameResult& ResultData::_internal_game_result() const {
  const ::fantasybit::GameResult* p = game_result_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fantasybit::GameResult*>(
      &::fantasybit::_GameResult_default_instance_);
}
inline const ::fantasybit::GameResult& ResultData::game_result() const {
  // @@protoc_insertion_point(field_get:fantasybit.ResultData.game_result)
  return _internal_game_result();
}
inline void ResultData::unsafe_arena_set_allocated_game_result(
    ::fantasybit::GameResult* game_result) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(game_result_);
  }
  game_result_ = game_result;
  if (game_result) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fantasybit.ResultData.game_result)
}
inline ::fantasybit::GameResult* ResultData::release_game_result() {
  _has_bits_[0] &= ~0x00000001u;
  ::fantasybit::GameResult* temp = game_result_;
  game_result_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fantasybit::GameResult* ResultData::unsafe_arena_release_game_result() {
  // @@protoc_insertion_point(field_release:fantasybit.ResultData.game_result)
  _has_bits_[0] &= ~0x00000001u;
  ::fantasybit::GameResult* temp = game_result_;
  game_result_ = nullptr;
  return temp;
}
inline ::fantasybit::GameResult* ResultData::_internal_mutable_game_result() {
  _has_bits_[0] |= 0x00000001u;
  if (game_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::fantasybit::GameResult>(GetArena());
    game_result_ = p;
  }
  return game_result_;
}
inline ::fantasybit::GameResult* ResultData::mutable_game_result() {
  // @@protoc_insertion_point(field_mutable:fantasybit.ResultData.game_result)
  return _internal_mutable_game_result();
}
inline void ResultData::set_allocated_game_result(::fantasybit::GameResult* game_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(game_result_);
  }
  if (game_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(game_result)->GetArena();
    if (message_arena != submessage_arena) {
      game_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, game_result, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  game_result_ = game_result;
  // @@protoc_insertion_point(field_set_allocated:fantasybit.ResultData.game_result)
}

// -------------------------------------------------------------------

// ScheduleData

// optional int32 week = 1;
inline bool ScheduleData::_internal_has_week() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ScheduleData::has_week() const {
  return _internal_has_week();
}
inline void ScheduleData::clear_week() {
  week_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ScheduleData::_internal_week() const {
  return week_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ScheduleData::week() const {
  // @@protoc_insertion_point(field_get:fantasybit.ScheduleData.week)
  return _internal_week();
}
inline void ScheduleData::_internal_set_week(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  week_ = value;
}
inline void ScheduleData::set_week(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_week(value);
  // @@protoc_insertion_point(field_set:fantasybit.ScheduleData.week)
}

// optional .fantasybit.WeeklySchedule weekly = 10;
inline bool ScheduleData::_internal_has_weekly() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || weekly_ != nullptr);
  return value;
}
inline bool ScheduleData::has_weekly() const {
  return _internal_has_weekly();
}
inline const ::fantasybit::WeeklySchedule& ScheduleData::_internal_weekly() const {
  const ::fantasybit::WeeklySchedule* p = weekly_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fantasybit::WeeklySchedule*>(
      &::fantasybit::_WeeklySchedule_default_instance_);
}
inline const ::fantasybit::WeeklySchedule& ScheduleData::weekly() const {
  // @@protoc_insertion_point(field_get:fantasybit.ScheduleData.weekly)
  return _internal_weekly();
}
inline void ScheduleData::unsafe_arena_set_allocated_weekly(
    ::fantasybit::WeeklySchedule* weekly) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(weekly_);
  }
  weekly_ = weekly;
  if (weekly) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fantasybit.ScheduleData.weekly)
}
inline ::fantasybit::WeeklySchedule* ScheduleData::release_weekly() {
  _has_bits_[0] &= ~0x00000001u;
  ::fantasybit::WeeklySchedule* temp = weekly_;
  weekly_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fantasybit::WeeklySchedule* ScheduleData::unsafe_arena_release_weekly() {
  // @@protoc_insertion_point(field_release:fantasybit.ScheduleData.weekly)
  _has_bits_[0] &= ~0x00000001u;
  ::fantasybit::WeeklySchedule* temp = weekly_;
  weekly_ = nullptr;
  return temp;
}
inline ::fantasybit::WeeklySchedule* ScheduleData::_internal_mutable_weekly() {
  _has_bits_[0] |= 0x00000001u;
  if (weekly_ == nullptr) {
    auto* p = CreateMaybeMessage<::fantasybit::WeeklySchedule>(GetArena());
    weekly_ = p;
  }
  return weekly_;
}
inline ::fantasybit::WeeklySchedule* ScheduleData::mutable_weekly() {
  // @@protoc_insertion_point(field_mutable:fantasybit.ScheduleData.weekly)
  return _internal_mutable_weekly();
}
inline void ScheduleData::set_allocated_weekly(::fantasybit::WeeklySchedule* weekly) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(weekly_);
  }
  if (weekly) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(weekly)->GetArena();
    if (message_arena != submessage_arena) {
      weekly = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, weekly, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  weekly_ = weekly;
  // @@protoc_insertion_point(field_set_allocated:fantasybit.ScheduleData.weekly)
}

// -------------------------------------------------------------------

// DataTransition

// optional .fantasybit.TrType type = 1;
inline bool DataTransition::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DataTransition::has_type() const {
  return _internal_has_type();
}
inline void DataTransition::clear_type() {
  type_ = 2;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::fantasybit::TrType DataTransition::_internal_type() const {
  return static_cast< ::fantasybit::TrType >(type_);
}
inline ::fantasybit::TrType DataTransition::type() const {
  // @@protoc_insertion_point(field_get:fantasybit.DataTransition.type)
  return _internal_type();
}
inline void DataTransition::_internal_set_type(::fantasybit::TrType value) {
  assert(::fantasybit::TrType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  type_ = value;
}
inline void DataTransition::set_type(::fantasybit::TrType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:fantasybit.DataTransition.type)
}

// optional uint32 season = 10;
inline bool DataTransition::_internal_has_season() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DataTransition::has_season() const {
  return _internal_has_season();
}
inline void DataTransition::clear_season() {
  season_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DataTransition::_internal_season() const {
  return season_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DataTransition::season() const {
  // @@protoc_insertion_point(field_get:fantasybit.DataTransition.season)
  return _internal_season();
}
inline void DataTransition::_internal_set_season(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  season_ = value;
}
inline void DataTransition::set_season(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_season(value);
  // @@protoc_insertion_point(field_set:fantasybit.DataTransition.season)
}

// optional uint32 week = 20;
inline bool DataTransition::_internal_has_week() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DataTransition::has_week() const {
  return _internal_has_week();
}
inline void DataTransition::clear_week() {
  week_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DataTransition::_internal_week() const {
  return week_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DataTransition::week() const {
  // @@protoc_insertion_point(field_get:fantasybit.DataTransition.week)
  return _internal_week();
}
inline void DataTransition::_internal_set_week(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  week_ = value;
}
inline void DataTransition::set_week(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_week(value);
  // @@protoc_insertion_point(field_set:fantasybit.DataTransition.week)
}

// repeated .fantasybit.GameData gamedata = 30;
inline int DataTransition::_internal_gamedata_size() const {
  return gamedata_.size();
}
inline int DataTransition::gamedata_size() const {
  return _internal_gamedata_size();
}
inline void DataTransition::clear_gamedata() {
  gamedata_.Clear();
}
inline ::fantasybit::GameData* DataTransition::mutable_gamedata(int index) {
  // @@protoc_insertion_point(field_mutable:fantasybit.DataTransition.gamedata)
  return gamedata_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fantasybit::GameData >*
DataTransition::mutable_gamedata() {
  // @@protoc_insertion_point(field_mutable_list:fantasybit.DataTransition.gamedata)
  return &gamedata_;
}
inline const ::fantasybit::GameData& DataTransition::_internal_gamedata(int index) const {
  return gamedata_.Get(index);
}
inline const ::fantasybit::GameData& DataTransition::gamedata(int index) const {
  // @@protoc_insertion_point(field_get:fantasybit.DataTransition.gamedata)
  return _internal_gamedata(index);
}
inline ::fantasybit::GameData* DataTransition::_internal_add_gamedata() {
  return gamedata_.Add();
}
inline ::fantasybit::GameData* DataTransition::add_gamedata() {
  // @@protoc_insertion_point(field_add:fantasybit.DataTransition.gamedata)
  return _internal_add_gamedata();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fantasybit::GameData >&
DataTransition::gamedata() const {
  // @@protoc_insertion_point(field_list:fantasybit.DataTransition.gamedata)
  return gamedata_;
}

// repeated .fantasybit.Data data = 40;
inline int DataTransition::_internal_data_size() const {
  return data_.size();
}
inline int DataTransition::data_size() const {
  return _internal_data_size();
}
inline void DataTransition::clear_data() {
  data_.Clear();
}
inline ::fantasybit::Data* DataTransition::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:fantasybit.DataTransition.data)
  return data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fantasybit::Data >*
DataTransition::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:fantasybit.DataTransition.data)
  return &data_;
}
inline const ::fantasybit::Data& DataTransition::_internal_data(int index) const {
  return data_.Get(index);
}
inline const ::fantasybit::Data& DataTransition::data(int index) const {
  // @@protoc_insertion_point(field_get:fantasybit.DataTransition.data)
  return _internal_data(index);
}
inline ::fantasybit::Data* DataTransition::_internal_add_data() {
  return data_.Add();
}
inline ::fantasybit::Data* DataTransition::add_data() {
  // @@protoc_insertion_point(field_add:fantasybit.DataTransition.data)
  return _internal_add_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fantasybit::Data >&
DataTransition::data() const {
  // @@protoc_insertion_point(field_list:fantasybit.DataTransition.data)
  return data_;
}

// -------------------------------------------------------------------

// TeamState

// optional .fantasybit.TeamState.State state = 1;
inline bool TeamState::_internal_has_state() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TeamState::has_state() const {
  return _internal_has_state();
}
inline void TeamState::clear_state() {
  state_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::fantasybit::TeamState_State TeamState::_internal_state() const {
  return static_cast< ::fantasybit::TeamState_State >(state_);
}
inline ::fantasybit::TeamState_State TeamState::state() const {
  // @@protoc_insertion_point(field_get:fantasybit.TeamState.state)
  return _internal_state();
}
inline void TeamState::_internal_set_state(::fantasybit::TeamState_State value) {
  assert(::fantasybit::TeamState_State_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  state_ = value;
}
inline void TeamState::set_state(::fantasybit::TeamState_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:fantasybit.TeamState.state)
}

// optional uint32 week = 10;
inline bool TeamState::_internal_has_week() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TeamState::has_week() const {
  return _internal_has_week();
}
inline void TeamState::clear_week() {
  week_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TeamState::_internal_week() const {
  return week_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TeamState::week() const {
  // @@protoc_insertion_point(field_get:fantasybit.TeamState.week)
  return _internal_week();
}
inline void TeamState::_internal_set_week(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  week_ = value;
}
inline void TeamState::set_week(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_week(value);
  // @@protoc_insertion_point(field_set:fantasybit.TeamState.week)
}

// optional string teamid = 20;
inline bool TeamState::_internal_has_teamid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TeamState::has_teamid() const {
  return _internal_has_teamid();
}
inline void TeamState::clear_teamid() {
  teamid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TeamState::teamid() const {
  // @@protoc_insertion_point(field_get:fantasybit.TeamState.teamid)
  return _internal_teamid();
}
inline void TeamState::set_teamid(const std::string& value) {
  _internal_set_teamid(value);
  // @@protoc_insertion_point(field_set:fantasybit.TeamState.teamid)
}
inline std::string* TeamState::mutable_teamid() {
  // @@protoc_insertion_point(field_mutable:fantasybit.TeamState.teamid)
  return _internal_mutable_teamid();
}
inline const std::string& TeamState::_internal_teamid() const {
  return teamid_.Get();
}
inline void TeamState::_internal_set_teamid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  teamid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TeamState::set_teamid(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  teamid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.TeamState.teamid)
}
inline void TeamState::set_teamid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  teamid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.TeamState.teamid)
}
inline void TeamState::set_teamid(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  teamid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.TeamState.teamid)
}
inline std::string* TeamState::_internal_mutable_teamid() {
  _has_bits_[0] |= 0x00000001u;
  return teamid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TeamState::release_teamid() {
  // @@protoc_insertion_point(field_release:fantasybit.TeamState.teamid)
  if (!_internal_has_teamid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return teamid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TeamState::set_allocated_teamid(std::string* teamid) {
  if (teamid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  teamid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), teamid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.TeamState.teamid)
}

// -------------------------------------------------------------------

// DeltaData

// optional .fantasybit.DeltaData.Type type = 1;
inline bool DeltaData::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DeltaData::has_type() const {
  return _internal_has_type();
}
inline void DeltaData::clear_type() {
  type_ = 2;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::fantasybit::DeltaData_Type DeltaData::_internal_type() const {
  return static_cast< ::fantasybit::DeltaData_Type >(type_);
}
inline ::fantasybit::DeltaData_Type DeltaData::type() const {
  // @@protoc_insertion_point(field_get:fantasybit.DeltaData.type)
  return _internal_type();
}
inline void DeltaData::_internal_set_type(::fantasybit::DeltaData_Type value) {
  assert(::fantasybit::DeltaData_Type_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
}
inline void DeltaData::set_type(::fantasybit::DeltaData_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:fantasybit.DeltaData.type)
}

// repeated .fantasybit.MyFantasyName myfantasyname = 2;
inline int DeltaData::_internal_myfantasyname_size() const {
  return myfantasyname_.size();
}
inline int DeltaData::myfantasyname_size() const {
  return _internal_myfantasyname_size();
}
inline void DeltaData::clear_myfantasyname() {
  myfantasyname_.Clear();
}
inline ::fantasybit::MyFantasyName* DeltaData::mutable_myfantasyname(int index) {
  // @@protoc_insertion_point(field_mutable:fantasybit.DeltaData.myfantasyname)
  return myfantasyname_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fantasybit::MyFantasyName >*
DeltaData::mutable_myfantasyname() {
  // @@protoc_insertion_point(field_mutable_list:fantasybit.DeltaData.myfantasyname)
  return &myfantasyname_;
}
inline const ::fantasybit::MyFantasyName& DeltaData::_internal_myfantasyname(int index) const {
  return myfantasyname_.Get(index);
}
inline const ::fantasybit::MyFantasyName& DeltaData::myfantasyname(int index) const {
  // @@protoc_insertion_point(field_get:fantasybit.DeltaData.myfantasyname)
  return _internal_myfantasyname(index);
}
inline ::fantasybit::MyFantasyName* DeltaData::_internal_add_myfantasyname() {
  return myfantasyname_.Add();
}
inline ::fantasybit::MyFantasyName* DeltaData::add_myfantasyname() {
  // @@protoc_insertion_point(field_add:fantasybit.DeltaData.myfantasyname)
  return _internal_add_myfantasyname();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fantasybit::MyFantasyName >&
DeltaData::myfantasyname() const {
  // @@protoc_insertion_point(field_list:fantasybit.DeltaData.myfantasyname)
  return myfantasyname_;
}

// optional .fantasybit.GlobalState globalstate = 10;
inline bool DeltaData::_internal_has_globalstate() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || globalstate_ != nullptr);
  return value;
}
inline bool DeltaData::has_globalstate() const {
  return _internal_has_globalstate();
}
inline const ::fantasybit::GlobalState& DeltaData::_internal_globalstate() const {
  const ::fantasybit::GlobalState* p = globalstate_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fantasybit::GlobalState*>(
      &::fantasybit::_GlobalState_default_instance_);
}
inline const ::fantasybit::GlobalState& DeltaData::globalstate() const {
  // @@protoc_insertion_point(field_get:fantasybit.DeltaData.globalstate)
  return _internal_globalstate();
}
inline void DeltaData::unsafe_arena_set_allocated_globalstate(
    ::fantasybit::GlobalState* globalstate) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(globalstate_);
  }
  globalstate_ = globalstate;
  if (globalstate) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fantasybit.DeltaData.globalstate)
}
inline ::fantasybit::GlobalState* DeltaData::release_globalstate() {
  _has_bits_[0] &= ~0x00000001u;
  ::fantasybit::GlobalState* temp = globalstate_;
  globalstate_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fantasybit::GlobalState* DeltaData::unsafe_arena_release_globalstate() {
  // @@protoc_insertion_point(field_release:fantasybit.DeltaData.globalstate)
  _has_bits_[0] &= ~0x00000001u;
  ::fantasybit::GlobalState* temp = globalstate_;
  globalstate_ = nullptr;
  return temp;
}
inline ::fantasybit::GlobalState* DeltaData::_internal_mutable_globalstate() {
  _has_bits_[0] |= 0x00000001u;
  if (globalstate_ == nullptr) {
    auto* p = CreateMaybeMessage<::fantasybit::GlobalState>(GetArena());
    globalstate_ = p;
  }
  return globalstate_;
}
inline ::fantasybit::GlobalState* DeltaData::mutable_globalstate() {
  // @@protoc_insertion_point(field_mutable:fantasybit.DeltaData.globalstate)
  return _internal_mutable_globalstate();
}
inline void DeltaData::set_allocated_globalstate(::fantasybit::GlobalState* globalstate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(globalstate_);
  }
  if (globalstate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(globalstate)->GetArena();
    if (message_arena != submessage_arena) {
      globalstate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, globalstate, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  globalstate_ = globalstate;
  // @@protoc_insertion_point(field_set_allocated:fantasybit.DeltaData.globalstate)
}

// repeated .fantasybit.TeamState teamstates = 20;
inline int DeltaData::_internal_teamstates_size() const {
  return teamstates_.size();
}
inline int DeltaData::teamstates_size() const {
  return _internal_teamstates_size();
}
inline void DeltaData::clear_teamstates() {
  teamstates_.Clear();
}
inline ::fantasybit::TeamState* DeltaData::mutable_teamstates(int index) {
  // @@protoc_insertion_point(field_mutable:fantasybit.DeltaData.teamstates)
  return teamstates_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fantasybit::TeamState >*
DeltaData::mutable_teamstates() {
  // @@protoc_insertion_point(field_mutable_list:fantasybit.DeltaData.teamstates)
  return &teamstates_;
}
inline const ::fantasybit::TeamState& DeltaData::_internal_teamstates(int index) const {
  return teamstates_.Get(index);
}
inline const ::fantasybit::TeamState& DeltaData::teamstates(int index) const {
  // @@protoc_insertion_point(field_get:fantasybit.DeltaData.teamstates)
  return _internal_teamstates(index);
}
inline ::fantasybit::TeamState* DeltaData::_internal_add_teamstates() {
  return teamstates_.Add();
}
inline ::fantasybit::TeamState* DeltaData::add_teamstates() {
  // @@protoc_insertion_point(field_add:fantasybit.DeltaData.teamstates)
  return _internal_add_teamstates();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fantasybit::TeamState >&
DeltaData::teamstates() const {
  // @@protoc_insertion_point(field_list:fantasybit.DeltaData.teamstates)
  return teamstates_;
}

// repeated .fantasybit.Data datas = 30;
inline int DeltaData::_internal_datas_size() const {
  return datas_.size();
}
inline int DeltaData::datas_size() const {
  return _internal_datas_size();
}
inline void DeltaData::clear_datas() {
  datas_.Clear();
}
inline ::fantasybit::Data* DeltaData::mutable_datas(int index) {
  // @@protoc_insertion_point(field_mutable:fantasybit.DeltaData.datas)
  return datas_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fantasybit::Data >*
DeltaData::mutable_datas() {
  // @@protoc_insertion_point(field_mutable_list:fantasybit.DeltaData.datas)
  return &datas_;
}
inline const ::fantasybit::Data& DeltaData::_internal_datas(int index) const {
  return datas_.Get(index);
}
inline const ::fantasybit::Data& DeltaData::datas(int index) const {
  // @@protoc_insertion_point(field_get:fantasybit.DeltaData.datas)
  return _internal_datas(index);
}
inline ::fantasybit::Data* DeltaData::_internal_add_datas() {
  return datas_.Add();
}
inline ::fantasybit::Data* DeltaData::add_datas() {
  // @@protoc_insertion_point(field_add:fantasybit.DeltaData.datas)
  return _internal_add_datas();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fantasybit::Data >&
DeltaData::datas() const {
  // @@protoc_insertion_point(field_list:fantasybit.DeltaData.datas)
  return datas_;
}

// repeated .fantasybit.FantasyPlayer players = 40;
inline int DeltaData::_internal_players_size() const {
  return players_.size();
}
inline int DeltaData::players_size() const {
  return _internal_players_size();
}
inline void DeltaData::clear_players() {
  players_.Clear();
}
inline ::fantasybit::FantasyPlayer* DeltaData::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:fantasybit.DeltaData.players)
  return players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fantasybit::FantasyPlayer >*
DeltaData::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:fantasybit.DeltaData.players)
  return &players_;
}
inline const ::fantasybit::FantasyPlayer& DeltaData::_internal_players(int index) const {
  return players_.Get(index);
}
inline const ::fantasybit::FantasyPlayer& DeltaData::players(int index) const {
  // @@protoc_insertion_point(field_get:fantasybit.DeltaData.players)
  return _internal_players(index);
}
inline ::fantasybit::FantasyPlayer* DeltaData::_internal_add_players() {
  return players_.Add();
}
inline ::fantasybit::FantasyPlayer* DeltaData::add_players() {
  // @@protoc_insertion_point(field_add:fantasybit.DeltaData.players)
  return _internal_add_players();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fantasybit::FantasyPlayer >&
DeltaData::players() const {
  // @@protoc_insertion_point(field_list:fantasybit.DeltaData.players)
  return players_;
}

// -------------------------------------------------------------------

// MessageData

// optional string msg = 10;
inline bool MessageData::_internal_has_msg() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MessageData::has_msg() const {
  return _internal_has_msg();
}
inline void MessageData::clear_msg() {
  msg_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MessageData::msg() const {
  // @@protoc_insertion_point(field_get:fantasybit.MessageData.msg)
  return _internal_msg();
}
inline void MessageData::set_msg(const std::string& value) {
  _internal_set_msg(value);
  // @@protoc_insertion_point(field_set:fantasybit.MessageData.msg)
}
inline std::string* MessageData::mutable_msg() {
  // @@protoc_insertion_point(field_mutable:fantasybit.MessageData.msg)
  return _internal_mutable_msg();
}
inline const std::string& MessageData::_internal_msg() const {
  return msg_.Get();
}
inline void MessageData::_internal_set_msg(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  msg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void MessageData::set_msg(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  msg_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.MessageData.msg)
}
inline void MessageData::set_msg(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  msg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.MessageData.msg)
}
inline void MessageData::set_msg(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  msg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.MessageData.msg)
}
inline std::string* MessageData::_internal_mutable_msg() {
  _has_bits_[0] |= 0x00000001u;
  return msg_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* MessageData::release_msg() {
  // @@protoc_insertion_point(field_release:fantasybit.MessageData.msg)
  if (!_internal_has_msg()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return msg_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MessageData::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.MessageData.msg)
}

// optional int32 gt = 20;
inline bool MessageData::_internal_has_gt() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MessageData::has_gt() const {
  return _internal_has_gt();
}
inline void MessageData::clear_gt() {
  gt_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MessageData::_internal_gt() const {
  return gt_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MessageData::gt() const {
  // @@protoc_insertion_point(field_get:fantasybit.MessageData.gt)
  return _internal_gt();
}
inline void MessageData::_internal_set_gt(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  gt_ = value;
}
inline void MessageData::set_gt(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_gt(value);
  // @@protoc_insertion_point(field_set:fantasybit.MessageData.gt)
}

// optional int32 lt = 30;
inline bool MessageData::_internal_has_lt() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MessageData::has_lt() const {
  return _internal_has_lt();
}
inline void MessageData::clear_lt() {
  lt_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MessageData::_internal_lt() const {
  return lt_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MessageData::lt() const {
  // @@protoc_insertion_point(field_get:fantasybit.MessageData.lt)
  return _internal_lt();
}
inline void MessageData::_internal_set_lt(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  lt_ = value;
}
inline void MessageData::set_lt(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_lt(value);
  // @@protoc_insertion_point(field_set:fantasybit.MessageData.lt)
}

// -------------------------------------------------------------------

// StampedTrans

// optional uint64 timestamp = 10;
inline bool StampedTrans::_internal_has_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StampedTrans::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void StampedTrans::clear_timestamp() {
  timestamp_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 StampedTrans::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 StampedTrans::timestamp() const {
  // @@protoc_insertion_point(field_get:fantasybit.StampedTrans.timestamp)
  return _internal_timestamp();
}
inline void StampedTrans::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  timestamp_ = value;
}
inline void StampedTrans::set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:fantasybit.StampedTrans.timestamp)
}

// optional int32 seqnum = 20;
inline bool StampedTrans::_internal_has_seqnum() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StampedTrans::has_seqnum() const {
  return _internal_has_seqnum();
}
inline void StampedTrans::clear_seqnum() {
  seqnum_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StampedTrans::_internal_seqnum() const {
  return seqnum_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StampedTrans::seqnum() const {
  // @@protoc_insertion_point(field_get:fantasybit.StampedTrans.seqnum)
  return _internal_seqnum();
}
inline void StampedTrans::_internal_set_seqnum(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  seqnum_ = value;
}
inline void StampedTrans::set_seqnum(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_seqnum(value);
  // @@protoc_insertion_point(field_set:fantasybit.StampedTrans.seqnum)
}

// optional int32 prevseq = 21;
inline bool StampedTrans::_internal_has_prevseq() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool StampedTrans::has_prevseq() const {
  return _internal_has_prevseq();
}
inline void StampedTrans::clear_prevseq() {
  prevseq_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StampedTrans::_internal_prevseq() const {
  return prevseq_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StampedTrans::prevseq() const {
  // @@protoc_insertion_point(field_get:fantasybit.StampedTrans.prevseq)
  return _internal_prevseq();
}
inline void StampedTrans::_internal_set_prevseq(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  prevseq_ = value;
}
inline void StampedTrans::set_prevseq(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_prevseq(value);
  // @@protoc_insertion_point(field_set:fantasybit.StampedTrans.prevseq)
}

// optional .fantasybit.SignedTransaction signed_orig = 30;
inline bool StampedTrans::_internal_has_signed_orig() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || signed_orig_ != nullptr);
  return value;
}
inline bool StampedTrans::has_signed_orig() const {
  return _internal_has_signed_orig();
}
inline void StampedTrans::clear_signed_orig() {
  if (signed_orig_ != nullptr) signed_orig_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::fantasybit::SignedTransaction& StampedTrans::_internal_signed_orig() const {
  const ::fantasybit::SignedTransaction* p = signed_orig_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fantasybit::SignedTransaction*>(
      &::fantasybit::_SignedTransaction_default_instance_);
}
inline const ::fantasybit::SignedTransaction& StampedTrans::signed_orig() const {
  // @@protoc_insertion_point(field_get:fantasybit.StampedTrans.signed_orig)
  return _internal_signed_orig();
}
inline void StampedTrans::unsafe_arena_set_allocated_signed_orig(
    ::fantasybit::SignedTransaction* signed_orig) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(signed_orig_);
  }
  signed_orig_ = signed_orig;
  if (signed_orig) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fantasybit.StampedTrans.signed_orig)
}
inline ::fantasybit::SignedTransaction* StampedTrans::release_signed_orig() {
  _has_bits_[0] &= ~0x00000001u;
  ::fantasybit::SignedTransaction* temp = signed_orig_;
  signed_orig_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fantasybit::SignedTransaction* StampedTrans::unsafe_arena_release_signed_orig() {
  // @@protoc_insertion_point(field_release:fantasybit.StampedTrans.signed_orig)
  _has_bits_[0] &= ~0x00000001u;
  ::fantasybit::SignedTransaction* temp = signed_orig_;
  signed_orig_ = nullptr;
  return temp;
}
inline ::fantasybit::SignedTransaction* StampedTrans::_internal_mutable_signed_orig() {
  _has_bits_[0] |= 0x00000001u;
  if (signed_orig_ == nullptr) {
    auto* p = CreateMaybeMessage<::fantasybit::SignedTransaction>(GetArena());
    signed_orig_ = p;
  }
  return signed_orig_;
}
inline ::fantasybit::SignedTransaction* StampedTrans::mutable_signed_orig() {
  // @@protoc_insertion_point(field_mutable:fantasybit.StampedTrans.signed_orig)
  return _internal_mutable_signed_orig();
}
inline void StampedTrans::set_allocated_signed_orig(::fantasybit::SignedTransaction* signed_orig) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete signed_orig_;
  }
  if (signed_orig) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(signed_orig);
    if (message_arena != submessage_arena) {
      signed_orig = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signed_orig, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  signed_orig_ = signed_orig;
  // @@protoc_insertion_point(field_set_allocated:fantasybit.StampedTrans.signed_orig)
}

// -------------------------------------------------------------------

// ExchangeOrder

// optional .fantasybit.ExchangeOrder.Type type = 10;
inline bool ExchangeOrder::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ExchangeOrder::has_type() const {
  return _internal_has_type();
}
inline void ExchangeOrder::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::fantasybit::ExchangeOrder_Type ExchangeOrder::_internal_type() const {
  return static_cast< ::fantasybit::ExchangeOrder_Type >(type_);
}
inline ::fantasybit::ExchangeOrder_Type ExchangeOrder::type() const {
  // @@protoc_insertion_point(field_get:fantasybit.ExchangeOrder.type)
  return _internal_type();
}
inline void ExchangeOrder::_internal_set_type(::fantasybit::ExchangeOrder_Type value) {
  assert(::fantasybit::ExchangeOrder_Type_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  type_ = value;
}
inline void ExchangeOrder::set_type(::fantasybit::ExchangeOrder_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:fantasybit.ExchangeOrder.type)
}

// optional string playerid = 40;
inline bool ExchangeOrder::_internal_has_playerid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ExchangeOrder::has_playerid() const {
  return _internal_has_playerid();
}
inline void ExchangeOrder::clear_playerid() {
  playerid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ExchangeOrder::playerid() const {
  // @@protoc_insertion_point(field_get:fantasybit.ExchangeOrder.playerid)
  return _internal_playerid();
}
inline void ExchangeOrder::set_playerid(const std::string& value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:fantasybit.ExchangeOrder.playerid)
}
inline std::string* ExchangeOrder::mutable_playerid() {
  // @@protoc_insertion_point(field_mutable:fantasybit.ExchangeOrder.playerid)
  return _internal_mutable_playerid();
}
inline const std::string& ExchangeOrder::_internal_playerid() const {
  return playerid_.Get();
}
inline void ExchangeOrder::_internal_set_playerid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  playerid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ExchangeOrder::set_playerid(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  playerid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.ExchangeOrder.playerid)
}
inline void ExchangeOrder::set_playerid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  playerid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.ExchangeOrder.playerid)
}
inline void ExchangeOrder::set_playerid(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  playerid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.ExchangeOrder.playerid)
}
inline std::string* ExchangeOrder::_internal_mutable_playerid() {
  _has_bits_[0] |= 0x00000001u;
  return playerid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ExchangeOrder::release_playerid() {
  // @@protoc_insertion_point(field_release:fantasybit.ExchangeOrder.playerid)
  if (!_internal_has_playerid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return playerid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ExchangeOrder::set_allocated_playerid(std::string* playerid) {
  if (playerid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  playerid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), playerid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.ExchangeOrder.playerid)
}

// optional .fantasybit.OrderCore core = 50;
inline bool ExchangeOrder::_internal_has_core() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || core_ != nullptr);
  return value;
}
inline bool ExchangeOrder::has_core() const {
  return _internal_has_core();
}
inline const ::fantasybit::OrderCore& ExchangeOrder::_internal_core() const {
  const ::fantasybit::OrderCore* p = core_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fantasybit::OrderCore*>(
      &::fantasybit::_OrderCore_default_instance_);
}
inline const ::fantasybit::OrderCore& ExchangeOrder::core() const {
  // @@protoc_insertion_point(field_get:fantasybit.ExchangeOrder.core)
  return _internal_core();
}
inline void ExchangeOrder::unsafe_arena_set_allocated_core(
    ::fantasybit::OrderCore* core) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(core_);
  }
  core_ = core;
  if (core) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fantasybit.ExchangeOrder.core)
}
inline ::fantasybit::OrderCore* ExchangeOrder::release_core() {
  _has_bits_[0] &= ~0x00000004u;
  ::fantasybit::OrderCore* temp = core_;
  core_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fantasybit::OrderCore* ExchangeOrder::unsafe_arena_release_core() {
  // @@protoc_insertion_point(field_release:fantasybit.ExchangeOrder.core)
  _has_bits_[0] &= ~0x00000004u;
  ::fantasybit::OrderCore* temp = core_;
  core_ = nullptr;
  return temp;
}
inline ::fantasybit::OrderCore* ExchangeOrder::_internal_mutable_core() {
  _has_bits_[0] |= 0x00000004u;
  if (core_ == nullptr) {
    auto* p = CreateMaybeMessage<::fantasybit::OrderCore>(GetArena());
    core_ = p;
  }
  return core_;
}
inline ::fantasybit::OrderCore* ExchangeOrder::mutable_core() {
  // @@protoc_insertion_point(field_mutable:fantasybit.ExchangeOrder.core)
  return _internal_mutable_core();
}
inline void ExchangeOrder::set_allocated_core(::fantasybit::OrderCore* core) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(core_);
  }
  if (core) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(core)->GetArena();
    if (message_arena != submessage_arena) {
      core = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, core, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  core_ = core;
  // @@protoc_insertion_point(field_set_allocated:fantasybit.ExchangeOrder.core)
}

// optional int32 cancel_oref = 100;
inline bool ExchangeOrder::_internal_has_cancel_oref() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ExchangeOrder::has_cancel_oref() const {
  return _internal_has_cancel_oref();
}
inline void ExchangeOrder::clear_cancel_oref() {
  cancel_oref_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ExchangeOrder::_internal_cancel_oref() const {
  return cancel_oref_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ExchangeOrder::cancel_oref() const {
  // @@protoc_insertion_point(field_get:fantasybit.ExchangeOrder.cancel_oref)
  return _internal_cancel_oref();
}
inline void ExchangeOrder::_internal_set_cancel_oref(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  cancel_oref_ = value;
}
inline void ExchangeOrder::set_cancel_oref(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_cancel_oref(value);
  // @@protoc_insertion_point(field_set:fantasybit.ExchangeOrder.cancel_oref)
}

// optional .fantasybit.FutContract futcontract = 110;
inline bool ExchangeOrder::_internal_has_futcontract() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || futcontract_ != nullptr);
  return value;
}
inline bool ExchangeOrder::has_futcontract() const {
  return _internal_has_futcontract();
}
inline const ::fantasybit::FutContract& ExchangeOrder::_internal_futcontract() const {
  const ::fantasybit::FutContract* p = futcontract_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fantasybit::FutContract*>(
      &::fantasybit::_FutContract_default_instance_);
}
inline const ::fantasybit::FutContract& ExchangeOrder::futcontract() const {
  // @@protoc_insertion_point(field_get:fantasybit.ExchangeOrder.futcontract)
  return _internal_futcontract();
}
inline void ExchangeOrder::unsafe_arena_set_allocated_futcontract(
    ::fantasybit::FutContract* futcontract) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(futcontract_);
  }
  futcontract_ = futcontract;
  if (futcontract) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fantasybit.ExchangeOrder.futcontract)
}
inline ::fantasybit::FutContract* ExchangeOrder::release_futcontract() {
  _has_bits_[0] &= ~0x00000008u;
  ::fantasybit::FutContract* temp = futcontract_;
  futcontract_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fantasybit::FutContract* ExchangeOrder::unsafe_arena_release_futcontract() {
  // @@protoc_insertion_point(field_release:fantasybit.ExchangeOrder.futcontract)
  _has_bits_[0] &= ~0x00000008u;
  ::fantasybit::FutContract* temp = futcontract_;
  futcontract_ = nullptr;
  return temp;
}
inline ::fantasybit::FutContract* ExchangeOrder::_internal_mutable_futcontract() {
  _has_bits_[0] |= 0x00000008u;
  if (futcontract_ == nullptr) {
    auto* p = CreateMaybeMessage<::fantasybit::FutContract>(GetArena());
    futcontract_ = p;
  }
  return futcontract_;
}
inline ::fantasybit::FutContract* ExchangeOrder::mutable_futcontract() {
  // @@protoc_insertion_point(field_mutable:fantasybit.ExchangeOrder.futcontract)
  return _internal_mutable_futcontract();
}
inline void ExchangeOrder::set_allocated_futcontract(::fantasybit::FutContract* futcontract) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(futcontract_);
  }
  if (futcontract) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(futcontract)->GetArena();
    if (message_arena != submessage_arena) {
      futcontract = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, futcontract, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  futcontract_ = futcontract;
  // @@protoc_insertion_point(field_set_allocated:fantasybit.ExchangeOrder.futcontract)
}

// optional string symbol = 120;
inline bool ExchangeOrder::_internal_has_symbol() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ExchangeOrder::has_symbol() const {
  return _internal_has_symbol();
}
inline void ExchangeOrder::clear_symbol() {
  symbol_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ExchangeOrder::symbol() const {
  // @@protoc_insertion_point(field_get:fantasybit.ExchangeOrder.symbol)
  return _internal_symbol();
}
inline void ExchangeOrder::set_symbol(const std::string& value) {
  _internal_set_symbol(value);
  // @@protoc_insertion_point(field_set:fantasybit.ExchangeOrder.symbol)
}
inline std::string* ExchangeOrder::mutable_symbol() {
  // @@protoc_insertion_point(field_mutable:fantasybit.ExchangeOrder.symbol)
  return _internal_mutable_symbol();
}
inline const std::string& ExchangeOrder::_internal_symbol() const {
  return symbol_.Get();
}
inline void ExchangeOrder::_internal_set_symbol(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  symbol_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ExchangeOrder::set_symbol(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  symbol_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.ExchangeOrder.symbol)
}
inline void ExchangeOrder::set_symbol(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  symbol_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.ExchangeOrder.symbol)
}
inline void ExchangeOrder::set_symbol(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  symbol_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.ExchangeOrder.symbol)
}
inline std::string* ExchangeOrder::_internal_mutable_symbol() {
  _has_bits_[0] |= 0x00000002u;
  return symbol_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ExchangeOrder::release_symbol() {
  // @@protoc_insertion_point(field_release:fantasybit.ExchangeOrder.symbol)
  if (!_internal_has_symbol()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return symbol_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ExchangeOrder::set_allocated_symbol(std::string* symbol) {
  if (symbol != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  symbol_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), symbol,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.ExchangeOrder.symbol)
}

// -------------------------------------------------------------------

// OrderUnique

// optional string public_key = 10;
inline bool OrderUnique::_internal_has_public_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OrderUnique::has_public_key() const {
  return _internal_has_public_key();
}
inline void OrderUnique::clear_public_key() {
  public_key_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OrderUnique::public_key() const {
  // @@protoc_insertion_point(field_get:fantasybit.OrderUnique.public_key)
  return _internal_public_key();
}
inline void OrderUnique::set_public_key(const std::string& value) {
  _internal_set_public_key(value);
  // @@protoc_insertion_point(field_set:fantasybit.OrderUnique.public_key)
}
inline std::string* OrderUnique::mutable_public_key() {
  // @@protoc_insertion_point(field_mutable:fantasybit.OrderUnique.public_key)
  return _internal_mutable_public_key();
}
inline const std::string& OrderUnique::_internal_public_key() const {
  return public_key_.Get();
}
inline void OrderUnique::_internal_set_public_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  public_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void OrderUnique::set_public_key(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  public_key_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.OrderUnique.public_key)
}
inline void OrderUnique::set_public_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  public_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.OrderUnique.public_key)
}
inline void OrderUnique::set_public_key(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  public_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.OrderUnique.public_key)
}
inline std::string* OrderUnique::_internal_mutable_public_key() {
  _has_bits_[0] |= 0x00000001u;
  return public_key_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* OrderUnique::release_public_key() {
  // @@protoc_insertion_point(field_release:fantasybit.OrderUnique.public_key)
  if (!_internal_has_public_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return public_key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void OrderUnique::set_allocated_public_key(std::string* public_key) {
  if (public_key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  public_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), public_key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.OrderUnique.public_key)
}

// optional uint32 season = 20;
inline bool OrderUnique::_internal_has_season() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool OrderUnique::has_season() const {
  return _internal_has_season();
}
inline void OrderUnique::clear_season() {
  season_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 OrderUnique::_internal_season() const {
  return season_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 OrderUnique::season() const {
  // @@protoc_insertion_point(field_get:fantasybit.OrderUnique.season)
  return _internal_season();
}
inline void OrderUnique::_internal_set_season(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  season_ = value;
}
inline void OrderUnique::set_season(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_season(value);
  // @@protoc_insertion_point(field_set:fantasybit.OrderUnique.season)
}

// optional uint32 week = 30;
inline bool OrderUnique::_internal_has_week() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool OrderUnique::has_week() const {
  return _internal_has_week();
}
inline void OrderUnique::clear_week() {
  week_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 OrderUnique::_internal_week() const {
  return week_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 OrderUnique::week() const {
  // @@protoc_insertion_point(field_get:fantasybit.OrderUnique.week)
  return _internal_week();
}
inline void OrderUnique::_internal_set_week(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  week_ = value;
}
inline void OrderUnique::set_week(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_week(value);
  // @@protoc_insertion_point(field_set:fantasybit.OrderUnique.week)
}

// optional bool buyside = 40;
inline bool OrderUnique::_internal_has_buyside() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool OrderUnique::has_buyside() const {
  return _internal_has_buyside();
}
inline void OrderUnique::clear_buyside() {
  buyside_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool OrderUnique::_internal_buyside() const {
  return buyside_;
}
inline bool OrderUnique::buyside() const {
  // @@protoc_insertion_point(field_get:fantasybit.OrderUnique.buyside)
  return _internal_buyside();
}
inline void OrderUnique::_internal_set_buyside(bool value) {
  _has_bits_[0] |= 0x00000010u;
  buyside_ = value;
}
inline void OrderUnique::set_buyside(bool value) {
  _internal_set_buyside(value);
  // @@protoc_insertion_point(field_set:fantasybit.OrderUnique.buyside)
}

// optional string playerid = 50;
inline bool OrderUnique::_internal_has_playerid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OrderUnique::has_playerid() const {
  return _internal_has_playerid();
}
inline void OrderUnique::clear_playerid() {
  playerid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& OrderUnique::playerid() const {
  // @@protoc_insertion_point(field_get:fantasybit.OrderUnique.playerid)
  return _internal_playerid();
}
inline void OrderUnique::set_playerid(const std::string& value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:fantasybit.OrderUnique.playerid)
}
inline std::string* OrderUnique::mutable_playerid() {
  // @@protoc_insertion_point(field_mutable:fantasybit.OrderUnique.playerid)
  return _internal_mutable_playerid();
}
inline const std::string& OrderUnique::_internal_playerid() const {
  return playerid_.Get();
}
inline void OrderUnique::_internal_set_playerid(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  playerid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void OrderUnique::set_playerid(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  playerid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.OrderUnique.playerid)
}
inline void OrderUnique::set_playerid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  playerid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.OrderUnique.playerid)
}
inline void OrderUnique::set_playerid(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  playerid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.OrderUnique.playerid)
}
inline std::string* OrderUnique::_internal_mutable_playerid() {
  _has_bits_[0] |= 0x00000002u;
  return playerid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* OrderUnique::release_playerid() {
  // @@protoc_insertion_point(field_release:fantasybit.OrderUnique.playerid)
  if (!_internal_has_playerid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return playerid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void OrderUnique::set_allocated_playerid(std::string* playerid) {
  if (playerid != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  playerid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), playerid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.OrderUnique.playerid)
}

// optional int32 price = 70;
inline bool OrderUnique::_internal_has_price() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool OrderUnique::has_price() const {
  return _internal_has_price();
}
inline void OrderUnique::clear_price() {
  price_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OrderUnique::_internal_price() const {
  return price_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OrderUnique::price() const {
  // @@protoc_insertion_point(field_get:fantasybit.OrderUnique.price)
  return _internal_price();
}
inline void OrderUnique::_internal_set_price(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  price_ = value;
}
inline void OrderUnique::set_price(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_price(value);
  // @@protoc_insertion_point(field_set:fantasybit.OrderUnique.price)
}

// -------------------------------------------------------------------

// OrderDeets

// optional bytes oid = 10;
inline bool OrderDeets::_internal_has_oid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OrderDeets::has_oid() const {
  return _internal_has_oid();
}
inline void OrderDeets::clear_oid() {
  oid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OrderDeets::oid() const {
  // @@protoc_insertion_point(field_get:fantasybit.OrderDeets.oid)
  return _internal_oid();
}
inline void OrderDeets::set_oid(const std::string& value) {
  _internal_set_oid(value);
  // @@protoc_insertion_point(field_set:fantasybit.OrderDeets.oid)
}
inline std::string* OrderDeets::mutable_oid() {
  // @@protoc_insertion_point(field_mutable:fantasybit.OrderDeets.oid)
  return _internal_mutable_oid();
}
inline const std::string& OrderDeets::_internal_oid() const {
  return oid_.Get();
}
inline void OrderDeets::_internal_set_oid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  oid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void OrderDeets::set_oid(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  oid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.OrderDeets.oid)
}
inline void OrderDeets::set_oid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  oid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.OrderDeets.oid)
}
inline void OrderDeets::set_oid(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  oid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.OrderDeets.oid)
}
inline std::string* OrderDeets::_internal_mutable_oid() {
  _has_bits_[0] |= 0x00000001u;
  return oid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* OrderDeets::release_oid() {
  // @@protoc_insertion_point(field_release:fantasybit.OrderDeets.oid)
  if (!_internal_has_oid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return oid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void OrderDeets::set_allocated_oid(std::string* oid) {
  if (oid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  oid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), oid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.OrderDeets.oid)
}

// optional .fantasybit.OrderUnique order = 20;
inline bool OrderDeets::_internal_has_order() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || order_ != nullptr);
  return value;
}
inline bool OrderDeets::has_order() const {
  return _internal_has_order();
}
inline void OrderDeets::clear_order() {
  if (order_ != nullptr) order_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::fantasybit::OrderUnique& OrderDeets::_internal_order() const {
  const ::fantasybit::OrderUnique* p = order_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fantasybit::OrderUnique*>(
      &::fantasybit::_OrderUnique_default_instance_);
}
inline const ::fantasybit::OrderUnique& OrderDeets::order() const {
  // @@protoc_insertion_point(field_get:fantasybit.OrderDeets.order)
  return _internal_order();
}
inline void OrderDeets::unsafe_arena_set_allocated_order(
    ::fantasybit::OrderUnique* order) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(order_);
  }
  order_ = order;
  if (order) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fantasybit.OrderDeets.order)
}
inline ::fantasybit::OrderUnique* OrderDeets::release_order() {
  _has_bits_[0] &= ~0x00000002u;
  ::fantasybit::OrderUnique* temp = order_;
  order_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fantasybit::OrderUnique* OrderDeets::unsafe_arena_release_order() {
  // @@protoc_insertion_point(field_release:fantasybit.OrderDeets.order)
  _has_bits_[0] &= ~0x00000002u;
  ::fantasybit::OrderUnique* temp = order_;
  order_ = nullptr;
  return temp;
}
inline ::fantasybit::OrderUnique* OrderDeets::_internal_mutable_order() {
  _has_bits_[0] |= 0x00000002u;
  if (order_ == nullptr) {
    auto* p = CreateMaybeMessage<::fantasybit::OrderUnique>(GetArena());
    order_ = p;
  }
  return order_;
}
inline ::fantasybit::OrderUnique* OrderDeets::mutable_order() {
  // @@protoc_insertion_point(field_mutable:fantasybit.OrderDeets.order)
  return _internal_mutable_order();
}
inline void OrderDeets::set_allocated_order(::fantasybit::OrderUnique* order) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete order_;
  }
  if (order) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(order);
    if (message_arena != submessage_arena) {
      order = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, order, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  order_ = order;
  // @@protoc_insertion_point(field_set_allocated:fantasybit.OrderDeets.order)
}

// optional int32 size = 30;
inline bool OrderDeets::_internal_has_size() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool OrderDeets::has_size() const {
  return _internal_has_size();
}
inline void OrderDeets::clear_size() {
  size_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OrderDeets::_internal_size() const {
  return size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OrderDeets::size() const {
  // @@protoc_insertion_point(field_get:fantasybit.OrderDeets.size)
  return _internal_size();
}
inline void OrderDeets::_internal_set_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  size_ = value;
}
inline void OrderDeets::set_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:fantasybit.OrderDeets.size)
}

// -------------------------------------------------------------------

// InsideUnique

// optional string playerid = 50;
inline bool InsideUnique::_internal_has_playerid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool InsideUnique::has_playerid() const {
  return _internal_has_playerid();
}
inline void InsideUnique::clear_playerid() {
  playerid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& InsideUnique::playerid() const {
  // @@protoc_insertion_point(field_get:fantasybit.InsideUnique.playerid)
  return _internal_playerid();
}
inline void InsideUnique::set_playerid(const std::string& value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:fantasybit.InsideUnique.playerid)
}
inline std::string* InsideUnique::mutable_playerid() {
  // @@protoc_insertion_point(field_mutable:fantasybit.InsideUnique.playerid)
  return _internal_mutable_playerid();
}
inline const std::string& InsideUnique::_internal_playerid() const {
  return playerid_.Get();
}
inline void InsideUnique::_internal_set_playerid(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  playerid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void InsideUnique::set_playerid(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  playerid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.InsideUnique.playerid)
}
inline void InsideUnique::set_playerid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  playerid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.InsideUnique.playerid)
}
inline void InsideUnique::set_playerid(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  playerid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.InsideUnique.playerid)
}
inline std::string* InsideUnique::_internal_mutable_playerid() {
  _has_bits_[0] |= 0x00000004u;
  return playerid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* InsideUnique::release_playerid() {
  // @@protoc_insertion_point(field_release:fantasybit.InsideUnique.playerid)
  if (!_internal_has_playerid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return playerid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void InsideUnique::set_allocated_playerid(std::string* playerid) {
  if (playerid != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  playerid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), playerid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.InsideUnique.playerid)
}

// optional string public_key = 10;
inline bool InsideUnique::_internal_has_public_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InsideUnique::has_public_key() const {
  return _internal_has_public_key();
}
inline void InsideUnique::clear_public_key() {
  public_key_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InsideUnique::public_key() const {
  // @@protoc_insertion_point(field_get:fantasybit.InsideUnique.public_key)
  return _internal_public_key();
}
inline void InsideUnique::set_public_key(const std::string& value) {
  _internal_set_public_key(value);
  // @@protoc_insertion_point(field_set:fantasybit.InsideUnique.public_key)
}
inline std::string* InsideUnique::mutable_public_key() {
  // @@protoc_insertion_point(field_mutable:fantasybit.InsideUnique.public_key)
  return _internal_mutable_public_key();
}
inline const std::string& InsideUnique::_internal_public_key() const {
  return public_key_.Get();
}
inline void InsideUnique::_internal_set_public_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  public_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void InsideUnique::set_public_key(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  public_key_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.InsideUnique.public_key)
}
inline void InsideUnique::set_public_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  public_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.InsideUnique.public_key)
}
inline void InsideUnique::set_public_key(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  public_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.InsideUnique.public_key)
}
inline std::string* InsideUnique::_internal_mutable_public_key() {
  _has_bits_[0] |= 0x00000001u;
  return public_key_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* InsideUnique::release_public_key() {
  // @@protoc_insertion_point(field_release:fantasybit.InsideUnique.public_key)
  if (!_internal_has_public_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return public_key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void InsideUnique::set_allocated_public_key(std::string* public_key) {
  if (public_key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  public_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), public_key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.InsideUnique.public_key)
}

// optional bool buyside = 40;
inline bool InsideUnique::_internal_has_buyside() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool InsideUnique::has_buyside() const {
  return _internal_has_buyside();
}
inline void InsideUnique::clear_buyside() {
  buyside_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool InsideUnique::_internal_buyside() const {
  return buyside_;
}
inline bool InsideUnique::buyside() const {
  // @@protoc_insertion_point(field_get:fantasybit.InsideUnique.buyside)
  return _internal_buyside();
}
inline void InsideUnique::_internal_set_buyside(bool value) {
  _has_bits_[0] |= 0x00000040u;
  buyside_ = value;
}
inline void InsideUnique::set_buyside(bool value) {
  _internal_set_buyside(value);
  // @@protoc_insertion_point(field_set:fantasybit.InsideUnique.buyside)
}

// optional int32 price = 70;
inline bool InsideUnique::_internal_has_price() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool InsideUnique::has_price() const {
  return _internal_has_price();
}
inline void InsideUnique::clear_price() {
  price_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InsideUnique::_internal_price() const {
  return price_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InsideUnique::price() const {
  // @@protoc_insertion_point(field_get:fantasybit.InsideUnique.price)
  return _internal_price();
}
inline void InsideUnique::_internal_set_price(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  price_ = value;
}
inline void InsideUnique::set_price(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_price(value);
  // @@protoc_insertion_point(field_set:fantasybit.InsideUnique.price)
}

// optional bytes oid = 11;
inline bool InsideUnique::_internal_has_oid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool InsideUnique::has_oid() const {
  return _internal_has_oid();
}
inline void InsideUnique::clear_oid() {
  oid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& InsideUnique::oid() const {
  // @@protoc_insertion_point(field_get:fantasybit.InsideUnique.oid)
  return _internal_oid();
}
inline void InsideUnique::set_oid(const std::string& value) {
  _internal_set_oid(value);
  // @@protoc_insertion_point(field_set:fantasybit.InsideUnique.oid)
}
inline std::string* InsideUnique::mutable_oid() {
  // @@protoc_insertion_point(field_mutable:fantasybit.InsideUnique.oid)
  return _internal_mutable_oid();
}
inline const std::string& InsideUnique::_internal_oid() const {
  return oid_.Get();
}
inline void InsideUnique::_internal_set_oid(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  oid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void InsideUnique::set_oid(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  oid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.InsideUnique.oid)
}
inline void InsideUnique::set_oid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  oid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.InsideUnique.oid)
}
inline void InsideUnique::set_oid(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  oid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.InsideUnique.oid)
}
inline std::string* InsideUnique::_internal_mutable_oid() {
  _has_bits_[0] |= 0x00000002u;
  return oid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* InsideUnique::release_oid() {
  // @@protoc_insertion_point(field_release:fantasybit.InsideUnique.oid)
  if (!_internal_has_oid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return oid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void InsideUnique::set_allocated_oid(std::string* oid) {
  if (oid != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  oid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), oid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.InsideUnique.oid)
}

// optional .fantasybit.OrderUnique order = 20;
inline bool InsideUnique::_internal_has_order() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || order_ != nullptr);
  return value;
}
inline bool InsideUnique::has_order() const {
  return _internal_has_order();
}
inline void InsideUnique::clear_order() {
  if (order_ != nullptr) order_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::fantasybit::OrderUnique& InsideUnique::_internal_order() const {
  const ::fantasybit::OrderUnique* p = order_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fantasybit::OrderUnique*>(
      &::fantasybit::_OrderUnique_default_instance_);
}
inline const ::fantasybit::OrderUnique& InsideUnique::order() const {
  // @@protoc_insertion_point(field_get:fantasybit.InsideUnique.order)
  return _internal_order();
}
inline void InsideUnique::unsafe_arena_set_allocated_order(
    ::fantasybit::OrderUnique* order) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(order_);
  }
  order_ = order;
  if (order) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fantasybit.InsideUnique.order)
}
inline ::fantasybit::OrderUnique* InsideUnique::release_order() {
  _has_bits_[0] &= ~0x00000008u;
  ::fantasybit::OrderUnique* temp = order_;
  order_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fantasybit::OrderUnique* InsideUnique::unsafe_arena_release_order() {
  // @@protoc_insertion_point(field_release:fantasybit.InsideUnique.order)
  _has_bits_[0] &= ~0x00000008u;
  ::fantasybit::OrderUnique* temp = order_;
  order_ = nullptr;
  return temp;
}
inline ::fantasybit::OrderUnique* InsideUnique::_internal_mutable_order() {
  _has_bits_[0] |= 0x00000008u;
  if (order_ == nullptr) {
    auto* p = CreateMaybeMessage<::fantasybit::OrderUnique>(GetArena());
    order_ = p;
  }
  return order_;
}
inline ::fantasybit::OrderUnique* InsideUnique::mutable_order() {
  // @@protoc_insertion_point(field_mutable:fantasybit.InsideUnique.order)
  return _internal_mutable_order();
}
inline void InsideUnique::set_allocated_order(::fantasybit::OrderUnique* order) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete order_;
  }
  if (order) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(order);
    if (message_arena != submessage_arena) {
      order = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, order, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  order_ = order;
  // @@protoc_insertion_point(field_set_allocated:fantasybit.InsideUnique.order)
}

// optional int32 size = 30;
inline bool InsideUnique::_internal_has_size() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool InsideUnique::has_size() const {
  return _internal_has_size();
}
inline void InsideUnique::clear_size() {
  size_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InsideUnique::_internal_size() const {
  return size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InsideUnique::size() const {
  // @@protoc_insertion_point(field_get:fantasybit.InsideUnique.size)
  return _internal_size();
}
inline void InsideUnique::_internal_set_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  size_ = value;
}
inline void InsideUnique::set_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:fantasybit.InsideUnique.size)
}

// -------------------------------------------------------------------

// TimeTransition

// optional .fantasybit.TimeTransition.Type type = 1;
inline bool TimeTransition::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TimeTransition::has_type() const {
  return _internal_has_type();
}
inline void TimeTransition::clear_type() {
  type_ = 2;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::fantasybit::TimeTransition_Type TimeTransition::_internal_type() const {
  return static_cast< ::fantasybit::TimeTransition_Type >(type_);
}
inline ::fantasybit::TimeTransition_Type TimeTransition::type() const {
  // @@protoc_insertion_point(field_get:fantasybit.TimeTransition.type)
  return _internal_type();
}
inline void TimeTransition::_internal_set_type(::fantasybit::TimeTransition_Type value) {
  assert(::fantasybit::TimeTransition_Type_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  type_ = value;
}
inline void TimeTransition::set_type(::fantasybit::TimeTransition_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:fantasybit.TimeTransition.type)
}

// optional uint32 season = 10;
inline bool TimeTransition::_internal_has_season() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TimeTransition::has_season() const {
  return _internal_has_season();
}
inline void TimeTransition::clear_season() {
  season_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TimeTransition::_internal_season() const {
  return season_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TimeTransition::season() const {
  // @@protoc_insertion_point(field_get:fantasybit.TimeTransition.season)
  return _internal_season();
}
inline void TimeTransition::_internal_set_season(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  season_ = value;
}
inline void TimeTransition::set_season(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_season(value);
  // @@protoc_insertion_point(field_set:fantasybit.TimeTransition.season)
}

// optional uint32 week = 20;
inline bool TimeTransition::_internal_has_week() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TimeTransition::has_week() const {
  return _internal_has_week();
}
inline void TimeTransition::clear_week() {
  week_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TimeTransition::_internal_week() const {
  return week_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TimeTransition::week() const {
  // @@protoc_insertion_point(field_get:fantasybit.TimeTransition.week)
  return _internal_week();
}
inline void TimeTransition::_internal_set_week(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  week_ = value;
}
inline void TimeTransition::set_week(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_week(value);
  // @@protoc_insertion_point(field_set:fantasybit.TimeTransition.week)
}

// -------------------------------------------------------------------

// Bitcoin_UTXO

// optional bytes txid = 10;
inline bool Bitcoin_UTXO::_internal_has_txid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Bitcoin_UTXO::has_txid() const {
  return _internal_has_txid();
}
inline void Bitcoin_UTXO::clear_txid() {
  txid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Bitcoin_UTXO::txid() const {
  // @@protoc_insertion_point(field_get:fantasybit.Bitcoin_UTXO.txid)
  return _internal_txid();
}
inline void Bitcoin_UTXO::set_txid(const std::string& value) {
  _internal_set_txid(value);
  // @@protoc_insertion_point(field_set:fantasybit.Bitcoin_UTXO.txid)
}
inline std::string* Bitcoin_UTXO::mutable_txid() {
  // @@protoc_insertion_point(field_mutable:fantasybit.Bitcoin_UTXO.txid)
  return _internal_mutable_txid();
}
inline const std::string& Bitcoin_UTXO::_internal_txid() const {
  return txid_.Get();
}
inline void Bitcoin_UTXO::_internal_set_txid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  txid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Bitcoin_UTXO::set_txid(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  txid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.Bitcoin_UTXO.txid)
}
inline void Bitcoin_UTXO::set_txid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  txid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.Bitcoin_UTXO.txid)
}
inline void Bitcoin_UTXO::set_txid(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  txid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.Bitcoin_UTXO.txid)
}
inline std::string* Bitcoin_UTXO::_internal_mutable_txid() {
  _has_bits_[0] |= 0x00000001u;
  return txid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Bitcoin_UTXO::release_txid() {
  // @@protoc_insertion_point(field_release:fantasybit.Bitcoin_UTXO.txid)
  if (!_internal_has_txid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return txid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Bitcoin_UTXO::set_allocated_txid(std::string* txid) {
  if (txid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  txid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), txid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.Bitcoin_UTXO.txid)
}

// optional uint32 tx_output_n = 20;
inline bool Bitcoin_UTXO::_internal_has_tx_output_n() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Bitcoin_UTXO::has_tx_output_n() const {
  return _internal_has_tx_output_n();
}
inline void Bitcoin_UTXO::clear_tx_output_n() {
  tx_output_n_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Bitcoin_UTXO::_internal_tx_output_n() const {
  return tx_output_n_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Bitcoin_UTXO::tx_output_n() const {
  // @@protoc_insertion_point(field_get:fantasybit.Bitcoin_UTXO.tx_output_n)
  return _internal_tx_output_n();
}
inline void Bitcoin_UTXO::_internal_set_tx_output_n(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  tx_output_n_ = value;
}
inline void Bitcoin_UTXO::set_tx_output_n(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_tx_output_n(value);
  // @@protoc_insertion_point(field_set:fantasybit.Bitcoin_UTXO.tx_output_n)
}

// optional uint64 in_value = 30;
inline bool Bitcoin_UTXO::_internal_has_in_value() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Bitcoin_UTXO::has_in_value() const {
  return _internal_has_in_value();
}
inline void Bitcoin_UTXO::clear_in_value() {
  in_value_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Bitcoin_UTXO::_internal_in_value() const {
  return in_value_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Bitcoin_UTXO::in_value() const {
  // @@protoc_insertion_point(field_get:fantasybit.Bitcoin_UTXO.in_value)
  return _internal_in_value();
}
inline void Bitcoin_UTXO::_internal_set_in_value(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  in_value_ = value;
}
inline void Bitcoin_UTXO::set_in_value(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_in_value(value);
  // @@protoc_insertion_point(field_set:fantasybit.Bitcoin_UTXO.in_value)
}

// optional bytes locking_script = 40;
inline bool Bitcoin_UTXO::_internal_has_locking_script() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Bitcoin_UTXO::has_locking_script() const {
  return _internal_has_locking_script();
}
inline void Bitcoin_UTXO::clear_locking_script() {
  locking_script_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Bitcoin_UTXO::locking_script() const {
  // @@protoc_insertion_point(field_get:fantasybit.Bitcoin_UTXO.locking_script)
  return _internal_locking_script();
}
inline void Bitcoin_UTXO::set_locking_script(const std::string& value) {
  _internal_set_locking_script(value);
  // @@protoc_insertion_point(field_set:fantasybit.Bitcoin_UTXO.locking_script)
}
inline std::string* Bitcoin_UTXO::mutable_locking_script() {
  // @@protoc_insertion_point(field_mutable:fantasybit.Bitcoin_UTXO.locking_script)
  return _internal_mutable_locking_script();
}
inline const std::string& Bitcoin_UTXO::_internal_locking_script() const {
  return locking_script_.Get();
}
inline void Bitcoin_UTXO::_internal_set_locking_script(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  locking_script_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Bitcoin_UTXO::set_locking_script(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  locking_script_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.Bitcoin_UTXO.locking_script)
}
inline void Bitcoin_UTXO::set_locking_script(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  locking_script_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.Bitcoin_UTXO.locking_script)
}
inline void Bitcoin_UTXO::set_locking_script(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  locking_script_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.Bitcoin_UTXO.locking_script)
}
inline std::string* Bitcoin_UTXO::_internal_mutable_locking_script() {
  _has_bits_[0] |= 0x00000002u;
  return locking_script_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Bitcoin_UTXO::release_locking_script() {
  // @@protoc_insertion_point(field_release:fantasybit.Bitcoin_UTXO.locking_script)
  if (!_internal_has_locking_script()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return locking_script_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Bitcoin_UTXO::set_allocated_locking_script(std::string* locking_script) {
  if (locking_script != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  locking_script_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), locking_script,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.Bitcoin_UTXO.locking_script)
}

// -------------------------------------------------------------------

// Bitcoin_UTXOS

// optional uint64 total_value = 10;
inline bool Bitcoin_UTXOS::_internal_has_total_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Bitcoin_UTXOS::has_total_value() const {
  return _internal_has_total_value();
}
inline void Bitcoin_UTXOS::clear_total_value() {
  total_value_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Bitcoin_UTXOS::_internal_total_value() const {
  return total_value_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Bitcoin_UTXOS::total_value() const {
  // @@protoc_insertion_point(field_get:fantasybit.Bitcoin_UTXOS.total_value)
  return _internal_total_value();
}
inline void Bitcoin_UTXOS::_internal_set_total_value(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  total_value_ = value;
}
inline void Bitcoin_UTXOS::set_total_value(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_total_value(value);
  // @@protoc_insertion_point(field_set:fantasybit.Bitcoin_UTXOS.total_value)
}

// repeated .fantasybit.Bitcoin_UTXO utxo = 20;
inline int Bitcoin_UTXOS::_internal_utxo_size() const {
  return utxo_.size();
}
inline int Bitcoin_UTXOS::utxo_size() const {
  return _internal_utxo_size();
}
inline void Bitcoin_UTXOS::clear_utxo() {
  utxo_.Clear();
}
inline ::fantasybit::Bitcoin_UTXO* Bitcoin_UTXOS::mutable_utxo(int index) {
  // @@protoc_insertion_point(field_mutable:fantasybit.Bitcoin_UTXOS.utxo)
  return utxo_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fantasybit::Bitcoin_UTXO >*
Bitcoin_UTXOS::mutable_utxo() {
  // @@protoc_insertion_point(field_mutable_list:fantasybit.Bitcoin_UTXOS.utxo)
  return &utxo_;
}
inline const ::fantasybit::Bitcoin_UTXO& Bitcoin_UTXOS::_internal_utxo(int index) const {
  return utxo_.Get(index);
}
inline const ::fantasybit::Bitcoin_UTXO& Bitcoin_UTXOS::utxo(int index) const {
  // @@protoc_insertion_point(field_get:fantasybit.Bitcoin_UTXOS.utxo)
  return _internal_utxo(index);
}
inline ::fantasybit::Bitcoin_UTXO* Bitcoin_UTXOS::_internal_add_utxo() {
  return utxo_.Add();
}
inline ::fantasybit::Bitcoin_UTXO* Bitcoin_UTXOS::add_utxo() {
  // @@protoc_insertion_point(field_add:fantasybit.Bitcoin_UTXOS.utxo)
  return _internal_add_utxo();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fantasybit::Bitcoin_UTXO >&
Bitcoin_UTXOS::utxo() const {
  // @@protoc_insertion_point(field_list:fantasybit.Bitcoin_UTXOS.utxo)
  return utxo_;
}

// -------------------------------------------------------------------

// SwapAsk

// optional uint64 satoshi_min = 10;
inline bool SwapAsk::_internal_has_satoshi_min() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SwapAsk::has_satoshi_min() const {
  return _internal_has_satoshi_min();
}
inline void SwapAsk::clear_satoshi_min() {
  satoshi_min_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SwapAsk::_internal_satoshi_min() const {
  return satoshi_min_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SwapAsk::satoshi_min() const {
  // @@protoc_insertion_point(field_get:fantasybit.SwapAsk.satoshi_min)
  return _internal_satoshi_min();
}
inline void SwapAsk::_internal_set_satoshi_min(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  satoshi_min_ = value;
}
inline void SwapAsk::set_satoshi_min(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_satoshi_min(value);
  // @@protoc_insertion_point(field_set:fantasybit.SwapAsk.satoshi_min)
}

// optional uint64 satoshi_max = 11;
inline bool SwapAsk::_internal_has_satoshi_max() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SwapAsk::has_satoshi_max() const {
  return _internal_has_satoshi_max();
}
inline void SwapAsk::clear_satoshi_max() {
  satoshi_max_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SwapAsk::_internal_satoshi_max() const {
  return satoshi_max_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SwapAsk::satoshi_max() const {
  // @@protoc_insertion_point(field_get:fantasybit.SwapAsk.satoshi_max)
  return _internal_satoshi_max();
}
inline void SwapAsk::_internal_set_satoshi_max(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  satoshi_max_ = value;
}
inline void SwapAsk::set_satoshi_max(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_satoshi_max(value);
  // @@protoc_insertion_point(field_set:fantasybit.SwapAsk.satoshi_max)
}

// optional uint64 rate = 20;
inline bool SwapAsk::_internal_has_rate() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SwapAsk::has_rate() const {
  return _internal_has_rate();
}
inline void SwapAsk::clear_rate() {
  rate_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SwapAsk::_internal_rate() const {
  return rate_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SwapAsk::rate() const {
  // @@protoc_insertion_point(field_get:fantasybit.SwapAsk.rate)
  return _internal_rate();
}
inline void SwapAsk::_internal_set_rate(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  rate_ = value;
}
inline void SwapAsk::set_rate(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_rate(value);
  // @@protoc_insertion_point(field_set:fantasybit.SwapAsk.rate)
}

// optional uint64 fb_qty = 30;
inline bool SwapAsk::_internal_has_fb_qty() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SwapAsk::has_fb_qty() const {
  return _internal_has_fb_qty();
}
inline void SwapAsk::clear_fb_qty() {
  fb_qty_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SwapAsk::_internal_fb_qty() const {
  return fb_qty_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SwapAsk::fb_qty() const {
  // @@protoc_insertion_point(field_get:fantasybit.SwapAsk.fb_qty)
  return _internal_fb_qty();
}
inline void SwapAsk::_internal_set_fb_qty(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  fb_qty_ = value;
}
inline void SwapAsk::set_fb_qty(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_fb_qty(value);
  // @@protoc_insertion_point(field_set:fantasybit.SwapAsk.fb_qty)
}

// -------------------------------------------------------------------

// SwapBid

// optional uint64 satoshi_min = 10;
inline bool SwapBid::_internal_has_satoshi_min() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SwapBid::has_satoshi_min() const {
  return _internal_has_satoshi_min();
}
inline void SwapBid::clear_satoshi_min() {
  satoshi_min_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SwapBid::_internal_satoshi_min() const {
  return satoshi_min_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SwapBid::satoshi_min() const {
  // @@protoc_insertion_point(field_get:fantasybit.SwapBid.satoshi_min)
  return _internal_satoshi_min();
}
inline void SwapBid::_internal_set_satoshi_min(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  satoshi_min_ = value;
}
inline void SwapBid::set_satoshi_min(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_satoshi_min(value);
  // @@protoc_insertion_point(field_set:fantasybit.SwapBid.satoshi_min)
}

// optional uint64 satoshi_max = 11;
inline bool SwapBid::_internal_has_satoshi_max() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool SwapBid::has_satoshi_max() const {
  return _internal_has_satoshi_max();
}
inline void SwapBid::clear_satoshi_max() {
  satoshi_max_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SwapBid::_internal_satoshi_max() const {
  return satoshi_max_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SwapBid::satoshi_max() const {
  // @@protoc_insertion_point(field_get:fantasybit.SwapBid.satoshi_max)
  return _internal_satoshi_max();
}
inline void SwapBid::_internal_set_satoshi_max(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  satoshi_max_ = value;
}
inline void SwapBid::set_satoshi_max(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_satoshi_max(value);
  // @@protoc_insertion_point(field_set:fantasybit.SwapBid.satoshi_max)
}

// optional uint64 rate = 20;
inline bool SwapBid::_internal_has_rate() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool SwapBid::has_rate() const {
  return _internal_has_rate();
}
inline void SwapBid::clear_rate() {
  rate_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SwapBid::_internal_rate() const {
  return rate_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SwapBid::rate() const {
  // @@protoc_insertion_point(field_get:fantasybit.SwapBid.rate)
  return _internal_rate();
}
inline void SwapBid::_internal_set_rate(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000040u;
  rate_ = value;
}
inline void SwapBid::set_rate(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_rate(value);
  // @@protoc_insertion_point(field_set:fantasybit.SwapBid.rate)
}

// optional .fantasybit.Bitcoin_UTXOS utxos = 30;
inline bool SwapBid::_internal_has_utxos() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || utxos_ != nullptr);
  return value;
}
inline bool SwapBid::has_utxos() const {
  return _internal_has_utxos();
}
inline void SwapBid::clear_utxos() {
  if (utxos_ != nullptr) utxos_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::fantasybit::Bitcoin_UTXOS& SwapBid::_internal_utxos() const {
  const ::fantasybit::Bitcoin_UTXOS* p = utxos_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fantasybit::Bitcoin_UTXOS*>(
      &::fantasybit::_Bitcoin_UTXOS_default_instance_);
}
inline const ::fantasybit::Bitcoin_UTXOS& SwapBid::utxos() const {
  // @@protoc_insertion_point(field_get:fantasybit.SwapBid.utxos)
  return _internal_utxos();
}
inline void SwapBid::unsafe_arena_set_allocated_utxos(
    ::fantasybit::Bitcoin_UTXOS* utxos) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(utxos_);
  }
  utxos_ = utxos;
  if (utxos) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fantasybit.SwapBid.utxos)
}
inline ::fantasybit::Bitcoin_UTXOS* SwapBid::release_utxos() {
  _has_bits_[0] &= ~0x00000004u;
  ::fantasybit::Bitcoin_UTXOS* temp = utxos_;
  utxos_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fantasybit::Bitcoin_UTXOS* SwapBid::unsafe_arena_release_utxos() {
  // @@protoc_insertion_point(field_release:fantasybit.SwapBid.utxos)
  _has_bits_[0] &= ~0x00000004u;
  ::fantasybit::Bitcoin_UTXOS* temp = utxos_;
  utxos_ = nullptr;
  return temp;
}
inline ::fantasybit::Bitcoin_UTXOS* SwapBid::_internal_mutable_utxos() {
  _has_bits_[0] |= 0x00000004u;
  if (utxos_ == nullptr) {
    auto* p = CreateMaybeMessage<::fantasybit::Bitcoin_UTXOS>(GetArena());
    utxos_ = p;
  }
  return utxos_;
}
inline ::fantasybit::Bitcoin_UTXOS* SwapBid::mutable_utxos() {
  // @@protoc_insertion_point(field_mutable:fantasybit.SwapBid.utxos)
  return _internal_mutable_utxos();
}
inline void SwapBid::set_allocated_utxos(::fantasybit::Bitcoin_UTXOS* utxos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete utxos_;
  }
  if (utxos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(utxos);
    if (message_arena != submessage_arena) {
      utxos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, utxos, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  utxos_ = utxos;
  // @@protoc_insertion_point(field_set_allocated:fantasybit.SwapBid.utxos)
}

// optional bytes change_addr = 40;
inline bool SwapBid::_internal_has_change_addr() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SwapBid::has_change_addr() const {
  return _internal_has_change_addr();
}
inline void SwapBid::clear_change_addr() {
  change_addr_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SwapBid::change_addr() const {
  // @@protoc_insertion_point(field_get:fantasybit.SwapBid.change_addr)
  return _internal_change_addr();
}
inline void SwapBid::set_change_addr(const std::string& value) {
  _internal_set_change_addr(value);
  // @@protoc_insertion_point(field_set:fantasybit.SwapBid.change_addr)
}
inline std::string* SwapBid::mutable_change_addr() {
  // @@protoc_insertion_point(field_mutable:fantasybit.SwapBid.change_addr)
  return _internal_mutable_change_addr();
}
inline const std::string& SwapBid::_internal_change_addr() const {
  return change_addr_.Get();
}
inline void SwapBid::_internal_set_change_addr(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  change_addr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SwapBid::set_change_addr(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  change_addr_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.SwapBid.change_addr)
}
inline void SwapBid::set_change_addr(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  change_addr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.SwapBid.change_addr)
}
inline void SwapBid::set_change_addr(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  change_addr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.SwapBid.change_addr)
}
inline std::string* SwapBid::_internal_mutable_change_addr() {
  _has_bits_[0] |= 0x00000001u;
  return change_addr_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SwapBid::release_change_addr() {
  // @@protoc_insertion_point(field_release:fantasybit.SwapBid.change_addr)
  if (!_internal_has_change_addr()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return change_addr_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SwapBid::set_allocated_change_addr(std::string* change_addr) {
  if (change_addr != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  change_addr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), change_addr,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.SwapBid.change_addr)
}

// optional .fantasybit.SwapAsk this_offer = 50;
inline bool SwapBid::_internal_has_this_offer() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || this_offer_ != nullptr);
  return value;
}
inline bool SwapBid::has_this_offer() const {
  return _internal_has_this_offer();
}
inline void SwapBid::clear_this_offer() {
  if (this_offer_ != nullptr) this_offer_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::fantasybit::SwapAsk& SwapBid::_internal_this_offer() const {
  const ::fantasybit::SwapAsk* p = this_offer_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fantasybit::SwapAsk*>(
      &::fantasybit::_SwapAsk_default_instance_);
}
inline const ::fantasybit::SwapAsk& SwapBid::this_offer() const {
  // @@protoc_insertion_point(field_get:fantasybit.SwapBid.this_offer)
  return _internal_this_offer();
}
inline void SwapBid::unsafe_arena_set_allocated_this_offer(
    ::fantasybit::SwapAsk* this_offer) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(this_offer_);
  }
  this_offer_ = this_offer;
  if (this_offer) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fantasybit.SwapBid.this_offer)
}
inline ::fantasybit::SwapAsk* SwapBid::release_this_offer() {
  _has_bits_[0] &= ~0x00000008u;
  ::fantasybit::SwapAsk* temp = this_offer_;
  this_offer_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fantasybit::SwapAsk* SwapBid::unsafe_arena_release_this_offer() {
  // @@protoc_insertion_point(field_release:fantasybit.SwapBid.this_offer)
  _has_bits_[0] &= ~0x00000008u;
  ::fantasybit::SwapAsk* temp = this_offer_;
  this_offer_ = nullptr;
  return temp;
}
inline ::fantasybit::SwapAsk* SwapBid::_internal_mutable_this_offer() {
  _has_bits_[0] |= 0x00000008u;
  if (this_offer_ == nullptr) {
    auto* p = CreateMaybeMessage<::fantasybit::SwapAsk>(GetArena());
    this_offer_ = p;
  }
  return this_offer_;
}
inline ::fantasybit::SwapAsk* SwapBid::mutable_this_offer() {
  // @@protoc_insertion_point(field_mutable:fantasybit.SwapBid.this_offer)
  return _internal_mutable_this_offer();
}
inline void SwapBid::set_allocated_this_offer(::fantasybit::SwapAsk* this_offer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete this_offer_;
  }
  if (this_offer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(this_offer);
    if (message_arena != submessage_arena) {
      this_offer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, this_offer, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  this_offer_ = this_offer;
  // @@protoc_insertion_point(field_set_allocated:fantasybit.SwapBid.this_offer)
}

// optional string counteroffer = 60;
inline bool SwapBid::_internal_has_counteroffer() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SwapBid::has_counteroffer() const {
  return _internal_has_counteroffer();
}
inline void SwapBid::clear_counteroffer() {
  counteroffer_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SwapBid::counteroffer() const {
  // @@protoc_insertion_point(field_get:fantasybit.SwapBid.counteroffer)
  return _internal_counteroffer();
}
inline void SwapBid::set_counteroffer(const std::string& value) {
  _internal_set_counteroffer(value);
  // @@protoc_insertion_point(field_set:fantasybit.SwapBid.counteroffer)
}
inline std::string* SwapBid::mutable_counteroffer() {
  // @@protoc_insertion_point(field_mutable:fantasybit.SwapBid.counteroffer)
  return _internal_mutable_counteroffer();
}
inline const std::string& SwapBid::_internal_counteroffer() const {
  return counteroffer_.Get();
}
inline void SwapBid::_internal_set_counteroffer(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  counteroffer_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SwapBid::set_counteroffer(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  counteroffer_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.SwapBid.counteroffer)
}
inline void SwapBid::set_counteroffer(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  counteroffer_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.SwapBid.counteroffer)
}
inline void SwapBid::set_counteroffer(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  counteroffer_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.SwapBid.counteroffer)
}
inline std::string* SwapBid::_internal_mutable_counteroffer() {
  _has_bits_[0] |= 0x00000002u;
  return counteroffer_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SwapBid::release_counteroffer() {
  // @@protoc_insertion_point(field_release:fantasybit.SwapBid.counteroffer)
  if (!_internal_has_counteroffer()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return counteroffer_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SwapBid::set_allocated_counteroffer(std::string* counteroffer) {
  if (counteroffer != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  counteroffer_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), counteroffer,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.SwapBid.counteroffer)
}

// -------------------------------------------------------------------

// SwapFill

// optional .fantasybit.SwapBid swapbid = 10;
inline bool SwapFill::_internal_has_swapbid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || swapbid_ != nullptr);
  return value;
}
inline bool SwapFill::has_swapbid() const {
  return _internal_has_swapbid();
}
inline void SwapFill::clear_swapbid() {
  if (swapbid_ != nullptr) swapbid_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::fantasybit::SwapBid& SwapFill::_internal_swapbid() const {
  const ::fantasybit::SwapBid* p = swapbid_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fantasybit::SwapBid*>(
      &::fantasybit::_SwapBid_default_instance_);
}
inline const ::fantasybit::SwapBid& SwapFill::swapbid() const {
  // @@protoc_insertion_point(field_get:fantasybit.SwapFill.swapbid)
  return _internal_swapbid();
}
inline void SwapFill::unsafe_arena_set_allocated_swapbid(
    ::fantasybit::SwapBid* swapbid) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(swapbid_);
  }
  swapbid_ = swapbid;
  if (swapbid) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fantasybit.SwapFill.swapbid)
}
inline ::fantasybit::SwapBid* SwapFill::release_swapbid() {
  _has_bits_[0] &= ~0x00000004u;
  ::fantasybit::SwapBid* temp = swapbid_;
  swapbid_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fantasybit::SwapBid* SwapFill::unsafe_arena_release_swapbid() {
  // @@protoc_insertion_point(field_release:fantasybit.SwapFill.swapbid)
  _has_bits_[0] &= ~0x00000004u;
  ::fantasybit::SwapBid* temp = swapbid_;
  swapbid_ = nullptr;
  return temp;
}
inline ::fantasybit::SwapBid* SwapFill::_internal_mutable_swapbid() {
  _has_bits_[0] |= 0x00000004u;
  if (swapbid_ == nullptr) {
    auto* p = CreateMaybeMessage<::fantasybit::SwapBid>(GetArena());
    swapbid_ = p;
  }
  return swapbid_;
}
inline ::fantasybit::SwapBid* SwapFill::mutable_swapbid() {
  // @@protoc_insertion_point(field_mutable:fantasybit.SwapFill.swapbid)
  return _internal_mutable_swapbid();
}
inline void SwapFill::set_allocated_swapbid(::fantasybit::SwapBid* swapbid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete swapbid_;
  }
  if (swapbid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(swapbid);
    if (message_arena != submessage_arena) {
      swapbid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, swapbid, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  swapbid_ = swapbid;
  // @@protoc_insertion_point(field_set_allocated:fantasybit.SwapFill.swapbid)
}

// optional bytes hash_to_sign = 20;
inline bool SwapFill::_internal_has_hash_to_sign() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SwapFill::has_hash_to_sign() const {
  return _internal_has_hash_to_sign();
}
inline void SwapFill::clear_hash_to_sign() {
  hash_to_sign_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SwapFill::hash_to_sign() const {
  // @@protoc_insertion_point(field_get:fantasybit.SwapFill.hash_to_sign)
  return _internal_hash_to_sign();
}
inline void SwapFill::set_hash_to_sign(const std::string& value) {
  _internal_set_hash_to_sign(value);
  // @@protoc_insertion_point(field_set:fantasybit.SwapFill.hash_to_sign)
}
inline std::string* SwapFill::mutable_hash_to_sign() {
  // @@protoc_insertion_point(field_mutable:fantasybit.SwapFill.hash_to_sign)
  return _internal_mutable_hash_to_sign();
}
inline const std::string& SwapFill::_internal_hash_to_sign() const {
  return hash_to_sign_.Get();
}
inline void SwapFill::_internal_set_hash_to_sign(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  hash_to_sign_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SwapFill::set_hash_to_sign(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  hash_to_sign_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.SwapFill.hash_to_sign)
}
inline void SwapFill::set_hash_to_sign(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  hash_to_sign_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.SwapFill.hash_to_sign)
}
inline void SwapFill::set_hash_to_sign(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  hash_to_sign_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.SwapFill.hash_to_sign)
}
inline std::string* SwapFill::_internal_mutable_hash_to_sign() {
  _has_bits_[0] |= 0x00000001u;
  return hash_to_sign_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SwapFill::release_hash_to_sign() {
  // @@protoc_insertion_point(field_release:fantasybit.SwapFill.hash_to_sign)
  if (!_internal_has_hash_to_sign()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return hash_to_sign_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SwapFill::set_allocated_hash_to_sign(std::string* hash_to_sign) {
  if (hash_to_sign != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  hash_to_sign_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hash_to_sign,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.SwapFill.hash_to_sign)
}

// optional uint64 satoshi_fee = 30;
inline bool SwapFill::_internal_has_satoshi_fee() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SwapFill::has_satoshi_fee() const {
  return _internal_has_satoshi_fee();
}
inline void SwapFill::clear_satoshi_fee() {
  satoshi_fee_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SwapFill::_internal_satoshi_fee() const {
  return satoshi_fee_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SwapFill::satoshi_fee() const {
  // @@protoc_insertion_point(field_get:fantasybit.SwapFill.satoshi_fee)
  return _internal_satoshi_fee();
}
inline void SwapFill::_internal_set_satoshi_fee(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  satoshi_fee_ = value;
}
inline void SwapFill::set_satoshi_fee(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_satoshi_fee(value);
  // @@protoc_insertion_point(field_set:fantasybit.SwapFill.satoshi_fee)
}

// optional uint64 fb_qty = 40;
inline bool SwapFill::_internal_has_fb_qty() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SwapFill::has_fb_qty() const {
  return _internal_has_fb_qty();
}
inline void SwapFill::clear_fb_qty() {
  fb_qty_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SwapFill::_internal_fb_qty() const {
  return fb_qty_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SwapFill::fb_qty() const {
  // @@protoc_insertion_point(field_get:fantasybit.SwapFill.fb_qty)
  return _internal_fb_qty();
}
inline void SwapFill::_internal_set_fb_qty(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  fb_qty_ = value;
}
inline void SwapFill::set_fb_qty(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_fb_qty(value);
  // @@protoc_insertion_point(field_set:fantasybit.SwapFill.fb_qty)
}

// optional string counterparty = 50;
inline bool SwapFill::_internal_has_counterparty() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SwapFill::has_counterparty() const {
  return _internal_has_counterparty();
}
inline void SwapFill::clear_counterparty() {
  counterparty_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SwapFill::counterparty() const {
  // @@protoc_insertion_point(field_get:fantasybit.SwapFill.counterparty)
  return _internal_counterparty();
}
inline void SwapFill::set_counterparty(const std::string& value) {
  _internal_set_counterparty(value);
  // @@protoc_insertion_point(field_set:fantasybit.SwapFill.counterparty)
}
inline std::string* SwapFill::mutable_counterparty() {
  // @@protoc_insertion_point(field_mutable:fantasybit.SwapFill.counterparty)
  return _internal_mutable_counterparty();
}
inline const std::string& SwapFill::_internal_counterparty() const {
  return counterparty_.Get();
}
inline void SwapFill::_internal_set_counterparty(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  counterparty_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SwapFill::set_counterparty(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  counterparty_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.SwapFill.counterparty)
}
inline void SwapFill::set_counterparty(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  counterparty_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.SwapFill.counterparty)
}
inline void SwapFill::set_counterparty(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  counterparty_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.SwapFill.counterparty)
}
inline std::string* SwapFill::_internal_mutable_counterparty() {
  _has_bits_[0] |= 0x00000002u;
  return counterparty_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SwapFill::release_counterparty() {
  // @@protoc_insertion_point(field_release:fantasybit.SwapFill.counterparty)
  if (!_internal_has_counterparty()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return counterparty_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SwapFill::set_allocated_counterparty(std::string* counterparty) {
  if (counterparty != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  counterparty_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), counterparty,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.SwapFill.counterparty)
}

// -------------------------------------------------------------------

// SwapSent

// optional .fantasybit.SwapFill swapfill = 10;
inline bool SwapSent::_internal_has_swapfill() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || swapfill_ != nullptr);
  return value;
}
inline bool SwapSent::has_swapfill() const {
  return _internal_has_swapfill();
}
inline void SwapSent::clear_swapfill() {
  if (swapfill_ != nullptr) swapfill_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::fantasybit::SwapFill& SwapSent::_internal_swapfill() const {
  const ::fantasybit::SwapFill* p = swapfill_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fantasybit::SwapFill*>(
      &::fantasybit::_SwapFill_default_instance_);
}
inline const ::fantasybit::SwapFill& SwapSent::swapfill() const {
  // @@protoc_insertion_point(field_get:fantasybit.SwapSent.swapfill)
  return _internal_swapfill();
}
inline void SwapSent::unsafe_arena_set_allocated_swapfill(
    ::fantasybit::SwapFill* swapfill) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(swapfill_);
  }
  swapfill_ = swapfill;
  if (swapfill) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fantasybit.SwapSent.swapfill)
}
inline ::fantasybit::SwapFill* SwapSent::release_swapfill() {
  _has_bits_[0] &= ~0x00000002u;
  ::fantasybit::SwapFill* temp = swapfill_;
  swapfill_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fantasybit::SwapFill* SwapSent::unsafe_arena_release_swapfill() {
  // @@protoc_insertion_point(field_release:fantasybit.SwapSent.swapfill)
  _has_bits_[0] &= ~0x00000002u;
  ::fantasybit::SwapFill* temp = swapfill_;
  swapfill_ = nullptr;
  return temp;
}
inline ::fantasybit::SwapFill* SwapSent::_internal_mutable_swapfill() {
  _has_bits_[0] |= 0x00000002u;
  if (swapfill_ == nullptr) {
    auto* p = CreateMaybeMessage<::fantasybit::SwapFill>(GetArena());
    swapfill_ = p;
  }
  return swapfill_;
}
inline ::fantasybit::SwapFill* SwapSent::mutable_swapfill() {
  // @@protoc_insertion_point(field_mutable:fantasybit.SwapSent.swapfill)
  return _internal_mutable_swapfill();
}
inline void SwapSent::set_allocated_swapfill(::fantasybit::SwapFill* swapfill) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete swapfill_;
  }
  if (swapfill) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(swapfill);
    if (message_arena != submessage_arena) {
      swapfill = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, swapfill, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  swapfill_ = swapfill;
  // @@protoc_insertion_point(field_set_allocated:fantasybit.SwapSent.swapfill)
}

// optional bytes sig = 20;
inline bool SwapSent::_internal_has_sig() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SwapSent::has_sig() const {
  return _internal_has_sig();
}
inline void SwapSent::clear_sig() {
  sig_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SwapSent::sig() const {
  // @@protoc_insertion_point(field_get:fantasybit.SwapSent.sig)
  return _internal_sig();
}
inline void SwapSent::set_sig(const std::string& value) {
  _internal_set_sig(value);
  // @@protoc_insertion_point(field_set:fantasybit.SwapSent.sig)
}
inline std::string* SwapSent::mutable_sig() {
  // @@protoc_insertion_point(field_mutable:fantasybit.SwapSent.sig)
  return _internal_mutable_sig();
}
inline const std::string& SwapSent::_internal_sig() const {
  return sig_.Get();
}
inline void SwapSent::_internal_set_sig(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  sig_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SwapSent::set_sig(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  sig_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.SwapSent.sig)
}
inline void SwapSent::set_sig(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  sig_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.SwapSent.sig)
}
inline void SwapSent::set_sig(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  sig_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.SwapSent.sig)
}
inline std::string* SwapSent::_internal_mutable_sig() {
  _has_bits_[0] |= 0x00000001u;
  return sig_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SwapSent::release_sig() {
  // @@protoc_insertion_point(field_release:fantasybit.SwapSent.sig)
  if (!_internal_has_sig()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return sig_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SwapSent::set_allocated_sig(std::string* sig) {
  if (sig != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  sig_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sig,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.SwapSent.sig)
}

// -------------------------------------------------------------------

// ProofOfDoubleSpend

// optional .fantasybit.SwapSent swapsent = 10;
inline bool ProofOfDoubleSpend::_internal_has_swapsent() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || swapsent_ != nullptr);
  return value;
}
inline bool ProofOfDoubleSpend::has_swapsent() const {
  return _internal_has_swapsent();
}
inline void ProofOfDoubleSpend::clear_swapsent() {
  if (swapsent_ != nullptr) swapsent_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::fantasybit::SwapSent& ProofOfDoubleSpend::_internal_swapsent() const {
  const ::fantasybit::SwapSent* p = swapsent_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fantasybit::SwapSent*>(
      &::fantasybit::_SwapSent_default_instance_);
}
inline const ::fantasybit::SwapSent& ProofOfDoubleSpend::swapsent() const {
  // @@protoc_insertion_point(field_get:fantasybit.ProofOfDoubleSpend.swapsent)
  return _internal_swapsent();
}
inline void ProofOfDoubleSpend::unsafe_arena_set_allocated_swapsent(
    ::fantasybit::SwapSent* swapsent) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(swapsent_);
  }
  swapsent_ = swapsent;
  if (swapsent) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fantasybit.ProofOfDoubleSpend.swapsent)
}
inline ::fantasybit::SwapSent* ProofOfDoubleSpend::release_swapsent() {
  _has_bits_[0] &= ~0x00000008u;
  ::fantasybit::SwapSent* temp = swapsent_;
  swapsent_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fantasybit::SwapSent* ProofOfDoubleSpend::unsafe_arena_release_swapsent() {
  // @@protoc_insertion_point(field_release:fantasybit.ProofOfDoubleSpend.swapsent)
  _has_bits_[0] &= ~0x00000008u;
  ::fantasybit::SwapSent* temp = swapsent_;
  swapsent_ = nullptr;
  return temp;
}
inline ::fantasybit::SwapSent* ProofOfDoubleSpend::_internal_mutable_swapsent() {
  _has_bits_[0] |= 0x00000008u;
  if (swapsent_ == nullptr) {
    auto* p = CreateMaybeMessage<::fantasybit::SwapSent>(GetArena());
    swapsent_ = p;
  }
  return swapsent_;
}
inline ::fantasybit::SwapSent* ProofOfDoubleSpend::mutable_swapsent() {
  // @@protoc_insertion_point(field_mutable:fantasybit.ProofOfDoubleSpend.swapsent)
  return _internal_mutable_swapsent();
}
inline void ProofOfDoubleSpend::set_allocated_swapsent(::fantasybit::SwapSent* swapsent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete swapsent_;
  }
  if (swapsent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(swapsent);
    if (message_arena != submessage_arena) {
      swapsent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, swapsent, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  swapsent_ = swapsent;
  // @@protoc_insertion_point(field_set_allocated:fantasybit.ProofOfDoubleSpend.swapsent)
}

// optional .fantasybit.Bitcoin_UTXO utxo = 20;
inline bool ProofOfDoubleSpend::_internal_has_utxo() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || utxo_ != nullptr);
  return value;
}
inline bool ProofOfDoubleSpend::has_utxo() const {
  return _internal_has_utxo();
}
inline void ProofOfDoubleSpend::clear_utxo() {
  if (utxo_ != nullptr) utxo_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::fantasybit::Bitcoin_UTXO& ProofOfDoubleSpend::_internal_utxo() const {
  const ::fantasybit::Bitcoin_UTXO* p = utxo_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fantasybit::Bitcoin_UTXO*>(
      &::fantasybit::_Bitcoin_UTXO_default_instance_);
}
inline const ::fantasybit::Bitcoin_UTXO& ProofOfDoubleSpend::utxo() const {
  // @@protoc_insertion_point(field_get:fantasybit.ProofOfDoubleSpend.utxo)
  return _internal_utxo();
}
inline void ProofOfDoubleSpend::unsafe_arena_set_allocated_utxo(
    ::fantasybit::Bitcoin_UTXO* utxo) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(utxo_);
  }
  utxo_ = utxo;
  if (utxo) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fantasybit.ProofOfDoubleSpend.utxo)
}
inline ::fantasybit::Bitcoin_UTXO* ProofOfDoubleSpend::release_utxo() {
  _has_bits_[0] &= ~0x00000010u;
  ::fantasybit::Bitcoin_UTXO* temp = utxo_;
  utxo_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fantasybit::Bitcoin_UTXO* ProofOfDoubleSpend::unsafe_arena_release_utxo() {
  // @@protoc_insertion_point(field_release:fantasybit.ProofOfDoubleSpend.utxo)
  _has_bits_[0] &= ~0x00000010u;
  ::fantasybit::Bitcoin_UTXO* temp = utxo_;
  utxo_ = nullptr;
  return temp;
}
inline ::fantasybit::Bitcoin_UTXO* ProofOfDoubleSpend::_internal_mutable_utxo() {
  _has_bits_[0] |= 0x00000010u;
  if (utxo_ == nullptr) {
    auto* p = CreateMaybeMessage<::fantasybit::Bitcoin_UTXO>(GetArena());
    utxo_ = p;
  }
  return utxo_;
}
inline ::fantasybit::Bitcoin_UTXO* ProofOfDoubleSpend::mutable_utxo() {
  // @@protoc_insertion_point(field_mutable:fantasybit.ProofOfDoubleSpend.utxo)
  return _internal_mutable_utxo();
}
inline void ProofOfDoubleSpend::set_allocated_utxo(::fantasybit::Bitcoin_UTXO* utxo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete utxo_;
  }
  if (utxo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(utxo);
    if (message_arena != submessage_arena) {
      utxo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, utxo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  utxo_ = utxo;
  // @@protoc_insertion_point(field_set_allocated:fantasybit.ProofOfDoubleSpend.utxo)
}

// optional bytes pre = 30;
inline bool ProofOfDoubleSpend::_internal_has_pre() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ProofOfDoubleSpend::has_pre() const {
  return _internal_has_pre();
}
inline void ProofOfDoubleSpend::clear_pre() {
  pre_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ProofOfDoubleSpend::pre() const {
  // @@protoc_insertion_point(field_get:fantasybit.ProofOfDoubleSpend.pre)
  return _internal_pre();
}
inline void ProofOfDoubleSpend::set_pre(const std::string& value) {
  _internal_set_pre(value);
  // @@protoc_insertion_point(field_set:fantasybit.ProofOfDoubleSpend.pre)
}
inline std::string* ProofOfDoubleSpend::mutable_pre() {
  // @@protoc_insertion_point(field_mutable:fantasybit.ProofOfDoubleSpend.pre)
  return _internal_mutable_pre();
}
inline const std::string& ProofOfDoubleSpend::_internal_pre() const {
  return pre_.Get();
}
inline void ProofOfDoubleSpend::_internal_set_pre(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  pre_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ProofOfDoubleSpend::set_pre(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  pre_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.ProofOfDoubleSpend.pre)
}
inline void ProofOfDoubleSpend::set_pre(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  pre_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.ProofOfDoubleSpend.pre)
}
inline void ProofOfDoubleSpend::set_pre(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  pre_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.ProofOfDoubleSpend.pre)
}
inline std::string* ProofOfDoubleSpend::_internal_mutable_pre() {
  _has_bits_[0] |= 0x00000001u;
  return pre_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ProofOfDoubleSpend::release_pre() {
  // @@protoc_insertion_point(field_release:fantasybit.ProofOfDoubleSpend.pre)
  if (!_internal_has_pre()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return pre_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ProofOfDoubleSpend::set_allocated_pre(std::string* pre) {
  if (pre != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  pre_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pre,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.ProofOfDoubleSpend.pre)
}

// optional bytes post = 40;
inline bool ProofOfDoubleSpend::_internal_has_post() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ProofOfDoubleSpend::has_post() const {
  return _internal_has_post();
}
inline void ProofOfDoubleSpend::clear_post() {
  post_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ProofOfDoubleSpend::post() const {
  // @@protoc_insertion_point(field_get:fantasybit.ProofOfDoubleSpend.post)
  return _internal_post();
}
inline void ProofOfDoubleSpend::set_post(const std::string& value) {
  _internal_set_post(value);
  // @@protoc_insertion_point(field_set:fantasybit.ProofOfDoubleSpend.post)
}
inline std::string* ProofOfDoubleSpend::mutable_post() {
  // @@protoc_insertion_point(field_mutable:fantasybit.ProofOfDoubleSpend.post)
  return _internal_mutable_post();
}
inline const std::string& ProofOfDoubleSpend::_internal_post() const {
  return post_.Get();
}
inline void ProofOfDoubleSpend::_internal_set_post(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  post_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ProofOfDoubleSpend::set_post(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  post_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.ProofOfDoubleSpend.post)
}
inline void ProofOfDoubleSpend::set_post(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  post_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.ProofOfDoubleSpend.post)
}
inline void ProofOfDoubleSpend::set_post(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  post_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.ProofOfDoubleSpend.post)
}
inline std::string* ProofOfDoubleSpend::_internal_mutable_post() {
  _has_bits_[0] |= 0x00000002u;
  return post_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ProofOfDoubleSpend::release_post() {
  // @@protoc_insertion_point(field_release:fantasybit.ProofOfDoubleSpend.post)
  if (!_internal_has_post()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return post_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ProofOfDoubleSpend::set_allocated_post(std::string* post) {
  if (post != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  post_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), post,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.ProofOfDoubleSpend.post)
}

// optional bytes sig = 50;
inline bool ProofOfDoubleSpend::_internal_has_sig() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ProofOfDoubleSpend::has_sig() const {
  return _internal_has_sig();
}
inline void ProofOfDoubleSpend::clear_sig() {
  sig_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ProofOfDoubleSpend::sig() const {
  // @@protoc_insertion_point(field_get:fantasybit.ProofOfDoubleSpend.sig)
  return _internal_sig();
}
inline void ProofOfDoubleSpend::set_sig(const std::string& value) {
  _internal_set_sig(value);
  // @@protoc_insertion_point(field_set:fantasybit.ProofOfDoubleSpend.sig)
}
inline std::string* ProofOfDoubleSpend::mutable_sig() {
  // @@protoc_insertion_point(field_mutable:fantasybit.ProofOfDoubleSpend.sig)
  return _internal_mutable_sig();
}
inline const std::string& ProofOfDoubleSpend::_internal_sig() const {
  return sig_.Get();
}
inline void ProofOfDoubleSpend::_internal_set_sig(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  sig_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ProofOfDoubleSpend::set_sig(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  sig_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.ProofOfDoubleSpend.sig)
}
inline void ProofOfDoubleSpend::set_sig(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  sig_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.ProofOfDoubleSpend.sig)
}
inline void ProofOfDoubleSpend::set_sig(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  sig_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.ProofOfDoubleSpend.sig)
}
inline std::string* ProofOfDoubleSpend::_internal_mutable_sig() {
  _has_bits_[0] |= 0x00000004u;
  return sig_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ProofOfDoubleSpend::release_sig() {
  // @@protoc_insertion_point(field_release:fantasybit.ProofOfDoubleSpend.sig)
  if (!_internal_has_sig()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return sig_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ProofOfDoubleSpend::set_allocated_sig(std::string* sig) {
  if (sig != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  sig_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sig,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.ProofOfDoubleSpend.sig)
}

// -------------------------------------------------------------------

// SwapSentAck

// optional .fantasybit.SwapSent swapsent = 10;
inline bool SwapSentAck::_internal_has_swapsent() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || swapsent_ != nullptr);
  return value;
}
inline bool SwapSentAck::has_swapsent() const {
  return _internal_has_swapsent();
}
inline void SwapSentAck::clear_swapsent() {
  if (swapsent_ != nullptr) swapsent_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::fantasybit::SwapSent& SwapSentAck::_internal_swapsent() const {
  const ::fantasybit::SwapSent* p = swapsent_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fantasybit::SwapSent*>(
      &::fantasybit::_SwapSent_default_instance_);
}
inline const ::fantasybit::SwapSent& SwapSentAck::swapsent() const {
  // @@protoc_insertion_point(field_get:fantasybit.SwapSentAck.swapsent)
  return _internal_swapsent();
}
inline void SwapSentAck::unsafe_arena_set_allocated_swapsent(
    ::fantasybit::SwapSent* swapsent) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(swapsent_);
  }
  swapsent_ = swapsent;
  if (swapsent) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fantasybit.SwapSentAck.swapsent)
}
inline ::fantasybit::SwapSent* SwapSentAck::release_swapsent() {
  _has_bits_[0] &= ~0x00000001u;
  ::fantasybit::SwapSent* temp = swapsent_;
  swapsent_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fantasybit::SwapSent* SwapSentAck::unsafe_arena_release_swapsent() {
  // @@protoc_insertion_point(field_release:fantasybit.SwapSentAck.swapsent)
  _has_bits_[0] &= ~0x00000001u;
  ::fantasybit::SwapSent* temp = swapsent_;
  swapsent_ = nullptr;
  return temp;
}
inline ::fantasybit::SwapSent* SwapSentAck::_internal_mutable_swapsent() {
  _has_bits_[0] |= 0x00000001u;
  if (swapsent_ == nullptr) {
    auto* p = CreateMaybeMessage<::fantasybit::SwapSent>(GetArena());
    swapsent_ = p;
  }
  return swapsent_;
}
inline ::fantasybit::SwapSent* SwapSentAck::mutable_swapsent() {
  // @@protoc_insertion_point(field_mutable:fantasybit.SwapSentAck.swapsent)
  return _internal_mutable_swapsent();
}
inline void SwapSentAck::set_allocated_swapsent(::fantasybit::SwapSent* swapsent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete swapsent_;
  }
  if (swapsent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(swapsent);
    if (message_arena != submessage_arena) {
      swapsent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, swapsent, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  swapsent_ = swapsent;
  // @@protoc_insertion_point(field_set_allocated:fantasybit.SwapSentAck.swapsent)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace fantasybit

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::fantasybit::OutData_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fantasybit::OutData_Type>() {
  return ::fantasybit::OutData_Type_descriptor();
}
template <> struct is_proto_enum< ::fantasybit::InData_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fantasybit::InData_Type>() {
  return ::fantasybit::InData_Type_descriptor();
}
template <> struct is_proto_enum< ::fantasybit::NameProof_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fantasybit::NameProof_Type>() {
  return ::fantasybit::NameProof_Type_descriptor();
}
template <> struct is_proto_enum< ::fantasybit::BlockHeader_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fantasybit::BlockHeader_Type>() {
  return ::fantasybit::BlockHeader_Type_descriptor();
}
template <> struct is_proto_enum< ::fantasybit::NodeRequest_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fantasybit::NodeRequest_Type>() {
  return ::fantasybit::NodeRequest_Type_descriptor();
}
template <> struct is_proto_enum< ::fantasybit::Data_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fantasybit::Data_Type>() {
  return ::fantasybit::Data_Type_descriptor();
}
template <> struct is_proto_enum< ::fantasybit::TeamState_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fantasybit::TeamState_State>() {
  return ::fantasybit::TeamState_State_descriptor();
}
template <> struct is_proto_enum< ::fantasybit::DeltaData_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fantasybit::DeltaData_Type>() {
  return ::fantasybit::DeltaData_Type_descriptor();
}
template <> struct is_proto_enum< ::fantasybit::ExchangeOrder_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fantasybit::ExchangeOrder_Type>() {
  return ::fantasybit::ExchangeOrder_Type_descriptor();
}
template <> struct is_proto_enum< ::fantasybit::TimeTransition_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fantasybit::TimeTransition_Type>() {
  return ::fantasybit::TimeTransition_Type_descriptor();
}
template <> struct is_proto_enum< ::fantasybit::MyNameStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fantasybit::MyNameStatus>() {
  return ::fantasybit::MyNameStatus_descriptor();
}
template <> struct is_proto_enum< ::fantasybit::TransType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fantasybit::TransType>() {
  return ::fantasybit::TransType_descriptor();
}
template <> struct is_proto_enum< ::fantasybit::TrType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fantasybit::TrType>() {
  return ::fantasybit::TrType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ProtoData_2eproto
