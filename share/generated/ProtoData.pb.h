// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ProtoData.proto

#ifndef PROTOBUF_ProtoData_2eproto__INCLUDED
#define PROTOBUF_ProtoData_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "StaticData.pb.h"
#include "StatusData.pb.h"
#include "ExData.pb.h"
// @@protoc_insertion_point(includes)

namespace fantasybit {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ProtoData_2eproto();
void protobuf_AssignDesc_ProtoData_2eproto();
void protobuf_ShutdownFile_ProtoData_2eproto();

class MyFantasyName;
class FantasyPlayer;
class Secret;
class Secret2;
class Secret3;
class OutData;
class InData;
class NameProof;
class TweetProof;
class MasterProof;
class Transaction;
class NameTrans;
class TransferTrans;
class SignedTransaction;
class BlockHeader;
class SignedBlockHeader;
class Block;
class NodeRequest;
class NodeReply;
class FantasyPlayerPoints;
class ProjectionTrans;
class PlayerPoints;
class ProjectionTransBlock;
class Data;
class PlayerData;
class GameData;
class ResultData;
class ScheduleData;
class DataTransition;
class TeamState;
class DeltaData;
class MessageData;
class StampedTrans;
class ExchangeOrder;
class OrderUnique;
class OrderDeets;
class InsideUnique;
class TimeTransition;
class Bitcoin_UTXO;
class Bitcoin_UTXOS;
class SwapAsk;
class SwapBid;
class SwapFill;
class SwapSent;
class ProofOfDoubleSpend;
class SwapSentAck;

enum OutData_Type {
  OutData_Type_MYFANTASYNAME = 1,
  OutData_Type_SNAPSHOT = 2,
  OutData_Type_HEARTBEAT = 3
};
bool OutData_Type_IsValid(int value);
const OutData_Type OutData_Type_Type_MIN = OutData_Type_MYFANTASYNAME;
const OutData_Type OutData_Type_Type_MAX = OutData_Type_HEARTBEAT;
const int OutData_Type_Type_ARRAYSIZE = OutData_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* OutData_Type_descriptor();
inline const ::std::string& OutData_Type_Name(OutData_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    OutData_Type_descriptor(), value);
}
inline bool OutData_Type_Parse(
    const ::std::string& name, OutData_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OutData_Type>(
    OutData_Type_descriptor(), name, value);
}
enum InData_Type {
  InData_Type_MINENAME = 1,
  InData_Type_QUIT = 2,
  InData_Type_HEARTBEAT = 3,
  InData_Type_CONNECT = 4,
  InData_Type_MAKE_BLOCK = 5,
  InData_Type_NEWNAME = 6,
  InData_Type_PROJ = 7,
  InData_Type_DATA = 8
};
bool InData_Type_IsValid(int value);
const InData_Type InData_Type_Type_MIN = InData_Type_MINENAME;
const InData_Type InData_Type_Type_MAX = InData_Type_DATA;
const int InData_Type_Type_ARRAYSIZE = InData_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* InData_Type_descriptor();
inline const ::std::string& InData_Type_Name(InData_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    InData_Type_descriptor(), value);
}
inline bool InData_Type_Parse(
    const ::std::string& name, InData_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InData_Type>(
    InData_Type_descriptor(), name, value);
}
enum NameProof_Type {
  NameProof_Type_POW = 1,
  NameProof_Type_TWEET = 2,
  NameProof_Type_ORACLE = 3,
  NameProof_Type_MASTER = 4
};
bool NameProof_Type_IsValid(int value);
const NameProof_Type NameProof_Type_Type_MIN = NameProof_Type_POW;
const NameProof_Type NameProof_Type_Type_MAX = NameProof_Type_MASTER;
const int NameProof_Type_Type_ARRAYSIZE = NameProof_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* NameProof_Type_descriptor();
inline const ::std::string& NameProof_Type_Name(NameProof_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    NameProof_Type_descriptor(), value);
}
inline bool NameProof_Type_Parse(
    const ::std::string& name, NameProof_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NameProof_Type>(
    NameProof_Type_descriptor(), name, value);
}
enum BlockHeader_Type {
  BlockHeader_Type_NORMAL = 1,
  BlockHeader_Type_DATA = 2
};
bool BlockHeader_Type_IsValid(int value);
const BlockHeader_Type BlockHeader_Type_Type_MIN = BlockHeader_Type_NORMAL;
const BlockHeader_Type BlockHeader_Type_Type_MAX = BlockHeader_Type_DATA;
const int BlockHeader_Type_Type_ARRAYSIZE = BlockHeader_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* BlockHeader_Type_descriptor();
inline const ::std::string& BlockHeader_Type_Name(BlockHeader_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    BlockHeader_Type_descriptor(), value);
}
inline bool BlockHeader_Type_Parse(
    const ::std::string& name, BlockHeader_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BlockHeader_Type>(
    BlockHeader_Type_descriptor(), name, value);
}
enum NodeRequest_Type {
  NodeRequest_Type_HANDSHAKE = 1,
  NodeRequest_Type_BLOCK_REQUEST = 2,
  NodeRequest_Type_HIGHT_REQUEST = 3,
  NodeRequest_Type_NAT_TEST = 4
};
bool NodeRequest_Type_IsValid(int value);
const NodeRequest_Type NodeRequest_Type_Type_MIN = NodeRequest_Type_HANDSHAKE;
const NodeRequest_Type NodeRequest_Type_Type_MAX = NodeRequest_Type_NAT_TEST;
const int NodeRequest_Type_Type_ARRAYSIZE = NodeRequest_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* NodeRequest_Type_descriptor();
inline const ::std::string& NodeRequest_Type_Name(NodeRequest_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    NodeRequest_Type_descriptor(), value);
}
inline bool NodeRequest_Type_Parse(
    const ::std::string& name, NodeRequest_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NodeRequest_Type>(
    NodeRequest_Type_descriptor(), name, value);
}
enum Data_Type {
  Data_Type_SCHEDULE = 0,
  Data_Type_PLAYER = 1,
  Data_Type_GAME = 2,
  Data_Type_RESULT = 3,
  Data_Type_MESSAGE = 4
};
bool Data_Type_IsValid(int value);
const Data_Type Data_Type_Type_MIN = Data_Type_SCHEDULE;
const Data_Type Data_Type_Type_MAX = Data_Type_MESSAGE;
const int Data_Type_Type_ARRAYSIZE = Data_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Data_Type_descriptor();
inline const ::std::string& Data_Type_Name(Data_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Data_Type_descriptor(), value);
}
inline bool Data_Type_Parse(
    const ::std::string& name, Data_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Data_Type>(
    Data_Type_descriptor(), name, value);
}
enum TeamState_State {
  TeamState_State_PREGAME = 1,
  TeamState_State_INGAME = 2
};
bool TeamState_State_IsValid(int value);
const TeamState_State TeamState_State_State_MIN = TeamState_State_PREGAME;
const TeamState_State TeamState_State_State_MAX = TeamState_State_INGAME;
const int TeamState_State_State_ARRAYSIZE = TeamState_State_State_MAX + 1;

const ::google::protobuf::EnumDescriptor* TeamState_State_descriptor();
inline const ::std::string& TeamState_State_Name(TeamState_State value) {
  return ::google::protobuf::internal::NameOfEnum(
    TeamState_State_descriptor(), value);
}
inline bool TeamState_State_Parse(
    const ::std::string& name, TeamState_State* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TeamState_State>(
    TeamState_State_descriptor(), name, value);
}
enum DeltaData_Type {
  DeltaData_Type_SNAPSHOT = 2,
  DeltaData_Type_HEARTBEAT = 3
};
bool DeltaData_Type_IsValid(int value);
const DeltaData_Type DeltaData_Type_Type_MIN = DeltaData_Type_SNAPSHOT;
const DeltaData_Type DeltaData_Type_Type_MAX = DeltaData_Type_HEARTBEAT;
const int DeltaData_Type_Type_ARRAYSIZE = DeltaData_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* DeltaData_Type_descriptor();
inline const ::std::string& DeltaData_Type_Name(DeltaData_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    DeltaData_Type_descriptor(), value);
}
inline bool DeltaData_Type_Parse(
    const ::std::string& name, DeltaData_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DeltaData_Type>(
    DeltaData_Type_descriptor(), name, value);
}
enum ExchangeOrder_Type {
  ExchangeOrder_Type_NEW = 1,
  ExchangeOrder_Type_CANCEL = 2,
  ExchangeOrder_Type_REPLACE = 3
};
bool ExchangeOrder_Type_IsValid(int value);
const ExchangeOrder_Type ExchangeOrder_Type_Type_MIN = ExchangeOrder_Type_NEW;
const ExchangeOrder_Type ExchangeOrder_Type_Type_MAX = ExchangeOrder_Type_REPLACE;
const int ExchangeOrder_Type_Type_ARRAYSIZE = ExchangeOrder_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExchangeOrder_Type_descriptor();
inline const ::std::string& ExchangeOrder_Type_Name(ExchangeOrder_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExchangeOrder_Type_descriptor(), value);
}
inline bool ExchangeOrder_Type_Parse(
    const ::std::string& name, ExchangeOrder_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExchangeOrder_Type>(
    ExchangeOrder_Type_descriptor(), name, value);
}
enum TimeTransition_Type {
  TimeTransition_Type_TRADEOPEN = 2,
  TimeTransition_Type_TRADECLOSE = 3
};
bool TimeTransition_Type_IsValid(int value);
const TimeTransition_Type TimeTransition_Type_Type_MIN = TimeTransition_Type_TRADEOPEN;
const TimeTransition_Type TimeTransition_Type_Type_MAX = TimeTransition_Type_TRADECLOSE;
const int TimeTransition_Type_Type_ARRAYSIZE = TimeTransition_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* TimeTransition_Type_descriptor();
inline const ::std::string& TimeTransition_Type_Name(TimeTransition_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    TimeTransition_Type_descriptor(), value);
}
inline bool TimeTransition_Type_Parse(
    const ::std::string& name, TimeTransition_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TimeTransition_Type>(
    TimeTransition_Type_descriptor(), name, value);
}
enum MyNameStatus {
  none = 1,
  notavil = 2,
  requested = 5,
  transaction_sent = 15,
  confirmed = 20
};
bool MyNameStatus_IsValid(int value);
const MyNameStatus MyNameStatus_MIN = none;
const MyNameStatus MyNameStatus_MAX = confirmed;
const int MyNameStatus_ARRAYSIZE = MyNameStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* MyNameStatus_descriptor();
inline const ::std::string& MyNameStatus_Name(MyNameStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    MyNameStatus_descriptor(), value);
}
inline bool MyNameStatus_Parse(
    const ::std::string& name, MyNameStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MyNameStatus>(
    MyNameStatus_descriptor(), name, value);
}
enum TransType {
  NAME = 0,
  PROJECTION = 1,
  RESULT = 2,
  DATA = 3,
  PROJECTION_BLOCK = 4,
  MASTER_NAME = 5,
  TIME = 6,
  STAMPED = 7,
  EXCHANGE = 8,
  EXCHANGE_BLOCK = 9,
  TRANSFER = 10,
  SWAPASK = 11,
  SWAPBID = 12,
  SWAPFIL = 13,
  SWAPSENT = 14,
  PODP = 15,
  SWAPSENTACK = 16
};
bool TransType_IsValid(int value);
const TransType TransType_MIN = NAME;
const TransType TransType_MAX = SWAPSENTACK;
const int TransType_ARRAYSIZE = TransType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TransType_descriptor();
inline const ::std::string& TransType_Name(TransType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TransType_descriptor(), value);
}
inline bool TransType_Parse(
    const ::std::string& name, TransType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TransType>(
    TransType_descriptor(), name, value);
}
enum TrType {
  SEASONSTART = 2,
  SEASONEND = 3,
  HEARTBEAT = 5,
  GAMESTART = 6,
  WEEKOVER = 7,
  TRADESESSIONSTART = 8,
  TRADESESSIONCLOSEANDPREOPEN = 9,
  PLAYOFFSTART = 10,
  SUPERBOWLEND = 12
};
bool TrType_IsValid(int value);
const TrType TrType_MIN = SEASONSTART;
const TrType TrType_MAX = SUPERBOWLEND;
const int TrType_ARRAYSIZE = TrType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrType_descriptor();
inline const ::std::string& TrType_Name(TrType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrType_descriptor(), value);
}
inline bool TrType_Parse(
    const ::std::string& name, TrType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrType>(
    TrType_descriptor(), name, value);
}
// ===================================================================

class MyFantasyName : public ::google::protobuf::Message {
 public:
  MyFantasyName();
  virtual ~MyFantasyName();

  MyFantasyName(const MyFantasyName& from);

  inline MyFantasyName& operator=(const MyFantasyName& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MyFantasyName& default_instance();

  void Swap(MyFantasyName* other);

  // implements Message ----------------------------------------------

  MyFantasyName* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MyFantasyName& from);
  void MergeFrom(const MyFantasyName& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .fantasybit.MyNameStatus status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::fantasybit::MyNameStatus status() const;
  inline void set_status(::fantasybit::MyNameStatus value);

  // @@protoc_insertion_point(class_scope:fantasybit.MyFantasyName)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static MyFantasyName* default_instance_;
};
// -------------------------------------------------------------------

class FantasyPlayer : public ::google::protobuf::Message {
 public:
  FantasyPlayer();
  virtual ~FantasyPlayer();

  FantasyPlayer(const FantasyPlayer& from);

  inline FantasyPlayer& operator=(const FantasyPlayer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FantasyPlayer& default_instance();

  void Swap(FantasyPlayer* other);

  // implements Message ----------------------------------------------

  FantasyPlayer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FantasyPlayer& from);
  void MergeFrom(const FantasyPlayer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 10;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 10;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint64 bits = 20;
  inline bool has_bits() const;
  inline void clear_bits();
  static const int kBitsFieldNumber = 20;
  inline ::google::protobuf::uint64 bits() const;
  inline void set_bits(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:fantasybit.FantasyPlayer)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_bits();
  inline void clear_has_bits();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint64 bits_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static FantasyPlayer* default_instance_;
};
// -------------------------------------------------------------------

class Secret : public ::google::protobuf::Message {
 public:
  Secret();
  virtual ~Secret();

  Secret(const Secret& from);

  inline Secret& operator=(const Secret& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Secret& default_instance();

  void Swap(Secret* other);

  // implements Message ----------------------------------------------

  Secret* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Secret& from);
  void MergeFrom(const Secret& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string private_key = 1;
  inline bool has_private_key() const;
  inline void clear_private_key();
  static const int kPrivateKeyFieldNumber = 1;
  inline const ::std::string& private_key() const;
  inline void set_private_key(const ::std::string& value);
  inline void set_private_key(const char* value);
  inline void set_private_key(const char* value, size_t size);
  inline ::std::string* mutable_private_key();
  inline ::std::string* release_private_key();
  inline void set_allocated_private_key(::std::string* private_key);

  // optional .fantasybit.MyFantasyName myfantasyname = 2;
  inline bool has_myfantasyname() const;
  inline void clear_myfantasyname();
  static const int kMyfantasynameFieldNumber = 2;
  inline const ::fantasybit::MyFantasyName& myfantasyname() const;
  inline ::fantasybit::MyFantasyName* mutable_myfantasyname();
  inline ::fantasybit::MyFantasyName* release_myfantasyname();
  inline void set_allocated_myfantasyname(::fantasybit::MyFantasyName* myfantasyname);

  // optional .fantasybit.NameTrans nametran = 10;
  inline bool has_nametran() const;
  inline void clear_nametran();
  static const int kNametranFieldNumber = 10;
  inline const ::fantasybit::NameTrans& nametran() const;
  inline ::fantasybit::NameTrans* mutable_nametran();
  inline ::fantasybit::NameTrans* release_nametran();
  inline void set_allocated_nametran(::fantasybit::NameTrans* nametran);

  // @@protoc_insertion_point(class_scope:fantasybit.Secret)
 private:
  inline void set_has_private_key();
  inline void clear_has_private_key();
  inline void set_has_myfantasyname();
  inline void clear_has_myfantasyname();
  inline void set_has_nametran();
  inline void clear_has_nametran();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* private_key_;
  ::fantasybit::MyFantasyName* myfantasyname_;
  ::fantasybit::NameTrans* nametran_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static Secret* default_instance_;
};
// -------------------------------------------------------------------

class Secret2 : public ::google::protobuf::Message {
 public:
  Secret2();
  virtual ~Secret2();

  Secret2(const Secret2& from);

  inline Secret2& operator=(const Secret2& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Secret2& default_instance();

  void Swap(Secret2* other);

  // implements Message ----------------------------------------------

  Secret2* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Secret2& from);
  void MergeFrom(const Secret2& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string private_key = 1;
  inline bool has_private_key() const;
  inline void clear_private_key();
  static const int kPrivateKeyFieldNumber = 1;
  inline const ::std::string& private_key() const;
  inline void set_private_key(const ::std::string& value);
  inline void set_private_key(const char* value);
  inline void set_private_key(const char* value, size_t size);
  inline ::std::string* mutable_private_key();
  inline ::std::string* release_private_key();
  inline void set_allocated_private_key(::std::string* private_key);

  // optional string fantasy_name = 20;
  inline bool has_fantasy_name() const;
  inline void clear_fantasy_name();
  static const int kFantasyNameFieldNumber = 20;
  inline const ::std::string& fantasy_name() const;
  inline void set_fantasy_name(const ::std::string& value);
  inline void set_fantasy_name(const char* value);
  inline void set_fantasy_name(const char* value, size_t size);
  inline ::std::string* mutable_fantasy_name();
  inline ::std::string* release_fantasy_name();
  inline void set_allocated_fantasy_name(::std::string* fantasy_name);

  // optional string public_key = 30;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 30;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const char* value, size_t size);
  inline ::std::string* mutable_public_key();
  inline ::std::string* release_public_key();
  inline void set_allocated_public_key(::std::string* public_key);

  // @@protoc_insertion_point(class_scope:fantasybit.Secret2)
 private:
  inline void set_has_private_key();
  inline void clear_has_private_key();
  inline void set_has_fantasy_name();
  inline void clear_has_fantasy_name();
  inline void set_has_public_key();
  inline void clear_has_public_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* private_key_;
  ::std::string* fantasy_name_;
  ::std::string* public_key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static Secret2* default_instance_;
};
// -------------------------------------------------------------------

class Secret3 : public ::google::protobuf::Message {
 public:
  Secret3();
  virtual ~Secret3();

  Secret3(const Secret3& from);

  inline Secret3& operator=(const Secret3& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Secret3& default_instance();

  void Swap(Secret3* other);

  // implements Message ----------------------------------------------

  Secret3* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Secret3& from);
  void MergeFrom(const Secret3& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string private_key = 1;
  inline bool has_private_key() const;
  inline void clear_private_key();
  static const int kPrivateKeyFieldNumber = 1;
  inline const ::std::string& private_key() const;
  inline void set_private_key(const ::std::string& value);
  inline void set_private_key(const char* value);
  inline void set_private_key(const char* value, size_t size);
  inline ::std::string* mutable_private_key();
  inline ::std::string* release_private_key();
  inline void set_allocated_private_key(::std::string* private_key);

  // optional string mnemonic_key = 3;
  inline bool has_mnemonic_key() const;
  inline void clear_mnemonic_key();
  static const int kMnemonicKeyFieldNumber = 3;
  inline const ::std::string& mnemonic_key() const;
  inline void set_mnemonic_key(const ::std::string& value);
  inline void set_mnemonic_key(const char* value);
  inline void set_mnemonic_key(const char* value, size_t size);
  inline ::std::string* mutable_mnemonic_key();
  inline ::std::string* release_mnemonic_key();
  inline void set_allocated_mnemonic_key(::std::string* mnemonic_key);

  // optional string fantasy_name = 20;
  inline bool has_fantasy_name() const;
  inline void clear_fantasy_name();
  static const int kFantasyNameFieldNumber = 20;
  inline const ::std::string& fantasy_name() const;
  inline void set_fantasy_name(const ::std::string& value);
  inline void set_fantasy_name(const char* value);
  inline void set_fantasy_name(const char* value, size_t size);
  inline ::std::string* mutable_fantasy_name();
  inline ::std::string* release_fantasy_name();
  inline void set_allocated_fantasy_name(::std::string* fantasy_name);

  // optional string public_key = 30;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 30;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const char* value, size_t size);
  inline ::std::string* mutable_public_key();
  inline ::std::string* release_public_key();
  inline void set_allocated_public_key(::std::string* public_key);

  // @@protoc_insertion_point(class_scope:fantasybit.Secret3)
 private:
  inline void set_has_private_key();
  inline void clear_has_private_key();
  inline void set_has_mnemonic_key();
  inline void clear_has_mnemonic_key();
  inline void set_has_fantasy_name();
  inline void clear_has_fantasy_name();
  inline void set_has_public_key();
  inline void clear_has_public_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* private_key_;
  ::std::string* mnemonic_key_;
  ::std::string* fantasy_name_;
  ::std::string* public_key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static Secret3* default_instance_;
};
// -------------------------------------------------------------------

class OutData : public ::google::protobuf::Message {
 public:
  OutData();
  virtual ~OutData();

  OutData(const OutData& from);

  inline OutData& operator=(const OutData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OutData& default_instance();

  void Swap(OutData* other);

  // implements Message ----------------------------------------------

  OutData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OutData& from);
  void MergeFrom(const OutData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef OutData_Type Type;
  static const Type MYFANTASYNAME = OutData_Type_MYFANTASYNAME;
  static const Type SNAPSHOT = OutData_Type_SNAPSHOT;
  static const Type HEARTBEAT = OutData_Type_HEARTBEAT;
  static inline bool Type_IsValid(int value) {
    return OutData_Type_IsValid(value);
  }
  static const Type Type_MIN =
    OutData_Type_Type_MIN;
  static const Type Type_MAX =
    OutData_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    OutData_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return OutData_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return OutData_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return OutData_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .fantasybit.OutData.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::fantasybit::OutData_Type type() const;
  inline void set_type(::fantasybit::OutData_Type value);

  // optional .fantasybit.MyFantasyName myfantasyname = 2;
  inline bool has_myfantasyname() const;
  inline void clear_myfantasyname();
  static const int kMyfantasynameFieldNumber = 2;
  inline const ::fantasybit::MyFantasyName& myfantasyname() const;
  inline ::fantasybit::MyFantasyName* mutable_myfantasyname();
  inline ::fantasybit::MyFantasyName* release_myfantasyname();
  inline void set_allocated_myfantasyname(::fantasybit::MyFantasyName* myfantasyname);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(OutData)
  // @@protoc_insertion_point(class_scope:fantasybit.OutData)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_myfantasyname();
  inline void clear_has_myfantasyname();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::fantasybit::MyFantasyName* myfantasyname_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static OutData* default_instance_;
};
// -------------------------------------------------------------------

class InData : public ::google::protobuf::Message {
 public:
  InData();
  virtual ~InData();

  InData(const InData& from);

  inline InData& operator=(const InData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InData& default_instance();

  void Swap(InData* other);

  // implements Message ----------------------------------------------

  InData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InData& from);
  void MergeFrom(const InData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef InData_Type Type;
  static const Type MINENAME = InData_Type_MINENAME;
  static const Type QUIT = InData_Type_QUIT;
  static const Type HEARTBEAT = InData_Type_HEARTBEAT;
  static const Type CONNECT = InData_Type_CONNECT;
  static const Type MAKE_BLOCK = InData_Type_MAKE_BLOCK;
  static const Type NEWNAME = InData_Type_NEWNAME;
  static const Type PROJ = InData_Type_PROJ;
  static const Type DATA = InData_Type_DATA;
  static inline bool Type_IsValid(int value) {
    return InData_Type_IsValid(value);
  }
  static const Type Type_MIN =
    InData_Type_Type_MIN;
  static const Type Type_MAX =
    InData_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    InData_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return InData_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return InData_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return InData_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .fantasybit.InData.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::fantasybit::InData_Type type() const;
  inline void set_type(::fantasybit::InData_Type value);

  // optional string data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const char* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // optional string data2 = 3;
  inline bool has_data2() const;
  inline void clear_data2();
  static const int kData2FieldNumber = 3;
  inline const ::std::string& data2() const;
  inline void set_data2(const ::std::string& value);
  inline void set_data2(const char* value);
  inline void set_data2(const char* value, size_t size);
  inline ::std::string* mutable_data2();
  inline ::std::string* release_data2();
  inline void set_allocated_data2(::std::string* data2);

  // optional int32 num = 4;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 4;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // optional .fantasybit.DataTransition data_trans = 5;
  inline bool has_data_trans() const;
  inline void clear_data_trans();
  static const int kDataTransFieldNumber = 5;
  inline const ::fantasybit::DataTransition& data_trans() const;
  inline ::fantasybit::DataTransition* mutable_data_trans();
  inline ::fantasybit::DataTransition* release_data_trans();
  inline void set_allocated_data_trans(::fantasybit::DataTransition* data_trans);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(InData)
  // @@protoc_insertion_point(class_scope:fantasybit.InData)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_data2();
  inline void clear_has_data2();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_data_trans();
  inline void clear_has_data_trans();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* data_;
  int type_;
  ::google::protobuf::int32 num_;
  ::std::string* data2_;
  ::fantasybit::DataTransition* data_trans_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static InData* default_instance_;
};
// -------------------------------------------------------------------

class NameProof : public ::google::protobuf::Message {
 public:
  NameProof();
  virtual ~NameProof();

  NameProof(const NameProof& from);

  inline NameProof& operator=(const NameProof& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NameProof& default_instance();

  void Swap(NameProof* other);

  // implements Message ----------------------------------------------

  NameProof* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NameProof& from);
  void MergeFrom(const NameProof& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef NameProof_Type Type;
  static const Type POW = NameProof_Type_POW;
  static const Type TWEET = NameProof_Type_TWEET;
  static const Type ORACLE = NameProof_Type_ORACLE;
  static const Type MASTER = NameProof_Type_MASTER;
  static inline bool Type_IsValid(int value) {
    return NameProof_Type_IsValid(value);
  }
  static const Type Type_MIN =
    NameProof_Type_Type_MIN;
  static const Type Type_MAX =
    NameProof_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    NameProof_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return NameProof_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return NameProof_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return NameProof_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .fantasybit.NameProof.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::fantasybit::NameProof_Type type() const;
  inline void set_type(::fantasybit::NameProof_Type value);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(NameProof)
  // @@protoc_insertion_point(class_scope:fantasybit.NameProof)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static NameProof* default_instance_;
};
// -------------------------------------------------------------------

class TweetProof : public ::google::protobuf::Message {
 public:
  TweetProof();
  virtual ~TweetProof();

  TweetProof(const TweetProof& from);

  inline TweetProof& operator=(const TweetProof& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TweetProof& default_instance();

  void Swap(TweetProof* other);

  // implements Message ----------------------------------------------

  TweetProof* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TweetProof& from);
  void MergeFrom(const TweetProof& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string tweet = 10;
  inline bool has_tweet() const;
  inline void clear_tweet();
  static const int kTweetFieldNumber = 10;
  inline const ::std::string& tweet() const;
  inline void set_tweet(const ::std::string& value);
  inline void set_tweet(const char* value);
  inline void set_tweet(const char* value, size_t size);
  inline ::std::string* mutable_tweet();
  inline ::std::string* release_tweet();
  inline void set_allocated_tweet(::std::string* tweet);

  static const int kTweetProofFieldNumber = 201;
  static ::google::protobuf::internal::ExtensionIdentifier< ::fantasybit::NameProof,
      ::google::protobuf::internal::MessageTypeTraits< ::fantasybit::TweetProof >, 11, false >
    tweet_proof;
  // @@protoc_insertion_point(class_scope:fantasybit.TweetProof)
 private:
  inline void set_has_tweet();
  inline void clear_has_tweet();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* tweet_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static TweetProof* default_instance_;
};
// -------------------------------------------------------------------

class MasterProof : public ::google::protobuf::Message {
 public:
  MasterProof();
  virtual ~MasterProof();

  MasterProof(const MasterProof& from);

  inline MasterProof& operator=(const MasterProof& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MasterProof& default_instance();

  void Swap(MasterProof* other);

  // implements Message ----------------------------------------------

  MasterProof* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MasterProof& from);
  void MergeFrom(const MasterProof& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string season = 10;
  inline bool has_season() const;
  inline void clear_season();
  static const int kSeasonFieldNumber = 10;
  inline const ::std::string& season() const;
  inline void set_season(const ::std::string& value);
  inline void set_season(const char* value);
  inline void set_season(const char* value, size_t size);
  inline ::std::string* mutable_season();
  inline ::std::string* release_season();
  inline void set_allocated_season(::std::string* season);

  // optional int32 week = 20;
  inline bool has_week() const;
  inline void clear_week();
  static const int kWeekFieldNumber = 20;
  inline ::google::protobuf::int32 week() const;
  inline void set_week(::google::protobuf::int32 value);

  // optional int32 timestamp = 21;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 21;
  inline ::google::protobuf::int32 timestamp() const;
  inline void set_timestamp(::google::protobuf::int32 value);

  // optional .fantasybit.SignedTransaction new_oracle_name = 66;
  inline bool has_new_oracle_name() const;
  inline void clear_new_oracle_name();
  static const int kNewOracleNameFieldNumber = 66;
  inline const ::fantasybit::SignedTransaction& new_oracle_name() const;
  inline ::fantasybit::SignedTransaction* mutable_new_oracle_name();
  inline ::fantasybit::SignedTransaction* release_new_oracle_name();
  inline void set_allocated_new_oracle_name(::fantasybit::SignedTransaction* new_oracle_name);

  static const int kMasterProofFieldNumber = 401;
  static ::google::protobuf::internal::ExtensionIdentifier< ::fantasybit::NameProof,
      ::google::protobuf::internal::MessageTypeTraits< ::fantasybit::MasterProof >, 11, false >
    master_proof;
  // @@protoc_insertion_point(class_scope:fantasybit.MasterProof)
 private:
  inline void set_has_season();
  inline void clear_has_season();
  inline void set_has_week();
  inline void clear_has_week();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_new_oracle_name();
  inline void clear_has_new_oracle_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* season_;
  ::google::protobuf::int32 week_;
  ::google::protobuf::int32 timestamp_;
  ::fantasybit::SignedTransaction* new_oracle_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static MasterProof* default_instance_;
};
// -------------------------------------------------------------------

class Transaction : public ::google::protobuf::Message {
 public:
  Transaction();
  virtual ~Transaction();

  Transaction(const Transaction& from);

  inline Transaction& operator=(const Transaction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Transaction& default_instance();

  void Swap(Transaction* other);

  // implements Message ----------------------------------------------

  Transaction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Transaction& from);
  void MergeFrom(const Transaction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);

  // optional .fantasybit.TransType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::fantasybit::TransType type() const;
  inline void set_type(::fantasybit::TransType value);

  // optional uint64 nonce = 10;
  inline bool has_nonce() const;
  inline void clear_nonce();
  static const int kNonceFieldNumber = 10;
  inline ::google::protobuf::uint64 nonce() const;
  inline void set_nonce(::google::protobuf::uint64 value);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(Transaction)
  // @@protoc_insertion_point(class_scope:fantasybit.Transaction)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_nonce();
  inline void clear_has_nonce();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 version_;
  int type_;
  ::google::protobuf::uint64 nonce_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static Transaction* default_instance_;
};
// -------------------------------------------------------------------

class NameTrans : public ::google::protobuf::Message {
 public:
  NameTrans();
  virtual ~NameTrans();

  NameTrans(const NameTrans& from);

  inline NameTrans& operator=(const NameTrans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NameTrans& default_instance();

  void Swap(NameTrans* other);

  // implements Message ----------------------------------------------

  NameTrans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NameTrans& from);
  void MergeFrom(const NameTrans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string fantasy_name = 10;
  inline bool has_fantasy_name() const;
  inline void clear_fantasy_name();
  static const int kFantasyNameFieldNumber = 10;
  inline const ::std::string& fantasy_name() const;
  inline void set_fantasy_name(const ::std::string& value);
  inline void set_fantasy_name(const char* value);
  inline void set_fantasy_name(const char* value, size_t size);
  inline ::std::string* mutable_fantasy_name();
  inline ::std::string* release_fantasy_name();
  inline void set_allocated_fantasy_name(::std::string* fantasy_name);

  // optional bytes public_key = 20;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 20;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const void* value, size_t size);
  inline ::std::string* mutable_public_key();
  inline ::std::string* release_public_key();
  inline void set_allocated_public_key(::std::string* public_key);

  // optional .fantasybit.NameProof proof = 30;
  inline bool has_proof() const;
  inline void clear_proof();
  static const int kProofFieldNumber = 30;
  inline const ::fantasybit::NameProof& proof() const;
  inline ::fantasybit::NameProof* mutable_proof();
  inline ::fantasybit::NameProof* release_proof();
  inline void set_allocated_proof(::fantasybit::NameProof* proof);

  // optional bytes recovery_key = 40;
  inline bool has_recovery_key() const;
  inline void clear_recovery_key();
  static const int kRecoveryKeyFieldNumber = 40;
  inline const ::std::string& recovery_key() const;
  inline void set_recovery_key(const ::std::string& value);
  inline void set_recovery_key(const char* value);
  inline void set_recovery_key(const void* value, size_t size);
  inline ::std::string* mutable_recovery_key();
  inline ::std::string* release_recovery_key();
  inline void set_allocated_recovery_key(::std::string* recovery_key);

  // optional bool am_agent = 50;
  inline bool has_am_agent() const;
  inline void clear_am_agent();
  static const int kAmAgentFieldNumber = 50;
  inline bool am_agent() const;
  inline void set_am_agent(bool value);

  // optional string my_agent = 60;
  inline bool has_my_agent() const;
  inline void clear_my_agent();
  static const int kMyAgentFieldNumber = 60;
  inline const ::std::string& my_agent() const;
  inline void set_my_agent(const ::std::string& value);
  inline void set_my_agent(const char* value);
  inline void set_my_agent(const char* value, size_t size);
  inline ::std::string* mutable_my_agent();
  inline ::std::string* release_my_agent();
  inline void set_allocated_my_agent(::std::string* my_agent);

  static const int kNameTransFieldNumber = 200;
  static ::google::protobuf::internal::ExtensionIdentifier< ::fantasybit::Transaction,
      ::google::protobuf::internal::MessageTypeTraits< ::fantasybit::NameTrans >, 11, false >
    name_trans;
  // @@protoc_insertion_point(class_scope:fantasybit.NameTrans)
 private:
  inline void set_has_fantasy_name();
  inline void clear_has_fantasy_name();
  inline void set_has_public_key();
  inline void clear_has_public_key();
  inline void set_has_proof();
  inline void clear_has_proof();
  inline void set_has_recovery_key();
  inline void clear_has_recovery_key();
  inline void set_has_am_agent();
  inline void clear_has_am_agent();
  inline void set_has_my_agent();
  inline void clear_has_my_agent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* fantasy_name_;
  ::std::string* public_key_;
  ::fantasybit::NameProof* proof_;
  ::std::string* recovery_key_;
  ::std::string* my_agent_;
  bool am_agent_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static NameTrans* default_instance_;
};
// -------------------------------------------------------------------

class TransferTrans : public ::google::protobuf::Message {
 public:
  TransferTrans();
  virtual ~TransferTrans();

  TransferTrans(const TransferTrans& from);

  inline TransferTrans& operator=(const TransferTrans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransferTrans& default_instance();

  void Swap(TransferTrans* other);

  // implements Message ----------------------------------------------

  TransferTrans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransferTrans& from);
  void MergeFrom(const TransferTrans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string from = 10;
  inline bool has_from() const;
  inline void clear_from();
  static const int kFromFieldNumber = 10;
  inline const ::std::string& from() const;
  inline void set_from(const ::std::string& value);
  inline void set_from(const char* value);
  inline void set_from(const char* value, size_t size);
  inline ::std::string* mutable_from();
  inline ::std::string* release_from();
  inline void set_allocated_from(::std::string* from);

  // optional string to = 20;
  inline bool has_to() const;
  inline void clear_to();
  static const int kToFieldNumber = 20;
  inline const ::std::string& to() const;
  inline void set_to(const ::std::string& value);
  inline void set_to(const char* value);
  inline void set_to(const char* value, size_t size);
  inline ::std::string* mutable_to();
  inline ::std::string* release_to();
  inline void set_allocated_to(::std::string* to);

  // optional uint64 amount = 30;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 30;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);

  static const int kTransferTranFieldNumber = 400;
  static ::google::protobuf::internal::ExtensionIdentifier< ::fantasybit::Transaction,
      ::google::protobuf::internal::MessageTypeTraits< ::fantasybit::TransferTrans >, 11, false >
    transfer_tran;
  // @@protoc_insertion_point(class_scope:fantasybit.TransferTrans)
 private:
  inline void set_has_from();
  inline void clear_has_from();
  inline void set_has_to();
  inline void clear_has_to();
  inline void set_has_amount();
  inline void clear_has_amount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* from_;
  ::std::string* to_;
  ::google::protobuf::uint64 amount_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static TransferTrans* default_instance_;
};
// -------------------------------------------------------------------

class SignedTransaction : public ::google::protobuf::Message {
 public:
  SignedTransaction();
  virtual ~SignedTransaction();

  SignedTransaction(const SignedTransaction& from);

  inline SignedTransaction& operator=(const SignedTransaction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignedTransaction& default_instance();

  void Swap(SignedTransaction* other);

  // implements Message ----------------------------------------------

  SignedTransaction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignedTransaction& from);
  void MergeFrom(const SignedTransaction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .fantasybit.Transaction trans = 10;
  inline bool has_trans() const;
  inline void clear_trans();
  static const int kTransFieldNumber = 10;
  inline const ::fantasybit::Transaction& trans() const;
  inline ::fantasybit::Transaction* mutable_trans();
  inline ::fantasybit::Transaction* release_trans();
  inline void set_allocated_trans(::fantasybit::Transaction* trans);

  // optional bytes id = 20;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 20;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const void* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional bytes sig = 30;
  inline bool has_sig() const;
  inline void clear_sig();
  static const int kSigFieldNumber = 30;
  inline const ::std::string& sig() const;
  inline void set_sig(const ::std::string& value);
  inline void set_sig(const char* value);
  inline void set_sig(const void* value, size_t size);
  inline ::std::string* mutable_sig();
  inline ::std::string* release_sig();
  inline void set_allocated_sig(::std::string* sig);

  // optional string fantasy_name = 40;
  inline bool has_fantasy_name() const;
  inline void clear_fantasy_name();
  static const int kFantasyNameFieldNumber = 40;
  inline const ::std::string& fantasy_name() const;
  inline void set_fantasy_name(const ::std::string& value);
  inline void set_fantasy_name(const char* value);
  inline void set_fantasy_name(const char* value, size_t size);
  inline ::std::string* mutable_fantasy_name();
  inline ::std::string* release_fantasy_name();
  inline void set_allocated_fantasy_name(::std::string* fantasy_name);

  // @@protoc_insertion_point(class_scope:fantasybit.SignedTransaction)
 private:
  inline void set_has_trans();
  inline void clear_has_trans();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_sig();
  inline void clear_has_sig();
  inline void set_has_fantasy_name();
  inline void clear_has_fantasy_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::fantasybit::Transaction* trans_;
  ::std::string* id_;
  ::std::string* sig_;
  ::std::string* fantasy_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static SignedTransaction* default_instance_;
};
// -------------------------------------------------------------------

class BlockHeader : public ::google::protobuf::Message {
 public:
  BlockHeader();
  virtual ~BlockHeader();

  BlockHeader(const BlockHeader& from);

  inline BlockHeader& operator=(const BlockHeader& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlockHeader& default_instance();

  void Swap(BlockHeader* other);

  // implements Message ----------------------------------------------

  BlockHeader* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlockHeader& from);
  void MergeFrom(const BlockHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef BlockHeader_Type Type;
  static const Type NORMAL = BlockHeader_Type_NORMAL;
  static const Type DATA = BlockHeader_Type_DATA;
  static inline bool Type_IsValid(int value) {
    return BlockHeader_Type_IsValid(value);
  }
  static const Type Type_MIN =
    BlockHeader_Type_Type_MIN;
  static const Type Type_MAX =
    BlockHeader_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    BlockHeader_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return BlockHeader_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return BlockHeader_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return BlockHeader_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional int32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);

  // optional int32 num = 10;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 10;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // optional bytes prev_id = 20;
  inline bool has_prev_id() const;
  inline void clear_prev_id();
  static const int kPrevIdFieldNumber = 20;
  inline const ::std::string& prev_id() const;
  inline void set_prev_id(const ::std::string& value);
  inline void set_prev_id(const char* value);
  inline void set_prev_id(const void* value, size_t size);
  inline ::std::string* mutable_prev_id();
  inline ::std::string* release_prev_id();
  inline void set_allocated_prev_id(::std::string* prev_id);

  // optional int32 timestamp = 21;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 21;
  inline ::google::protobuf::int32 timestamp() const;
  inline void set_timestamp(::google::protobuf::int32 value);

  // optional bytes generator_pk = 30;
  inline bool has_generator_pk() const;
  inline void clear_generator_pk();
  static const int kGeneratorPkFieldNumber = 30;
  inline const ::std::string& generator_pk() const;
  inline void set_generator_pk(const ::std::string& value);
  inline void set_generator_pk(const char* value);
  inline void set_generator_pk(const void* value, size_t size);
  inline ::std::string* mutable_generator_pk();
  inline ::std::string* release_generator_pk();
  inline void set_allocated_generator_pk(::std::string* generator_pk);

  // optional bytes generating_sig = 40;
  inline bool has_generating_sig() const;
  inline void clear_generating_sig();
  static const int kGeneratingSigFieldNumber = 40;
  inline const ::std::string& generating_sig() const;
  inline void set_generating_sig(const ::std::string& value);
  inline void set_generating_sig(const char* value);
  inline void set_generating_sig(const void* value, size_t size);
  inline ::std::string* mutable_generating_sig();
  inline ::std::string* release_generating_sig();
  inline void set_allocated_generating_sig(::std::string* generating_sig);

  // optional uint64 basetarget = 50;
  inline bool has_basetarget() const;
  inline void clear_basetarget();
  static const int kBasetargetFieldNumber = 50;
  inline ::google::protobuf::uint64 basetarget() const;
  inline void set_basetarget(::google::protobuf::uint64 value);

  // optional .fantasybit.BlockHeader.Type blocktype = 60;
  inline bool has_blocktype() const;
  inline void clear_blocktype();
  static const int kBlocktypeFieldNumber = 60;
  inline ::fantasybit::BlockHeader_Type blocktype() const;
  inline void set_blocktype(::fantasybit::BlockHeader_Type value);

  // optional bytes transaction_id = 70;
  inline bool has_transaction_id() const;
  inline void clear_transaction_id();
  static const int kTransactionIdFieldNumber = 70;
  inline const ::std::string& transaction_id() const;
  inline void set_transaction_id(const ::std::string& value);
  inline void set_transaction_id(const char* value);
  inline void set_transaction_id(const void* value, size_t size);
  inline ::std::string* mutable_transaction_id();
  inline ::std::string* release_transaction_id();
  inline void set_allocated_transaction_id(::std::string* transaction_id);

  // @@protoc_insertion_point(class_scope:fantasybit.BlockHeader)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_prev_id();
  inline void clear_has_prev_id();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_generator_pk();
  inline void clear_has_generator_pk();
  inline void set_has_generating_sig();
  inline void clear_has_generating_sig();
  inline void set_has_basetarget();
  inline void clear_has_basetarget();
  inline void set_has_blocktype();
  inline void clear_has_blocktype();
  inline void set_has_transaction_id();
  inline void clear_has_transaction_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 version_;
  ::google::protobuf::int32 num_;
  ::std::string* prev_id_;
  ::std::string* generator_pk_;
  ::std::string* generating_sig_;
  ::google::protobuf::int32 timestamp_;
  int blocktype_;
  ::google::protobuf::uint64 basetarget_;
  ::std::string* transaction_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static BlockHeader* default_instance_;
};
// -------------------------------------------------------------------

class SignedBlockHeader : public ::google::protobuf::Message {
 public:
  SignedBlockHeader();
  virtual ~SignedBlockHeader();

  SignedBlockHeader(const SignedBlockHeader& from);

  inline SignedBlockHeader& operator=(const SignedBlockHeader& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignedBlockHeader& default_instance();

  void Swap(SignedBlockHeader* other);

  // implements Message ----------------------------------------------

  SignedBlockHeader* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignedBlockHeader& from);
  void MergeFrom(const SignedBlockHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .fantasybit.BlockHeader head = 10;
  inline bool has_head() const;
  inline void clear_head();
  static const int kHeadFieldNumber = 10;
  inline const ::fantasybit::BlockHeader& head() const;
  inline ::fantasybit::BlockHeader* mutable_head();
  inline ::fantasybit::BlockHeader* release_head();
  inline void set_allocated_head(::fantasybit::BlockHeader* head);

  // optional string sig = 30;
  inline bool has_sig() const;
  inline void clear_sig();
  static const int kSigFieldNumber = 30;
  inline const ::std::string& sig() const;
  inline void set_sig(const ::std::string& value);
  inline void set_sig(const char* value);
  inline void set_sig(const char* value, size_t size);
  inline ::std::string* mutable_sig();
  inline ::std::string* release_sig();
  inline void set_allocated_sig(::std::string* sig);

  // @@protoc_insertion_point(class_scope:fantasybit.SignedBlockHeader)
 private:
  inline void set_has_head();
  inline void clear_has_head();
  inline void set_has_sig();
  inline void clear_has_sig();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::fantasybit::BlockHeader* head_;
  ::std::string* sig_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static SignedBlockHeader* default_instance_;
};
// -------------------------------------------------------------------

class Block : public ::google::protobuf::Message {
 public:
  Block();
  virtual ~Block();

  Block(const Block& from);

  inline Block& operator=(const Block& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Block& default_instance();

  void Swap(Block* other);

  // implements Message ----------------------------------------------

  Block* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Block& from);
  void MergeFrom(const Block& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .fantasybit.SignedBlockHeader signedhead = 10;
  inline bool has_signedhead() const;
  inline void clear_signedhead();
  static const int kSignedheadFieldNumber = 10;
  inline const ::fantasybit::SignedBlockHeader& signedhead() const;
  inline ::fantasybit::SignedBlockHeader* mutable_signedhead();
  inline ::fantasybit::SignedBlockHeader* release_signedhead();
  inline void set_allocated_signedhead(::fantasybit::SignedBlockHeader* signedhead);

  // repeated .fantasybit.SignedTransaction signed_transactions = 20;
  inline int signed_transactions_size() const;
  inline void clear_signed_transactions();
  static const int kSignedTransactionsFieldNumber = 20;
  inline const ::fantasybit::SignedTransaction& signed_transactions(int index) const;
  inline ::fantasybit::SignedTransaction* mutable_signed_transactions(int index);
  inline ::fantasybit::SignedTransaction* add_signed_transactions();
  inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::SignedTransaction >&
      signed_transactions() const;
  inline ::google::protobuf::RepeatedPtrField< ::fantasybit::SignedTransaction >*
      mutable_signed_transactions();

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(Block)
  // @@protoc_insertion_point(class_scope:fantasybit.Block)
 private:
  inline void set_has_signedhead();
  inline void clear_has_signedhead();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::fantasybit::SignedBlockHeader* signedhead_;
  ::google::protobuf::RepeatedPtrField< ::fantasybit::SignedTransaction > signed_transactions_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static Block* default_instance_;
};
// -------------------------------------------------------------------

class NodeRequest : public ::google::protobuf::Message {
 public:
  NodeRequest();
  virtual ~NodeRequest();

  NodeRequest(const NodeRequest& from);

  inline NodeRequest& operator=(const NodeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeRequest& default_instance();

  void Swap(NodeRequest* other);

  // implements Message ----------------------------------------------

  NodeRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeRequest& from);
  void MergeFrom(const NodeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef NodeRequest_Type Type;
  static const Type HANDSHAKE = NodeRequest_Type_HANDSHAKE;
  static const Type BLOCK_REQUEST = NodeRequest_Type_BLOCK_REQUEST;
  static const Type HIGHT_REQUEST = NodeRequest_Type_HIGHT_REQUEST;
  static const Type NAT_TEST = NodeRequest_Type_NAT_TEST;
  static inline bool Type_IsValid(int value) {
    return NodeRequest_Type_IsValid(value);
  }
  static const Type Type_MIN =
    NodeRequest_Type_Type_MIN;
  static const Type Type_MAX =
    NodeRequest_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    NodeRequest_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return NodeRequest_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return NodeRequest_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return NodeRequest_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .fantasybit.NodeRequest.Type type = 10;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 10;
  inline ::fantasybit::NodeRequest_Type type() const;
  inline void set_type(::fantasybit::NodeRequest_Type value);

  // optional string myip = 20;
  inline bool has_myip() const;
  inline void clear_myip();
  static const int kMyipFieldNumber = 20;
  inline const ::std::string& myip() const;
  inline void set_myip(const ::std::string& value);
  inline void set_myip(const char* value);
  inline void set_myip(const char* value, size_t size);
  inline ::std::string* mutable_myip();
  inline ::std::string* release_myip();
  inline void set_allocated_myip(::std::string* myip);

  // optional int32 num = 30;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 30;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // optional string myhost = 40;
  inline bool has_myhost() const;
  inline void clear_myhost();
  static const int kMyhostFieldNumber = 40;
  inline const ::std::string& myhost() const;
  inline void set_myhost(const ::std::string& value);
  inline void set_myhost(const char* value);
  inline void set_myhost(const char* value, size_t size);
  inline ::std::string* mutable_myhost();
  inline ::std::string* release_myhost();
  inline void set_allocated_myhost(::std::string* myhost);

  // @@protoc_insertion_point(class_scope:fantasybit.NodeRequest)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_myip();
  inline void clear_has_myip();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_myhost();
  inline void clear_has_myhost();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* myip_;
  int type_;
  ::google::protobuf::int32 num_;
  ::std::string* myhost_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static NodeRequest* default_instance_;
};
// -------------------------------------------------------------------

class NodeReply : public ::google::protobuf::Message {
 public:
  NodeReply();
  virtual ~NodeReply();

  NodeReply(const NodeReply& from);

  inline NodeReply& operator=(const NodeReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeReply& default_instance();

  void Swap(NodeReply* other);

  // implements Message ----------------------------------------------

  NodeReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeReply& from);
  void MergeFrom(const NodeReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 hight = 10;
  inline bool has_hight() const;
  inline void clear_hight();
  static const int kHightFieldNumber = 10;
  inline ::google::protobuf::int32 hight() const;
  inline void set_hight(::google::protobuf::int32 value);

  // repeated string ips = 20;
  inline int ips_size() const;
  inline void clear_ips();
  static const int kIpsFieldNumber = 20;
  inline const ::std::string& ips(int index) const;
  inline ::std::string* mutable_ips(int index);
  inline void set_ips(int index, const ::std::string& value);
  inline void set_ips(int index, const char* value);
  inline void set_ips(int index, const char* value, size_t size);
  inline ::std::string* add_ips();
  inline void add_ips(const ::std::string& value);
  inline void add_ips(const char* value);
  inline void add_ips(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& ips() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_ips();

  // @@protoc_insertion_point(class_scope:fantasybit.NodeReply)
 private:
  inline void set_has_hight();
  inline void clear_has_hight();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> ips_;
  ::google::protobuf::int32 hight_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static NodeReply* default_instance_;
};
// -------------------------------------------------------------------

class FantasyPlayerPoints : public ::google::protobuf::Message {
 public:
  FantasyPlayerPoints();
  virtual ~FantasyPlayerPoints();

  FantasyPlayerPoints(const FantasyPlayerPoints& from);

  inline FantasyPlayerPoints& operator=(const FantasyPlayerPoints& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FantasyPlayerPoints& default_instance();

  void Swap(FantasyPlayerPoints* other);

  // implements Message ----------------------------------------------

  FantasyPlayerPoints* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FantasyPlayerPoints& from);
  void MergeFrom(const FantasyPlayerPoints& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 season = 10;
  inline bool has_season() const;
  inline void clear_season();
  static const int kSeasonFieldNumber = 10;
  inline ::google::protobuf::uint32 season() const;
  inline void set_season(::google::protobuf::uint32 value);

  // optional uint32 week = 20;
  inline bool has_week() const;
  inline void clear_week();
  static const int kWeekFieldNumber = 20;
  inline ::google::protobuf::uint32 week() const;
  inline void set_week(::google::protobuf::uint32 value);

  // optional string playerid = 30;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 30;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  inline void set_allocated_playerid(::std::string* playerid);

  // optional int32 points = 40;
  inline bool has_points() const;
  inline void clear_points();
  static const int kPointsFieldNumber = 40;
  inline ::google::protobuf::int32 points() const;
  inline void set_points(::google::protobuf::int32 value);

  // optional float result = 50;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 50;
  inline float result() const;
  inline void set_result(float value);

  // @@protoc_insertion_point(class_scope:fantasybit.FantasyPlayerPoints)
 private:
  inline void set_has_season();
  inline void clear_has_season();
  inline void set_has_week();
  inline void clear_has_week();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_points();
  inline void clear_has_points();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 season_;
  ::google::protobuf::uint32 week_;
  ::std::string* playerid_;
  ::google::protobuf::int32 points_;
  float result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static FantasyPlayerPoints* default_instance_;
};
// -------------------------------------------------------------------

class ProjectionTrans : public ::google::protobuf::Message {
 public:
  ProjectionTrans();
  virtual ~ProjectionTrans();

  ProjectionTrans(const ProjectionTrans& from);

  inline ProjectionTrans& operator=(const ProjectionTrans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProjectionTrans& default_instance();

  void Swap(ProjectionTrans* other);

  // implements Message ----------------------------------------------

  ProjectionTrans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProjectionTrans& from);
  void MergeFrom(const ProjectionTrans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 season = 10;
  inline bool has_season() const;
  inline void clear_season();
  static const int kSeasonFieldNumber = 10;
  inline ::google::protobuf::uint32 season() const;
  inline void set_season(::google::protobuf::uint32 value);

  // optional uint32 week = 20;
  inline bool has_week() const;
  inline void clear_week();
  static const int kWeekFieldNumber = 20;
  inline ::google::protobuf::uint32 week() const;
  inline void set_week(::google::protobuf::uint32 value);

  // optional string playerid = 30;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 30;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  inline void set_allocated_playerid(::std::string* playerid);

  // optional int32 points = 40;
  inline bool has_points() const;
  inline void clear_points();
  static const int kPointsFieldNumber = 40;
  inline ::google::protobuf::int32 points() const;
  inline void set_points(::google::protobuf::int32 value);

  static const int kProjTransFieldNumber = 201;
  static ::google::protobuf::internal::ExtensionIdentifier< ::fantasybit::Transaction,
      ::google::protobuf::internal::MessageTypeTraits< ::fantasybit::ProjectionTrans >, 11, false >
    proj_trans;
  // @@protoc_insertion_point(class_scope:fantasybit.ProjectionTrans)
 private:
  inline void set_has_season();
  inline void clear_has_season();
  inline void set_has_week();
  inline void clear_has_week();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_points();
  inline void clear_has_points();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 season_;
  ::google::protobuf::uint32 week_;
  ::std::string* playerid_;
  ::google::protobuf::int32 points_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static ProjectionTrans* default_instance_;
};
// -------------------------------------------------------------------

class PlayerPoints : public ::google::protobuf::Message {
 public:
  PlayerPoints();
  virtual ~PlayerPoints();

  PlayerPoints(const PlayerPoints& from);

  inline PlayerPoints& operator=(const PlayerPoints& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerPoints& default_instance();

  void Swap(PlayerPoints* other);

  // implements Message ----------------------------------------------

  PlayerPoints* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerPoints& from);
  void MergeFrom(const PlayerPoints& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string playerid = 30;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 30;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  inline void set_allocated_playerid(::std::string* playerid);

  // optional int32 points = 40;
  inline bool has_points() const;
  inline void clear_points();
  static const int kPointsFieldNumber = 40;
  inline ::google::protobuf::int32 points() const;
  inline void set_points(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fantasybit.PlayerPoints)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_points();
  inline void clear_has_points();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* playerid_;
  ::google::protobuf::int32 points_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static PlayerPoints* default_instance_;
};
// -------------------------------------------------------------------

class ProjectionTransBlock : public ::google::protobuf::Message {
 public:
  ProjectionTransBlock();
  virtual ~ProjectionTransBlock();

  ProjectionTransBlock(const ProjectionTransBlock& from);

  inline ProjectionTransBlock& operator=(const ProjectionTransBlock& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProjectionTransBlock& default_instance();

  void Swap(ProjectionTransBlock* other);

  // implements Message ----------------------------------------------

  ProjectionTransBlock* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProjectionTransBlock& from);
  void MergeFrom(const ProjectionTransBlock& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 season = 10;
  inline bool has_season() const;
  inline void clear_season();
  static const int kSeasonFieldNumber = 10;
  inline ::google::protobuf::uint32 season() const;
  inline void set_season(::google::protobuf::uint32 value);

  // optional uint32 week = 20;
  inline bool has_week() const;
  inline void clear_week();
  static const int kWeekFieldNumber = 20;
  inline ::google::protobuf::uint32 week() const;
  inline void set_week(::google::protobuf::uint32 value);

  // repeated .fantasybit.PlayerPoints player_points = 30;
  inline int player_points_size() const;
  inline void clear_player_points();
  static const int kPlayerPointsFieldNumber = 30;
  inline const ::fantasybit::PlayerPoints& player_points(int index) const;
  inline ::fantasybit::PlayerPoints* mutable_player_points(int index);
  inline ::fantasybit::PlayerPoints* add_player_points();
  inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::PlayerPoints >&
      player_points() const;
  inline ::google::protobuf::RepeatedPtrField< ::fantasybit::PlayerPoints >*
      mutable_player_points();

  static const int kProjTransBlockFieldNumber = 211;
  static ::google::protobuf::internal::ExtensionIdentifier< ::fantasybit::Transaction,
      ::google::protobuf::internal::MessageTypeTraits< ::fantasybit::ProjectionTransBlock >, 11, false >
    proj_trans_block;
  // @@protoc_insertion_point(class_scope:fantasybit.ProjectionTransBlock)
 private:
  inline void set_has_season();
  inline void clear_has_season();
  inline void set_has_week();
  inline void clear_has_week();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 season_;
  ::google::protobuf::uint32 week_;
  ::google::protobuf::RepeatedPtrField< ::fantasybit::PlayerPoints > player_points_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static ProjectionTransBlock* default_instance_;
};
// -------------------------------------------------------------------

class Data : public ::google::protobuf::Message {
 public:
  Data();
  virtual ~Data();

  Data(const Data& from);

  inline Data& operator=(const Data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Data& default_instance();

  void Swap(Data* other);

  // implements Message ----------------------------------------------

  Data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Data& from);
  void MergeFrom(const Data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Data_Type Type;
  static const Type SCHEDULE = Data_Type_SCHEDULE;
  static const Type PLAYER = Data_Type_PLAYER;
  static const Type GAME = Data_Type_GAME;
  static const Type RESULT = Data_Type_RESULT;
  static const Type MESSAGE = Data_Type_MESSAGE;
  static inline bool Type_IsValid(int value) {
    return Data_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Data_Type_Type_MIN;
  static const Type Type_MAX =
    Data_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Data_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Data_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Data_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Data_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional int32 version = 10;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 10;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);

  // optional .fantasybit.Data.Type type = 20;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 20;
  inline ::fantasybit::Data_Type type() const;
  inline void set_type(::fantasybit::Data_Type value);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(Data)
  // @@protoc_insertion_point(class_scope:fantasybit.Data)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 version_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static Data* default_instance_;
};
// -------------------------------------------------------------------

class PlayerData : public ::google::protobuf::Message {
 public:
  PlayerData();
  virtual ~PlayerData();

  PlayerData(const PlayerData& from);

  inline PlayerData& operator=(const PlayerData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerData& default_instance();

  void Swap(PlayerData* other);

  // implements Message ----------------------------------------------

  PlayerData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerData& from);
  void MergeFrom(const PlayerData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string playerid = 10;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 10;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  inline void set_allocated_playerid(::std::string* playerid);

  // optional .fantasybit.PlayerBase player_base = 20;
  inline bool has_player_base() const;
  inline void clear_player_base();
  static const int kPlayerBaseFieldNumber = 20;
  inline const ::fantasybit::PlayerBase& player_base() const;
  inline ::fantasybit::PlayerBase* mutable_player_base();
  inline ::fantasybit::PlayerBase* release_player_base();
  inline void set_allocated_player_base(::fantasybit::PlayerBase* player_base);

  // optional .fantasybit.PlayerStatus player_status = 30;
  inline bool has_player_status() const;
  inline void clear_player_status();
  static const int kPlayerStatusFieldNumber = 30;
  inline const ::fantasybit::PlayerStatus& player_status() const;
  inline ::fantasybit::PlayerStatus* mutable_player_status();
  inline ::fantasybit::PlayerStatus* release_player_status();
  inline void set_allocated_player_status(::fantasybit::PlayerStatus* player_status);

  // optional .fantasybit.PlayerGameStatus player_game_status = 40;
  inline bool has_player_game_status() const;
  inline void clear_player_game_status();
  static const int kPlayerGameStatusFieldNumber = 40;
  inline ::fantasybit::PlayerGameStatus player_game_status() const;
  inline void set_player_game_status(::fantasybit::PlayerGameStatus value);

  static const int kPlayerDataFieldNumber = 101;
  static ::google::protobuf::internal::ExtensionIdentifier< ::fantasybit::Data,
      ::google::protobuf::internal::MessageTypeTraits< ::fantasybit::PlayerData >, 11, false >
    player_data;
  // @@protoc_insertion_point(class_scope:fantasybit.PlayerData)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_player_base();
  inline void clear_has_player_base();
  inline void set_has_player_status();
  inline void clear_has_player_status();
  inline void set_has_player_game_status();
  inline void clear_has_player_game_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* playerid_;
  ::fantasybit::PlayerBase* player_base_;
  ::fantasybit::PlayerStatus* player_status_;
  int player_game_status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static PlayerData* default_instance_;
};
// -------------------------------------------------------------------

class GameData : public ::google::protobuf::Message {
 public:
  GameData();
  virtual ~GameData();

  GameData(const GameData& from);

  inline GameData& operator=(const GameData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameData& default_instance();

  void Swap(GameData* other);

  // implements Message ----------------------------------------------

  GameData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameData& from);
  void MergeFrom(const GameData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string gameid = 10;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameidFieldNumber = 10;
  inline const ::std::string& gameid() const;
  inline void set_gameid(const ::std::string& value);
  inline void set_gameid(const char* value);
  inline void set_gameid(const char* value, size_t size);
  inline ::std::string* mutable_gameid();
  inline ::std::string* release_gameid();
  inline void set_allocated_gameid(::std::string* gameid);

  // optional .fantasybit.GameStatus status = 20;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 20;
  inline const ::fantasybit::GameStatus& status() const;
  inline ::fantasybit::GameStatus* mutable_status();
  inline ::fantasybit::GameStatus* release_status();
  inline void set_allocated_status(::fantasybit::GameStatus* status);

  static const int kGameDataFieldNumber = 111;
  static ::google::protobuf::internal::ExtensionIdentifier< ::fantasybit::Data,
      ::google::protobuf::internal::MessageTypeTraits< ::fantasybit::GameData >, 11, false >
    game_data;
  // @@protoc_insertion_point(class_scope:fantasybit.GameData)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* gameid_;
  ::fantasybit::GameStatus* status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static GameData* default_instance_;
};
// -------------------------------------------------------------------

class ResultData : public ::google::protobuf::Message {
 public:
  ResultData();
  virtual ~ResultData();

  ResultData(const ResultData& from);

  inline ResultData& operator=(const ResultData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResultData& default_instance();

  void Swap(ResultData* other);

  // implements Message ----------------------------------------------

  ResultData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResultData& from);
  void MergeFrom(const ResultData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .fantasybit.GameResult game_result = 10;
  inline bool has_game_result() const;
  inline void clear_game_result();
  static const int kGameResultFieldNumber = 10;
  inline const ::fantasybit::GameResult& game_result() const;
  inline ::fantasybit::GameResult* mutable_game_result();
  inline ::fantasybit::GameResult* release_game_result();
  inline void set_allocated_game_result(::fantasybit::GameResult* game_result);

  static const int kResultDataFieldNumber = 202;
  static ::google::protobuf::internal::ExtensionIdentifier< ::fantasybit::Data,
      ::google::protobuf::internal::MessageTypeTraits< ::fantasybit::ResultData >, 11, false >
    result_data;
  // @@protoc_insertion_point(class_scope:fantasybit.ResultData)
 private:
  inline void set_has_game_result();
  inline void clear_has_game_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::fantasybit::GameResult* game_result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static ResultData* default_instance_;
};
// -------------------------------------------------------------------

class ScheduleData : public ::google::protobuf::Message {
 public:
  ScheduleData();
  virtual ~ScheduleData();

  ScheduleData(const ScheduleData& from);

  inline ScheduleData& operator=(const ScheduleData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScheduleData& default_instance();

  void Swap(ScheduleData* other);

  // implements Message ----------------------------------------------

  ScheduleData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ScheduleData& from);
  void MergeFrom(const ScheduleData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 week = 1;
  inline bool has_week() const;
  inline void clear_week();
  static const int kWeekFieldNumber = 1;
  inline ::google::protobuf::int32 week() const;
  inline void set_week(::google::protobuf::int32 value);

  // optional .fantasybit.WeeklySchedule weekly = 10;
  inline bool has_weekly() const;
  inline void clear_weekly();
  static const int kWeeklyFieldNumber = 10;
  inline const ::fantasybit::WeeklySchedule& weekly() const;
  inline ::fantasybit::WeeklySchedule* mutable_weekly();
  inline ::fantasybit::WeeklySchedule* release_weekly();
  inline void set_allocated_weekly(::fantasybit::WeeklySchedule* weekly);

  static const int kScheduleDataFieldNumber = 302;
  static ::google::protobuf::internal::ExtensionIdentifier< ::fantasybit::Data,
      ::google::protobuf::internal::MessageTypeTraits< ::fantasybit::ScheduleData >, 11, false >
    schedule_data;
  // @@protoc_insertion_point(class_scope:fantasybit.ScheduleData)
 private:
  inline void set_has_week();
  inline void clear_has_week();
  inline void set_has_weekly();
  inline void clear_has_weekly();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::fantasybit::WeeklySchedule* weekly_;
  ::google::protobuf::int32 week_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static ScheduleData* default_instance_;
};
// -------------------------------------------------------------------

class DataTransition : public ::google::protobuf::Message {
 public:
  DataTransition();
  virtual ~DataTransition();

  DataTransition(const DataTransition& from);

  inline DataTransition& operator=(const DataTransition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataTransition& default_instance();

  void Swap(DataTransition* other);

  // implements Message ----------------------------------------------

  DataTransition* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataTransition& from);
  void MergeFrom(const DataTransition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .fantasybit.TrType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::fantasybit::TrType type() const;
  inline void set_type(::fantasybit::TrType value);

  // optional uint32 season = 10;
  inline bool has_season() const;
  inline void clear_season();
  static const int kSeasonFieldNumber = 10;
  inline ::google::protobuf::uint32 season() const;
  inline void set_season(::google::protobuf::uint32 value);

  // optional uint32 week = 20;
  inline bool has_week() const;
  inline void clear_week();
  static const int kWeekFieldNumber = 20;
  inline ::google::protobuf::uint32 week() const;
  inline void set_week(::google::protobuf::uint32 value);

  // repeated .fantasybit.GameData gamedata = 30;
  inline int gamedata_size() const;
  inline void clear_gamedata();
  static const int kGamedataFieldNumber = 30;
  inline const ::fantasybit::GameData& gamedata(int index) const;
  inline ::fantasybit::GameData* mutable_gamedata(int index);
  inline ::fantasybit::GameData* add_gamedata();
  inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::GameData >&
      gamedata() const;
  inline ::google::protobuf::RepeatedPtrField< ::fantasybit::GameData >*
      mutable_gamedata();

  // repeated .fantasybit.Data data = 40;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 40;
  inline const ::fantasybit::Data& data(int index) const;
  inline ::fantasybit::Data* mutable_data(int index);
  inline ::fantasybit::Data* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::Data >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::fantasybit::Data >*
      mutable_data();

  static const int kDataTransFieldNumber = 203;
  static ::google::protobuf::internal::ExtensionIdentifier< ::fantasybit::Transaction,
      ::google::protobuf::internal::MessageTypeTraits< ::fantasybit::DataTransition >, 11, false >
    data_trans;
  // @@protoc_insertion_point(class_scope:fantasybit.DataTransition)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_season();
  inline void clear_has_season();
  inline void set_has_week();
  inline void clear_has_week();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::uint32 season_;
  ::google::protobuf::RepeatedPtrField< ::fantasybit::GameData > gamedata_;
  ::google::protobuf::RepeatedPtrField< ::fantasybit::Data > data_;
  ::google::protobuf::uint32 week_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static DataTransition* default_instance_;
};
// -------------------------------------------------------------------

class TeamState : public ::google::protobuf::Message {
 public:
  TeamState();
  virtual ~TeamState();

  TeamState(const TeamState& from);

  inline TeamState& operator=(const TeamState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TeamState& default_instance();

  void Swap(TeamState* other);

  // implements Message ----------------------------------------------

  TeamState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TeamState& from);
  void MergeFrom(const TeamState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TeamState_State State;
  static const State PREGAME = TeamState_State_PREGAME;
  static const State INGAME = TeamState_State_INGAME;
  static inline bool State_IsValid(int value) {
    return TeamState_State_IsValid(value);
  }
  static const State State_MIN =
    TeamState_State_State_MIN;
  static const State State_MAX =
    TeamState_State_State_MAX;
  static const int State_ARRAYSIZE =
    TeamState_State_State_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  State_descriptor() {
    return TeamState_State_descriptor();
  }
  static inline const ::std::string& State_Name(State value) {
    return TeamState_State_Name(value);
  }
  static inline bool State_Parse(const ::std::string& name,
      State* value) {
    return TeamState_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .fantasybit.TeamState.State state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::fantasybit::TeamState_State state() const;
  inline void set_state(::fantasybit::TeamState_State value);

  // optional uint32 week = 10;
  inline bool has_week() const;
  inline void clear_week();
  static const int kWeekFieldNumber = 10;
  inline ::google::protobuf::uint32 week() const;
  inline void set_week(::google::protobuf::uint32 value);

  // optional string teamid = 20;
  inline bool has_teamid() const;
  inline void clear_teamid();
  static const int kTeamidFieldNumber = 20;
  inline const ::std::string& teamid() const;
  inline void set_teamid(const ::std::string& value);
  inline void set_teamid(const char* value);
  inline void set_teamid(const char* value, size_t size);
  inline ::std::string* mutable_teamid();
  inline ::std::string* release_teamid();
  inline void set_allocated_teamid(::std::string* teamid);

  // @@protoc_insertion_point(class_scope:fantasybit.TeamState)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_week();
  inline void clear_has_week();
  inline void set_has_teamid();
  inline void clear_has_teamid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int state_;
  ::google::protobuf::uint32 week_;
  ::std::string* teamid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static TeamState* default_instance_;
};
// -------------------------------------------------------------------

class DeltaData : public ::google::protobuf::Message {
 public:
  DeltaData();
  virtual ~DeltaData();

  DeltaData(const DeltaData& from);

  inline DeltaData& operator=(const DeltaData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeltaData& default_instance();

  void Swap(DeltaData* other);

  // implements Message ----------------------------------------------

  DeltaData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeltaData& from);
  void MergeFrom(const DeltaData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef DeltaData_Type Type;
  static const Type SNAPSHOT = DeltaData_Type_SNAPSHOT;
  static const Type HEARTBEAT = DeltaData_Type_HEARTBEAT;
  static inline bool Type_IsValid(int value) {
    return DeltaData_Type_IsValid(value);
  }
  static const Type Type_MIN =
    DeltaData_Type_Type_MIN;
  static const Type Type_MAX =
    DeltaData_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    DeltaData_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return DeltaData_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return DeltaData_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return DeltaData_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .fantasybit.DeltaData.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::fantasybit::DeltaData_Type type() const;
  inline void set_type(::fantasybit::DeltaData_Type value);

  // repeated .fantasybit.MyFantasyName myfantasyname = 2;
  inline int myfantasyname_size() const;
  inline void clear_myfantasyname();
  static const int kMyfantasynameFieldNumber = 2;
  inline const ::fantasybit::MyFantasyName& myfantasyname(int index) const;
  inline ::fantasybit::MyFantasyName* mutable_myfantasyname(int index);
  inline ::fantasybit::MyFantasyName* add_myfantasyname();
  inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::MyFantasyName >&
      myfantasyname() const;
  inline ::google::protobuf::RepeatedPtrField< ::fantasybit::MyFantasyName >*
      mutable_myfantasyname();

  // optional .fantasybit.GlobalState globalstate = 10;
  inline bool has_globalstate() const;
  inline void clear_globalstate();
  static const int kGlobalstateFieldNumber = 10;
  inline const ::fantasybit::GlobalState& globalstate() const;
  inline ::fantasybit::GlobalState* mutable_globalstate();
  inline ::fantasybit::GlobalState* release_globalstate();
  inline void set_allocated_globalstate(::fantasybit::GlobalState* globalstate);

  // repeated .fantasybit.TeamState teamstates = 20;
  inline int teamstates_size() const;
  inline void clear_teamstates();
  static const int kTeamstatesFieldNumber = 20;
  inline const ::fantasybit::TeamState& teamstates(int index) const;
  inline ::fantasybit::TeamState* mutable_teamstates(int index);
  inline ::fantasybit::TeamState* add_teamstates();
  inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::TeamState >&
      teamstates() const;
  inline ::google::protobuf::RepeatedPtrField< ::fantasybit::TeamState >*
      mutable_teamstates();

  // repeated .fantasybit.Data datas = 30;
  inline int datas_size() const;
  inline void clear_datas();
  static const int kDatasFieldNumber = 30;
  inline const ::fantasybit::Data& datas(int index) const;
  inline ::fantasybit::Data* mutable_datas(int index);
  inline ::fantasybit::Data* add_datas();
  inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::Data >&
      datas() const;
  inline ::google::protobuf::RepeatedPtrField< ::fantasybit::Data >*
      mutable_datas();

  // repeated .fantasybit.FantasyPlayer players = 40;
  inline int players_size() const;
  inline void clear_players();
  static const int kPlayersFieldNumber = 40;
  inline const ::fantasybit::FantasyPlayer& players(int index) const;
  inline ::fantasybit::FantasyPlayer* mutable_players(int index);
  inline ::fantasybit::FantasyPlayer* add_players();
  inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::FantasyPlayer >&
      players() const;
  inline ::google::protobuf::RepeatedPtrField< ::fantasybit::FantasyPlayer >*
      mutable_players();

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(DeltaData)
  // @@protoc_insertion_point(class_scope:fantasybit.DeltaData)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_globalstate();
  inline void clear_has_globalstate();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::fantasybit::MyFantasyName > myfantasyname_;
  ::fantasybit::GlobalState* globalstate_;
  ::google::protobuf::RepeatedPtrField< ::fantasybit::TeamState > teamstates_;
  ::google::protobuf::RepeatedPtrField< ::fantasybit::Data > datas_;
  ::google::protobuf::RepeatedPtrField< ::fantasybit::FantasyPlayer > players_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static DeltaData* default_instance_;
};
// -------------------------------------------------------------------

class MessageData : public ::google::protobuf::Message {
 public:
  MessageData();
  virtual ~MessageData();

  MessageData(const MessageData& from);

  inline MessageData& operator=(const MessageData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageData& default_instance();

  void Swap(MessageData* other);

  // implements Message ----------------------------------------------

  MessageData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MessageData& from);
  void MergeFrom(const MessageData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string msg = 10;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 10;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // optional int32 gt = 20;
  inline bool has_gt() const;
  inline void clear_gt();
  static const int kGtFieldNumber = 20;
  inline ::google::protobuf::int32 gt() const;
  inline void set_gt(::google::protobuf::int32 value);

  // optional int32 lt = 30;
  inline bool has_lt() const;
  inline void clear_lt();
  static const int kLtFieldNumber = 30;
  inline ::google::protobuf::int32 lt() const;
  inline void set_lt(::google::protobuf::int32 value);

  static const int kMessageDataFieldNumber = 404;
  static ::google::protobuf::internal::ExtensionIdentifier< ::fantasybit::Data,
      ::google::protobuf::internal::MessageTypeTraits< ::fantasybit::MessageData >, 11, false >
    message_data;
  // @@protoc_insertion_point(class_scope:fantasybit.MessageData)
 private:
  inline void set_has_msg();
  inline void clear_has_msg();
  inline void set_has_gt();
  inline void clear_has_gt();
  inline void set_has_lt();
  inline void clear_has_lt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msg_;
  ::google::protobuf::int32 gt_;
  ::google::protobuf::int32 lt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static MessageData* default_instance_;
};
// -------------------------------------------------------------------

class StampedTrans : public ::google::protobuf::Message {
 public:
  StampedTrans();
  virtual ~StampedTrans();

  StampedTrans(const StampedTrans& from);

  inline StampedTrans& operator=(const StampedTrans& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StampedTrans& default_instance();

  void Swap(StampedTrans* other);

  // implements Message ----------------------------------------------

  StampedTrans* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StampedTrans& from);
  void MergeFrom(const StampedTrans& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 timestamp = 10;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 10;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);

  // optional int32 seqnum = 20;
  inline bool has_seqnum() const;
  inline void clear_seqnum();
  static const int kSeqnumFieldNumber = 20;
  inline ::google::protobuf::int32 seqnum() const;
  inline void set_seqnum(::google::protobuf::int32 value);

  // optional int32 prevseq = 21;
  inline bool has_prevseq() const;
  inline void clear_prevseq();
  static const int kPrevseqFieldNumber = 21;
  inline ::google::protobuf::int32 prevseq() const;
  inline void set_prevseq(::google::protobuf::int32 value);

  // optional .fantasybit.SignedTransaction signed_orig = 30;
  inline bool has_signed_orig() const;
  inline void clear_signed_orig();
  static const int kSignedOrigFieldNumber = 30;
  inline const ::fantasybit::SignedTransaction& signed_orig() const;
  inline ::fantasybit::SignedTransaction* mutable_signed_orig();
  inline ::fantasybit::SignedTransaction* release_signed_orig();
  inline void set_allocated_signed_orig(::fantasybit::SignedTransaction* signed_orig);

  static const int kStampedTransFieldNumber = 300;
  static ::google::protobuf::internal::ExtensionIdentifier< ::fantasybit::Transaction,
      ::google::protobuf::internal::MessageTypeTraits< ::fantasybit::StampedTrans >, 11, false >
    stamped_trans;
  // @@protoc_insertion_point(class_scope:fantasybit.StampedTrans)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_seqnum();
  inline void clear_has_seqnum();
  inline void set_has_prevseq();
  inline void clear_has_prevseq();
  inline void set_has_signed_orig();
  inline void clear_has_signed_orig();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::int32 seqnum_;
  ::google::protobuf::int32 prevseq_;
  ::fantasybit::SignedTransaction* signed_orig_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static StampedTrans* default_instance_;
};
// -------------------------------------------------------------------

class ExchangeOrder : public ::google::protobuf::Message {
 public:
  ExchangeOrder();
  virtual ~ExchangeOrder();

  ExchangeOrder(const ExchangeOrder& from);

  inline ExchangeOrder& operator=(const ExchangeOrder& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExchangeOrder& default_instance();

  void Swap(ExchangeOrder* other);

  // implements Message ----------------------------------------------

  ExchangeOrder* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExchangeOrder& from);
  void MergeFrom(const ExchangeOrder& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ExchangeOrder_Type Type;
  static const Type NEW = ExchangeOrder_Type_NEW;
  static const Type CANCEL = ExchangeOrder_Type_CANCEL;
  static const Type REPLACE = ExchangeOrder_Type_REPLACE;
  static inline bool Type_IsValid(int value) {
    return ExchangeOrder_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ExchangeOrder_Type_Type_MIN;
  static const Type Type_MAX =
    ExchangeOrder_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ExchangeOrder_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ExchangeOrder_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ExchangeOrder_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ExchangeOrder_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .fantasybit.ExchangeOrder.Type type = 10;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 10;
  inline ::fantasybit::ExchangeOrder_Type type() const;
  inline void set_type(::fantasybit::ExchangeOrder_Type value);

  // optional string playerid = 40;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 40;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  inline void set_allocated_playerid(::std::string* playerid);

  // optional .fantasybit.OrderCore core = 50;
  inline bool has_core() const;
  inline void clear_core();
  static const int kCoreFieldNumber = 50;
  inline const ::fantasybit::OrderCore& core() const;
  inline ::fantasybit::OrderCore* mutable_core();
  inline ::fantasybit::OrderCore* release_core();
  inline void set_allocated_core(::fantasybit::OrderCore* core);

  // optional int32 cancel_oref = 100;
  inline bool has_cancel_oref() const;
  inline void clear_cancel_oref();
  static const int kCancelOrefFieldNumber = 100;
  inline ::google::protobuf::int32 cancel_oref() const;
  inline void set_cancel_oref(::google::protobuf::int32 value);

  // optional .fantasybit.FutContract futcontract = 110;
  inline bool has_futcontract() const;
  inline void clear_futcontract();
  static const int kFutcontractFieldNumber = 110;
  inline const ::fantasybit::FutContract& futcontract() const;
  inline ::fantasybit::FutContract* mutable_futcontract();
  inline ::fantasybit::FutContract* release_futcontract();
  inline void set_allocated_futcontract(::fantasybit::FutContract* futcontract);

  // optional string symbol = 120;
  inline bool has_symbol() const;
  inline void clear_symbol();
  static const int kSymbolFieldNumber = 120;
  inline const ::std::string& symbol() const;
  inline void set_symbol(const ::std::string& value);
  inline void set_symbol(const char* value);
  inline void set_symbol(const char* value, size_t size);
  inline ::std::string* mutable_symbol();
  inline ::std::string* release_symbol();
  inline void set_allocated_symbol(::std::string* symbol);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(ExchangeOrder)
  static const int kExchangeOrderFieldNumber = 310;
  static ::google::protobuf::internal::ExtensionIdentifier< ::fantasybit::Transaction,
      ::google::protobuf::internal::MessageTypeTraits< ::fantasybit::ExchangeOrder >, 11, false >
    exchange_order;
  // @@protoc_insertion_point(class_scope:fantasybit.ExchangeOrder)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_core();
  inline void clear_has_core();
  inline void set_has_cancel_oref();
  inline void clear_has_cancel_oref();
  inline void set_has_futcontract();
  inline void clear_has_futcontract();
  inline void set_has_symbol();
  inline void clear_has_symbol();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* playerid_;
  int type_;
  ::google::protobuf::int32 cancel_oref_;
  ::fantasybit::OrderCore* core_;
  ::fantasybit::FutContract* futcontract_;
  ::std::string* symbol_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static ExchangeOrder* default_instance_;
};
// -------------------------------------------------------------------

class OrderUnique : public ::google::protobuf::Message {
 public:
  OrderUnique();
  virtual ~OrderUnique();

  OrderUnique(const OrderUnique& from);

  inline OrderUnique& operator=(const OrderUnique& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OrderUnique& default_instance();

  void Swap(OrderUnique* other);

  // implements Message ----------------------------------------------

  OrderUnique* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OrderUnique& from);
  void MergeFrom(const OrderUnique& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string public_key = 10;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 10;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const char* value, size_t size);
  inline ::std::string* mutable_public_key();
  inline ::std::string* release_public_key();
  inline void set_allocated_public_key(::std::string* public_key);

  // optional uint32 season = 20;
  inline bool has_season() const;
  inline void clear_season();
  static const int kSeasonFieldNumber = 20;
  inline ::google::protobuf::uint32 season() const;
  inline void set_season(::google::protobuf::uint32 value);

  // optional uint32 week = 30;
  inline bool has_week() const;
  inline void clear_week();
  static const int kWeekFieldNumber = 30;
  inline ::google::protobuf::uint32 week() const;
  inline void set_week(::google::protobuf::uint32 value);

  // optional bool buyside = 40;
  inline bool has_buyside() const;
  inline void clear_buyside();
  static const int kBuysideFieldNumber = 40;
  inline bool buyside() const;
  inline void set_buyside(bool value);

  // optional string playerid = 50;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 50;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  inline void set_allocated_playerid(::std::string* playerid);

  // optional int32 price = 70;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 70;
  inline ::google::protobuf::int32 price() const;
  inline void set_price(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fantasybit.OrderUnique)
 private:
  inline void set_has_public_key();
  inline void clear_has_public_key();
  inline void set_has_season();
  inline void clear_has_season();
  inline void set_has_week();
  inline void clear_has_week();
  inline void set_has_buyside();
  inline void clear_has_buyside();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_price();
  inline void clear_has_price();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* public_key_;
  ::google::protobuf::uint32 season_;
  ::google::protobuf::uint32 week_;
  ::std::string* playerid_;
  bool buyside_;
  ::google::protobuf::int32 price_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static OrderUnique* default_instance_;
};
// -------------------------------------------------------------------

class OrderDeets : public ::google::protobuf::Message {
 public:
  OrderDeets();
  virtual ~OrderDeets();

  OrderDeets(const OrderDeets& from);

  inline OrderDeets& operator=(const OrderDeets& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OrderDeets& default_instance();

  void Swap(OrderDeets* other);

  // implements Message ----------------------------------------------

  OrderDeets* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OrderDeets& from);
  void MergeFrom(const OrderDeets& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes oid = 10;
  inline bool has_oid() const;
  inline void clear_oid();
  static const int kOidFieldNumber = 10;
  inline const ::std::string& oid() const;
  inline void set_oid(const ::std::string& value);
  inline void set_oid(const char* value);
  inline void set_oid(const void* value, size_t size);
  inline ::std::string* mutable_oid();
  inline ::std::string* release_oid();
  inline void set_allocated_oid(::std::string* oid);

  // optional .fantasybit.OrderUnique order = 20;
  inline bool has_order() const;
  inline void clear_order();
  static const int kOrderFieldNumber = 20;
  inline const ::fantasybit::OrderUnique& order() const;
  inline ::fantasybit::OrderUnique* mutable_order();
  inline ::fantasybit::OrderUnique* release_order();
  inline void set_allocated_order(::fantasybit::OrderUnique* order);

  // optional int32 size = 30;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 30;
  inline ::google::protobuf::int32 size() const;
  inline void set_size(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fantasybit.OrderDeets)
 private:
  inline void set_has_oid();
  inline void clear_has_oid();
  inline void set_has_order();
  inline void clear_has_order();
  inline void set_has_size();
  inline void clear_has_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* oid_;
  ::fantasybit::OrderUnique* order_;
  ::google::protobuf::int32 size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static OrderDeets* default_instance_;
};
// -------------------------------------------------------------------

class InsideUnique : public ::google::protobuf::Message {
 public:
  InsideUnique();
  virtual ~InsideUnique();

  InsideUnique(const InsideUnique& from);

  inline InsideUnique& operator=(const InsideUnique& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InsideUnique& default_instance();

  void Swap(InsideUnique* other);

  // implements Message ----------------------------------------------

  InsideUnique* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InsideUnique& from);
  void MergeFrom(const InsideUnique& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string playerid = 50;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 50;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  inline void set_allocated_playerid(::std::string* playerid);

  // optional string public_key = 10;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 10;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const char* value, size_t size);
  inline ::std::string* mutable_public_key();
  inline ::std::string* release_public_key();
  inline void set_allocated_public_key(::std::string* public_key);

  // optional bool buyside = 40;
  inline bool has_buyside() const;
  inline void clear_buyside();
  static const int kBuysideFieldNumber = 40;
  inline bool buyside() const;
  inline void set_buyside(bool value);

  // optional int32 price = 70;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 70;
  inline ::google::protobuf::int32 price() const;
  inline void set_price(::google::protobuf::int32 value);

  // optional bytes oid = 11;
  inline bool has_oid() const;
  inline void clear_oid();
  static const int kOidFieldNumber = 11;
  inline const ::std::string& oid() const;
  inline void set_oid(const ::std::string& value);
  inline void set_oid(const char* value);
  inline void set_oid(const void* value, size_t size);
  inline ::std::string* mutable_oid();
  inline ::std::string* release_oid();
  inline void set_allocated_oid(::std::string* oid);

  // optional .fantasybit.OrderUnique order = 20;
  inline bool has_order() const;
  inline void clear_order();
  static const int kOrderFieldNumber = 20;
  inline const ::fantasybit::OrderUnique& order() const;
  inline ::fantasybit::OrderUnique* mutable_order();
  inline ::fantasybit::OrderUnique* release_order();
  inline void set_allocated_order(::fantasybit::OrderUnique* order);

  // optional int32 size = 30;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 30;
  inline ::google::protobuf::int32 size() const;
  inline void set_size(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fantasybit.InsideUnique)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_public_key();
  inline void clear_has_public_key();
  inline void set_has_buyside();
  inline void clear_has_buyside();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_oid();
  inline void clear_has_oid();
  inline void set_has_order();
  inline void clear_has_order();
  inline void set_has_size();
  inline void clear_has_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* playerid_;
  ::std::string* public_key_;
  bool buyside_;
  ::google::protobuf::int32 price_;
  ::std::string* oid_;
  ::fantasybit::OrderUnique* order_;
  ::google::protobuf::int32 size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static InsideUnique* default_instance_;
};
// -------------------------------------------------------------------

class TimeTransition : public ::google::protobuf::Message {
 public:
  TimeTransition();
  virtual ~TimeTransition();

  TimeTransition(const TimeTransition& from);

  inline TimeTransition& operator=(const TimeTransition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TimeTransition& default_instance();

  void Swap(TimeTransition* other);

  // implements Message ----------------------------------------------

  TimeTransition* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TimeTransition& from);
  void MergeFrom(const TimeTransition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TimeTransition_Type Type;
  static const Type TRADEOPEN = TimeTransition_Type_TRADEOPEN;
  static const Type TRADECLOSE = TimeTransition_Type_TRADECLOSE;
  static inline bool Type_IsValid(int value) {
    return TimeTransition_Type_IsValid(value);
  }
  static const Type Type_MIN =
    TimeTransition_Type_Type_MIN;
  static const Type Type_MAX =
    TimeTransition_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    TimeTransition_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return TimeTransition_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return TimeTransition_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return TimeTransition_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .fantasybit.TimeTransition.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::fantasybit::TimeTransition_Type type() const;
  inline void set_type(::fantasybit::TimeTransition_Type value);

  // optional uint32 season = 10;
  inline bool has_season() const;
  inline void clear_season();
  static const int kSeasonFieldNumber = 10;
  inline ::google::protobuf::uint32 season() const;
  inline void set_season(::google::protobuf::uint32 value);

  // optional uint32 week = 20;
  inline bool has_week() const;
  inline void clear_week();
  static const int kWeekFieldNumber = 20;
  inline ::google::protobuf::uint32 week() const;
  inline void set_week(::google::protobuf::uint32 value);

  static const int kTimeTransFieldNumber = 303;
  static ::google::protobuf::internal::ExtensionIdentifier< ::fantasybit::Transaction,
      ::google::protobuf::internal::MessageTypeTraits< ::fantasybit::TimeTransition >, 11, false >
    time_trans;
  // @@protoc_insertion_point(class_scope:fantasybit.TimeTransition)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_season();
  inline void clear_has_season();
  inline void set_has_week();
  inline void clear_has_week();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::uint32 season_;
  ::google::protobuf::uint32 week_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static TimeTransition* default_instance_;
};
// -------------------------------------------------------------------

class Bitcoin_UTXO : public ::google::protobuf::Message {
 public:
  Bitcoin_UTXO();
  virtual ~Bitcoin_UTXO();

  Bitcoin_UTXO(const Bitcoin_UTXO& from);

  inline Bitcoin_UTXO& operator=(const Bitcoin_UTXO& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Bitcoin_UTXO& default_instance();

  void Swap(Bitcoin_UTXO* other);

  // implements Message ----------------------------------------------

  Bitcoin_UTXO* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Bitcoin_UTXO& from);
  void MergeFrom(const Bitcoin_UTXO& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes txid = 10;
  inline bool has_txid() const;
  inline void clear_txid();
  static const int kTxidFieldNumber = 10;
  inline const ::std::string& txid() const;
  inline void set_txid(const ::std::string& value);
  inline void set_txid(const char* value);
  inline void set_txid(const void* value, size_t size);
  inline ::std::string* mutable_txid();
  inline ::std::string* release_txid();
  inline void set_allocated_txid(::std::string* txid);

  // optional uint32 tx_output_n = 20;
  inline bool has_tx_output_n() const;
  inline void clear_tx_output_n();
  static const int kTxOutputNFieldNumber = 20;
  inline ::google::protobuf::uint32 tx_output_n() const;
  inline void set_tx_output_n(::google::protobuf::uint32 value);

  // optional uint64 in_value = 30;
  inline bool has_in_value() const;
  inline void clear_in_value();
  static const int kInValueFieldNumber = 30;
  inline ::google::protobuf::uint64 in_value() const;
  inline void set_in_value(::google::protobuf::uint64 value);

  // optional bytes locking_script = 40;
  inline bool has_locking_script() const;
  inline void clear_locking_script();
  static const int kLockingScriptFieldNumber = 40;
  inline const ::std::string& locking_script() const;
  inline void set_locking_script(const ::std::string& value);
  inline void set_locking_script(const char* value);
  inline void set_locking_script(const void* value, size_t size);
  inline ::std::string* mutable_locking_script();
  inline ::std::string* release_locking_script();
  inline void set_allocated_locking_script(::std::string* locking_script);

  // @@protoc_insertion_point(class_scope:fantasybit.Bitcoin_UTXO)
 private:
  inline void set_has_txid();
  inline void clear_has_txid();
  inline void set_has_tx_output_n();
  inline void clear_has_tx_output_n();
  inline void set_has_in_value();
  inline void clear_has_in_value();
  inline void set_has_locking_script();
  inline void clear_has_locking_script();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* txid_;
  ::google::protobuf::uint64 in_value_;
  ::std::string* locking_script_;
  ::google::protobuf::uint32 tx_output_n_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static Bitcoin_UTXO* default_instance_;
};
// -------------------------------------------------------------------

class Bitcoin_UTXOS : public ::google::protobuf::Message {
 public:
  Bitcoin_UTXOS();
  virtual ~Bitcoin_UTXOS();

  Bitcoin_UTXOS(const Bitcoin_UTXOS& from);

  inline Bitcoin_UTXOS& operator=(const Bitcoin_UTXOS& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Bitcoin_UTXOS& default_instance();

  void Swap(Bitcoin_UTXOS* other);

  // implements Message ----------------------------------------------

  Bitcoin_UTXOS* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Bitcoin_UTXOS& from);
  void MergeFrom(const Bitcoin_UTXOS& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 total_value = 10;
  inline bool has_total_value() const;
  inline void clear_total_value();
  static const int kTotalValueFieldNumber = 10;
  inline ::google::protobuf::uint64 total_value() const;
  inline void set_total_value(::google::protobuf::uint64 value);

  // repeated .fantasybit.Bitcoin_UTXO utxo = 20;
  inline int utxo_size() const;
  inline void clear_utxo();
  static const int kUtxoFieldNumber = 20;
  inline const ::fantasybit::Bitcoin_UTXO& utxo(int index) const;
  inline ::fantasybit::Bitcoin_UTXO* mutable_utxo(int index);
  inline ::fantasybit::Bitcoin_UTXO* add_utxo();
  inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::Bitcoin_UTXO >&
      utxo() const;
  inline ::google::protobuf::RepeatedPtrField< ::fantasybit::Bitcoin_UTXO >*
      mutable_utxo();

  // @@protoc_insertion_point(class_scope:fantasybit.Bitcoin_UTXOS)
 private:
  inline void set_has_total_value();
  inline void clear_has_total_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 total_value_;
  ::google::protobuf::RepeatedPtrField< ::fantasybit::Bitcoin_UTXO > utxo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static Bitcoin_UTXOS* default_instance_;
};
// -------------------------------------------------------------------

class SwapAsk : public ::google::protobuf::Message {
 public:
  SwapAsk();
  virtual ~SwapAsk();

  SwapAsk(const SwapAsk& from);

  inline SwapAsk& operator=(const SwapAsk& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SwapAsk& default_instance();

  void Swap(SwapAsk* other);

  // implements Message ----------------------------------------------

  SwapAsk* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SwapAsk& from);
  void MergeFrom(const SwapAsk& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 satoshi_min = 10;
  inline bool has_satoshi_min() const;
  inline void clear_satoshi_min();
  static const int kSatoshiMinFieldNumber = 10;
  inline ::google::protobuf::uint64 satoshi_min() const;
  inline void set_satoshi_min(::google::protobuf::uint64 value);

  // optional uint64 satoshi_max = 11;
  inline bool has_satoshi_max() const;
  inline void clear_satoshi_max();
  static const int kSatoshiMaxFieldNumber = 11;
  inline ::google::protobuf::uint64 satoshi_max() const;
  inline void set_satoshi_max(::google::protobuf::uint64 value);

  // optional uint64 rate = 20;
  inline bool has_rate() const;
  inline void clear_rate();
  static const int kRateFieldNumber = 20;
  inline ::google::protobuf::uint64 rate() const;
  inline void set_rate(::google::protobuf::uint64 value);

  // optional uint64 fb_qty = 30;
  inline bool has_fb_qty() const;
  inline void clear_fb_qty();
  static const int kFbQtyFieldNumber = 30;
  inline ::google::protobuf::uint64 fb_qty() const;
  inline void set_fb_qty(::google::protobuf::uint64 value);

  static const int kSwapaskTranFieldNumber = 450;
  static ::google::protobuf::internal::ExtensionIdentifier< ::fantasybit::Transaction,
      ::google::protobuf::internal::MessageTypeTraits< ::fantasybit::SwapAsk >, 11, false >
    swapask_tran;
  // @@protoc_insertion_point(class_scope:fantasybit.SwapAsk)
 private:
  inline void set_has_satoshi_min();
  inline void clear_has_satoshi_min();
  inline void set_has_satoshi_max();
  inline void clear_has_satoshi_max();
  inline void set_has_rate();
  inline void clear_has_rate();
  inline void set_has_fb_qty();
  inline void clear_has_fb_qty();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 satoshi_min_;
  ::google::protobuf::uint64 satoshi_max_;
  ::google::protobuf::uint64 rate_;
  ::google::protobuf::uint64 fb_qty_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static SwapAsk* default_instance_;
};
// -------------------------------------------------------------------

class SwapBid : public ::google::protobuf::Message {
 public:
  SwapBid();
  virtual ~SwapBid();

  SwapBid(const SwapBid& from);

  inline SwapBid& operator=(const SwapBid& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SwapBid& default_instance();

  void Swap(SwapBid* other);

  // implements Message ----------------------------------------------

  SwapBid* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SwapBid& from);
  void MergeFrom(const SwapBid& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 satoshi_min = 10;
  inline bool has_satoshi_min() const;
  inline void clear_satoshi_min();
  static const int kSatoshiMinFieldNumber = 10;
  inline ::google::protobuf::uint64 satoshi_min() const;
  inline void set_satoshi_min(::google::protobuf::uint64 value);

  // optional uint64 satoshi_max = 11;
  inline bool has_satoshi_max() const;
  inline void clear_satoshi_max();
  static const int kSatoshiMaxFieldNumber = 11;
  inline ::google::protobuf::uint64 satoshi_max() const;
  inline void set_satoshi_max(::google::protobuf::uint64 value);

  // optional uint64 rate = 20;
  inline bool has_rate() const;
  inline void clear_rate();
  static const int kRateFieldNumber = 20;
  inline ::google::protobuf::uint64 rate() const;
  inline void set_rate(::google::protobuf::uint64 value);

  // optional .fantasybit.Bitcoin_UTXOS utxos = 30;
  inline bool has_utxos() const;
  inline void clear_utxos();
  static const int kUtxosFieldNumber = 30;
  inline const ::fantasybit::Bitcoin_UTXOS& utxos() const;
  inline ::fantasybit::Bitcoin_UTXOS* mutable_utxos();
  inline ::fantasybit::Bitcoin_UTXOS* release_utxos();
  inline void set_allocated_utxos(::fantasybit::Bitcoin_UTXOS* utxos);

  // optional bytes change_addr = 40;
  inline bool has_change_addr() const;
  inline void clear_change_addr();
  static const int kChangeAddrFieldNumber = 40;
  inline const ::std::string& change_addr() const;
  inline void set_change_addr(const ::std::string& value);
  inline void set_change_addr(const char* value);
  inline void set_change_addr(const void* value, size_t size);
  inline ::std::string* mutable_change_addr();
  inline ::std::string* release_change_addr();
  inline void set_allocated_change_addr(::std::string* change_addr);

  // optional .fantasybit.SwapAsk this_offer = 50;
  inline bool has_this_offer() const;
  inline void clear_this_offer();
  static const int kThisOfferFieldNumber = 50;
  inline const ::fantasybit::SwapAsk& this_offer() const;
  inline ::fantasybit::SwapAsk* mutable_this_offer();
  inline ::fantasybit::SwapAsk* release_this_offer();
  inline void set_allocated_this_offer(::fantasybit::SwapAsk* this_offer);

  // optional string counteroffer = 60;
  inline bool has_counteroffer() const;
  inline void clear_counteroffer();
  static const int kCounterofferFieldNumber = 60;
  inline const ::std::string& counteroffer() const;
  inline void set_counteroffer(const ::std::string& value);
  inline void set_counteroffer(const char* value);
  inline void set_counteroffer(const char* value, size_t size);
  inline ::std::string* mutable_counteroffer();
  inline ::std::string* release_counteroffer();
  inline void set_allocated_counteroffer(::std::string* counteroffer);

  static const int kSwapbidTranFieldNumber = 500;
  static ::google::protobuf::internal::ExtensionIdentifier< ::fantasybit::Transaction,
      ::google::protobuf::internal::MessageTypeTraits< ::fantasybit::SwapBid >, 11, false >
    swapbid_tran;
  // @@protoc_insertion_point(class_scope:fantasybit.SwapBid)
 private:
  inline void set_has_satoshi_min();
  inline void clear_has_satoshi_min();
  inline void set_has_satoshi_max();
  inline void clear_has_satoshi_max();
  inline void set_has_rate();
  inline void clear_has_rate();
  inline void set_has_utxos();
  inline void clear_has_utxos();
  inline void set_has_change_addr();
  inline void clear_has_change_addr();
  inline void set_has_this_offer();
  inline void clear_has_this_offer();
  inline void set_has_counteroffer();
  inline void clear_has_counteroffer();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 satoshi_min_;
  ::google::protobuf::uint64 satoshi_max_;
  ::google::protobuf::uint64 rate_;
  ::fantasybit::Bitcoin_UTXOS* utxos_;
  ::std::string* change_addr_;
  ::fantasybit::SwapAsk* this_offer_;
  ::std::string* counteroffer_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static SwapBid* default_instance_;
};
// -------------------------------------------------------------------

class SwapFill : public ::google::protobuf::Message {
 public:
  SwapFill();
  virtual ~SwapFill();

  SwapFill(const SwapFill& from);

  inline SwapFill& operator=(const SwapFill& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SwapFill& default_instance();

  void Swap(SwapFill* other);

  // implements Message ----------------------------------------------

  SwapFill* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SwapFill& from);
  void MergeFrom(const SwapFill& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .fantasybit.SwapBid swapbid = 10;
  inline bool has_swapbid() const;
  inline void clear_swapbid();
  static const int kSwapbidFieldNumber = 10;
  inline const ::fantasybit::SwapBid& swapbid() const;
  inline ::fantasybit::SwapBid* mutable_swapbid();
  inline ::fantasybit::SwapBid* release_swapbid();
  inline void set_allocated_swapbid(::fantasybit::SwapBid* swapbid);

  // optional bytes hash_to_sign = 20;
  inline bool has_hash_to_sign() const;
  inline void clear_hash_to_sign();
  static const int kHashToSignFieldNumber = 20;
  inline const ::std::string& hash_to_sign() const;
  inline void set_hash_to_sign(const ::std::string& value);
  inline void set_hash_to_sign(const char* value);
  inline void set_hash_to_sign(const void* value, size_t size);
  inline ::std::string* mutable_hash_to_sign();
  inline ::std::string* release_hash_to_sign();
  inline void set_allocated_hash_to_sign(::std::string* hash_to_sign);

  // optional uint64 satoshi_fee = 30;
  inline bool has_satoshi_fee() const;
  inline void clear_satoshi_fee();
  static const int kSatoshiFeeFieldNumber = 30;
  inline ::google::protobuf::uint64 satoshi_fee() const;
  inline void set_satoshi_fee(::google::protobuf::uint64 value);

  // optional uint64 fb_qty = 40;
  inline bool has_fb_qty() const;
  inline void clear_fb_qty();
  static const int kFbQtyFieldNumber = 40;
  inline ::google::protobuf::uint64 fb_qty() const;
  inline void set_fb_qty(::google::protobuf::uint64 value);

  // optional string counterparty = 50;
  inline bool has_counterparty() const;
  inline void clear_counterparty();
  static const int kCounterpartyFieldNumber = 50;
  inline const ::std::string& counterparty() const;
  inline void set_counterparty(const ::std::string& value);
  inline void set_counterparty(const char* value);
  inline void set_counterparty(const char* value, size_t size);
  inline ::std::string* mutable_counterparty();
  inline ::std::string* release_counterparty();
  inline void set_allocated_counterparty(::std::string* counterparty);

  static const int kSwapfilTranFieldNumber = 600;
  static ::google::protobuf::internal::ExtensionIdentifier< ::fantasybit::Transaction,
      ::google::protobuf::internal::MessageTypeTraits< ::fantasybit::SwapFill >, 11, false >
    swapfil_tran;
  // @@protoc_insertion_point(class_scope:fantasybit.SwapFill)
 private:
  inline void set_has_swapbid();
  inline void clear_has_swapbid();
  inline void set_has_hash_to_sign();
  inline void clear_has_hash_to_sign();
  inline void set_has_satoshi_fee();
  inline void clear_has_satoshi_fee();
  inline void set_has_fb_qty();
  inline void clear_has_fb_qty();
  inline void set_has_counterparty();
  inline void clear_has_counterparty();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::fantasybit::SwapBid* swapbid_;
  ::std::string* hash_to_sign_;
  ::google::protobuf::uint64 satoshi_fee_;
  ::google::protobuf::uint64 fb_qty_;
  ::std::string* counterparty_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static SwapFill* default_instance_;
};
// -------------------------------------------------------------------

class SwapSent : public ::google::protobuf::Message {
 public:
  SwapSent();
  virtual ~SwapSent();

  SwapSent(const SwapSent& from);

  inline SwapSent& operator=(const SwapSent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SwapSent& default_instance();

  void Swap(SwapSent* other);

  // implements Message ----------------------------------------------

  SwapSent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SwapSent& from);
  void MergeFrom(const SwapSent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .fantasybit.SwapFill swapfill = 10;
  inline bool has_swapfill() const;
  inline void clear_swapfill();
  static const int kSwapfillFieldNumber = 10;
  inline const ::fantasybit::SwapFill& swapfill() const;
  inline ::fantasybit::SwapFill* mutable_swapfill();
  inline ::fantasybit::SwapFill* release_swapfill();
  inline void set_allocated_swapfill(::fantasybit::SwapFill* swapfill);

  // optional bytes sig = 20;
  inline bool has_sig() const;
  inline void clear_sig();
  static const int kSigFieldNumber = 20;
  inline const ::std::string& sig() const;
  inline void set_sig(const ::std::string& value);
  inline void set_sig(const char* value);
  inline void set_sig(const void* value, size_t size);
  inline ::std::string* mutable_sig();
  inline ::std::string* release_sig();
  inline void set_allocated_sig(::std::string* sig);

  static const int kSwapsentTranFieldNumber = 700;
  static ::google::protobuf::internal::ExtensionIdentifier< ::fantasybit::Transaction,
      ::google::protobuf::internal::MessageTypeTraits< ::fantasybit::SwapSent >, 11, false >
    swapsent_tran;
  // @@protoc_insertion_point(class_scope:fantasybit.SwapSent)
 private:
  inline void set_has_swapfill();
  inline void clear_has_swapfill();
  inline void set_has_sig();
  inline void clear_has_sig();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::fantasybit::SwapFill* swapfill_;
  ::std::string* sig_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static SwapSent* default_instance_;
};
// -------------------------------------------------------------------

class ProofOfDoubleSpend : public ::google::protobuf::Message {
 public:
  ProofOfDoubleSpend();
  virtual ~ProofOfDoubleSpend();

  ProofOfDoubleSpend(const ProofOfDoubleSpend& from);

  inline ProofOfDoubleSpend& operator=(const ProofOfDoubleSpend& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProofOfDoubleSpend& default_instance();

  void Swap(ProofOfDoubleSpend* other);

  // implements Message ----------------------------------------------

  ProofOfDoubleSpend* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProofOfDoubleSpend& from);
  void MergeFrom(const ProofOfDoubleSpend& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .fantasybit.SwapSent swapsent = 10;
  inline bool has_swapsent() const;
  inline void clear_swapsent();
  static const int kSwapsentFieldNumber = 10;
  inline const ::fantasybit::SwapSent& swapsent() const;
  inline ::fantasybit::SwapSent* mutable_swapsent();
  inline ::fantasybit::SwapSent* release_swapsent();
  inline void set_allocated_swapsent(::fantasybit::SwapSent* swapsent);

  // optional .fantasybit.Bitcoin_UTXO utxo = 20;
  inline bool has_utxo() const;
  inline void clear_utxo();
  static const int kUtxoFieldNumber = 20;
  inline const ::fantasybit::Bitcoin_UTXO& utxo() const;
  inline ::fantasybit::Bitcoin_UTXO* mutable_utxo();
  inline ::fantasybit::Bitcoin_UTXO* release_utxo();
  inline void set_allocated_utxo(::fantasybit::Bitcoin_UTXO* utxo);

  // optional bytes pre = 30;
  inline bool has_pre() const;
  inline void clear_pre();
  static const int kPreFieldNumber = 30;
  inline const ::std::string& pre() const;
  inline void set_pre(const ::std::string& value);
  inline void set_pre(const char* value);
  inline void set_pre(const void* value, size_t size);
  inline ::std::string* mutable_pre();
  inline ::std::string* release_pre();
  inline void set_allocated_pre(::std::string* pre);

  // optional bytes post = 40;
  inline bool has_post() const;
  inline void clear_post();
  static const int kPostFieldNumber = 40;
  inline const ::std::string& post() const;
  inline void set_post(const ::std::string& value);
  inline void set_post(const char* value);
  inline void set_post(const void* value, size_t size);
  inline ::std::string* mutable_post();
  inline ::std::string* release_post();
  inline void set_allocated_post(::std::string* post);

  // optional bytes sig = 50;
  inline bool has_sig() const;
  inline void clear_sig();
  static const int kSigFieldNumber = 50;
  inline const ::std::string& sig() const;
  inline void set_sig(const ::std::string& value);
  inline void set_sig(const char* value);
  inline void set_sig(const void* value, size_t size);
  inline ::std::string* mutable_sig();
  inline ::std::string* release_sig();
  inline void set_allocated_sig(::std::string* sig);

  static const int kPodpTranFieldNumber = 800;
  static ::google::protobuf::internal::ExtensionIdentifier< ::fantasybit::Transaction,
      ::google::protobuf::internal::MessageTypeTraits< ::fantasybit::ProofOfDoubleSpend >, 11, false >
    podp_tran;
  // @@protoc_insertion_point(class_scope:fantasybit.ProofOfDoubleSpend)
 private:
  inline void set_has_swapsent();
  inline void clear_has_swapsent();
  inline void set_has_utxo();
  inline void clear_has_utxo();
  inline void set_has_pre();
  inline void clear_has_pre();
  inline void set_has_post();
  inline void clear_has_post();
  inline void set_has_sig();
  inline void clear_has_sig();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::fantasybit::SwapSent* swapsent_;
  ::fantasybit::Bitcoin_UTXO* utxo_;
  ::std::string* pre_;
  ::std::string* post_;
  ::std::string* sig_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static ProofOfDoubleSpend* default_instance_;
};
// -------------------------------------------------------------------

class SwapSentAck : public ::google::protobuf::Message {
 public:
  SwapSentAck();
  virtual ~SwapSentAck();

  SwapSentAck(const SwapSentAck& from);

  inline SwapSentAck& operator=(const SwapSentAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SwapSentAck& default_instance();

  void Swap(SwapSentAck* other);

  // implements Message ----------------------------------------------

  SwapSentAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SwapSentAck& from);
  void MergeFrom(const SwapSentAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .fantasybit.SwapSent swapsent = 10;
  inline bool has_swapsent() const;
  inline void clear_swapsent();
  static const int kSwapsentFieldNumber = 10;
  inline const ::fantasybit::SwapSent& swapsent() const;
  inline ::fantasybit::SwapSent* mutable_swapsent();
  inline ::fantasybit::SwapSent* release_swapsent();
  inline void set_allocated_swapsent(::fantasybit::SwapSent* swapsent);

  static const int kSwapsentackTranFieldNumber = 810;
  static ::google::protobuf::internal::ExtensionIdentifier< ::fantasybit::Transaction,
      ::google::protobuf::internal::MessageTypeTraits< ::fantasybit::SwapSentAck >, 11, false >
    swapsentack_tran;
  // @@protoc_insertion_point(class_scope:fantasybit.SwapSentAck)
 private:
  inline void set_has_swapsent();
  inline void clear_has_swapsent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::fantasybit::SwapSent* swapsent_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoData_2eproto();
  friend void protobuf_AssignDesc_ProtoData_2eproto();
  friend void protobuf_ShutdownFile_ProtoData_2eproto();

  void InitAsDefaultInstance();
  static SwapSentAck* default_instance_;
};
// ===================================================================


// ===================================================================

// MyFantasyName

// optional string name = 1;
inline bool MyFantasyName::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MyFantasyName::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MyFantasyName::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MyFantasyName::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& MyFantasyName::name() const {
  return *name_;
}
inline void MyFantasyName::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MyFantasyName::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MyFantasyName::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MyFantasyName::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* MyFantasyName::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MyFantasyName::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .fantasybit.MyNameStatus status = 2;
inline bool MyFantasyName::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MyFantasyName::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MyFantasyName::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MyFantasyName::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::fantasybit::MyNameStatus MyFantasyName::status() const {
  return static_cast< ::fantasybit::MyNameStatus >(status_);
}
inline void MyFantasyName::set_status(::fantasybit::MyNameStatus value) {
  assert(::fantasybit::MyNameStatus_IsValid(value));
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// FantasyPlayer

// optional string name = 10;
inline bool FantasyPlayer::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FantasyPlayer::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FantasyPlayer::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FantasyPlayer::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& FantasyPlayer::name() const {
  return *name_;
}
inline void FantasyPlayer::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FantasyPlayer::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FantasyPlayer::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FantasyPlayer::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* FantasyPlayer::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FantasyPlayer::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 bits = 20;
inline bool FantasyPlayer::has_bits() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FantasyPlayer::set_has_bits() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FantasyPlayer::clear_has_bits() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FantasyPlayer::clear_bits() {
  bits_ = GOOGLE_ULONGLONG(0);
  clear_has_bits();
}
inline ::google::protobuf::uint64 FantasyPlayer::bits() const {
  return bits_;
}
inline void FantasyPlayer::set_bits(::google::protobuf::uint64 value) {
  set_has_bits();
  bits_ = value;
}

// -------------------------------------------------------------------

// Secret

// required string private_key = 1;
inline bool Secret::has_private_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Secret::set_has_private_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Secret::clear_has_private_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Secret::clear_private_key() {
  if (private_key_ != &::google::protobuf::internal::kEmptyString) {
    private_key_->clear();
  }
  clear_has_private_key();
}
inline const ::std::string& Secret::private_key() const {
  return *private_key_;
}
inline void Secret::set_private_key(const ::std::string& value) {
  set_has_private_key();
  if (private_key_ == &::google::protobuf::internal::kEmptyString) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(value);
}
inline void Secret::set_private_key(const char* value) {
  set_has_private_key();
  if (private_key_ == &::google::protobuf::internal::kEmptyString) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(value);
}
inline void Secret::set_private_key(const char* value, size_t size) {
  set_has_private_key();
  if (private_key_ == &::google::protobuf::internal::kEmptyString) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Secret::mutable_private_key() {
  set_has_private_key();
  if (private_key_ == &::google::protobuf::internal::kEmptyString) {
    private_key_ = new ::std::string;
  }
  return private_key_;
}
inline ::std::string* Secret::release_private_key() {
  clear_has_private_key();
  if (private_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = private_key_;
    private_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Secret::set_allocated_private_key(::std::string* private_key) {
  if (private_key_ != &::google::protobuf::internal::kEmptyString) {
    delete private_key_;
  }
  if (private_key) {
    set_has_private_key();
    private_key_ = private_key;
  } else {
    clear_has_private_key();
    private_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .fantasybit.MyFantasyName myfantasyname = 2;
inline bool Secret::has_myfantasyname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Secret::set_has_myfantasyname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Secret::clear_has_myfantasyname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Secret::clear_myfantasyname() {
  if (myfantasyname_ != NULL) myfantasyname_->::fantasybit::MyFantasyName::Clear();
  clear_has_myfantasyname();
}
inline const ::fantasybit::MyFantasyName& Secret::myfantasyname() const {
  return myfantasyname_ != NULL ? *myfantasyname_ : *default_instance_->myfantasyname_;
}
inline ::fantasybit::MyFantasyName* Secret::mutable_myfantasyname() {
  set_has_myfantasyname();
  if (myfantasyname_ == NULL) myfantasyname_ = new ::fantasybit::MyFantasyName;
  return myfantasyname_;
}
inline ::fantasybit::MyFantasyName* Secret::release_myfantasyname() {
  clear_has_myfantasyname();
  ::fantasybit::MyFantasyName* temp = myfantasyname_;
  myfantasyname_ = NULL;
  return temp;
}
inline void Secret::set_allocated_myfantasyname(::fantasybit::MyFantasyName* myfantasyname) {
  delete myfantasyname_;
  myfantasyname_ = myfantasyname;
  if (myfantasyname) {
    set_has_myfantasyname();
  } else {
    clear_has_myfantasyname();
  }
}

// optional .fantasybit.NameTrans nametran = 10;
inline bool Secret::has_nametran() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Secret::set_has_nametran() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Secret::clear_has_nametran() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Secret::clear_nametran() {
  if (nametran_ != NULL) nametran_->::fantasybit::NameTrans::Clear();
  clear_has_nametran();
}
inline const ::fantasybit::NameTrans& Secret::nametran() const {
  return nametran_ != NULL ? *nametran_ : *default_instance_->nametran_;
}
inline ::fantasybit::NameTrans* Secret::mutable_nametran() {
  set_has_nametran();
  if (nametran_ == NULL) nametran_ = new ::fantasybit::NameTrans;
  return nametran_;
}
inline ::fantasybit::NameTrans* Secret::release_nametran() {
  clear_has_nametran();
  ::fantasybit::NameTrans* temp = nametran_;
  nametran_ = NULL;
  return temp;
}
inline void Secret::set_allocated_nametran(::fantasybit::NameTrans* nametran) {
  delete nametran_;
  nametran_ = nametran;
  if (nametran) {
    set_has_nametran();
  } else {
    clear_has_nametran();
  }
}

// -------------------------------------------------------------------

// Secret2

// optional string private_key = 1;
inline bool Secret2::has_private_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Secret2::set_has_private_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Secret2::clear_has_private_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Secret2::clear_private_key() {
  if (private_key_ != &::google::protobuf::internal::kEmptyString) {
    private_key_->clear();
  }
  clear_has_private_key();
}
inline const ::std::string& Secret2::private_key() const {
  return *private_key_;
}
inline void Secret2::set_private_key(const ::std::string& value) {
  set_has_private_key();
  if (private_key_ == &::google::protobuf::internal::kEmptyString) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(value);
}
inline void Secret2::set_private_key(const char* value) {
  set_has_private_key();
  if (private_key_ == &::google::protobuf::internal::kEmptyString) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(value);
}
inline void Secret2::set_private_key(const char* value, size_t size) {
  set_has_private_key();
  if (private_key_ == &::google::protobuf::internal::kEmptyString) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Secret2::mutable_private_key() {
  set_has_private_key();
  if (private_key_ == &::google::protobuf::internal::kEmptyString) {
    private_key_ = new ::std::string;
  }
  return private_key_;
}
inline ::std::string* Secret2::release_private_key() {
  clear_has_private_key();
  if (private_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = private_key_;
    private_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Secret2::set_allocated_private_key(::std::string* private_key) {
  if (private_key_ != &::google::protobuf::internal::kEmptyString) {
    delete private_key_;
  }
  if (private_key) {
    set_has_private_key();
    private_key_ = private_key;
  } else {
    clear_has_private_key();
    private_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string fantasy_name = 20;
inline bool Secret2::has_fantasy_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Secret2::set_has_fantasy_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Secret2::clear_has_fantasy_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Secret2::clear_fantasy_name() {
  if (fantasy_name_ != &::google::protobuf::internal::kEmptyString) {
    fantasy_name_->clear();
  }
  clear_has_fantasy_name();
}
inline const ::std::string& Secret2::fantasy_name() const {
  return *fantasy_name_;
}
inline void Secret2::set_fantasy_name(const ::std::string& value) {
  set_has_fantasy_name();
  if (fantasy_name_ == &::google::protobuf::internal::kEmptyString) {
    fantasy_name_ = new ::std::string;
  }
  fantasy_name_->assign(value);
}
inline void Secret2::set_fantasy_name(const char* value) {
  set_has_fantasy_name();
  if (fantasy_name_ == &::google::protobuf::internal::kEmptyString) {
    fantasy_name_ = new ::std::string;
  }
  fantasy_name_->assign(value);
}
inline void Secret2::set_fantasy_name(const char* value, size_t size) {
  set_has_fantasy_name();
  if (fantasy_name_ == &::google::protobuf::internal::kEmptyString) {
    fantasy_name_ = new ::std::string;
  }
  fantasy_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Secret2::mutable_fantasy_name() {
  set_has_fantasy_name();
  if (fantasy_name_ == &::google::protobuf::internal::kEmptyString) {
    fantasy_name_ = new ::std::string;
  }
  return fantasy_name_;
}
inline ::std::string* Secret2::release_fantasy_name() {
  clear_has_fantasy_name();
  if (fantasy_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fantasy_name_;
    fantasy_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Secret2::set_allocated_fantasy_name(::std::string* fantasy_name) {
  if (fantasy_name_ != &::google::protobuf::internal::kEmptyString) {
    delete fantasy_name_;
  }
  if (fantasy_name) {
    set_has_fantasy_name();
    fantasy_name_ = fantasy_name;
  } else {
    clear_has_fantasy_name();
    fantasy_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string public_key = 30;
inline bool Secret2::has_public_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Secret2::set_has_public_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Secret2::clear_has_public_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Secret2::clear_public_key() {
  if (public_key_ != &::google::protobuf::internal::kEmptyString) {
    public_key_->clear();
  }
  clear_has_public_key();
}
inline const ::std::string& Secret2::public_key() const {
  return *public_key_;
}
inline void Secret2::set_public_key(const ::std::string& value) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void Secret2::set_public_key(const char* value) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void Secret2::set_public_key(const char* value, size_t size) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Secret2::mutable_public_key() {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}
inline ::std::string* Secret2::release_public_key() {
  clear_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = public_key_;
    public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Secret2::set_allocated_public_key(::std::string* public_key) {
  if (public_key_ != &::google::protobuf::internal::kEmptyString) {
    delete public_key_;
  }
  if (public_key) {
    set_has_public_key();
    public_key_ = public_key;
  } else {
    clear_has_public_key();
    public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Secret3

// optional string private_key = 1;
inline bool Secret3::has_private_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Secret3::set_has_private_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Secret3::clear_has_private_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Secret3::clear_private_key() {
  if (private_key_ != &::google::protobuf::internal::kEmptyString) {
    private_key_->clear();
  }
  clear_has_private_key();
}
inline const ::std::string& Secret3::private_key() const {
  return *private_key_;
}
inline void Secret3::set_private_key(const ::std::string& value) {
  set_has_private_key();
  if (private_key_ == &::google::protobuf::internal::kEmptyString) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(value);
}
inline void Secret3::set_private_key(const char* value) {
  set_has_private_key();
  if (private_key_ == &::google::protobuf::internal::kEmptyString) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(value);
}
inline void Secret3::set_private_key(const char* value, size_t size) {
  set_has_private_key();
  if (private_key_ == &::google::protobuf::internal::kEmptyString) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Secret3::mutable_private_key() {
  set_has_private_key();
  if (private_key_ == &::google::protobuf::internal::kEmptyString) {
    private_key_ = new ::std::string;
  }
  return private_key_;
}
inline ::std::string* Secret3::release_private_key() {
  clear_has_private_key();
  if (private_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = private_key_;
    private_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Secret3::set_allocated_private_key(::std::string* private_key) {
  if (private_key_ != &::google::protobuf::internal::kEmptyString) {
    delete private_key_;
  }
  if (private_key) {
    set_has_private_key();
    private_key_ = private_key;
  } else {
    clear_has_private_key();
    private_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mnemonic_key = 3;
inline bool Secret3::has_mnemonic_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Secret3::set_has_mnemonic_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Secret3::clear_has_mnemonic_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Secret3::clear_mnemonic_key() {
  if (mnemonic_key_ != &::google::protobuf::internal::kEmptyString) {
    mnemonic_key_->clear();
  }
  clear_has_mnemonic_key();
}
inline const ::std::string& Secret3::mnemonic_key() const {
  return *mnemonic_key_;
}
inline void Secret3::set_mnemonic_key(const ::std::string& value) {
  set_has_mnemonic_key();
  if (mnemonic_key_ == &::google::protobuf::internal::kEmptyString) {
    mnemonic_key_ = new ::std::string;
  }
  mnemonic_key_->assign(value);
}
inline void Secret3::set_mnemonic_key(const char* value) {
  set_has_mnemonic_key();
  if (mnemonic_key_ == &::google::protobuf::internal::kEmptyString) {
    mnemonic_key_ = new ::std::string;
  }
  mnemonic_key_->assign(value);
}
inline void Secret3::set_mnemonic_key(const char* value, size_t size) {
  set_has_mnemonic_key();
  if (mnemonic_key_ == &::google::protobuf::internal::kEmptyString) {
    mnemonic_key_ = new ::std::string;
  }
  mnemonic_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Secret3::mutable_mnemonic_key() {
  set_has_mnemonic_key();
  if (mnemonic_key_ == &::google::protobuf::internal::kEmptyString) {
    mnemonic_key_ = new ::std::string;
  }
  return mnemonic_key_;
}
inline ::std::string* Secret3::release_mnemonic_key() {
  clear_has_mnemonic_key();
  if (mnemonic_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mnemonic_key_;
    mnemonic_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Secret3::set_allocated_mnemonic_key(::std::string* mnemonic_key) {
  if (mnemonic_key_ != &::google::protobuf::internal::kEmptyString) {
    delete mnemonic_key_;
  }
  if (mnemonic_key) {
    set_has_mnemonic_key();
    mnemonic_key_ = mnemonic_key;
  } else {
    clear_has_mnemonic_key();
    mnemonic_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string fantasy_name = 20;
inline bool Secret3::has_fantasy_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Secret3::set_has_fantasy_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Secret3::clear_has_fantasy_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Secret3::clear_fantasy_name() {
  if (fantasy_name_ != &::google::protobuf::internal::kEmptyString) {
    fantasy_name_->clear();
  }
  clear_has_fantasy_name();
}
inline const ::std::string& Secret3::fantasy_name() const {
  return *fantasy_name_;
}
inline void Secret3::set_fantasy_name(const ::std::string& value) {
  set_has_fantasy_name();
  if (fantasy_name_ == &::google::protobuf::internal::kEmptyString) {
    fantasy_name_ = new ::std::string;
  }
  fantasy_name_->assign(value);
}
inline void Secret3::set_fantasy_name(const char* value) {
  set_has_fantasy_name();
  if (fantasy_name_ == &::google::protobuf::internal::kEmptyString) {
    fantasy_name_ = new ::std::string;
  }
  fantasy_name_->assign(value);
}
inline void Secret3::set_fantasy_name(const char* value, size_t size) {
  set_has_fantasy_name();
  if (fantasy_name_ == &::google::protobuf::internal::kEmptyString) {
    fantasy_name_ = new ::std::string;
  }
  fantasy_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Secret3::mutable_fantasy_name() {
  set_has_fantasy_name();
  if (fantasy_name_ == &::google::protobuf::internal::kEmptyString) {
    fantasy_name_ = new ::std::string;
  }
  return fantasy_name_;
}
inline ::std::string* Secret3::release_fantasy_name() {
  clear_has_fantasy_name();
  if (fantasy_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fantasy_name_;
    fantasy_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Secret3::set_allocated_fantasy_name(::std::string* fantasy_name) {
  if (fantasy_name_ != &::google::protobuf::internal::kEmptyString) {
    delete fantasy_name_;
  }
  if (fantasy_name) {
    set_has_fantasy_name();
    fantasy_name_ = fantasy_name;
  } else {
    clear_has_fantasy_name();
    fantasy_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string public_key = 30;
inline bool Secret3::has_public_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Secret3::set_has_public_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Secret3::clear_has_public_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Secret3::clear_public_key() {
  if (public_key_ != &::google::protobuf::internal::kEmptyString) {
    public_key_->clear();
  }
  clear_has_public_key();
}
inline const ::std::string& Secret3::public_key() const {
  return *public_key_;
}
inline void Secret3::set_public_key(const ::std::string& value) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void Secret3::set_public_key(const char* value) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void Secret3::set_public_key(const char* value, size_t size) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Secret3::mutable_public_key() {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}
inline ::std::string* Secret3::release_public_key() {
  clear_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = public_key_;
    public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Secret3::set_allocated_public_key(::std::string* public_key) {
  if (public_key_ != &::google::protobuf::internal::kEmptyString) {
    delete public_key_;
  }
  if (public_key) {
    set_has_public_key();
    public_key_ = public_key;
  } else {
    clear_has_public_key();
    public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// OutData

// required .fantasybit.OutData.Type type = 1;
inline bool OutData::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OutData::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OutData::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OutData::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::fantasybit::OutData_Type OutData::type() const {
  return static_cast< ::fantasybit::OutData_Type >(type_);
}
inline void OutData::set_type(::fantasybit::OutData_Type value) {
  assert(::fantasybit::OutData_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .fantasybit.MyFantasyName myfantasyname = 2;
inline bool OutData::has_myfantasyname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OutData::set_has_myfantasyname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OutData::clear_has_myfantasyname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OutData::clear_myfantasyname() {
  if (myfantasyname_ != NULL) myfantasyname_->::fantasybit::MyFantasyName::Clear();
  clear_has_myfantasyname();
}
inline const ::fantasybit::MyFantasyName& OutData::myfantasyname() const {
  return myfantasyname_ != NULL ? *myfantasyname_ : *default_instance_->myfantasyname_;
}
inline ::fantasybit::MyFantasyName* OutData::mutable_myfantasyname() {
  set_has_myfantasyname();
  if (myfantasyname_ == NULL) myfantasyname_ = new ::fantasybit::MyFantasyName;
  return myfantasyname_;
}
inline ::fantasybit::MyFantasyName* OutData::release_myfantasyname() {
  clear_has_myfantasyname();
  ::fantasybit::MyFantasyName* temp = myfantasyname_;
  myfantasyname_ = NULL;
  return temp;
}
inline void OutData::set_allocated_myfantasyname(::fantasybit::MyFantasyName* myfantasyname) {
  delete myfantasyname_;
  myfantasyname_ = myfantasyname;
  if (myfantasyname) {
    set_has_myfantasyname();
  } else {
    clear_has_myfantasyname();
  }
}

// -------------------------------------------------------------------

// InData

// required .fantasybit.InData.Type type = 1;
inline bool InData::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InData::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InData::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InData::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::fantasybit::InData_Type InData::type() const {
  return static_cast< ::fantasybit::InData_Type >(type_);
}
inline void InData::set_type(::fantasybit::InData_Type value) {
  assert(::fantasybit::InData_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string data = 2;
inline bool InData::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InData::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InData::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InData::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& InData::data() const {
  return *data_;
}
inline void InData::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void InData::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void InData::set_data(const char* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InData::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* InData::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InData::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string data2 = 3;
inline bool InData::has_data2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InData::set_has_data2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InData::clear_has_data2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InData::clear_data2() {
  if (data2_ != &::google::protobuf::internal::kEmptyString) {
    data2_->clear();
  }
  clear_has_data2();
}
inline const ::std::string& InData::data2() const {
  return *data2_;
}
inline void InData::set_data2(const ::std::string& value) {
  set_has_data2();
  if (data2_ == &::google::protobuf::internal::kEmptyString) {
    data2_ = new ::std::string;
  }
  data2_->assign(value);
}
inline void InData::set_data2(const char* value) {
  set_has_data2();
  if (data2_ == &::google::protobuf::internal::kEmptyString) {
    data2_ = new ::std::string;
  }
  data2_->assign(value);
}
inline void InData::set_data2(const char* value, size_t size) {
  set_has_data2();
  if (data2_ == &::google::protobuf::internal::kEmptyString) {
    data2_ = new ::std::string;
  }
  data2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InData::mutable_data2() {
  set_has_data2();
  if (data2_ == &::google::protobuf::internal::kEmptyString) {
    data2_ = new ::std::string;
  }
  return data2_;
}
inline ::std::string* InData::release_data2() {
  clear_has_data2();
  if (data2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data2_;
    data2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InData::set_allocated_data2(::std::string* data2) {
  if (data2_ != &::google::protobuf::internal::kEmptyString) {
    delete data2_;
  }
  if (data2) {
    set_has_data2();
    data2_ = data2;
  } else {
    clear_has_data2();
    data2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 num = 4;
inline bool InData::has_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InData::set_has_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InData::clear_has_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InData::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 InData::num() const {
  return num_;
}
inline void InData::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// optional .fantasybit.DataTransition data_trans = 5;
inline bool InData::has_data_trans() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InData::set_has_data_trans() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InData::clear_has_data_trans() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InData::clear_data_trans() {
  if (data_trans_ != NULL) data_trans_->::fantasybit::DataTransition::Clear();
  clear_has_data_trans();
}
inline const ::fantasybit::DataTransition& InData::data_trans() const {
  return data_trans_ != NULL ? *data_trans_ : *default_instance_->data_trans_;
}
inline ::fantasybit::DataTransition* InData::mutable_data_trans() {
  set_has_data_trans();
  if (data_trans_ == NULL) data_trans_ = new ::fantasybit::DataTransition;
  return data_trans_;
}
inline ::fantasybit::DataTransition* InData::release_data_trans() {
  clear_has_data_trans();
  ::fantasybit::DataTransition* temp = data_trans_;
  data_trans_ = NULL;
  return temp;
}
inline void InData::set_allocated_data_trans(::fantasybit::DataTransition* data_trans) {
  delete data_trans_;
  data_trans_ = data_trans;
  if (data_trans) {
    set_has_data_trans();
  } else {
    clear_has_data_trans();
  }
}

// -------------------------------------------------------------------

// NameProof

// optional .fantasybit.NameProof.Type type = 1;
inline bool NameProof::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NameProof::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NameProof::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NameProof::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::fantasybit::NameProof_Type NameProof::type() const {
  return static_cast< ::fantasybit::NameProof_Type >(type_);
}
inline void NameProof::set_type(::fantasybit::NameProof_Type value) {
  assert(::fantasybit::NameProof_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// TweetProof

// optional string tweet = 10;
inline bool TweetProof::has_tweet() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TweetProof::set_has_tweet() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TweetProof::clear_has_tweet() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TweetProof::clear_tweet() {
  if (tweet_ != &::google::protobuf::internal::kEmptyString) {
    tweet_->clear();
  }
  clear_has_tweet();
}
inline const ::std::string& TweetProof::tweet() const {
  return *tweet_;
}
inline void TweetProof::set_tweet(const ::std::string& value) {
  set_has_tweet();
  if (tweet_ == &::google::protobuf::internal::kEmptyString) {
    tweet_ = new ::std::string;
  }
  tweet_->assign(value);
}
inline void TweetProof::set_tweet(const char* value) {
  set_has_tweet();
  if (tweet_ == &::google::protobuf::internal::kEmptyString) {
    tweet_ = new ::std::string;
  }
  tweet_->assign(value);
}
inline void TweetProof::set_tweet(const char* value, size_t size) {
  set_has_tweet();
  if (tweet_ == &::google::protobuf::internal::kEmptyString) {
    tweet_ = new ::std::string;
  }
  tweet_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TweetProof::mutable_tweet() {
  set_has_tweet();
  if (tweet_ == &::google::protobuf::internal::kEmptyString) {
    tweet_ = new ::std::string;
  }
  return tweet_;
}
inline ::std::string* TweetProof::release_tweet() {
  clear_has_tweet();
  if (tweet_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tweet_;
    tweet_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TweetProof::set_allocated_tweet(::std::string* tweet) {
  if (tweet_ != &::google::protobuf::internal::kEmptyString) {
    delete tweet_;
  }
  if (tweet) {
    set_has_tweet();
    tweet_ = tweet;
  } else {
    clear_has_tweet();
    tweet_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MasterProof

// optional string season = 10;
inline bool MasterProof::has_season() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MasterProof::set_has_season() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MasterProof::clear_has_season() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MasterProof::clear_season() {
  if (season_ != &::google::protobuf::internal::kEmptyString) {
    season_->clear();
  }
  clear_has_season();
}
inline const ::std::string& MasterProof::season() const {
  return *season_;
}
inline void MasterProof::set_season(const ::std::string& value) {
  set_has_season();
  if (season_ == &::google::protobuf::internal::kEmptyString) {
    season_ = new ::std::string;
  }
  season_->assign(value);
}
inline void MasterProof::set_season(const char* value) {
  set_has_season();
  if (season_ == &::google::protobuf::internal::kEmptyString) {
    season_ = new ::std::string;
  }
  season_->assign(value);
}
inline void MasterProof::set_season(const char* value, size_t size) {
  set_has_season();
  if (season_ == &::google::protobuf::internal::kEmptyString) {
    season_ = new ::std::string;
  }
  season_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MasterProof::mutable_season() {
  set_has_season();
  if (season_ == &::google::protobuf::internal::kEmptyString) {
    season_ = new ::std::string;
  }
  return season_;
}
inline ::std::string* MasterProof::release_season() {
  clear_has_season();
  if (season_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = season_;
    season_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MasterProof::set_allocated_season(::std::string* season) {
  if (season_ != &::google::protobuf::internal::kEmptyString) {
    delete season_;
  }
  if (season) {
    set_has_season();
    season_ = season;
  } else {
    clear_has_season();
    season_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 week = 20;
inline bool MasterProof::has_week() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MasterProof::set_has_week() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MasterProof::clear_has_week() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MasterProof::clear_week() {
  week_ = 0;
  clear_has_week();
}
inline ::google::protobuf::int32 MasterProof::week() const {
  return week_;
}
inline void MasterProof::set_week(::google::protobuf::int32 value) {
  set_has_week();
  week_ = value;
}

// optional int32 timestamp = 21;
inline bool MasterProof::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MasterProof::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MasterProof::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MasterProof::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline ::google::protobuf::int32 MasterProof::timestamp() const {
  return timestamp_;
}
inline void MasterProof::set_timestamp(::google::protobuf::int32 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional .fantasybit.SignedTransaction new_oracle_name = 66;
inline bool MasterProof::has_new_oracle_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MasterProof::set_has_new_oracle_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MasterProof::clear_has_new_oracle_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MasterProof::clear_new_oracle_name() {
  if (new_oracle_name_ != NULL) new_oracle_name_->::fantasybit::SignedTransaction::Clear();
  clear_has_new_oracle_name();
}
inline const ::fantasybit::SignedTransaction& MasterProof::new_oracle_name() const {
  return new_oracle_name_ != NULL ? *new_oracle_name_ : *default_instance_->new_oracle_name_;
}
inline ::fantasybit::SignedTransaction* MasterProof::mutable_new_oracle_name() {
  set_has_new_oracle_name();
  if (new_oracle_name_ == NULL) new_oracle_name_ = new ::fantasybit::SignedTransaction;
  return new_oracle_name_;
}
inline ::fantasybit::SignedTransaction* MasterProof::release_new_oracle_name() {
  clear_has_new_oracle_name();
  ::fantasybit::SignedTransaction* temp = new_oracle_name_;
  new_oracle_name_ = NULL;
  return temp;
}
inline void MasterProof::set_allocated_new_oracle_name(::fantasybit::SignedTransaction* new_oracle_name) {
  delete new_oracle_name_;
  new_oracle_name_ = new_oracle_name;
  if (new_oracle_name) {
    set_has_new_oracle_name();
  } else {
    clear_has_new_oracle_name();
  }
}

// -------------------------------------------------------------------

// Transaction

// optional int32 version = 1;
inline bool Transaction::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Transaction::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Transaction::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Transaction::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 Transaction::version() const {
  return version_;
}
inline void Transaction::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
}

// optional .fantasybit.TransType type = 2;
inline bool Transaction::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Transaction::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Transaction::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Transaction::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::fantasybit::TransType Transaction::type() const {
  return static_cast< ::fantasybit::TransType >(type_);
}
inline void Transaction::set_type(::fantasybit::TransType value) {
  assert(::fantasybit::TransType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional uint64 nonce = 10;
inline bool Transaction::has_nonce() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Transaction::set_has_nonce() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Transaction::clear_has_nonce() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Transaction::clear_nonce() {
  nonce_ = GOOGLE_ULONGLONG(0);
  clear_has_nonce();
}
inline ::google::protobuf::uint64 Transaction::nonce() const {
  return nonce_;
}
inline void Transaction::set_nonce(::google::protobuf::uint64 value) {
  set_has_nonce();
  nonce_ = value;
}

// -------------------------------------------------------------------

// NameTrans

// optional string fantasy_name = 10;
inline bool NameTrans::has_fantasy_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NameTrans::set_has_fantasy_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NameTrans::clear_has_fantasy_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NameTrans::clear_fantasy_name() {
  if (fantasy_name_ != &::google::protobuf::internal::kEmptyString) {
    fantasy_name_->clear();
  }
  clear_has_fantasy_name();
}
inline const ::std::string& NameTrans::fantasy_name() const {
  return *fantasy_name_;
}
inline void NameTrans::set_fantasy_name(const ::std::string& value) {
  set_has_fantasy_name();
  if (fantasy_name_ == &::google::protobuf::internal::kEmptyString) {
    fantasy_name_ = new ::std::string;
  }
  fantasy_name_->assign(value);
}
inline void NameTrans::set_fantasy_name(const char* value) {
  set_has_fantasy_name();
  if (fantasy_name_ == &::google::protobuf::internal::kEmptyString) {
    fantasy_name_ = new ::std::string;
  }
  fantasy_name_->assign(value);
}
inline void NameTrans::set_fantasy_name(const char* value, size_t size) {
  set_has_fantasy_name();
  if (fantasy_name_ == &::google::protobuf::internal::kEmptyString) {
    fantasy_name_ = new ::std::string;
  }
  fantasy_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NameTrans::mutable_fantasy_name() {
  set_has_fantasy_name();
  if (fantasy_name_ == &::google::protobuf::internal::kEmptyString) {
    fantasy_name_ = new ::std::string;
  }
  return fantasy_name_;
}
inline ::std::string* NameTrans::release_fantasy_name() {
  clear_has_fantasy_name();
  if (fantasy_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fantasy_name_;
    fantasy_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NameTrans::set_allocated_fantasy_name(::std::string* fantasy_name) {
  if (fantasy_name_ != &::google::protobuf::internal::kEmptyString) {
    delete fantasy_name_;
  }
  if (fantasy_name) {
    set_has_fantasy_name();
    fantasy_name_ = fantasy_name;
  } else {
    clear_has_fantasy_name();
    fantasy_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes public_key = 20;
inline bool NameTrans::has_public_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NameTrans::set_has_public_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NameTrans::clear_has_public_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NameTrans::clear_public_key() {
  if (public_key_ != &::google::protobuf::internal::kEmptyString) {
    public_key_->clear();
  }
  clear_has_public_key();
}
inline const ::std::string& NameTrans::public_key() const {
  return *public_key_;
}
inline void NameTrans::set_public_key(const ::std::string& value) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void NameTrans::set_public_key(const char* value) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void NameTrans::set_public_key(const void* value, size_t size) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NameTrans::mutable_public_key() {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}
inline ::std::string* NameTrans::release_public_key() {
  clear_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = public_key_;
    public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NameTrans::set_allocated_public_key(::std::string* public_key) {
  if (public_key_ != &::google::protobuf::internal::kEmptyString) {
    delete public_key_;
  }
  if (public_key) {
    set_has_public_key();
    public_key_ = public_key;
  } else {
    clear_has_public_key();
    public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .fantasybit.NameProof proof = 30;
inline bool NameTrans::has_proof() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NameTrans::set_has_proof() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NameTrans::clear_has_proof() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NameTrans::clear_proof() {
  if (proof_ != NULL) proof_->::fantasybit::NameProof::Clear();
  clear_has_proof();
}
inline const ::fantasybit::NameProof& NameTrans::proof() const {
  return proof_ != NULL ? *proof_ : *default_instance_->proof_;
}
inline ::fantasybit::NameProof* NameTrans::mutable_proof() {
  set_has_proof();
  if (proof_ == NULL) proof_ = new ::fantasybit::NameProof;
  return proof_;
}
inline ::fantasybit::NameProof* NameTrans::release_proof() {
  clear_has_proof();
  ::fantasybit::NameProof* temp = proof_;
  proof_ = NULL;
  return temp;
}
inline void NameTrans::set_allocated_proof(::fantasybit::NameProof* proof) {
  delete proof_;
  proof_ = proof;
  if (proof) {
    set_has_proof();
  } else {
    clear_has_proof();
  }
}

// optional bytes recovery_key = 40;
inline bool NameTrans::has_recovery_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NameTrans::set_has_recovery_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NameTrans::clear_has_recovery_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NameTrans::clear_recovery_key() {
  if (recovery_key_ != &::google::protobuf::internal::kEmptyString) {
    recovery_key_->clear();
  }
  clear_has_recovery_key();
}
inline const ::std::string& NameTrans::recovery_key() const {
  return *recovery_key_;
}
inline void NameTrans::set_recovery_key(const ::std::string& value) {
  set_has_recovery_key();
  if (recovery_key_ == &::google::protobuf::internal::kEmptyString) {
    recovery_key_ = new ::std::string;
  }
  recovery_key_->assign(value);
}
inline void NameTrans::set_recovery_key(const char* value) {
  set_has_recovery_key();
  if (recovery_key_ == &::google::protobuf::internal::kEmptyString) {
    recovery_key_ = new ::std::string;
  }
  recovery_key_->assign(value);
}
inline void NameTrans::set_recovery_key(const void* value, size_t size) {
  set_has_recovery_key();
  if (recovery_key_ == &::google::protobuf::internal::kEmptyString) {
    recovery_key_ = new ::std::string;
  }
  recovery_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NameTrans::mutable_recovery_key() {
  set_has_recovery_key();
  if (recovery_key_ == &::google::protobuf::internal::kEmptyString) {
    recovery_key_ = new ::std::string;
  }
  return recovery_key_;
}
inline ::std::string* NameTrans::release_recovery_key() {
  clear_has_recovery_key();
  if (recovery_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = recovery_key_;
    recovery_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NameTrans::set_allocated_recovery_key(::std::string* recovery_key) {
  if (recovery_key_ != &::google::protobuf::internal::kEmptyString) {
    delete recovery_key_;
  }
  if (recovery_key) {
    set_has_recovery_key();
    recovery_key_ = recovery_key;
  } else {
    clear_has_recovery_key();
    recovery_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool am_agent = 50;
inline bool NameTrans::has_am_agent() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NameTrans::set_has_am_agent() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NameTrans::clear_has_am_agent() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NameTrans::clear_am_agent() {
  am_agent_ = false;
  clear_has_am_agent();
}
inline bool NameTrans::am_agent() const {
  return am_agent_;
}
inline void NameTrans::set_am_agent(bool value) {
  set_has_am_agent();
  am_agent_ = value;
}

// optional string my_agent = 60;
inline bool NameTrans::has_my_agent() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NameTrans::set_has_my_agent() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NameTrans::clear_has_my_agent() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NameTrans::clear_my_agent() {
  if (my_agent_ != &::google::protobuf::internal::kEmptyString) {
    my_agent_->clear();
  }
  clear_has_my_agent();
}
inline const ::std::string& NameTrans::my_agent() const {
  return *my_agent_;
}
inline void NameTrans::set_my_agent(const ::std::string& value) {
  set_has_my_agent();
  if (my_agent_ == &::google::protobuf::internal::kEmptyString) {
    my_agent_ = new ::std::string;
  }
  my_agent_->assign(value);
}
inline void NameTrans::set_my_agent(const char* value) {
  set_has_my_agent();
  if (my_agent_ == &::google::protobuf::internal::kEmptyString) {
    my_agent_ = new ::std::string;
  }
  my_agent_->assign(value);
}
inline void NameTrans::set_my_agent(const char* value, size_t size) {
  set_has_my_agent();
  if (my_agent_ == &::google::protobuf::internal::kEmptyString) {
    my_agent_ = new ::std::string;
  }
  my_agent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NameTrans::mutable_my_agent() {
  set_has_my_agent();
  if (my_agent_ == &::google::protobuf::internal::kEmptyString) {
    my_agent_ = new ::std::string;
  }
  return my_agent_;
}
inline ::std::string* NameTrans::release_my_agent() {
  clear_has_my_agent();
  if (my_agent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = my_agent_;
    my_agent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NameTrans::set_allocated_my_agent(::std::string* my_agent) {
  if (my_agent_ != &::google::protobuf::internal::kEmptyString) {
    delete my_agent_;
  }
  if (my_agent) {
    set_has_my_agent();
    my_agent_ = my_agent;
  } else {
    clear_has_my_agent();
    my_agent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TransferTrans

// optional string from = 10;
inline bool TransferTrans::has_from() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransferTrans::set_has_from() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransferTrans::clear_has_from() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransferTrans::clear_from() {
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    from_->clear();
  }
  clear_has_from();
}
inline const ::std::string& TransferTrans::from() const {
  return *from_;
}
inline void TransferTrans::set_from(const ::std::string& value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(value);
}
inline void TransferTrans::set_from(const char* value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(value);
}
inline void TransferTrans::set_from(const char* value, size_t size) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TransferTrans::mutable_from() {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  return from_;
}
inline ::std::string* TransferTrans::release_from() {
  clear_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_;
    from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TransferTrans::set_allocated_from(::std::string* from) {
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    delete from_;
  }
  if (from) {
    set_has_from();
    from_ = from;
  } else {
    clear_has_from();
    from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string to = 20;
inline bool TransferTrans::has_to() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransferTrans::set_has_to() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransferTrans::clear_has_to() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransferTrans::clear_to() {
  if (to_ != &::google::protobuf::internal::kEmptyString) {
    to_->clear();
  }
  clear_has_to();
}
inline const ::std::string& TransferTrans::to() const {
  return *to_;
}
inline void TransferTrans::set_to(const ::std::string& value) {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  to_->assign(value);
}
inline void TransferTrans::set_to(const char* value) {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  to_->assign(value);
}
inline void TransferTrans::set_to(const char* value, size_t size) {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  to_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TransferTrans::mutable_to() {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  return to_;
}
inline ::std::string* TransferTrans::release_to() {
  clear_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = to_;
    to_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TransferTrans::set_allocated_to(::std::string* to) {
  if (to_ != &::google::protobuf::internal::kEmptyString) {
    delete to_;
  }
  if (to) {
    set_has_to();
    to_ = to;
  } else {
    clear_has_to();
    to_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 amount = 30;
inline bool TransferTrans::has_amount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransferTrans::set_has_amount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransferTrans::clear_has_amount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransferTrans::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 TransferTrans::amount() const {
  return amount_;
}
inline void TransferTrans::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
}

// -------------------------------------------------------------------

// SignedTransaction

// optional .fantasybit.Transaction trans = 10;
inline bool SignedTransaction::has_trans() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignedTransaction::set_has_trans() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignedTransaction::clear_has_trans() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignedTransaction::clear_trans() {
  if (trans_ != NULL) trans_->::fantasybit::Transaction::Clear();
  clear_has_trans();
}
inline const ::fantasybit::Transaction& SignedTransaction::trans() const {
  return trans_ != NULL ? *trans_ : *default_instance_->trans_;
}
inline ::fantasybit::Transaction* SignedTransaction::mutable_trans() {
  set_has_trans();
  if (trans_ == NULL) trans_ = new ::fantasybit::Transaction;
  return trans_;
}
inline ::fantasybit::Transaction* SignedTransaction::release_trans() {
  clear_has_trans();
  ::fantasybit::Transaction* temp = trans_;
  trans_ = NULL;
  return temp;
}
inline void SignedTransaction::set_allocated_trans(::fantasybit::Transaction* trans) {
  delete trans_;
  trans_ = trans;
  if (trans) {
    set_has_trans();
  } else {
    clear_has_trans();
  }
}

// optional bytes id = 20;
inline bool SignedTransaction::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignedTransaction::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignedTransaction::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignedTransaction::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& SignedTransaction::id() const {
  return *id_;
}
inline void SignedTransaction::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void SignedTransaction::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void SignedTransaction::set_id(const void* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignedTransaction::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* SignedTransaction::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignedTransaction::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes sig = 30;
inline bool SignedTransaction::has_sig() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignedTransaction::set_has_sig() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignedTransaction::clear_has_sig() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignedTransaction::clear_sig() {
  if (sig_ != &::google::protobuf::internal::kEmptyString) {
    sig_->clear();
  }
  clear_has_sig();
}
inline const ::std::string& SignedTransaction::sig() const {
  return *sig_;
}
inline void SignedTransaction::set_sig(const ::std::string& value) {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  sig_->assign(value);
}
inline void SignedTransaction::set_sig(const char* value) {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  sig_->assign(value);
}
inline void SignedTransaction::set_sig(const void* value, size_t size) {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  sig_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignedTransaction::mutable_sig() {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  return sig_;
}
inline ::std::string* SignedTransaction::release_sig() {
  clear_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sig_;
    sig_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignedTransaction::set_allocated_sig(::std::string* sig) {
  if (sig_ != &::google::protobuf::internal::kEmptyString) {
    delete sig_;
  }
  if (sig) {
    set_has_sig();
    sig_ = sig;
  } else {
    clear_has_sig();
    sig_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string fantasy_name = 40;
inline bool SignedTransaction::has_fantasy_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SignedTransaction::set_has_fantasy_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SignedTransaction::clear_has_fantasy_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SignedTransaction::clear_fantasy_name() {
  if (fantasy_name_ != &::google::protobuf::internal::kEmptyString) {
    fantasy_name_->clear();
  }
  clear_has_fantasy_name();
}
inline const ::std::string& SignedTransaction::fantasy_name() const {
  return *fantasy_name_;
}
inline void SignedTransaction::set_fantasy_name(const ::std::string& value) {
  set_has_fantasy_name();
  if (fantasy_name_ == &::google::protobuf::internal::kEmptyString) {
    fantasy_name_ = new ::std::string;
  }
  fantasy_name_->assign(value);
}
inline void SignedTransaction::set_fantasy_name(const char* value) {
  set_has_fantasy_name();
  if (fantasy_name_ == &::google::protobuf::internal::kEmptyString) {
    fantasy_name_ = new ::std::string;
  }
  fantasy_name_->assign(value);
}
inline void SignedTransaction::set_fantasy_name(const char* value, size_t size) {
  set_has_fantasy_name();
  if (fantasy_name_ == &::google::protobuf::internal::kEmptyString) {
    fantasy_name_ = new ::std::string;
  }
  fantasy_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignedTransaction::mutable_fantasy_name() {
  set_has_fantasy_name();
  if (fantasy_name_ == &::google::protobuf::internal::kEmptyString) {
    fantasy_name_ = new ::std::string;
  }
  return fantasy_name_;
}
inline ::std::string* SignedTransaction::release_fantasy_name() {
  clear_has_fantasy_name();
  if (fantasy_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fantasy_name_;
    fantasy_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignedTransaction::set_allocated_fantasy_name(::std::string* fantasy_name) {
  if (fantasy_name_ != &::google::protobuf::internal::kEmptyString) {
    delete fantasy_name_;
  }
  if (fantasy_name) {
    set_has_fantasy_name();
    fantasy_name_ = fantasy_name;
  } else {
    clear_has_fantasy_name();
    fantasy_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BlockHeader

// optional int32 version = 1;
inline bool BlockHeader::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlockHeader::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlockHeader::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlockHeader::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 BlockHeader::version() const {
  return version_;
}
inline void BlockHeader::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
}

// optional int32 num = 10;
inline bool BlockHeader::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlockHeader::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlockHeader::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlockHeader::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 BlockHeader::num() const {
  return num_;
}
inline void BlockHeader::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// optional bytes prev_id = 20;
inline bool BlockHeader::has_prev_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BlockHeader::set_has_prev_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BlockHeader::clear_has_prev_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BlockHeader::clear_prev_id() {
  if (prev_id_ != &::google::protobuf::internal::kEmptyString) {
    prev_id_->clear();
  }
  clear_has_prev_id();
}
inline const ::std::string& BlockHeader::prev_id() const {
  return *prev_id_;
}
inline void BlockHeader::set_prev_id(const ::std::string& value) {
  set_has_prev_id();
  if (prev_id_ == &::google::protobuf::internal::kEmptyString) {
    prev_id_ = new ::std::string;
  }
  prev_id_->assign(value);
}
inline void BlockHeader::set_prev_id(const char* value) {
  set_has_prev_id();
  if (prev_id_ == &::google::protobuf::internal::kEmptyString) {
    prev_id_ = new ::std::string;
  }
  prev_id_->assign(value);
}
inline void BlockHeader::set_prev_id(const void* value, size_t size) {
  set_has_prev_id();
  if (prev_id_ == &::google::protobuf::internal::kEmptyString) {
    prev_id_ = new ::std::string;
  }
  prev_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BlockHeader::mutable_prev_id() {
  set_has_prev_id();
  if (prev_id_ == &::google::protobuf::internal::kEmptyString) {
    prev_id_ = new ::std::string;
  }
  return prev_id_;
}
inline ::std::string* BlockHeader::release_prev_id() {
  clear_has_prev_id();
  if (prev_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prev_id_;
    prev_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BlockHeader::set_allocated_prev_id(::std::string* prev_id) {
  if (prev_id_ != &::google::protobuf::internal::kEmptyString) {
    delete prev_id_;
  }
  if (prev_id) {
    set_has_prev_id();
    prev_id_ = prev_id;
  } else {
    clear_has_prev_id();
    prev_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 timestamp = 21;
inline bool BlockHeader::has_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BlockHeader::set_has_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BlockHeader::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BlockHeader::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline ::google::protobuf::int32 BlockHeader::timestamp() const {
  return timestamp_;
}
inline void BlockHeader::set_timestamp(::google::protobuf::int32 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional bytes generator_pk = 30;
inline bool BlockHeader::has_generator_pk() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BlockHeader::set_has_generator_pk() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BlockHeader::clear_has_generator_pk() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BlockHeader::clear_generator_pk() {
  if (generator_pk_ != &::google::protobuf::internal::kEmptyString) {
    generator_pk_->clear();
  }
  clear_has_generator_pk();
}
inline const ::std::string& BlockHeader::generator_pk() const {
  return *generator_pk_;
}
inline void BlockHeader::set_generator_pk(const ::std::string& value) {
  set_has_generator_pk();
  if (generator_pk_ == &::google::protobuf::internal::kEmptyString) {
    generator_pk_ = new ::std::string;
  }
  generator_pk_->assign(value);
}
inline void BlockHeader::set_generator_pk(const char* value) {
  set_has_generator_pk();
  if (generator_pk_ == &::google::protobuf::internal::kEmptyString) {
    generator_pk_ = new ::std::string;
  }
  generator_pk_->assign(value);
}
inline void BlockHeader::set_generator_pk(const void* value, size_t size) {
  set_has_generator_pk();
  if (generator_pk_ == &::google::protobuf::internal::kEmptyString) {
    generator_pk_ = new ::std::string;
  }
  generator_pk_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BlockHeader::mutable_generator_pk() {
  set_has_generator_pk();
  if (generator_pk_ == &::google::protobuf::internal::kEmptyString) {
    generator_pk_ = new ::std::string;
  }
  return generator_pk_;
}
inline ::std::string* BlockHeader::release_generator_pk() {
  clear_has_generator_pk();
  if (generator_pk_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = generator_pk_;
    generator_pk_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BlockHeader::set_allocated_generator_pk(::std::string* generator_pk) {
  if (generator_pk_ != &::google::protobuf::internal::kEmptyString) {
    delete generator_pk_;
  }
  if (generator_pk) {
    set_has_generator_pk();
    generator_pk_ = generator_pk;
  } else {
    clear_has_generator_pk();
    generator_pk_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes generating_sig = 40;
inline bool BlockHeader::has_generating_sig() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BlockHeader::set_has_generating_sig() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BlockHeader::clear_has_generating_sig() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BlockHeader::clear_generating_sig() {
  if (generating_sig_ != &::google::protobuf::internal::kEmptyString) {
    generating_sig_->clear();
  }
  clear_has_generating_sig();
}
inline const ::std::string& BlockHeader::generating_sig() const {
  return *generating_sig_;
}
inline void BlockHeader::set_generating_sig(const ::std::string& value) {
  set_has_generating_sig();
  if (generating_sig_ == &::google::protobuf::internal::kEmptyString) {
    generating_sig_ = new ::std::string;
  }
  generating_sig_->assign(value);
}
inline void BlockHeader::set_generating_sig(const char* value) {
  set_has_generating_sig();
  if (generating_sig_ == &::google::protobuf::internal::kEmptyString) {
    generating_sig_ = new ::std::string;
  }
  generating_sig_->assign(value);
}
inline void BlockHeader::set_generating_sig(const void* value, size_t size) {
  set_has_generating_sig();
  if (generating_sig_ == &::google::protobuf::internal::kEmptyString) {
    generating_sig_ = new ::std::string;
  }
  generating_sig_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BlockHeader::mutable_generating_sig() {
  set_has_generating_sig();
  if (generating_sig_ == &::google::protobuf::internal::kEmptyString) {
    generating_sig_ = new ::std::string;
  }
  return generating_sig_;
}
inline ::std::string* BlockHeader::release_generating_sig() {
  clear_has_generating_sig();
  if (generating_sig_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = generating_sig_;
    generating_sig_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BlockHeader::set_allocated_generating_sig(::std::string* generating_sig) {
  if (generating_sig_ != &::google::protobuf::internal::kEmptyString) {
    delete generating_sig_;
  }
  if (generating_sig) {
    set_has_generating_sig();
    generating_sig_ = generating_sig;
  } else {
    clear_has_generating_sig();
    generating_sig_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 basetarget = 50;
inline bool BlockHeader::has_basetarget() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BlockHeader::set_has_basetarget() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BlockHeader::clear_has_basetarget() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BlockHeader::clear_basetarget() {
  basetarget_ = GOOGLE_ULONGLONG(0);
  clear_has_basetarget();
}
inline ::google::protobuf::uint64 BlockHeader::basetarget() const {
  return basetarget_;
}
inline void BlockHeader::set_basetarget(::google::protobuf::uint64 value) {
  set_has_basetarget();
  basetarget_ = value;
}

// optional .fantasybit.BlockHeader.Type blocktype = 60;
inline bool BlockHeader::has_blocktype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BlockHeader::set_has_blocktype() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BlockHeader::clear_has_blocktype() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BlockHeader::clear_blocktype() {
  blocktype_ = 1;
  clear_has_blocktype();
}
inline ::fantasybit::BlockHeader_Type BlockHeader::blocktype() const {
  return static_cast< ::fantasybit::BlockHeader_Type >(blocktype_);
}
inline void BlockHeader::set_blocktype(::fantasybit::BlockHeader_Type value) {
  assert(::fantasybit::BlockHeader_Type_IsValid(value));
  set_has_blocktype();
  blocktype_ = value;
}

// optional bytes transaction_id = 70;
inline bool BlockHeader::has_transaction_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BlockHeader::set_has_transaction_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BlockHeader::clear_has_transaction_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BlockHeader::clear_transaction_id() {
  if (transaction_id_ != &::google::protobuf::internal::kEmptyString) {
    transaction_id_->clear();
  }
  clear_has_transaction_id();
}
inline const ::std::string& BlockHeader::transaction_id() const {
  return *transaction_id_;
}
inline void BlockHeader::set_transaction_id(const ::std::string& value) {
  set_has_transaction_id();
  if (transaction_id_ == &::google::protobuf::internal::kEmptyString) {
    transaction_id_ = new ::std::string;
  }
  transaction_id_->assign(value);
}
inline void BlockHeader::set_transaction_id(const char* value) {
  set_has_transaction_id();
  if (transaction_id_ == &::google::protobuf::internal::kEmptyString) {
    transaction_id_ = new ::std::string;
  }
  transaction_id_->assign(value);
}
inline void BlockHeader::set_transaction_id(const void* value, size_t size) {
  set_has_transaction_id();
  if (transaction_id_ == &::google::protobuf::internal::kEmptyString) {
    transaction_id_ = new ::std::string;
  }
  transaction_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BlockHeader::mutable_transaction_id() {
  set_has_transaction_id();
  if (transaction_id_ == &::google::protobuf::internal::kEmptyString) {
    transaction_id_ = new ::std::string;
  }
  return transaction_id_;
}
inline ::std::string* BlockHeader::release_transaction_id() {
  clear_has_transaction_id();
  if (transaction_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = transaction_id_;
    transaction_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BlockHeader::set_allocated_transaction_id(::std::string* transaction_id) {
  if (transaction_id_ != &::google::protobuf::internal::kEmptyString) {
    delete transaction_id_;
  }
  if (transaction_id) {
    set_has_transaction_id();
    transaction_id_ = transaction_id;
  } else {
    clear_has_transaction_id();
    transaction_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SignedBlockHeader

// optional .fantasybit.BlockHeader head = 10;
inline bool SignedBlockHeader::has_head() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignedBlockHeader::set_has_head() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignedBlockHeader::clear_has_head() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignedBlockHeader::clear_head() {
  if (head_ != NULL) head_->::fantasybit::BlockHeader::Clear();
  clear_has_head();
}
inline const ::fantasybit::BlockHeader& SignedBlockHeader::head() const {
  return head_ != NULL ? *head_ : *default_instance_->head_;
}
inline ::fantasybit::BlockHeader* SignedBlockHeader::mutable_head() {
  set_has_head();
  if (head_ == NULL) head_ = new ::fantasybit::BlockHeader;
  return head_;
}
inline ::fantasybit::BlockHeader* SignedBlockHeader::release_head() {
  clear_has_head();
  ::fantasybit::BlockHeader* temp = head_;
  head_ = NULL;
  return temp;
}
inline void SignedBlockHeader::set_allocated_head(::fantasybit::BlockHeader* head) {
  delete head_;
  head_ = head;
  if (head) {
    set_has_head();
  } else {
    clear_has_head();
  }
}

// optional string sig = 30;
inline bool SignedBlockHeader::has_sig() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignedBlockHeader::set_has_sig() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignedBlockHeader::clear_has_sig() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignedBlockHeader::clear_sig() {
  if (sig_ != &::google::protobuf::internal::kEmptyString) {
    sig_->clear();
  }
  clear_has_sig();
}
inline const ::std::string& SignedBlockHeader::sig() const {
  return *sig_;
}
inline void SignedBlockHeader::set_sig(const ::std::string& value) {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  sig_->assign(value);
}
inline void SignedBlockHeader::set_sig(const char* value) {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  sig_->assign(value);
}
inline void SignedBlockHeader::set_sig(const char* value, size_t size) {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  sig_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignedBlockHeader::mutable_sig() {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  return sig_;
}
inline ::std::string* SignedBlockHeader::release_sig() {
  clear_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sig_;
    sig_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignedBlockHeader::set_allocated_sig(::std::string* sig) {
  if (sig_ != &::google::protobuf::internal::kEmptyString) {
    delete sig_;
  }
  if (sig) {
    set_has_sig();
    sig_ = sig;
  } else {
    clear_has_sig();
    sig_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Block

// optional .fantasybit.SignedBlockHeader signedhead = 10;
inline bool Block::has_signedhead() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Block::set_has_signedhead() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Block::clear_has_signedhead() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Block::clear_signedhead() {
  if (signedhead_ != NULL) signedhead_->::fantasybit::SignedBlockHeader::Clear();
  clear_has_signedhead();
}
inline const ::fantasybit::SignedBlockHeader& Block::signedhead() const {
  return signedhead_ != NULL ? *signedhead_ : *default_instance_->signedhead_;
}
inline ::fantasybit::SignedBlockHeader* Block::mutable_signedhead() {
  set_has_signedhead();
  if (signedhead_ == NULL) signedhead_ = new ::fantasybit::SignedBlockHeader;
  return signedhead_;
}
inline ::fantasybit::SignedBlockHeader* Block::release_signedhead() {
  clear_has_signedhead();
  ::fantasybit::SignedBlockHeader* temp = signedhead_;
  signedhead_ = NULL;
  return temp;
}
inline void Block::set_allocated_signedhead(::fantasybit::SignedBlockHeader* signedhead) {
  delete signedhead_;
  signedhead_ = signedhead;
  if (signedhead) {
    set_has_signedhead();
  } else {
    clear_has_signedhead();
  }
}

// repeated .fantasybit.SignedTransaction signed_transactions = 20;
inline int Block::signed_transactions_size() const {
  return signed_transactions_.size();
}
inline void Block::clear_signed_transactions() {
  signed_transactions_.Clear();
}
inline const ::fantasybit::SignedTransaction& Block::signed_transactions(int index) const {
  return signed_transactions_.Get(index);
}
inline ::fantasybit::SignedTransaction* Block::mutable_signed_transactions(int index) {
  return signed_transactions_.Mutable(index);
}
inline ::fantasybit::SignedTransaction* Block::add_signed_transactions() {
  return signed_transactions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::SignedTransaction >&
Block::signed_transactions() const {
  return signed_transactions_;
}
inline ::google::protobuf::RepeatedPtrField< ::fantasybit::SignedTransaction >*
Block::mutable_signed_transactions() {
  return &signed_transactions_;
}

// -------------------------------------------------------------------

// NodeRequest

// optional .fantasybit.NodeRequest.Type type = 10;
inline bool NodeRequest::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeRequest::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeRequest::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::fantasybit::NodeRequest_Type NodeRequest::type() const {
  return static_cast< ::fantasybit::NodeRequest_Type >(type_);
}
inline void NodeRequest::set_type(::fantasybit::NodeRequest_Type value) {
  assert(::fantasybit::NodeRequest_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string myip = 20;
inline bool NodeRequest::has_myip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NodeRequest::set_has_myip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NodeRequest::clear_has_myip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NodeRequest::clear_myip() {
  if (myip_ != &::google::protobuf::internal::kEmptyString) {
    myip_->clear();
  }
  clear_has_myip();
}
inline const ::std::string& NodeRequest::myip() const {
  return *myip_;
}
inline void NodeRequest::set_myip(const ::std::string& value) {
  set_has_myip();
  if (myip_ == &::google::protobuf::internal::kEmptyString) {
    myip_ = new ::std::string;
  }
  myip_->assign(value);
}
inline void NodeRequest::set_myip(const char* value) {
  set_has_myip();
  if (myip_ == &::google::protobuf::internal::kEmptyString) {
    myip_ = new ::std::string;
  }
  myip_->assign(value);
}
inline void NodeRequest::set_myip(const char* value, size_t size) {
  set_has_myip();
  if (myip_ == &::google::protobuf::internal::kEmptyString) {
    myip_ = new ::std::string;
  }
  myip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeRequest::mutable_myip() {
  set_has_myip();
  if (myip_ == &::google::protobuf::internal::kEmptyString) {
    myip_ = new ::std::string;
  }
  return myip_;
}
inline ::std::string* NodeRequest::release_myip() {
  clear_has_myip();
  if (myip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = myip_;
    myip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NodeRequest::set_allocated_myip(::std::string* myip) {
  if (myip_ != &::google::protobuf::internal::kEmptyString) {
    delete myip_;
  }
  if (myip) {
    set_has_myip();
    myip_ = myip;
  } else {
    clear_has_myip();
    myip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 num = 30;
inline bool NodeRequest::has_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NodeRequest::set_has_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NodeRequest::clear_has_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NodeRequest::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 NodeRequest::num() const {
  return num_;
}
inline void NodeRequest::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// optional string myhost = 40;
inline bool NodeRequest::has_myhost() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NodeRequest::set_has_myhost() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NodeRequest::clear_has_myhost() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NodeRequest::clear_myhost() {
  if (myhost_ != &::google::protobuf::internal::kEmptyString) {
    myhost_->clear();
  }
  clear_has_myhost();
}
inline const ::std::string& NodeRequest::myhost() const {
  return *myhost_;
}
inline void NodeRequest::set_myhost(const ::std::string& value) {
  set_has_myhost();
  if (myhost_ == &::google::protobuf::internal::kEmptyString) {
    myhost_ = new ::std::string;
  }
  myhost_->assign(value);
}
inline void NodeRequest::set_myhost(const char* value) {
  set_has_myhost();
  if (myhost_ == &::google::protobuf::internal::kEmptyString) {
    myhost_ = new ::std::string;
  }
  myhost_->assign(value);
}
inline void NodeRequest::set_myhost(const char* value, size_t size) {
  set_has_myhost();
  if (myhost_ == &::google::protobuf::internal::kEmptyString) {
    myhost_ = new ::std::string;
  }
  myhost_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeRequest::mutable_myhost() {
  set_has_myhost();
  if (myhost_ == &::google::protobuf::internal::kEmptyString) {
    myhost_ = new ::std::string;
  }
  return myhost_;
}
inline ::std::string* NodeRequest::release_myhost() {
  clear_has_myhost();
  if (myhost_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = myhost_;
    myhost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NodeRequest::set_allocated_myhost(::std::string* myhost) {
  if (myhost_ != &::google::protobuf::internal::kEmptyString) {
    delete myhost_;
  }
  if (myhost) {
    set_has_myhost();
    myhost_ = myhost;
  } else {
    clear_has_myhost();
    myhost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// NodeReply

// optional int32 hight = 10;
inline bool NodeReply::has_hight() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeReply::set_has_hight() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeReply::clear_has_hight() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeReply::clear_hight() {
  hight_ = 0;
  clear_has_hight();
}
inline ::google::protobuf::int32 NodeReply::hight() const {
  return hight_;
}
inline void NodeReply::set_hight(::google::protobuf::int32 value) {
  set_has_hight();
  hight_ = value;
}

// repeated string ips = 20;
inline int NodeReply::ips_size() const {
  return ips_.size();
}
inline void NodeReply::clear_ips() {
  ips_.Clear();
}
inline const ::std::string& NodeReply::ips(int index) const {
  return ips_.Get(index);
}
inline ::std::string* NodeReply::mutable_ips(int index) {
  return ips_.Mutable(index);
}
inline void NodeReply::set_ips(int index, const ::std::string& value) {
  ips_.Mutable(index)->assign(value);
}
inline void NodeReply::set_ips(int index, const char* value) {
  ips_.Mutable(index)->assign(value);
}
inline void NodeReply::set_ips(int index, const char* value, size_t size) {
  ips_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeReply::add_ips() {
  return ips_.Add();
}
inline void NodeReply::add_ips(const ::std::string& value) {
  ips_.Add()->assign(value);
}
inline void NodeReply::add_ips(const char* value) {
  ips_.Add()->assign(value);
}
inline void NodeReply::add_ips(const char* value, size_t size) {
  ips_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
NodeReply::ips() const {
  return ips_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
NodeReply::mutable_ips() {
  return &ips_;
}

// -------------------------------------------------------------------

// FantasyPlayerPoints

// optional uint32 season = 10;
inline bool FantasyPlayerPoints::has_season() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FantasyPlayerPoints::set_has_season() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FantasyPlayerPoints::clear_has_season() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FantasyPlayerPoints::clear_season() {
  season_ = 0u;
  clear_has_season();
}
inline ::google::protobuf::uint32 FantasyPlayerPoints::season() const {
  return season_;
}
inline void FantasyPlayerPoints::set_season(::google::protobuf::uint32 value) {
  set_has_season();
  season_ = value;
}

// optional uint32 week = 20;
inline bool FantasyPlayerPoints::has_week() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FantasyPlayerPoints::set_has_week() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FantasyPlayerPoints::clear_has_week() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FantasyPlayerPoints::clear_week() {
  week_ = 0u;
  clear_has_week();
}
inline ::google::protobuf::uint32 FantasyPlayerPoints::week() const {
  return week_;
}
inline void FantasyPlayerPoints::set_week(::google::protobuf::uint32 value) {
  set_has_week();
  week_ = value;
}

// optional string playerid = 30;
inline bool FantasyPlayerPoints::has_playerid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FantasyPlayerPoints::set_has_playerid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FantasyPlayerPoints::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FantasyPlayerPoints::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& FantasyPlayerPoints::playerid() const {
  return *playerid_;
}
inline void FantasyPlayerPoints::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void FantasyPlayerPoints::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void FantasyPlayerPoints::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FantasyPlayerPoints::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* FantasyPlayerPoints::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FantasyPlayerPoints::set_allocated_playerid(::std::string* playerid) {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    delete playerid_;
  }
  if (playerid) {
    set_has_playerid();
    playerid_ = playerid;
  } else {
    clear_has_playerid();
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 points = 40;
inline bool FantasyPlayerPoints::has_points() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FantasyPlayerPoints::set_has_points() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FantasyPlayerPoints::clear_has_points() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FantasyPlayerPoints::clear_points() {
  points_ = 0;
  clear_has_points();
}
inline ::google::protobuf::int32 FantasyPlayerPoints::points() const {
  return points_;
}
inline void FantasyPlayerPoints::set_points(::google::protobuf::int32 value) {
  set_has_points();
  points_ = value;
}

// optional float result = 50;
inline bool FantasyPlayerPoints::has_result() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FantasyPlayerPoints::set_has_result() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FantasyPlayerPoints::clear_has_result() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FantasyPlayerPoints::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline float FantasyPlayerPoints::result() const {
  return result_;
}
inline void FantasyPlayerPoints::set_result(float value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// ProjectionTrans

// optional uint32 season = 10;
inline bool ProjectionTrans::has_season() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProjectionTrans::set_has_season() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProjectionTrans::clear_has_season() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProjectionTrans::clear_season() {
  season_ = 0u;
  clear_has_season();
}
inline ::google::protobuf::uint32 ProjectionTrans::season() const {
  return season_;
}
inline void ProjectionTrans::set_season(::google::protobuf::uint32 value) {
  set_has_season();
  season_ = value;
}

// optional uint32 week = 20;
inline bool ProjectionTrans::has_week() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProjectionTrans::set_has_week() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProjectionTrans::clear_has_week() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProjectionTrans::clear_week() {
  week_ = 0u;
  clear_has_week();
}
inline ::google::protobuf::uint32 ProjectionTrans::week() const {
  return week_;
}
inline void ProjectionTrans::set_week(::google::protobuf::uint32 value) {
  set_has_week();
  week_ = value;
}

// optional string playerid = 30;
inline bool ProjectionTrans::has_playerid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProjectionTrans::set_has_playerid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProjectionTrans::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProjectionTrans::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& ProjectionTrans::playerid() const {
  return *playerid_;
}
inline void ProjectionTrans::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void ProjectionTrans::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void ProjectionTrans::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProjectionTrans::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* ProjectionTrans::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProjectionTrans::set_allocated_playerid(::std::string* playerid) {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    delete playerid_;
  }
  if (playerid) {
    set_has_playerid();
    playerid_ = playerid;
  } else {
    clear_has_playerid();
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 points = 40;
inline bool ProjectionTrans::has_points() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProjectionTrans::set_has_points() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProjectionTrans::clear_has_points() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProjectionTrans::clear_points() {
  points_ = 0;
  clear_has_points();
}
inline ::google::protobuf::int32 ProjectionTrans::points() const {
  return points_;
}
inline void ProjectionTrans::set_points(::google::protobuf::int32 value) {
  set_has_points();
  points_ = value;
}

// -------------------------------------------------------------------

// PlayerPoints

// optional string playerid = 30;
inline bool PlayerPoints::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerPoints::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerPoints::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerPoints::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& PlayerPoints::playerid() const {
  return *playerid_;
}
inline void PlayerPoints::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void PlayerPoints::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void PlayerPoints::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerPoints::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* PlayerPoints::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerPoints::set_allocated_playerid(::std::string* playerid) {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    delete playerid_;
  }
  if (playerid) {
    set_has_playerid();
    playerid_ = playerid;
  } else {
    clear_has_playerid();
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 points = 40;
inline bool PlayerPoints::has_points() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerPoints::set_has_points() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerPoints::clear_has_points() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerPoints::clear_points() {
  points_ = 0;
  clear_has_points();
}
inline ::google::protobuf::int32 PlayerPoints::points() const {
  return points_;
}
inline void PlayerPoints::set_points(::google::protobuf::int32 value) {
  set_has_points();
  points_ = value;
}

// -------------------------------------------------------------------

// ProjectionTransBlock

// optional uint32 season = 10;
inline bool ProjectionTransBlock::has_season() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProjectionTransBlock::set_has_season() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProjectionTransBlock::clear_has_season() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProjectionTransBlock::clear_season() {
  season_ = 0u;
  clear_has_season();
}
inline ::google::protobuf::uint32 ProjectionTransBlock::season() const {
  return season_;
}
inline void ProjectionTransBlock::set_season(::google::protobuf::uint32 value) {
  set_has_season();
  season_ = value;
}

// optional uint32 week = 20;
inline bool ProjectionTransBlock::has_week() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProjectionTransBlock::set_has_week() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProjectionTransBlock::clear_has_week() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProjectionTransBlock::clear_week() {
  week_ = 0u;
  clear_has_week();
}
inline ::google::protobuf::uint32 ProjectionTransBlock::week() const {
  return week_;
}
inline void ProjectionTransBlock::set_week(::google::protobuf::uint32 value) {
  set_has_week();
  week_ = value;
}

// repeated .fantasybit.PlayerPoints player_points = 30;
inline int ProjectionTransBlock::player_points_size() const {
  return player_points_.size();
}
inline void ProjectionTransBlock::clear_player_points() {
  player_points_.Clear();
}
inline const ::fantasybit::PlayerPoints& ProjectionTransBlock::player_points(int index) const {
  return player_points_.Get(index);
}
inline ::fantasybit::PlayerPoints* ProjectionTransBlock::mutable_player_points(int index) {
  return player_points_.Mutable(index);
}
inline ::fantasybit::PlayerPoints* ProjectionTransBlock::add_player_points() {
  return player_points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::PlayerPoints >&
ProjectionTransBlock::player_points() const {
  return player_points_;
}
inline ::google::protobuf::RepeatedPtrField< ::fantasybit::PlayerPoints >*
ProjectionTransBlock::mutable_player_points() {
  return &player_points_;
}

// -------------------------------------------------------------------

// Data

// optional int32 version = 10;
inline bool Data::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Data::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Data::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Data::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 Data::version() const {
  return version_;
}
inline void Data::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
}

// optional .fantasybit.Data.Type type = 20;
inline bool Data::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Data::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Data::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Data::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::fantasybit::Data_Type Data::type() const {
  return static_cast< ::fantasybit::Data_Type >(type_);
}
inline void Data::set_type(::fantasybit::Data_Type value) {
  assert(::fantasybit::Data_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// PlayerData

// optional string playerid = 10;
inline bool PlayerData::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerData::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerData::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerData::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& PlayerData::playerid() const {
  return *playerid_;
}
inline void PlayerData::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void PlayerData::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void PlayerData::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerData::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* PlayerData::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerData::set_allocated_playerid(::std::string* playerid) {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    delete playerid_;
  }
  if (playerid) {
    set_has_playerid();
    playerid_ = playerid;
  } else {
    clear_has_playerid();
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .fantasybit.PlayerBase player_base = 20;
inline bool PlayerData::has_player_base() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerData::set_has_player_base() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerData::clear_has_player_base() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerData::clear_player_base() {
  if (player_base_ != NULL) player_base_->::fantasybit::PlayerBase::Clear();
  clear_has_player_base();
}
inline const ::fantasybit::PlayerBase& PlayerData::player_base() const {
  return player_base_ != NULL ? *player_base_ : *default_instance_->player_base_;
}
inline ::fantasybit::PlayerBase* PlayerData::mutable_player_base() {
  set_has_player_base();
  if (player_base_ == NULL) player_base_ = new ::fantasybit::PlayerBase;
  return player_base_;
}
inline ::fantasybit::PlayerBase* PlayerData::release_player_base() {
  clear_has_player_base();
  ::fantasybit::PlayerBase* temp = player_base_;
  player_base_ = NULL;
  return temp;
}
inline void PlayerData::set_allocated_player_base(::fantasybit::PlayerBase* player_base) {
  delete player_base_;
  player_base_ = player_base;
  if (player_base) {
    set_has_player_base();
  } else {
    clear_has_player_base();
  }
}

// optional .fantasybit.PlayerStatus player_status = 30;
inline bool PlayerData::has_player_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerData::set_has_player_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerData::clear_has_player_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerData::clear_player_status() {
  if (player_status_ != NULL) player_status_->::fantasybit::PlayerStatus::Clear();
  clear_has_player_status();
}
inline const ::fantasybit::PlayerStatus& PlayerData::player_status() const {
  return player_status_ != NULL ? *player_status_ : *default_instance_->player_status_;
}
inline ::fantasybit::PlayerStatus* PlayerData::mutable_player_status() {
  set_has_player_status();
  if (player_status_ == NULL) player_status_ = new ::fantasybit::PlayerStatus;
  return player_status_;
}
inline ::fantasybit::PlayerStatus* PlayerData::release_player_status() {
  clear_has_player_status();
  ::fantasybit::PlayerStatus* temp = player_status_;
  player_status_ = NULL;
  return temp;
}
inline void PlayerData::set_allocated_player_status(::fantasybit::PlayerStatus* player_status) {
  delete player_status_;
  player_status_ = player_status;
  if (player_status) {
    set_has_player_status();
  } else {
    clear_has_player_status();
  }
}

// optional .fantasybit.PlayerGameStatus player_game_status = 40;
inline bool PlayerData::has_player_game_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerData::set_has_player_game_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerData::clear_has_player_game_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerData::clear_player_game_status() {
  player_game_status_ = 0;
  clear_has_player_game_status();
}
inline ::fantasybit::PlayerGameStatus PlayerData::player_game_status() const {
  return static_cast< ::fantasybit::PlayerGameStatus >(player_game_status_);
}
inline void PlayerData::set_player_game_status(::fantasybit::PlayerGameStatus value) {
  assert(::fantasybit::PlayerGameStatus_IsValid(value));
  set_has_player_game_status();
  player_game_status_ = value;
}

// -------------------------------------------------------------------

// GameData

// optional string gameid = 10;
inline bool GameData::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameData::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameData::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameData::clear_gameid() {
  if (gameid_ != &::google::protobuf::internal::kEmptyString) {
    gameid_->clear();
  }
  clear_has_gameid();
}
inline const ::std::string& GameData::gameid() const {
  return *gameid_;
}
inline void GameData::set_gameid(const ::std::string& value) {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  gameid_->assign(value);
}
inline void GameData::set_gameid(const char* value) {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  gameid_->assign(value);
}
inline void GameData::set_gameid(const char* value, size_t size) {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  gameid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameData::mutable_gameid() {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  return gameid_;
}
inline ::std::string* GameData::release_gameid() {
  clear_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gameid_;
    gameid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameData::set_allocated_gameid(::std::string* gameid) {
  if (gameid_ != &::google::protobuf::internal::kEmptyString) {
    delete gameid_;
  }
  if (gameid) {
    set_has_gameid();
    gameid_ = gameid;
  } else {
    clear_has_gameid();
    gameid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .fantasybit.GameStatus status = 20;
inline bool GameData::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameData::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameData::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameData::clear_status() {
  if (status_ != NULL) status_->::fantasybit::GameStatus::Clear();
  clear_has_status();
}
inline const ::fantasybit::GameStatus& GameData::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::fantasybit::GameStatus* GameData::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::fantasybit::GameStatus;
  return status_;
}
inline ::fantasybit::GameStatus* GameData::release_status() {
  clear_has_status();
  ::fantasybit::GameStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline void GameData::set_allocated_status(::fantasybit::GameStatus* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
}

// -------------------------------------------------------------------

// ResultData

// optional .fantasybit.GameResult game_result = 10;
inline bool ResultData::has_game_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResultData::set_has_game_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResultData::clear_has_game_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResultData::clear_game_result() {
  if (game_result_ != NULL) game_result_->::fantasybit::GameResult::Clear();
  clear_has_game_result();
}
inline const ::fantasybit::GameResult& ResultData::game_result() const {
  return game_result_ != NULL ? *game_result_ : *default_instance_->game_result_;
}
inline ::fantasybit::GameResult* ResultData::mutable_game_result() {
  set_has_game_result();
  if (game_result_ == NULL) game_result_ = new ::fantasybit::GameResult;
  return game_result_;
}
inline ::fantasybit::GameResult* ResultData::release_game_result() {
  clear_has_game_result();
  ::fantasybit::GameResult* temp = game_result_;
  game_result_ = NULL;
  return temp;
}
inline void ResultData::set_allocated_game_result(::fantasybit::GameResult* game_result) {
  delete game_result_;
  game_result_ = game_result;
  if (game_result) {
    set_has_game_result();
  } else {
    clear_has_game_result();
  }
}

// -------------------------------------------------------------------

// ScheduleData

// optional int32 week = 1;
inline bool ScheduleData::has_week() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScheduleData::set_has_week() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScheduleData::clear_has_week() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScheduleData::clear_week() {
  week_ = 0;
  clear_has_week();
}
inline ::google::protobuf::int32 ScheduleData::week() const {
  return week_;
}
inline void ScheduleData::set_week(::google::protobuf::int32 value) {
  set_has_week();
  week_ = value;
}

// optional .fantasybit.WeeklySchedule weekly = 10;
inline bool ScheduleData::has_weekly() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScheduleData::set_has_weekly() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScheduleData::clear_has_weekly() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScheduleData::clear_weekly() {
  if (weekly_ != NULL) weekly_->::fantasybit::WeeklySchedule::Clear();
  clear_has_weekly();
}
inline const ::fantasybit::WeeklySchedule& ScheduleData::weekly() const {
  return weekly_ != NULL ? *weekly_ : *default_instance_->weekly_;
}
inline ::fantasybit::WeeklySchedule* ScheduleData::mutable_weekly() {
  set_has_weekly();
  if (weekly_ == NULL) weekly_ = new ::fantasybit::WeeklySchedule;
  return weekly_;
}
inline ::fantasybit::WeeklySchedule* ScheduleData::release_weekly() {
  clear_has_weekly();
  ::fantasybit::WeeklySchedule* temp = weekly_;
  weekly_ = NULL;
  return temp;
}
inline void ScheduleData::set_allocated_weekly(::fantasybit::WeeklySchedule* weekly) {
  delete weekly_;
  weekly_ = weekly;
  if (weekly) {
    set_has_weekly();
  } else {
    clear_has_weekly();
  }
}

// -------------------------------------------------------------------

// DataTransition

// optional .fantasybit.TrType type = 1;
inline bool DataTransition::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataTransition::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataTransition::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataTransition::clear_type() {
  type_ = 2;
  clear_has_type();
}
inline ::fantasybit::TrType DataTransition::type() const {
  return static_cast< ::fantasybit::TrType >(type_);
}
inline void DataTransition::set_type(::fantasybit::TrType value) {
  assert(::fantasybit::TrType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional uint32 season = 10;
inline bool DataTransition::has_season() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataTransition::set_has_season() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataTransition::clear_has_season() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataTransition::clear_season() {
  season_ = 0u;
  clear_has_season();
}
inline ::google::protobuf::uint32 DataTransition::season() const {
  return season_;
}
inline void DataTransition::set_season(::google::protobuf::uint32 value) {
  set_has_season();
  season_ = value;
}

// optional uint32 week = 20;
inline bool DataTransition::has_week() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DataTransition::set_has_week() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DataTransition::clear_has_week() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DataTransition::clear_week() {
  week_ = 0u;
  clear_has_week();
}
inline ::google::protobuf::uint32 DataTransition::week() const {
  return week_;
}
inline void DataTransition::set_week(::google::protobuf::uint32 value) {
  set_has_week();
  week_ = value;
}

// repeated .fantasybit.GameData gamedata = 30;
inline int DataTransition::gamedata_size() const {
  return gamedata_.size();
}
inline void DataTransition::clear_gamedata() {
  gamedata_.Clear();
}
inline const ::fantasybit::GameData& DataTransition::gamedata(int index) const {
  return gamedata_.Get(index);
}
inline ::fantasybit::GameData* DataTransition::mutable_gamedata(int index) {
  return gamedata_.Mutable(index);
}
inline ::fantasybit::GameData* DataTransition::add_gamedata() {
  return gamedata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::GameData >&
DataTransition::gamedata() const {
  return gamedata_;
}
inline ::google::protobuf::RepeatedPtrField< ::fantasybit::GameData >*
DataTransition::mutable_gamedata() {
  return &gamedata_;
}

// repeated .fantasybit.Data data = 40;
inline int DataTransition::data_size() const {
  return data_.size();
}
inline void DataTransition::clear_data() {
  data_.Clear();
}
inline const ::fantasybit::Data& DataTransition::data(int index) const {
  return data_.Get(index);
}
inline ::fantasybit::Data* DataTransition::mutable_data(int index) {
  return data_.Mutable(index);
}
inline ::fantasybit::Data* DataTransition::add_data() {
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::Data >&
DataTransition::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::fantasybit::Data >*
DataTransition::mutable_data() {
  return &data_;
}

// -------------------------------------------------------------------

// TeamState

// optional .fantasybit.TeamState.State state = 1;
inline bool TeamState::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TeamState::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TeamState::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TeamState::clear_state() {
  state_ = 1;
  clear_has_state();
}
inline ::fantasybit::TeamState_State TeamState::state() const {
  return static_cast< ::fantasybit::TeamState_State >(state_);
}
inline void TeamState::set_state(::fantasybit::TeamState_State value) {
  assert(::fantasybit::TeamState_State_IsValid(value));
  set_has_state();
  state_ = value;
}

// optional uint32 week = 10;
inline bool TeamState::has_week() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TeamState::set_has_week() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TeamState::clear_has_week() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TeamState::clear_week() {
  week_ = 0u;
  clear_has_week();
}
inline ::google::protobuf::uint32 TeamState::week() const {
  return week_;
}
inline void TeamState::set_week(::google::protobuf::uint32 value) {
  set_has_week();
  week_ = value;
}

// optional string teamid = 20;
inline bool TeamState::has_teamid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TeamState::set_has_teamid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TeamState::clear_has_teamid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TeamState::clear_teamid() {
  if (teamid_ != &::google::protobuf::internal::kEmptyString) {
    teamid_->clear();
  }
  clear_has_teamid();
}
inline const ::std::string& TeamState::teamid() const {
  return *teamid_;
}
inline void TeamState::set_teamid(const ::std::string& value) {
  set_has_teamid();
  if (teamid_ == &::google::protobuf::internal::kEmptyString) {
    teamid_ = new ::std::string;
  }
  teamid_->assign(value);
}
inline void TeamState::set_teamid(const char* value) {
  set_has_teamid();
  if (teamid_ == &::google::protobuf::internal::kEmptyString) {
    teamid_ = new ::std::string;
  }
  teamid_->assign(value);
}
inline void TeamState::set_teamid(const char* value, size_t size) {
  set_has_teamid();
  if (teamid_ == &::google::protobuf::internal::kEmptyString) {
    teamid_ = new ::std::string;
  }
  teamid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TeamState::mutable_teamid() {
  set_has_teamid();
  if (teamid_ == &::google::protobuf::internal::kEmptyString) {
    teamid_ = new ::std::string;
  }
  return teamid_;
}
inline ::std::string* TeamState::release_teamid() {
  clear_has_teamid();
  if (teamid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = teamid_;
    teamid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TeamState::set_allocated_teamid(::std::string* teamid) {
  if (teamid_ != &::google::protobuf::internal::kEmptyString) {
    delete teamid_;
  }
  if (teamid) {
    set_has_teamid();
    teamid_ = teamid;
  } else {
    clear_has_teamid();
    teamid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DeltaData

// optional .fantasybit.DeltaData.Type type = 1;
inline bool DeltaData::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeltaData::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeltaData::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeltaData::clear_type() {
  type_ = 2;
  clear_has_type();
}
inline ::fantasybit::DeltaData_Type DeltaData::type() const {
  return static_cast< ::fantasybit::DeltaData_Type >(type_);
}
inline void DeltaData::set_type(::fantasybit::DeltaData_Type value) {
  assert(::fantasybit::DeltaData_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// repeated .fantasybit.MyFantasyName myfantasyname = 2;
inline int DeltaData::myfantasyname_size() const {
  return myfantasyname_.size();
}
inline void DeltaData::clear_myfantasyname() {
  myfantasyname_.Clear();
}
inline const ::fantasybit::MyFantasyName& DeltaData::myfantasyname(int index) const {
  return myfantasyname_.Get(index);
}
inline ::fantasybit::MyFantasyName* DeltaData::mutable_myfantasyname(int index) {
  return myfantasyname_.Mutable(index);
}
inline ::fantasybit::MyFantasyName* DeltaData::add_myfantasyname() {
  return myfantasyname_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::MyFantasyName >&
DeltaData::myfantasyname() const {
  return myfantasyname_;
}
inline ::google::protobuf::RepeatedPtrField< ::fantasybit::MyFantasyName >*
DeltaData::mutable_myfantasyname() {
  return &myfantasyname_;
}

// optional .fantasybit.GlobalState globalstate = 10;
inline bool DeltaData::has_globalstate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeltaData::set_has_globalstate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeltaData::clear_has_globalstate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeltaData::clear_globalstate() {
  if (globalstate_ != NULL) globalstate_->::fantasybit::GlobalState::Clear();
  clear_has_globalstate();
}
inline const ::fantasybit::GlobalState& DeltaData::globalstate() const {
  return globalstate_ != NULL ? *globalstate_ : *default_instance_->globalstate_;
}
inline ::fantasybit::GlobalState* DeltaData::mutable_globalstate() {
  set_has_globalstate();
  if (globalstate_ == NULL) globalstate_ = new ::fantasybit::GlobalState;
  return globalstate_;
}
inline ::fantasybit::GlobalState* DeltaData::release_globalstate() {
  clear_has_globalstate();
  ::fantasybit::GlobalState* temp = globalstate_;
  globalstate_ = NULL;
  return temp;
}
inline void DeltaData::set_allocated_globalstate(::fantasybit::GlobalState* globalstate) {
  delete globalstate_;
  globalstate_ = globalstate;
  if (globalstate) {
    set_has_globalstate();
  } else {
    clear_has_globalstate();
  }
}

// repeated .fantasybit.TeamState teamstates = 20;
inline int DeltaData::teamstates_size() const {
  return teamstates_.size();
}
inline void DeltaData::clear_teamstates() {
  teamstates_.Clear();
}
inline const ::fantasybit::TeamState& DeltaData::teamstates(int index) const {
  return teamstates_.Get(index);
}
inline ::fantasybit::TeamState* DeltaData::mutable_teamstates(int index) {
  return teamstates_.Mutable(index);
}
inline ::fantasybit::TeamState* DeltaData::add_teamstates() {
  return teamstates_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::TeamState >&
DeltaData::teamstates() const {
  return teamstates_;
}
inline ::google::protobuf::RepeatedPtrField< ::fantasybit::TeamState >*
DeltaData::mutable_teamstates() {
  return &teamstates_;
}

// repeated .fantasybit.Data datas = 30;
inline int DeltaData::datas_size() const {
  return datas_.size();
}
inline void DeltaData::clear_datas() {
  datas_.Clear();
}
inline const ::fantasybit::Data& DeltaData::datas(int index) const {
  return datas_.Get(index);
}
inline ::fantasybit::Data* DeltaData::mutable_datas(int index) {
  return datas_.Mutable(index);
}
inline ::fantasybit::Data* DeltaData::add_datas() {
  return datas_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::Data >&
DeltaData::datas() const {
  return datas_;
}
inline ::google::protobuf::RepeatedPtrField< ::fantasybit::Data >*
DeltaData::mutable_datas() {
  return &datas_;
}

// repeated .fantasybit.FantasyPlayer players = 40;
inline int DeltaData::players_size() const {
  return players_.size();
}
inline void DeltaData::clear_players() {
  players_.Clear();
}
inline const ::fantasybit::FantasyPlayer& DeltaData::players(int index) const {
  return players_.Get(index);
}
inline ::fantasybit::FantasyPlayer* DeltaData::mutable_players(int index) {
  return players_.Mutable(index);
}
inline ::fantasybit::FantasyPlayer* DeltaData::add_players() {
  return players_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::FantasyPlayer >&
DeltaData::players() const {
  return players_;
}
inline ::google::protobuf::RepeatedPtrField< ::fantasybit::FantasyPlayer >*
DeltaData::mutable_players() {
  return &players_;
}

// -------------------------------------------------------------------

// MessageData

// optional string msg = 10;
inline bool MessageData::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageData::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageData::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageData::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& MessageData::msg() const {
  return *msg_;
}
inline void MessageData::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void MessageData::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void MessageData::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageData::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* MessageData::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessageData::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 gt = 20;
inline bool MessageData::has_gt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageData::set_has_gt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageData::clear_has_gt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessageData::clear_gt() {
  gt_ = 0;
  clear_has_gt();
}
inline ::google::protobuf::int32 MessageData::gt() const {
  return gt_;
}
inline void MessageData::set_gt(::google::protobuf::int32 value) {
  set_has_gt();
  gt_ = value;
}

// optional int32 lt = 30;
inline bool MessageData::has_lt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MessageData::set_has_lt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MessageData::clear_has_lt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MessageData::clear_lt() {
  lt_ = 0;
  clear_has_lt();
}
inline ::google::protobuf::int32 MessageData::lt() const {
  return lt_;
}
inline void MessageData::set_lt(::google::protobuf::int32 value) {
  set_has_lt();
  lt_ = value;
}

// -------------------------------------------------------------------

// StampedTrans

// optional uint64 timestamp = 10;
inline bool StampedTrans::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StampedTrans::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StampedTrans::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StampedTrans::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 StampedTrans::timestamp() const {
  return timestamp_;
}
inline void StampedTrans::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional int32 seqnum = 20;
inline bool StampedTrans::has_seqnum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StampedTrans::set_has_seqnum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StampedTrans::clear_has_seqnum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StampedTrans::clear_seqnum() {
  seqnum_ = 0;
  clear_has_seqnum();
}
inline ::google::protobuf::int32 StampedTrans::seqnum() const {
  return seqnum_;
}
inline void StampedTrans::set_seqnum(::google::protobuf::int32 value) {
  set_has_seqnum();
  seqnum_ = value;
}

// optional int32 prevseq = 21;
inline bool StampedTrans::has_prevseq() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StampedTrans::set_has_prevseq() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StampedTrans::clear_has_prevseq() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StampedTrans::clear_prevseq() {
  prevseq_ = 0;
  clear_has_prevseq();
}
inline ::google::protobuf::int32 StampedTrans::prevseq() const {
  return prevseq_;
}
inline void StampedTrans::set_prevseq(::google::protobuf::int32 value) {
  set_has_prevseq();
  prevseq_ = value;
}

// optional .fantasybit.SignedTransaction signed_orig = 30;
inline bool StampedTrans::has_signed_orig() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StampedTrans::set_has_signed_orig() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StampedTrans::clear_has_signed_orig() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StampedTrans::clear_signed_orig() {
  if (signed_orig_ != NULL) signed_orig_->::fantasybit::SignedTransaction::Clear();
  clear_has_signed_orig();
}
inline const ::fantasybit::SignedTransaction& StampedTrans::signed_orig() const {
  return signed_orig_ != NULL ? *signed_orig_ : *default_instance_->signed_orig_;
}
inline ::fantasybit::SignedTransaction* StampedTrans::mutable_signed_orig() {
  set_has_signed_orig();
  if (signed_orig_ == NULL) signed_orig_ = new ::fantasybit::SignedTransaction;
  return signed_orig_;
}
inline ::fantasybit::SignedTransaction* StampedTrans::release_signed_orig() {
  clear_has_signed_orig();
  ::fantasybit::SignedTransaction* temp = signed_orig_;
  signed_orig_ = NULL;
  return temp;
}
inline void StampedTrans::set_allocated_signed_orig(::fantasybit::SignedTransaction* signed_orig) {
  delete signed_orig_;
  signed_orig_ = signed_orig;
  if (signed_orig) {
    set_has_signed_orig();
  } else {
    clear_has_signed_orig();
  }
}

// -------------------------------------------------------------------

// ExchangeOrder

// optional .fantasybit.ExchangeOrder.Type type = 10;
inline bool ExchangeOrder::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExchangeOrder::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExchangeOrder::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExchangeOrder::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::fantasybit::ExchangeOrder_Type ExchangeOrder::type() const {
  return static_cast< ::fantasybit::ExchangeOrder_Type >(type_);
}
inline void ExchangeOrder::set_type(::fantasybit::ExchangeOrder_Type value) {
  assert(::fantasybit::ExchangeOrder_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string playerid = 40;
inline bool ExchangeOrder::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExchangeOrder::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExchangeOrder::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExchangeOrder::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& ExchangeOrder::playerid() const {
  return *playerid_;
}
inline void ExchangeOrder::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void ExchangeOrder::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void ExchangeOrder::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExchangeOrder::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* ExchangeOrder::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExchangeOrder::set_allocated_playerid(::std::string* playerid) {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    delete playerid_;
  }
  if (playerid) {
    set_has_playerid();
    playerid_ = playerid;
  } else {
    clear_has_playerid();
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .fantasybit.OrderCore core = 50;
inline bool ExchangeOrder::has_core() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExchangeOrder::set_has_core() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExchangeOrder::clear_has_core() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExchangeOrder::clear_core() {
  if (core_ != NULL) core_->::fantasybit::OrderCore::Clear();
  clear_has_core();
}
inline const ::fantasybit::OrderCore& ExchangeOrder::core() const {
  return core_ != NULL ? *core_ : *default_instance_->core_;
}
inline ::fantasybit::OrderCore* ExchangeOrder::mutable_core() {
  set_has_core();
  if (core_ == NULL) core_ = new ::fantasybit::OrderCore;
  return core_;
}
inline ::fantasybit::OrderCore* ExchangeOrder::release_core() {
  clear_has_core();
  ::fantasybit::OrderCore* temp = core_;
  core_ = NULL;
  return temp;
}
inline void ExchangeOrder::set_allocated_core(::fantasybit::OrderCore* core) {
  delete core_;
  core_ = core;
  if (core) {
    set_has_core();
  } else {
    clear_has_core();
  }
}

// optional int32 cancel_oref = 100;
inline bool ExchangeOrder::has_cancel_oref() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExchangeOrder::set_has_cancel_oref() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExchangeOrder::clear_has_cancel_oref() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExchangeOrder::clear_cancel_oref() {
  cancel_oref_ = 0;
  clear_has_cancel_oref();
}
inline ::google::protobuf::int32 ExchangeOrder::cancel_oref() const {
  return cancel_oref_;
}
inline void ExchangeOrder::set_cancel_oref(::google::protobuf::int32 value) {
  set_has_cancel_oref();
  cancel_oref_ = value;
}

// optional .fantasybit.FutContract futcontract = 110;
inline bool ExchangeOrder::has_futcontract() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ExchangeOrder::set_has_futcontract() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ExchangeOrder::clear_has_futcontract() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ExchangeOrder::clear_futcontract() {
  if (futcontract_ != NULL) futcontract_->::fantasybit::FutContract::Clear();
  clear_has_futcontract();
}
inline const ::fantasybit::FutContract& ExchangeOrder::futcontract() const {
  return futcontract_ != NULL ? *futcontract_ : *default_instance_->futcontract_;
}
inline ::fantasybit::FutContract* ExchangeOrder::mutable_futcontract() {
  set_has_futcontract();
  if (futcontract_ == NULL) futcontract_ = new ::fantasybit::FutContract;
  return futcontract_;
}
inline ::fantasybit::FutContract* ExchangeOrder::release_futcontract() {
  clear_has_futcontract();
  ::fantasybit::FutContract* temp = futcontract_;
  futcontract_ = NULL;
  return temp;
}
inline void ExchangeOrder::set_allocated_futcontract(::fantasybit::FutContract* futcontract) {
  delete futcontract_;
  futcontract_ = futcontract;
  if (futcontract) {
    set_has_futcontract();
  } else {
    clear_has_futcontract();
  }
}

// optional string symbol = 120;
inline bool ExchangeOrder::has_symbol() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ExchangeOrder::set_has_symbol() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ExchangeOrder::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ExchangeOrder::clear_symbol() {
  if (symbol_ != &::google::protobuf::internal::kEmptyString) {
    symbol_->clear();
  }
  clear_has_symbol();
}
inline const ::std::string& ExchangeOrder::symbol() const {
  return *symbol_;
}
inline void ExchangeOrder::set_symbol(const ::std::string& value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void ExchangeOrder::set_symbol(const char* value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void ExchangeOrder::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExchangeOrder::mutable_symbol() {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  return symbol_;
}
inline ::std::string* ExchangeOrder::release_symbol() {
  clear_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = symbol_;
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExchangeOrder::set_allocated_symbol(::std::string* symbol) {
  if (symbol_ != &::google::protobuf::internal::kEmptyString) {
    delete symbol_;
  }
  if (symbol) {
    set_has_symbol();
    symbol_ = symbol;
  } else {
    clear_has_symbol();
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// OrderUnique

// optional string public_key = 10;
inline bool OrderUnique::has_public_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OrderUnique::set_has_public_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OrderUnique::clear_has_public_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OrderUnique::clear_public_key() {
  if (public_key_ != &::google::protobuf::internal::kEmptyString) {
    public_key_->clear();
  }
  clear_has_public_key();
}
inline const ::std::string& OrderUnique::public_key() const {
  return *public_key_;
}
inline void OrderUnique::set_public_key(const ::std::string& value) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void OrderUnique::set_public_key(const char* value) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void OrderUnique::set_public_key(const char* value, size_t size) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderUnique::mutable_public_key() {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}
inline ::std::string* OrderUnique::release_public_key() {
  clear_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = public_key_;
    public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderUnique::set_allocated_public_key(::std::string* public_key) {
  if (public_key_ != &::google::protobuf::internal::kEmptyString) {
    delete public_key_;
  }
  if (public_key) {
    set_has_public_key();
    public_key_ = public_key;
  } else {
    clear_has_public_key();
    public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 season = 20;
inline bool OrderUnique::has_season() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OrderUnique::set_has_season() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OrderUnique::clear_has_season() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OrderUnique::clear_season() {
  season_ = 0u;
  clear_has_season();
}
inline ::google::protobuf::uint32 OrderUnique::season() const {
  return season_;
}
inline void OrderUnique::set_season(::google::protobuf::uint32 value) {
  set_has_season();
  season_ = value;
}

// optional uint32 week = 30;
inline bool OrderUnique::has_week() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OrderUnique::set_has_week() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OrderUnique::clear_has_week() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OrderUnique::clear_week() {
  week_ = 0u;
  clear_has_week();
}
inline ::google::protobuf::uint32 OrderUnique::week() const {
  return week_;
}
inline void OrderUnique::set_week(::google::protobuf::uint32 value) {
  set_has_week();
  week_ = value;
}

// optional bool buyside = 40;
inline bool OrderUnique::has_buyside() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OrderUnique::set_has_buyside() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OrderUnique::clear_has_buyside() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OrderUnique::clear_buyside() {
  buyside_ = false;
  clear_has_buyside();
}
inline bool OrderUnique::buyside() const {
  return buyside_;
}
inline void OrderUnique::set_buyside(bool value) {
  set_has_buyside();
  buyside_ = value;
}

// optional string playerid = 50;
inline bool OrderUnique::has_playerid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OrderUnique::set_has_playerid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OrderUnique::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OrderUnique::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& OrderUnique::playerid() const {
  return *playerid_;
}
inline void OrderUnique::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void OrderUnique::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void OrderUnique::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderUnique::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* OrderUnique::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderUnique::set_allocated_playerid(::std::string* playerid) {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    delete playerid_;
  }
  if (playerid) {
    set_has_playerid();
    playerid_ = playerid;
  } else {
    clear_has_playerid();
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 price = 70;
inline bool OrderUnique::has_price() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OrderUnique::set_has_price() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OrderUnique::clear_has_price() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OrderUnique::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 OrderUnique::price() const {
  return price_;
}
inline void OrderUnique::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
}

// -------------------------------------------------------------------

// OrderDeets

// optional bytes oid = 10;
inline bool OrderDeets::has_oid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OrderDeets::set_has_oid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OrderDeets::clear_has_oid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OrderDeets::clear_oid() {
  if (oid_ != &::google::protobuf::internal::kEmptyString) {
    oid_->clear();
  }
  clear_has_oid();
}
inline const ::std::string& OrderDeets::oid() const {
  return *oid_;
}
inline void OrderDeets::set_oid(const ::std::string& value) {
  set_has_oid();
  if (oid_ == &::google::protobuf::internal::kEmptyString) {
    oid_ = new ::std::string;
  }
  oid_->assign(value);
}
inline void OrderDeets::set_oid(const char* value) {
  set_has_oid();
  if (oid_ == &::google::protobuf::internal::kEmptyString) {
    oid_ = new ::std::string;
  }
  oid_->assign(value);
}
inline void OrderDeets::set_oid(const void* value, size_t size) {
  set_has_oid();
  if (oid_ == &::google::protobuf::internal::kEmptyString) {
    oid_ = new ::std::string;
  }
  oid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderDeets::mutable_oid() {
  set_has_oid();
  if (oid_ == &::google::protobuf::internal::kEmptyString) {
    oid_ = new ::std::string;
  }
  return oid_;
}
inline ::std::string* OrderDeets::release_oid() {
  clear_has_oid();
  if (oid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = oid_;
    oid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderDeets::set_allocated_oid(::std::string* oid) {
  if (oid_ != &::google::protobuf::internal::kEmptyString) {
    delete oid_;
  }
  if (oid) {
    set_has_oid();
    oid_ = oid;
  } else {
    clear_has_oid();
    oid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .fantasybit.OrderUnique order = 20;
inline bool OrderDeets::has_order() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OrderDeets::set_has_order() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OrderDeets::clear_has_order() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OrderDeets::clear_order() {
  if (order_ != NULL) order_->::fantasybit::OrderUnique::Clear();
  clear_has_order();
}
inline const ::fantasybit::OrderUnique& OrderDeets::order() const {
  return order_ != NULL ? *order_ : *default_instance_->order_;
}
inline ::fantasybit::OrderUnique* OrderDeets::mutable_order() {
  set_has_order();
  if (order_ == NULL) order_ = new ::fantasybit::OrderUnique;
  return order_;
}
inline ::fantasybit::OrderUnique* OrderDeets::release_order() {
  clear_has_order();
  ::fantasybit::OrderUnique* temp = order_;
  order_ = NULL;
  return temp;
}
inline void OrderDeets::set_allocated_order(::fantasybit::OrderUnique* order) {
  delete order_;
  order_ = order;
  if (order) {
    set_has_order();
  } else {
    clear_has_order();
  }
}

// optional int32 size = 30;
inline bool OrderDeets::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OrderDeets::set_has_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OrderDeets::clear_has_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OrderDeets::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::google::protobuf::int32 OrderDeets::size() const {
  return size_;
}
inline void OrderDeets::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
}

// -------------------------------------------------------------------

// InsideUnique

// optional string playerid = 50;
inline bool InsideUnique::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InsideUnique::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InsideUnique::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InsideUnique::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& InsideUnique::playerid() const {
  return *playerid_;
}
inline void InsideUnique::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void InsideUnique::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void InsideUnique::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InsideUnique::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* InsideUnique::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InsideUnique::set_allocated_playerid(::std::string* playerid) {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    delete playerid_;
  }
  if (playerid) {
    set_has_playerid();
    playerid_ = playerid;
  } else {
    clear_has_playerid();
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string public_key = 10;
inline bool InsideUnique::has_public_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InsideUnique::set_has_public_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InsideUnique::clear_has_public_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InsideUnique::clear_public_key() {
  if (public_key_ != &::google::protobuf::internal::kEmptyString) {
    public_key_->clear();
  }
  clear_has_public_key();
}
inline const ::std::string& InsideUnique::public_key() const {
  return *public_key_;
}
inline void InsideUnique::set_public_key(const ::std::string& value) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void InsideUnique::set_public_key(const char* value) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void InsideUnique::set_public_key(const char* value, size_t size) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InsideUnique::mutable_public_key() {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}
inline ::std::string* InsideUnique::release_public_key() {
  clear_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = public_key_;
    public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InsideUnique::set_allocated_public_key(::std::string* public_key) {
  if (public_key_ != &::google::protobuf::internal::kEmptyString) {
    delete public_key_;
  }
  if (public_key) {
    set_has_public_key();
    public_key_ = public_key;
  } else {
    clear_has_public_key();
    public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool buyside = 40;
inline bool InsideUnique::has_buyside() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InsideUnique::set_has_buyside() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InsideUnique::clear_has_buyside() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InsideUnique::clear_buyside() {
  buyside_ = false;
  clear_has_buyside();
}
inline bool InsideUnique::buyside() const {
  return buyside_;
}
inline void InsideUnique::set_buyside(bool value) {
  set_has_buyside();
  buyside_ = value;
}

// optional int32 price = 70;
inline bool InsideUnique::has_price() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InsideUnique::set_has_price() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InsideUnique::clear_has_price() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InsideUnique::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 InsideUnique::price() const {
  return price_;
}
inline void InsideUnique::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
}

// optional bytes oid = 11;
inline bool InsideUnique::has_oid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InsideUnique::set_has_oid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InsideUnique::clear_has_oid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InsideUnique::clear_oid() {
  if (oid_ != &::google::protobuf::internal::kEmptyString) {
    oid_->clear();
  }
  clear_has_oid();
}
inline const ::std::string& InsideUnique::oid() const {
  return *oid_;
}
inline void InsideUnique::set_oid(const ::std::string& value) {
  set_has_oid();
  if (oid_ == &::google::protobuf::internal::kEmptyString) {
    oid_ = new ::std::string;
  }
  oid_->assign(value);
}
inline void InsideUnique::set_oid(const char* value) {
  set_has_oid();
  if (oid_ == &::google::protobuf::internal::kEmptyString) {
    oid_ = new ::std::string;
  }
  oid_->assign(value);
}
inline void InsideUnique::set_oid(const void* value, size_t size) {
  set_has_oid();
  if (oid_ == &::google::protobuf::internal::kEmptyString) {
    oid_ = new ::std::string;
  }
  oid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InsideUnique::mutable_oid() {
  set_has_oid();
  if (oid_ == &::google::protobuf::internal::kEmptyString) {
    oid_ = new ::std::string;
  }
  return oid_;
}
inline ::std::string* InsideUnique::release_oid() {
  clear_has_oid();
  if (oid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = oid_;
    oid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InsideUnique::set_allocated_oid(::std::string* oid) {
  if (oid_ != &::google::protobuf::internal::kEmptyString) {
    delete oid_;
  }
  if (oid) {
    set_has_oid();
    oid_ = oid;
  } else {
    clear_has_oid();
    oid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .fantasybit.OrderUnique order = 20;
inline bool InsideUnique::has_order() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InsideUnique::set_has_order() {
  _has_bits_[0] |= 0x00000020u;
}
inline void InsideUnique::clear_has_order() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void InsideUnique::clear_order() {
  if (order_ != NULL) order_->::fantasybit::OrderUnique::Clear();
  clear_has_order();
}
inline const ::fantasybit::OrderUnique& InsideUnique::order() const {
  return order_ != NULL ? *order_ : *default_instance_->order_;
}
inline ::fantasybit::OrderUnique* InsideUnique::mutable_order() {
  set_has_order();
  if (order_ == NULL) order_ = new ::fantasybit::OrderUnique;
  return order_;
}
inline ::fantasybit::OrderUnique* InsideUnique::release_order() {
  clear_has_order();
  ::fantasybit::OrderUnique* temp = order_;
  order_ = NULL;
  return temp;
}
inline void InsideUnique::set_allocated_order(::fantasybit::OrderUnique* order) {
  delete order_;
  order_ = order;
  if (order) {
    set_has_order();
  } else {
    clear_has_order();
  }
}

// optional int32 size = 30;
inline bool InsideUnique::has_size() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void InsideUnique::set_has_size() {
  _has_bits_[0] |= 0x00000040u;
}
inline void InsideUnique::clear_has_size() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void InsideUnique::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::google::protobuf::int32 InsideUnique::size() const {
  return size_;
}
inline void InsideUnique::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
}

// -------------------------------------------------------------------

// TimeTransition

// optional .fantasybit.TimeTransition.Type type = 1;
inline bool TimeTransition::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimeTransition::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimeTransition::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimeTransition::clear_type() {
  type_ = 2;
  clear_has_type();
}
inline ::fantasybit::TimeTransition_Type TimeTransition::type() const {
  return static_cast< ::fantasybit::TimeTransition_Type >(type_);
}
inline void TimeTransition::set_type(::fantasybit::TimeTransition_Type value) {
  assert(::fantasybit::TimeTransition_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional uint32 season = 10;
inline bool TimeTransition::has_season() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimeTransition::set_has_season() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TimeTransition::clear_has_season() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TimeTransition::clear_season() {
  season_ = 0u;
  clear_has_season();
}
inline ::google::protobuf::uint32 TimeTransition::season() const {
  return season_;
}
inline void TimeTransition::set_season(::google::protobuf::uint32 value) {
  set_has_season();
  season_ = value;
}

// optional uint32 week = 20;
inline bool TimeTransition::has_week() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TimeTransition::set_has_week() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TimeTransition::clear_has_week() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TimeTransition::clear_week() {
  week_ = 0u;
  clear_has_week();
}
inline ::google::protobuf::uint32 TimeTransition::week() const {
  return week_;
}
inline void TimeTransition::set_week(::google::protobuf::uint32 value) {
  set_has_week();
  week_ = value;
}

// -------------------------------------------------------------------

// Bitcoin_UTXO

// optional bytes txid = 10;
inline bool Bitcoin_UTXO::has_txid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Bitcoin_UTXO::set_has_txid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Bitcoin_UTXO::clear_has_txid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Bitcoin_UTXO::clear_txid() {
  if (txid_ != &::google::protobuf::internal::kEmptyString) {
    txid_->clear();
  }
  clear_has_txid();
}
inline const ::std::string& Bitcoin_UTXO::txid() const {
  return *txid_;
}
inline void Bitcoin_UTXO::set_txid(const ::std::string& value) {
  set_has_txid();
  if (txid_ == &::google::protobuf::internal::kEmptyString) {
    txid_ = new ::std::string;
  }
  txid_->assign(value);
}
inline void Bitcoin_UTXO::set_txid(const char* value) {
  set_has_txid();
  if (txid_ == &::google::protobuf::internal::kEmptyString) {
    txid_ = new ::std::string;
  }
  txid_->assign(value);
}
inline void Bitcoin_UTXO::set_txid(const void* value, size_t size) {
  set_has_txid();
  if (txid_ == &::google::protobuf::internal::kEmptyString) {
    txid_ = new ::std::string;
  }
  txid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Bitcoin_UTXO::mutable_txid() {
  set_has_txid();
  if (txid_ == &::google::protobuf::internal::kEmptyString) {
    txid_ = new ::std::string;
  }
  return txid_;
}
inline ::std::string* Bitcoin_UTXO::release_txid() {
  clear_has_txid();
  if (txid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = txid_;
    txid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Bitcoin_UTXO::set_allocated_txid(::std::string* txid) {
  if (txid_ != &::google::protobuf::internal::kEmptyString) {
    delete txid_;
  }
  if (txid) {
    set_has_txid();
    txid_ = txid;
  } else {
    clear_has_txid();
    txid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 tx_output_n = 20;
inline bool Bitcoin_UTXO::has_tx_output_n() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Bitcoin_UTXO::set_has_tx_output_n() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Bitcoin_UTXO::clear_has_tx_output_n() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Bitcoin_UTXO::clear_tx_output_n() {
  tx_output_n_ = 0u;
  clear_has_tx_output_n();
}
inline ::google::protobuf::uint32 Bitcoin_UTXO::tx_output_n() const {
  return tx_output_n_;
}
inline void Bitcoin_UTXO::set_tx_output_n(::google::protobuf::uint32 value) {
  set_has_tx_output_n();
  tx_output_n_ = value;
}

// optional uint64 in_value = 30;
inline bool Bitcoin_UTXO::has_in_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Bitcoin_UTXO::set_has_in_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Bitcoin_UTXO::clear_has_in_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Bitcoin_UTXO::clear_in_value() {
  in_value_ = GOOGLE_ULONGLONG(0);
  clear_has_in_value();
}
inline ::google::protobuf::uint64 Bitcoin_UTXO::in_value() const {
  return in_value_;
}
inline void Bitcoin_UTXO::set_in_value(::google::protobuf::uint64 value) {
  set_has_in_value();
  in_value_ = value;
}

// optional bytes locking_script = 40;
inline bool Bitcoin_UTXO::has_locking_script() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Bitcoin_UTXO::set_has_locking_script() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Bitcoin_UTXO::clear_has_locking_script() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Bitcoin_UTXO::clear_locking_script() {
  if (locking_script_ != &::google::protobuf::internal::kEmptyString) {
    locking_script_->clear();
  }
  clear_has_locking_script();
}
inline const ::std::string& Bitcoin_UTXO::locking_script() const {
  return *locking_script_;
}
inline void Bitcoin_UTXO::set_locking_script(const ::std::string& value) {
  set_has_locking_script();
  if (locking_script_ == &::google::protobuf::internal::kEmptyString) {
    locking_script_ = new ::std::string;
  }
  locking_script_->assign(value);
}
inline void Bitcoin_UTXO::set_locking_script(const char* value) {
  set_has_locking_script();
  if (locking_script_ == &::google::protobuf::internal::kEmptyString) {
    locking_script_ = new ::std::string;
  }
  locking_script_->assign(value);
}
inline void Bitcoin_UTXO::set_locking_script(const void* value, size_t size) {
  set_has_locking_script();
  if (locking_script_ == &::google::protobuf::internal::kEmptyString) {
    locking_script_ = new ::std::string;
  }
  locking_script_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Bitcoin_UTXO::mutable_locking_script() {
  set_has_locking_script();
  if (locking_script_ == &::google::protobuf::internal::kEmptyString) {
    locking_script_ = new ::std::string;
  }
  return locking_script_;
}
inline ::std::string* Bitcoin_UTXO::release_locking_script() {
  clear_has_locking_script();
  if (locking_script_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = locking_script_;
    locking_script_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Bitcoin_UTXO::set_allocated_locking_script(::std::string* locking_script) {
  if (locking_script_ != &::google::protobuf::internal::kEmptyString) {
    delete locking_script_;
  }
  if (locking_script) {
    set_has_locking_script();
    locking_script_ = locking_script;
  } else {
    clear_has_locking_script();
    locking_script_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Bitcoin_UTXOS

// optional uint64 total_value = 10;
inline bool Bitcoin_UTXOS::has_total_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Bitcoin_UTXOS::set_has_total_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Bitcoin_UTXOS::clear_has_total_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Bitcoin_UTXOS::clear_total_value() {
  total_value_ = GOOGLE_ULONGLONG(0);
  clear_has_total_value();
}
inline ::google::protobuf::uint64 Bitcoin_UTXOS::total_value() const {
  return total_value_;
}
inline void Bitcoin_UTXOS::set_total_value(::google::protobuf::uint64 value) {
  set_has_total_value();
  total_value_ = value;
}

// repeated .fantasybit.Bitcoin_UTXO utxo = 20;
inline int Bitcoin_UTXOS::utxo_size() const {
  return utxo_.size();
}
inline void Bitcoin_UTXOS::clear_utxo() {
  utxo_.Clear();
}
inline const ::fantasybit::Bitcoin_UTXO& Bitcoin_UTXOS::utxo(int index) const {
  return utxo_.Get(index);
}
inline ::fantasybit::Bitcoin_UTXO* Bitcoin_UTXOS::mutable_utxo(int index) {
  return utxo_.Mutable(index);
}
inline ::fantasybit::Bitcoin_UTXO* Bitcoin_UTXOS::add_utxo() {
  return utxo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fantasybit::Bitcoin_UTXO >&
Bitcoin_UTXOS::utxo() const {
  return utxo_;
}
inline ::google::protobuf::RepeatedPtrField< ::fantasybit::Bitcoin_UTXO >*
Bitcoin_UTXOS::mutable_utxo() {
  return &utxo_;
}

// -------------------------------------------------------------------

// SwapAsk

// optional uint64 satoshi_min = 10;
inline bool SwapAsk::has_satoshi_min() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SwapAsk::set_has_satoshi_min() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SwapAsk::clear_has_satoshi_min() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SwapAsk::clear_satoshi_min() {
  satoshi_min_ = GOOGLE_ULONGLONG(0);
  clear_has_satoshi_min();
}
inline ::google::protobuf::uint64 SwapAsk::satoshi_min() const {
  return satoshi_min_;
}
inline void SwapAsk::set_satoshi_min(::google::protobuf::uint64 value) {
  set_has_satoshi_min();
  satoshi_min_ = value;
}

// optional uint64 satoshi_max = 11;
inline bool SwapAsk::has_satoshi_max() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SwapAsk::set_has_satoshi_max() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SwapAsk::clear_has_satoshi_max() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SwapAsk::clear_satoshi_max() {
  satoshi_max_ = GOOGLE_ULONGLONG(0);
  clear_has_satoshi_max();
}
inline ::google::protobuf::uint64 SwapAsk::satoshi_max() const {
  return satoshi_max_;
}
inline void SwapAsk::set_satoshi_max(::google::protobuf::uint64 value) {
  set_has_satoshi_max();
  satoshi_max_ = value;
}

// optional uint64 rate = 20;
inline bool SwapAsk::has_rate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SwapAsk::set_has_rate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SwapAsk::clear_has_rate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SwapAsk::clear_rate() {
  rate_ = GOOGLE_ULONGLONG(0);
  clear_has_rate();
}
inline ::google::protobuf::uint64 SwapAsk::rate() const {
  return rate_;
}
inline void SwapAsk::set_rate(::google::protobuf::uint64 value) {
  set_has_rate();
  rate_ = value;
}

// optional uint64 fb_qty = 30;
inline bool SwapAsk::has_fb_qty() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SwapAsk::set_has_fb_qty() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SwapAsk::clear_has_fb_qty() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SwapAsk::clear_fb_qty() {
  fb_qty_ = GOOGLE_ULONGLONG(0);
  clear_has_fb_qty();
}
inline ::google::protobuf::uint64 SwapAsk::fb_qty() const {
  return fb_qty_;
}
inline void SwapAsk::set_fb_qty(::google::protobuf::uint64 value) {
  set_has_fb_qty();
  fb_qty_ = value;
}

// -------------------------------------------------------------------

// SwapBid

// optional uint64 satoshi_min = 10;
inline bool SwapBid::has_satoshi_min() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SwapBid::set_has_satoshi_min() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SwapBid::clear_has_satoshi_min() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SwapBid::clear_satoshi_min() {
  satoshi_min_ = GOOGLE_ULONGLONG(0);
  clear_has_satoshi_min();
}
inline ::google::protobuf::uint64 SwapBid::satoshi_min() const {
  return satoshi_min_;
}
inline void SwapBid::set_satoshi_min(::google::protobuf::uint64 value) {
  set_has_satoshi_min();
  satoshi_min_ = value;
}

// optional uint64 satoshi_max = 11;
inline bool SwapBid::has_satoshi_max() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SwapBid::set_has_satoshi_max() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SwapBid::clear_has_satoshi_max() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SwapBid::clear_satoshi_max() {
  satoshi_max_ = GOOGLE_ULONGLONG(0);
  clear_has_satoshi_max();
}
inline ::google::protobuf::uint64 SwapBid::satoshi_max() const {
  return satoshi_max_;
}
inline void SwapBid::set_satoshi_max(::google::protobuf::uint64 value) {
  set_has_satoshi_max();
  satoshi_max_ = value;
}

// optional uint64 rate = 20;
inline bool SwapBid::has_rate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SwapBid::set_has_rate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SwapBid::clear_has_rate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SwapBid::clear_rate() {
  rate_ = GOOGLE_ULONGLONG(0);
  clear_has_rate();
}
inline ::google::protobuf::uint64 SwapBid::rate() const {
  return rate_;
}
inline void SwapBid::set_rate(::google::protobuf::uint64 value) {
  set_has_rate();
  rate_ = value;
}

// optional .fantasybit.Bitcoin_UTXOS utxos = 30;
inline bool SwapBid::has_utxos() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SwapBid::set_has_utxos() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SwapBid::clear_has_utxos() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SwapBid::clear_utxos() {
  if (utxos_ != NULL) utxos_->::fantasybit::Bitcoin_UTXOS::Clear();
  clear_has_utxos();
}
inline const ::fantasybit::Bitcoin_UTXOS& SwapBid::utxos() const {
  return utxos_ != NULL ? *utxos_ : *default_instance_->utxos_;
}
inline ::fantasybit::Bitcoin_UTXOS* SwapBid::mutable_utxos() {
  set_has_utxos();
  if (utxos_ == NULL) utxos_ = new ::fantasybit::Bitcoin_UTXOS;
  return utxos_;
}
inline ::fantasybit::Bitcoin_UTXOS* SwapBid::release_utxos() {
  clear_has_utxos();
  ::fantasybit::Bitcoin_UTXOS* temp = utxos_;
  utxos_ = NULL;
  return temp;
}
inline void SwapBid::set_allocated_utxos(::fantasybit::Bitcoin_UTXOS* utxos) {
  delete utxos_;
  utxos_ = utxos;
  if (utxos) {
    set_has_utxos();
  } else {
    clear_has_utxos();
  }
}

// optional bytes change_addr = 40;
inline bool SwapBid::has_change_addr() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SwapBid::set_has_change_addr() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SwapBid::clear_has_change_addr() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SwapBid::clear_change_addr() {
  if (change_addr_ != &::google::protobuf::internal::kEmptyString) {
    change_addr_->clear();
  }
  clear_has_change_addr();
}
inline const ::std::string& SwapBid::change_addr() const {
  return *change_addr_;
}
inline void SwapBid::set_change_addr(const ::std::string& value) {
  set_has_change_addr();
  if (change_addr_ == &::google::protobuf::internal::kEmptyString) {
    change_addr_ = new ::std::string;
  }
  change_addr_->assign(value);
}
inline void SwapBid::set_change_addr(const char* value) {
  set_has_change_addr();
  if (change_addr_ == &::google::protobuf::internal::kEmptyString) {
    change_addr_ = new ::std::string;
  }
  change_addr_->assign(value);
}
inline void SwapBid::set_change_addr(const void* value, size_t size) {
  set_has_change_addr();
  if (change_addr_ == &::google::protobuf::internal::kEmptyString) {
    change_addr_ = new ::std::string;
  }
  change_addr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SwapBid::mutable_change_addr() {
  set_has_change_addr();
  if (change_addr_ == &::google::protobuf::internal::kEmptyString) {
    change_addr_ = new ::std::string;
  }
  return change_addr_;
}
inline ::std::string* SwapBid::release_change_addr() {
  clear_has_change_addr();
  if (change_addr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = change_addr_;
    change_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SwapBid::set_allocated_change_addr(::std::string* change_addr) {
  if (change_addr_ != &::google::protobuf::internal::kEmptyString) {
    delete change_addr_;
  }
  if (change_addr) {
    set_has_change_addr();
    change_addr_ = change_addr;
  } else {
    clear_has_change_addr();
    change_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .fantasybit.SwapAsk this_offer = 50;
inline bool SwapBid::has_this_offer() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SwapBid::set_has_this_offer() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SwapBid::clear_has_this_offer() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SwapBid::clear_this_offer() {
  if (this_offer_ != NULL) this_offer_->::fantasybit::SwapAsk::Clear();
  clear_has_this_offer();
}
inline const ::fantasybit::SwapAsk& SwapBid::this_offer() const {
  return this_offer_ != NULL ? *this_offer_ : *default_instance_->this_offer_;
}
inline ::fantasybit::SwapAsk* SwapBid::mutable_this_offer() {
  set_has_this_offer();
  if (this_offer_ == NULL) this_offer_ = new ::fantasybit::SwapAsk;
  return this_offer_;
}
inline ::fantasybit::SwapAsk* SwapBid::release_this_offer() {
  clear_has_this_offer();
  ::fantasybit::SwapAsk* temp = this_offer_;
  this_offer_ = NULL;
  return temp;
}
inline void SwapBid::set_allocated_this_offer(::fantasybit::SwapAsk* this_offer) {
  delete this_offer_;
  this_offer_ = this_offer;
  if (this_offer) {
    set_has_this_offer();
  } else {
    clear_has_this_offer();
  }
}

// optional string counteroffer = 60;
inline bool SwapBid::has_counteroffer() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SwapBid::set_has_counteroffer() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SwapBid::clear_has_counteroffer() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SwapBid::clear_counteroffer() {
  if (counteroffer_ != &::google::protobuf::internal::kEmptyString) {
    counteroffer_->clear();
  }
  clear_has_counteroffer();
}
inline const ::std::string& SwapBid::counteroffer() const {
  return *counteroffer_;
}
inline void SwapBid::set_counteroffer(const ::std::string& value) {
  set_has_counteroffer();
  if (counteroffer_ == &::google::protobuf::internal::kEmptyString) {
    counteroffer_ = new ::std::string;
  }
  counteroffer_->assign(value);
}
inline void SwapBid::set_counteroffer(const char* value) {
  set_has_counteroffer();
  if (counteroffer_ == &::google::protobuf::internal::kEmptyString) {
    counteroffer_ = new ::std::string;
  }
  counteroffer_->assign(value);
}
inline void SwapBid::set_counteroffer(const char* value, size_t size) {
  set_has_counteroffer();
  if (counteroffer_ == &::google::protobuf::internal::kEmptyString) {
    counteroffer_ = new ::std::string;
  }
  counteroffer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SwapBid::mutable_counteroffer() {
  set_has_counteroffer();
  if (counteroffer_ == &::google::protobuf::internal::kEmptyString) {
    counteroffer_ = new ::std::string;
  }
  return counteroffer_;
}
inline ::std::string* SwapBid::release_counteroffer() {
  clear_has_counteroffer();
  if (counteroffer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = counteroffer_;
    counteroffer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SwapBid::set_allocated_counteroffer(::std::string* counteroffer) {
  if (counteroffer_ != &::google::protobuf::internal::kEmptyString) {
    delete counteroffer_;
  }
  if (counteroffer) {
    set_has_counteroffer();
    counteroffer_ = counteroffer;
  } else {
    clear_has_counteroffer();
    counteroffer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SwapFill

// optional .fantasybit.SwapBid swapbid = 10;
inline bool SwapFill::has_swapbid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SwapFill::set_has_swapbid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SwapFill::clear_has_swapbid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SwapFill::clear_swapbid() {
  if (swapbid_ != NULL) swapbid_->::fantasybit::SwapBid::Clear();
  clear_has_swapbid();
}
inline const ::fantasybit::SwapBid& SwapFill::swapbid() const {
  return swapbid_ != NULL ? *swapbid_ : *default_instance_->swapbid_;
}
inline ::fantasybit::SwapBid* SwapFill::mutable_swapbid() {
  set_has_swapbid();
  if (swapbid_ == NULL) swapbid_ = new ::fantasybit::SwapBid;
  return swapbid_;
}
inline ::fantasybit::SwapBid* SwapFill::release_swapbid() {
  clear_has_swapbid();
  ::fantasybit::SwapBid* temp = swapbid_;
  swapbid_ = NULL;
  return temp;
}
inline void SwapFill::set_allocated_swapbid(::fantasybit::SwapBid* swapbid) {
  delete swapbid_;
  swapbid_ = swapbid;
  if (swapbid) {
    set_has_swapbid();
  } else {
    clear_has_swapbid();
  }
}

// optional bytes hash_to_sign = 20;
inline bool SwapFill::has_hash_to_sign() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SwapFill::set_has_hash_to_sign() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SwapFill::clear_has_hash_to_sign() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SwapFill::clear_hash_to_sign() {
  if (hash_to_sign_ != &::google::protobuf::internal::kEmptyString) {
    hash_to_sign_->clear();
  }
  clear_has_hash_to_sign();
}
inline const ::std::string& SwapFill::hash_to_sign() const {
  return *hash_to_sign_;
}
inline void SwapFill::set_hash_to_sign(const ::std::string& value) {
  set_has_hash_to_sign();
  if (hash_to_sign_ == &::google::protobuf::internal::kEmptyString) {
    hash_to_sign_ = new ::std::string;
  }
  hash_to_sign_->assign(value);
}
inline void SwapFill::set_hash_to_sign(const char* value) {
  set_has_hash_to_sign();
  if (hash_to_sign_ == &::google::protobuf::internal::kEmptyString) {
    hash_to_sign_ = new ::std::string;
  }
  hash_to_sign_->assign(value);
}
inline void SwapFill::set_hash_to_sign(const void* value, size_t size) {
  set_has_hash_to_sign();
  if (hash_to_sign_ == &::google::protobuf::internal::kEmptyString) {
    hash_to_sign_ = new ::std::string;
  }
  hash_to_sign_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SwapFill::mutable_hash_to_sign() {
  set_has_hash_to_sign();
  if (hash_to_sign_ == &::google::protobuf::internal::kEmptyString) {
    hash_to_sign_ = new ::std::string;
  }
  return hash_to_sign_;
}
inline ::std::string* SwapFill::release_hash_to_sign() {
  clear_has_hash_to_sign();
  if (hash_to_sign_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hash_to_sign_;
    hash_to_sign_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SwapFill::set_allocated_hash_to_sign(::std::string* hash_to_sign) {
  if (hash_to_sign_ != &::google::protobuf::internal::kEmptyString) {
    delete hash_to_sign_;
  }
  if (hash_to_sign) {
    set_has_hash_to_sign();
    hash_to_sign_ = hash_to_sign;
  } else {
    clear_has_hash_to_sign();
    hash_to_sign_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 satoshi_fee = 30;
inline bool SwapFill::has_satoshi_fee() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SwapFill::set_has_satoshi_fee() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SwapFill::clear_has_satoshi_fee() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SwapFill::clear_satoshi_fee() {
  satoshi_fee_ = GOOGLE_ULONGLONG(0);
  clear_has_satoshi_fee();
}
inline ::google::protobuf::uint64 SwapFill::satoshi_fee() const {
  return satoshi_fee_;
}
inline void SwapFill::set_satoshi_fee(::google::protobuf::uint64 value) {
  set_has_satoshi_fee();
  satoshi_fee_ = value;
}

// optional uint64 fb_qty = 40;
inline bool SwapFill::has_fb_qty() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SwapFill::set_has_fb_qty() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SwapFill::clear_has_fb_qty() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SwapFill::clear_fb_qty() {
  fb_qty_ = GOOGLE_ULONGLONG(0);
  clear_has_fb_qty();
}
inline ::google::protobuf::uint64 SwapFill::fb_qty() const {
  return fb_qty_;
}
inline void SwapFill::set_fb_qty(::google::protobuf::uint64 value) {
  set_has_fb_qty();
  fb_qty_ = value;
}

// optional string counterparty = 50;
inline bool SwapFill::has_counterparty() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SwapFill::set_has_counterparty() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SwapFill::clear_has_counterparty() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SwapFill::clear_counterparty() {
  if (counterparty_ != &::google::protobuf::internal::kEmptyString) {
    counterparty_->clear();
  }
  clear_has_counterparty();
}
inline const ::std::string& SwapFill::counterparty() const {
  return *counterparty_;
}
inline void SwapFill::set_counterparty(const ::std::string& value) {
  set_has_counterparty();
  if (counterparty_ == &::google::protobuf::internal::kEmptyString) {
    counterparty_ = new ::std::string;
  }
  counterparty_->assign(value);
}
inline void SwapFill::set_counterparty(const char* value) {
  set_has_counterparty();
  if (counterparty_ == &::google::protobuf::internal::kEmptyString) {
    counterparty_ = new ::std::string;
  }
  counterparty_->assign(value);
}
inline void SwapFill::set_counterparty(const char* value, size_t size) {
  set_has_counterparty();
  if (counterparty_ == &::google::protobuf::internal::kEmptyString) {
    counterparty_ = new ::std::string;
  }
  counterparty_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SwapFill::mutable_counterparty() {
  set_has_counterparty();
  if (counterparty_ == &::google::protobuf::internal::kEmptyString) {
    counterparty_ = new ::std::string;
  }
  return counterparty_;
}
inline ::std::string* SwapFill::release_counterparty() {
  clear_has_counterparty();
  if (counterparty_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = counterparty_;
    counterparty_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SwapFill::set_allocated_counterparty(::std::string* counterparty) {
  if (counterparty_ != &::google::protobuf::internal::kEmptyString) {
    delete counterparty_;
  }
  if (counterparty) {
    set_has_counterparty();
    counterparty_ = counterparty;
  } else {
    clear_has_counterparty();
    counterparty_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SwapSent

// optional .fantasybit.SwapFill swapfill = 10;
inline bool SwapSent::has_swapfill() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SwapSent::set_has_swapfill() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SwapSent::clear_has_swapfill() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SwapSent::clear_swapfill() {
  if (swapfill_ != NULL) swapfill_->::fantasybit::SwapFill::Clear();
  clear_has_swapfill();
}
inline const ::fantasybit::SwapFill& SwapSent::swapfill() const {
  return swapfill_ != NULL ? *swapfill_ : *default_instance_->swapfill_;
}
inline ::fantasybit::SwapFill* SwapSent::mutable_swapfill() {
  set_has_swapfill();
  if (swapfill_ == NULL) swapfill_ = new ::fantasybit::SwapFill;
  return swapfill_;
}
inline ::fantasybit::SwapFill* SwapSent::release_swapfill() {
  clear_has_swapfill();
  ::fantasybit::SwapFill* temp = swapfill_;
  swapfill_ = NULL;
  return temp;
}
inline void SwapSent::set_allocated_swapfill(::fantasybit::SwapFill* swapfill) {
  delete swapfill_;
  swapfill_ = swapfill;
  if (swapfill) {
    set_has_swapfill();
  } else {
    clear_has_swapfill();
  }
}

// optional bytes sig = 20;
inline bool SwapSent::has_sig() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SwapSent::set_has_sig() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SwapSent::clear_has_sig() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SwapSent::clear_sig() {
  if (sig_ != &::google::protobuf::internal::kEmptyString) {
    sig_->clear();
  }
  clear_has_sig();
}
inline const ::std::string& SwapSent::sig() const {
  return *sig_;
}
inline void SwapSent::set_sig(const ::std::string& value) {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  sig_->assign(value);
}
inline void SwapSent::set_sig(const char* value) {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  sig_->assign(value);
}
inline void SwapSent::set_sig(const void* value, size_t size) {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  sig_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SwapSent::mutable_sig() {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  return sig_;
}
inline ::std::string* SwapSent::release_sig() {
  clear_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sig_;
    sig_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SwapSent::set_allocated_sig(::std::string* sig) {
  if (sig_ != &::google::protobuf::internal::kEmptyString) {
    delete sig_;
  }
  if (sig) {
    set_has_sig();
    sig_ = sig;
  } else {
    clear_has_sig();
    sig_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ProofOfDoubleSpend

// optional .fantasybit.SwapSent swapsent = 10;
inline bool ProofOfDoubleSpend::has_swapsent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProofOfDoubleSpend::set_has_swapsent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProofOfDoubleSpend::clear_has_swapsent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProofOfDoubleSpend::clear_swapsent() {
  if (swapsent_ != NULL) swapsent_->::fantasybit::SwapSent::Clear();
  clear_has_swapsent();
}
inline const ::fantasybit::SwapSent& ProofOfDoubleSpend::swapsent() const {
  return swapsent_ != NULL ? *swapsent_ : *default_instance_->swapsent_;
}
inline ::fantasybit::SwapSent* ProofOfDoubleSpend::mutable_swapsent() {
  set_has_swapsent();
  if (swapsent_ == NULL) swapsent_ = new ::fantasybit::SwapSent;
  return swapsent_;
}
inline ::fantasybit::SwapSent* ProofOfDoubleSpend::release_swapsent() {
  clear_has_swapsent();
  ::fantasybit::SwapSent* temp = swapsent_;
  swapsent_ = NULL;
  return temp;
}
inline void ProofOfDoubleSpend::set_allocated_swapsent(::fantasybit::SwapSent* swapsent) {
  delete swapsent_;
  swapsent_ = swapsent;
  if (swapsent) {
    set_has_swapsent();
  } else {
    clear_has_swapsent();
  }
}

// optional .fantasybit.Bitcoin_UTXO utxo = 20;
inline bool ProofOfDoubleSpend::has_utxo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProofOfDoubleSpend::set_has_utxo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProofOfDoubleSpend::clear_has_utxo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProofOfDoubleSpend::clear_utxo() {
  if (utxo_ != NULL) utxo_->::fantasybit::Bitcoin_UTXO::Clear();
  clear_has_utxo();
}
inline const ::fantasybit::Bitcoin_UTXO& ProofOfDoubleSpend::utxo() const {
  return utxo_ != NULL ? *utxo_ : *default_instance_->utxo_;
}
inline ::fantasybit::Bitcoin_UTXO* ProofOfDoubleSpend::mutable_utxo() {
  set_has_utxo();
  if (utxo_ == NULL) utxo_ = new ::fantasybit::Bitcoin_UTXO;
  return utxo_;
}
inline ::fantasybit::Bitcoin_UTXO* ProofOfDoubleSpend::release_utxo() {
  clear_has_utxo();
  ::fantasybit::Bitcoin_UTXO* temp = utxo_;
  utxo_ = NULL;
  return temp;
}
inline void ProofOfDoubleSpend::set_allocated_utxo(::fantasybit::Bitcoin_UTXO* utxo) {
  delete utxo_;
  utxo_ = utxo;
  if (utxo) {
    set_has_utxo();
  } else {
    clear_has_utxo();
  }
}

// optional bytes pre = 30;
inline bool ProofOfDoubleSpend::has_pre() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProofOfDoubleSpend::set_has_pre() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProofOfDoubleSpend::clear_has_pre() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProofOfDoubleSpend::clear_pre() {
  if (pre_ != &::google::protobuf::internal::kEmptyString) {
    pre_->clear();
  }
  clear_has_pre();
}
inline const ::std::string& ProofOfDoubleSpend::pre() const {
  return *pre_;
}
inline void ProofOfDoubleSpend::set_pre(const ::std::string& value) {
  set_has_pre();
  if (pre_ == &::google::protobuf::internal::kEmptyString) {
    pre_ = new ::std::string;
  }
  pre_->assign(value);
}
inline void ProofOfDoubleSpend::set_pre(const char* value) {
  set_has_pre();
  if (pre_ == &::google::protobuf::internal::kEmptyString) {
    pre_ = new ::std::string;
  }
  pre_->assign(value);
}
inline void ProofOfDoubleSpend::set_pre(const void* value, size_t size) {
  set_has_pre();
  if (pre_ == &::google::protobuf::internal::kEmptyString) {
    pre_ = new ::std::string;
  }
  pre_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProofOfDoubleSpend::mutable_pre() {
  set_has_pre();
  if (pre_ == &::google::protobuf::internal::kEmptyString) {
    pre_ = new ::std::string;
  }
  return pre_;
}
inline ::std::string* ProofOfDoubleSpend::release_pre() {
  clear_has_pre();
  if (pre_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pre_;
    pre_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProofOfDoubleSpend::set_allocated_pre(::std::string* pre) {
  if (pre_ != &::google::protobuf::internal::kEmptyString) {
    delete pre_;
  }
  if (pre) {
    set_has_pre();
    pre_ = pre;
  } else {
    clear_has_pre();
    pre_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes post = 40;
inline bool ProofOfDoubleSpend::has_post() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProofOfDoubleSpend::set_has_post() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProofOfDoubleSpend::clear_has_post() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProofOfDoubleSpend::clear_post() {
  if (post_ != &::google::protobuf::internal::kEmptyString) {
    post_->clear();
  }
  clear_has_post();
}
inline const ::std::string& ProofOfDoubleSpend::post() const {
  return *post_;
}
inline void ProofOfDoubleSpend::set_post(const ::std::string& value) {
  set_has_post();
  if (post_ == &::google::protobuf::internal::kEmptyString) {
    post_ = new ::std::string;
  }
  post_->assign(value);
}
inline void ProofOfDoubleSpend::set_post(const char* value) {
  set_has_post();
  if (post_ == &::google::protobuf::internal::kEmptyString) {
    post_ = new ::std::string;
  }
  post_->assign(value);
}
inline void ProofOfDoubleSpend::set_post(const void* value, size_t size) {
  set_has_post();
  if (post_ == &::google::protobuf::internal::kEmptyString) {
    post_ = new ::std::string;
  }
  post_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProofOfDoubleSpend::mutable_post() {
  set_has_post();
  if (post_ == &::google::protobuf::internal::kEmptyString) {
    post_ = new ::std::string;
  }
  return post_;
}
inline ::std::string* ProofOfDoubleSpend::release_post() {
  clear_has_post();
  if (post_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = post_;
    post_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProofOfDoubleSpend::set_allocated_post(::std::string* post) {
  if (post_ != &::google::protobuf::internal::kEmptyString) {
    delete post_;
  }
  if (post) {
    set_has_post();
    post_ = post;
  } else {
    clear_has_post();
    post_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes sig = 50;
inline bool ProofOfDoubleSpend::has_sig() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProofOfDoubleSpend::set_has_sig() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProofOfDoubleSpend::clear_has_sig() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProofOfDoubleSpend::clear_sig() {
  if (sig_ != &::google::protobuf::internal::kEmptyString) {
    sig_->clear();
  }
  clear_has_sig();
}
inline const ::std::string& ProofOfDoubleSpend::sig() const {
  return *sig_;
}
inline void ProofOfDoubleSpend::set_sig(const ::std::string& value) {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  sig_->assign(value);
}
inline void ProofOfDoubleSpend::set_sig(const char* value) {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  sig_->assign(value);
}
inline void ProofOfDoubleSpend::set_sig(const void* value, size_t size) {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  sig_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProofOfDoubleSpend::mutable_sig() {
  set_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    sig_ = new ::std::string;
  }
  return sig_;
}
inline ::std::string* ProofOfDoubleSpend::release_sig() {
  clear_has_sig();
  if (sig_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sig_;
    sig_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProofOfDoubleSpend::set_allocated_sig(::std::string* sig) {
  if (sig_ != &::google::protobuf::internal::kEmptyString) {
    delete sig_;
  }
  if (sig) {
    set_has_sig();
    sig_ = sig;
  } else {
    clear_has_sig();
    sig_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SwapSentAck

// optional .fantasybit.SwapSent swapsent = 10;
inline bool SwapSentAck::has_swapsent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SwapSentAck::set_has_swapsent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SwapSentAck::clear_has_swapsent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SwapSentAck::clear_swapsent() {
  if (swapsent_ != NULL) swapsent_->::fantasybit::SwapSent::Clear();
  clear_has_swapsent();
}
inline const ::fantasybit::SwapSent& SwapSentAck::swapsent() const {
  return swapsent_ != NULL ? *swapsent_ : *default_instance_->swapsent_;
}
inline ::fantasybit::SwapSent* SwapSentAck::mutable_swapsent() {
  set_has_swapsent();
  if (swapsent_ == NULL) swapsent_ = new ::fantasybit::SwapSent;
  return swapsent_;
}
inline ::fantasybit::SwapSent* SwapSentAck::release_swapsent() {
  clear_has_swapsent();
  ::fantasybit::SwapSent* temp = swapsent_;
  swapsent_ = NULL;
  return temp;
}
inline void SwapSentAck::set_allocated_swapsent(::fantasybit::SwapSent* swapsent) {
  delete swapsent_;
  swapsent_ = swapsent;
  if (swapsent) {
    set_has_swapsent();
  } else {
    clear_has_swapsent();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace fantasybit

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fantasybit::OutData_Type>() {
  return ::fantasybit::OutData_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fantasybit::InData_Type>() {
  return ::fantasybit::InData_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fantasybit::NameProof_Type>() {
  return ::fantasybit::NameProof_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fantasybit::BlockHeader_Type>() {
  return ::fantasybit::BlockHeader_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fantasybit::NodeRequest_Type>() {
  return ::fantasybit::NodeRequest_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fantasybit::Data_Type>() {
  return ::fantasybit::Data_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fantasybit::TeamState_State>() {
  return ::fantasybit::TeamState_State_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fantasybit::DeltaData_Type>() {
  return ::fantasybit::DeltaData_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fantasybit::ExchangeOrder_Type>() {
  return ::fantasybit::ExchangeOrder_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fantasybit::TimeTransition_Type>() {
  return ::fantasybit::TimeTransition_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fantasybit::MyNameStatus>() {
  return ::fantasybit::MyNameStatus_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fantasybit::TransType>() {
  return ::fantasybit::TransType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fantasybit::TrType>() {
  return ::fantasybit::TrType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ProtoData_2eproto__INCLUDED
