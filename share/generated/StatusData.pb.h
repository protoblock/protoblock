// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: StatusData.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_StatusData_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_StatusData_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "StaticData.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_StatusData_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_StatusData_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[4]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_StatusData_2eproto;
namespace fantasybit {
class GameStatus;
class GameStatusDefaultTypeInternal;
extern GameStatusDefaultTypeInternal _GameStatus_default_instance_;
class GlobalState;
class GlobalStateDefaultTypeInternal;
extern GlobalStateDefaultTypeInternal _GlobalState_default_instance_;
class PlayerStatus;
class PlayerStatusDefaultTypeInternal;
extern PlayerStatusDefaultTypeInternal _PlayerStatus_default_instance_;
class TeamDepth;
class TeamDepthDefaultTypeInternal;
extern TeamDepthDefaultTypeInternal _TeamDepth_default_instance_;
}  // namespace fantasybit
PROTOBUF_NAMESPACE_OPEN
template<> ::fantasybit::GameStatus* Arena::CreateMaybeMessage<::fantasybit::GameStatus>(Arena*);
template<> ::fantasybit::GlobalState* Arena::CreateMaybeMessage<::fantasybit::GlobalState>(Arena*);
template<> ::fantasybit::PlayerStatus* Arena::CreateMaybeMessage<::fantasybit::PlayerStatus>(Arena*);
template<> ::fantasybit::TeamDepth* Arena::CreateMaybeMessage<::fantasybit::TeamDepth>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace fantasybit {

enum PlayerStatus_Status : int {
  PlayerStatus_Status_ACTIVE = 0,
  PlayerStatus_Status_INACTIVE = 1,
  PlayerStatus_Status_OTHER = 3,
  PlayerStatus_Status_FA = 4
};
bool PlayerStatus_Status_IsValid(int value);
constexpr PlayerStatus_Status PlayerStatus_Status_Status_MIN = PlayerStatus_Status_ACTIVE;
constexpr PlayerStatus_Status PlayerStatus_Status_Status_MAX = PlayerStatus_Status_FA;
constexpr int PlayerStatus_Status_Status_ARRAYSIZE = PlayerStatus_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlayerStatus_Status_descriptor();
template<typename T>
inline const std::string& PlayerStatus_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlayerStatus_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlayerStatus_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PlayerStatus_Status_descriptor(), enum_t_value);
}
inline bool PlayerStatus_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlayerStatus_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlayerStatus_Status>(
    PlayerStatus_Status_descriptor(), name, value);
}
enum GameStatus_Status : int {
  GameStatus_Status_SCHEDULED = 0,
  GameStatus_Status_PREGAME = 2,
  GameStatus_Status_INGAME = 3,
  GameStatus_Status_POSTGAME = 5,
  GameStatus_Status_CLOSED = 4
};
bool GameStatus_Status_IsValid(int value);
constexpr GameStatus_Status GameStatus_Status_Status_MIN = GameStatus_Status_SCHEDULED;
constexpr GameStatus_Status GameStatus_Status_Status_MAX = GameStatus_Status_POSTGAME;
constexpr int GameStatus_Status_Status_ARRAYSIZE = GameStatus_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GameStatus_Status_descriptor();
template<typename T>
inline const std::string& GameStatus_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GameStatus_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GameStatus_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GameStatus_Status_descriptor(), enum_t_value);
}
inline bool GameStatus_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GameStatus_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GameStatus_Status>(
    GameStatus_Status_descriptor(), name, value);
}
enum GlobalState_State : int {
  GlobalState_State_OFFSEASON = 10,
  GlobalState_State_INSEASON = 30,
  GlobalState_State_PLAYOFFS = 40
};
bool GlobalState_State_IsValid(int value);
constexpr GlobalState_State GlobalState_State_State_MIN = GlobalState_State_OFFSEASON;
constexpr GlobalState_State GlobalState_State_State_MAX = GlobalState_State_PLAYOFFS;
constexpr int GlobalState_State_State_ARRAYSIZE = GlobalState_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GlobalState_State_descriptor();
template<typename T>
inline const std::string& GlobalState_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GlobalState_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GlobalState_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GlobalState_State_descriptor(), enum_t_value);
}
inline bool GlobalState_State_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GlobalState_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GlobalState_State>(
    GlobalState_State_descriptor(), name, value);
}
enum PlayerGameStatus : int {
  OUT = 0,
  IN = 1,
  NA = 2
};
bool PlayerGameStatus_IsValid(int value);
constexpr PlayerGameStatus PlayerGameStatus_MIN = OUT;
constexpr PlayerGameStatus PlayerGameStatus_MAX = NA;
constexpr int PlayerGameStatus_ARRAYSIZE = PlayerGameStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlayerGameStatus_descriptor();
template<typename T>
inline const std::string& PlayerGameStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlayerGameStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlayerGameStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PlayerGameStatus_descriptor(), enum_t_value);
}
inline bool PlayerGameStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlayerGameStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlayerGameStatus>(
    PlayerGameStatus_descriptor(), name, value);
}
// ===================================================================

class PlayerStatus PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.PlayerStatus) */ {
 public:
  inline PlayerStatus() : PlayerStatus(nullptr) {};
  virtual ~PlayerStatus();

  PlayerStatus(const PlayerStatus& from);
  PlayerStatus(PlayerStatus&& from) noexcept
    : PlayerStatus() {
    *this = ::std::move(from);
  }

  inline PlayerStatus& operator=(const PlayerStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerStatus& operator=(PlayerStatus&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlayerStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerStatus* internal_default_instance() {
    return reinterpret_cast<const PlayerStatus*>(
               &_PlayerStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PlayerStatus& a, PlayerStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerStatus* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayerStatus* New() const final {
    return CreateMaybeMessage<PlayerStatus>(nullptr);
  }

  PlayerStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayerStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlayerStatus& from);
  void MergeFrom(const PlayerStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.PlayerStatus";
  }
  protected:
  explicit PlayerStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_StatusData_2eproto);
    return ::descriptor_table_StatusData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef PlayerStatus_Status Status;
  static constexpr Status ACTIVE =
    PlayerStatus_Status_ACTIVE;
  static constexpr Status INACTIVE =
    PlayerStatus_Status_INACTIVE;
  static constexpr Status OTHER =
    PlayerStatus_Status_OTHER;
  static constexpr Status FA =
    PlayerStatus_Status_FA;
  static inline bool Status_IsValid(int value) {
    return PlayerStatus_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    PlayerStatus_Status_Status_MIN;
  static constexpr Status Status_MAX =
    PlayerStatus_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    PlayerStatus_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return PlayerStatus_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return PlayerStatus_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return PlayerStatus_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTeamidFieldNumber = 20,
    kSymbolFieldNumber = 50,
    kTotalsFieldNumber = 40,
    kStatusFieldNumber = 30,
  };
  // optional string teamid = 20;
  bool has_teamid() const;
  private:
  bool _internal_has_teamid() const;
  public:
  void clear_teamid();
  const std::string& teamid() const;
  void set_teamid(const std::string& value);
  void set_teamid(std::string&& value);
  void set_teamid(const char* value);
  void set_teamid(const char* value, size_t size);
  std::string* mutable_teamid();
  std::string* release_teamid();
  void set_allocated_teamid(std::string* teamid);
  private:
  const std::string& _internal_teamid() const;
  void _internal_set_teamid(const std::string& value);
  std::string* _internal_mutable_teamid();
  public:

  // optional string symbol = 50;
  bool has_symbol() const;
  private:
  bool _internal_has_symbol() const;
  public:
  void clear_symbol();
  const std::string& symbol() const;
  void set_symbol(const std::string& value);
  void set_symbol(std::string&& value);
  void set_symbol(const char* value);
  void set_symbol(const char* value, size_t size);
  std::string* mutable_symbol();
  std::string* release_symbol();
  void set_allocated_symbol(std::string* symbol);
  private:
  const std::string& _internal_symbol() const;
  void _internal_set_symbol(const std::string& value);
  std::string* _internal_mutable_symbol();
  public:

  // optional .fantasybit.PlayerResult totals = 40;
  bool has_totals() const;
  private:
  bool _internal_has_totals() const;
  public:
  void clear_totals();
  const ::fantasybit::PlayerResult& totals() const;
  ::fantasybit::PlayerResult* release_totals();
  ::fantasybit::PlayerResult* mutable_totals();
  void set_allocated_totals(::fantasybit::PlayerResult* totals);
  private:
  const ::fantasybit::PlayerResult& _internal_totals() const;
  ::fantasybit::PlayerResult* _internal_mutable_totals();
  public:
  void unsafe_arena_set_allocated_totals(
      ::fantasybit::PlayerResult* totals);
  ::fantasybit::PlayerResult* unsafe_arena_release_totals();

  // optional .fantasybit.PlayerStatus.Status status = 30;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::fantasybit::PlayerStatus_Status status() const;
  void set_status(::fantasybit::PlayerStatus_Status value);
  private:
  ::fantasybit::PlayerStatus_Status _internal_status() const;
  void _internal_set_status(::fantasybit::PlayerStatus_Status value);
  public:

  // @@protoc_insertion_point(class_scope:fantasybit.PlayerStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr teamid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr symbol_;
  ::fantasybit::PlayerResult* totals_;
  int status_;
  friend struct ::TableStruct_StatusData_2eproto;
};
// -------------------------------------------------------------------

class GameStatus PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.GameStatus) */ {
 public:
  inline GameStatus() : GameStatus(nullptr) {};
  virtual ~GameStatus();

  GameStatus(const GameStatus& from);
  GameStatus(GameStatus&& from) noexcept
    : GameStatus() {
    *this = ::std::move(from);
  }

  inline GameStatus& operator=(const GameStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameStatus& operator=(GameStatus&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameStatus* internal_default_instance() {
    return reinterpret_cast<const GameStatus*>(
               &_GameStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GameStatus& a, GameStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(GameStatus* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameStatus* New() const final {
    return CreateMaybeMessage<GameStatus>(nullptr);
  }

  GameStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameStatus& from);
  void MergeFrom(const GameStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.GameStatus";
  }
  protected:
  explicit GameStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_StatusData_2eproto);
    return ::descriptor_table_StatusData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef GameStatus_Status Status;
  static constexpr Status SCHEDULED =
    GameStatus_Status_SCHEDULED;
  static constexpr Status PREGAME =
    GameStatus_Status_PREGAME;
  static constexpr Status INGAME =
    GameStatus_Status_INGAME;
  static constexpr Status POSTGAME =
    GameStatus_Status_POSTGAME;
  static constexpr Status CLOSED =
    GameStatus_Status_CLOSED;
  static inline bool Status_IsValid(int value) {
    return GameStatus_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    GameStatus_Status_Status_MIN;
  static constexpr Status Status_MAX =
    GameStatus_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    GameStatus_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return GameStatus_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return GameStatus_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return GameStatus_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 10,
    kDatetimeFieldNumber = 20,
  };
  // optional .fantasybit.GameStatus.Status status = 10;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::fantasybit::GameStatus_Status status() const;
  void set_status(::fantasybit::GameStatus_Status value);
  private:
  ::fantasybit::GameStatus_Status _internal_status() const;
  void _internal_set_status(::fantasybit::GameStatus_Status value);
  public:

  // optional uint32 datetime = 20;
  bool has_datetime() const;
  private:
  bool _internal_has_datetime() const;
  public:
  void clear_datetime();
  ::PROTOBUF_NAMESPACE_ID::uint32 datetime() const;
  void set_datetime(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_datetime() const;
  void _internal_set_datetime(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:fantasybit.GameStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int status_;
  ::PROTOBUF_NAMESPACE_ID::uint32 datetime_;
  friend struct ::TableStruct_StatusData_2eproto;
};
// -------------------------------------------------------------------

class TeamDepth PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.TeamDepth) */ {
 public:
  inline TeamDepth() : TeamDepth(nullptr) {};
  virtual ~TeamDepth();

  TeamDepth(const TeamDepth& from);
  TeamDepth(TeamDepth&& from) noexcept
    : TeamDepth() {
    *this = ::std::move(from);
  }

  inline TeamDepth& operator=(const TeamDepth& from) {
    CopyFrom(from);
    return *this;
  }
  inline TeamDepth& operator=(TeamDepth&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TeamDepth& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TeamDepth* internal_default_instance() {
    return reinterpret_cast<const TeamDepth*>(
               &_TeamDepth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TeamDepth& a, TeamDepth& b) {
    a.Swap(&b);
  }
  inline void Swap(TeamDepth* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TeamDepth* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TeamDepth* New() const final {
    return CreateMaybeMessage<TeamDepth>(nullptr);
  }

  TeamDepth* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TeamDepth>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TeamDepth& from);
  void MergeFrom(const TeamDepth& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TeamDepth* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.TeamDepth";
  }
  protected:
  explicit TeamDepth(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_StatusData_2eproto);
    return ::descriptor_table_StatusData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQbFieldNumber = 10,
    kRbFieldNumber = 20,
    kWrFieldNumber = 30,
    kTeFieldNumber = 40,
    kKFieldNumber = 50,
  };
  // repeated string qb = 10;
  int qb_size() const;
  private:
  int _internal_qb_size() const;
  public:
  void clear_qb();
  const std::string& qb(int index) const;
  std::string* mutable_qb(int index);
  void set_qb(int index, const std::string& value);
  void set_qb(int index, std::string&& value);
  void set_qb(int index, const char* value);
  void set_qb(int index, const char* value, size_t size);
  std::string* add_qb();
  void add_qb(const std::string& value);
  void add_qb(std::string&& value);
  void add_qb(const char* value);
  void add_qb(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& qb() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_qb();
  private:
  const std::string& _internal_qb(int index) const;
  std::string* _internal_add_qb();
  public:

  // repeated string rb = 20;
  int rb_size() const;
  private:
  int _internal_rb_size() const;
  public:
  void clear_rb();
  const std::string& rb(int index) const;
  std::string* mutable_rb(int index);
  void set_rb(int index, const std::string& value);
  void set_rb(int index, std::string&& value);
  void set_rb(int index, const char* value);
  void set_rb(int index, const char* value, size_t size);
  std::string* add_rb();
  void add_rb(const std::string& value);
  void add_rb(std::string&& value);
  void add_rb(const char* value);
  void add_rb(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& rb() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_rb();
  private:
  const std::string& _internal_rb(int index) const;
  std::string* _internal_add_rb();
  public:

  // repeated string wr = 30;
  int wr_size() const;
  private:
  int _internal_wr_size() const;
  public:
  void clear_wr();
  const std::string& wr(int index) const;
  std::string* mutable_wr(int index);
  void set_wr(int index, const std::string& value);
  void set_wr(int index, std::string&& value);
  void set_wr(int index, const char* value);
  void set_wr(int index, const char* value, size_t size);
  std::string* add_wr();
  void add_wr(const std::string& value);
  void add_wr(std::string&& value);
  void add_wr(const char* value);
  void add_wr(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& wr() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_wr();
  private:
  const std::string& _internal_wr(int index) const;
  std::string* _internal_add_wr();
  public:

  // repeated string te = 40;
  int te_size() const;
  private:
  int _internal_te_size() const;
  public:
  void clear_te();
  const std::string& te(int index) const;
  std::string* mutable_te(int index);
  void set_te(int index, const std::string& value);
  void set_te(int index, std::string&& value);
  void set_te(int index, const char* value);
  void set_te(int index, const char* value, size_t size);
  std::string* add_te();
  void add_te(const std::string& value);
  void add_te(std::string&& value);
  void add_te(const char* value);
  void add_te(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& te() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_te();
  private:
  const std::string& _internal_te(int index) const;
  std::string* _internal_add_te();
  public:

  // repeated string k = 50;
  int k_size() const;
  private:
  int _internal_k_size() const;
  public:
  void clear_k();
  const std::string& k(int index) const;
  std::string* mutable_k(int index);
  void set_k(int index, const std::string& value);
  void set_k(int index, std::string&& value);
  void set_k(int index, const char* value);
  void set_k(int index, const char* value, size_t size);
  std::string* add_k();
  void add_k(const std::string& value);
  void add_k(std::string&& value);
  void add_k(const char* value);
  void add_k(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& k() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_k();
  private:
  const std::string& _internal_k(int index) const;
  std::string* _internal_add_k();
  public:

  // @@protoc_insertion_point(class_scope:fantasybit.TeamDepth)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> qb_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> rb_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> wr_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> te_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> k_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_StatusData_2eproto;
};
// -------------------------------------------------------------------

class GlobalState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fantasybit.GlobalState) */ {
 public:
  inline GlobalState() : GlobalState(nullptr) {};
  virtual ~GlobalState();

  GlobalState(const GlobalState& from);
  GlobalState(GlobalState&& from) noexcept
    : GlobalState() {
    *this = ::std::move(from);
  }

  inline GlobalState& operator=(const GlobalState& from) {
    CopyFrom(from);
    return *this;
  }
  inline GlobalState& operator=(GlobalState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GlobalState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GlobalState* internal_default_instance() {
    return reinterpret_cast<const GlobalState*>(
               &_GlobalState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GlobalState& a, GlobalState& b) {
    a.Swap(&b);
  }
  inline void Swap(GlobalState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GlobalState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GlobalState* New() const final {
    return CreateMaybeMessage<GlobalState>(nullptr);
  }

  GlobalState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GlobalState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GlobalState& from);
  void MergeFrom(const GlobalState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GlobalState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fantasybit.GlobalState";
  }
  protected:
  explicit GlobalState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_StatusData_2eproto);
    return ::descriptor_table_StatusData_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef GlobalState_State State;
  static constexpr State OFFSEASON =
    GlobalState_State_OFFSEASON;
  static constexpr State INSEASON =
    GlobalState_State_INSEASON;
  static constexpr State PLAYOFFS =
    GlobalState_State_PLAYOFFS;
  static inline bool State_IsValid(int value) {
    return GlobalState_State_IsValid(value);
  }
  static constexpr State State_MIN =
    GlobalState_State_State_MIN;
  static constexpr State State_MAX =
    GlobalState_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    GlobalState_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return GlobalState_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return GlobalState_State_Name(enum_t_value);
  }
  static inline bool State_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      State* value) {
    return GlobalState_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSeasonFieldNumber = 10,
    kWeekFieldNumber = 20,
    kStateFieldNumber = 1,
  };
  // optional uint32 season = 10;
  bool has_season() const;
  private:
  bool _internal_has_season() const;
  public:
  void clear_season();
  ::PROTOBUF_NAMESPACE_ID::uint32 season() const;
  void set_season(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_season() const;
  void _internal_set_season(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 week = 20;
  bool has_week() const;
  private:
  bool _internal_has_week() const;
  public:
  void clear_week();
  ::PROTOBUF_NAMESPACE_ID::uint32 week() const;
  void set_week(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_week() const;
  void _internal_set_week(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional .fantasybit.GlobalState.State state = 1;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  ::fantasybit::GlobalState_State state() const;
  void set_state(::fantasybit::GlobalState_State value);
  private:
  ::fantasybit::GlobalState_State _internal_state() const;
  void _internal_set_state(::fantasybit::GlobalState_State value);
  public:

  // @@protoc_insertion_point(class_scope:fantasybit.GlobalState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 season_;
  ::PROTOBUF_NAMESPACE_ID::uint32 week_;
  int state_;
  friend struct ::TableStruct_StatusData_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PlayerStatus

// optional string teamid = 20;
inline bool PlayerStatus::_internal_has_teamid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PlayerStatus::has_teamid() const {
  return _internal_has_teamid();
}
inline void PlayerStatus::clear_teamid() {
  teamid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PlayerStatus::teamid() const {
  // @@protoc_insertion_point(field_get:fantasybit.PlayerStatus.teamid)
  return _internal_teamid();
}
inline void PlayerStatus::set_teamid(const std::string& value) {
  _internal_set_teamid(value);
  // @@protoc_insertion_point(field_set:fantasybit.PlayerStatus.teamid)
}
inline std::string* PlayerStatus::mutable_teamid() {
  // @@protoc_insertion_point(field_mutable:fantasybit.PlayerStatus.teamid)
  return _internal_mutable_teamid();
}
inline const std::string& PlayerStatus::_internal_teamid() const {
  return teamid_.Get();
}
inline void PlayerStatus::_internal_set_teamid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  teamid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void PlayerStatus::set_teamid(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  teamid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.PlayerStatus.teamid)
}
inline void PlayerStatus::set_teamid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  teamid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.PlayerStatus.teamid)
}
inline void PlayerStatus::set_teamid(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  teamid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.PlayerStatus.teamid)
}
inline std::string* PlayerStatus::_internal_mutable_teamid() {
  _has_bits_[0] |= 0x00000001u;
  return teamid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* PlayerStatus::release_teamid() {
  // @@protoc_insertion_point(field_release:fantasybit.PlayerStatus.teamid)
  if (!_internal_has_teamid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return teamid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PlayerStatus::set_allocated_teamid(std::string* teamid) {
  if (teamid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  teamid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), teamid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.PlayerStatus.teamid)
}

// optional .fantasybit.PlayerStatus.Status status = 30;
inline bool PlayerStatus::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PlayerStatus::has_status() const {
  return _internal_has_status();
}
inline void PlayerStatus::clear_status() {
  status_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::fantasybit::PlayerStatus_Status PlayerStatus::_internal_status() const {
  return static_cast< ::fantasybit::PlayerStatus_Status >(status_);
}
inline ::fantasybit::PlayerStatus_Status PlayerStatus::status() const {
  // @@protoc_insertion_point(field_get:fantasybit.PlayerStatus.status)
  return _internal_status();
}
inline void PlayerStatus::_internal_set_status(::fantasybit::PlayerStatus_Status value) {
  assert(::fantasybit::PlayerStatus_Status_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  status_ = value;
}
inline void PlayerStatus::set_status(::fantasybit::PlayerStatus_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:fantasybit.PlayerStatus.status)
}

// optional .fantasybit.PlayerResult totals = 40;
inline bool PlayerStatus::_internal_has_totals() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || totals_ != nullptr);
  return value;
}
inline bool PlayerStatus::has_totals() const {
  return _internal_has_totals();
}
inline const ::fantasybit::PlayerResult& PlayerStatus::_internal_totals() const {
  const ::fantasybit::PlayerResult* p = totals_;
  return p != nullptr ? *p : *reinterpret_cast<const ::fantasybit::PlayerResult*>(
      &::fantasybit::_PlayerResult_default_instance_);
}
inline const ::fantasybit::PlayerResult& PlayerStatus::totals() const {
  // @@protoc_insertion_point(field_get:fantasybit.PlayerStatus.totals)
  return _internal_totals();
}
inline void PlayerStatus::unsafe_arena_set_allocated_totals(
    ::fantasybit::PlayerResult* totals) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(totals_);
  }
  totals_ = totals;
  if (totals) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fantasybit.PlayerStatus.totals)
}
inline ::fantasybit::PlayerResult* PlayerStatus::release_totals() {
  _has_bits_[0] &= ~0x00000004u;
  ::fantasybit::PlayerResult* temp = totals_;
  totals_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::fantasybit::PlayerResult* PlayerStatus::unsafe_arena_release_totals() {
  // @@protoc_insertion_point(field_release:fantasybit.PlayerStatus.totals)
  _has_bits_[0] &= ~0x00000004u;
  ::fantasybit::PlayerResult* temp = totals_;
  totals_ = nullptr;
  return temp;
}
inline ::fantasybit::PlayerResult* PlayerStatus::_internal_mutable_totals() {
  _has_bits_[0] |= 0x00000004u;
  if (totals_ == nullptr) {
    auto* p = CreateMaybeMessage<::fantasybit::PlayerResult>(GetArena());
    totals_ = p;
  }
  return totals_;
}
inline ::fantasybit::PlayerResult* PlayerStatus::mutable_totals() {
  // @@protoc_insertion_point(field_mutable:fantasybit.PlayerStatus.totals)
  return _internal_mutable_totals();
}
inline void PlayerStatus::set_allocated_totals(::fantasybit::PlayerResult* totals) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(totals_);
  }
  if (totals) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(totals)->GetArena();
    if (message_arena != submessage_arena) {
      totals = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, totals, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  totals_ = totals;
  // @@protoc_insertion_point(field_set_allocated:fantasybit.PlayerStatus.totals)
}

// optional string symbol = 50;
inline bool PlayerStatus::_internal_has_symbol() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PlayerStatus::has_symbol() const {
  return _internal_has_symbol();
}
inline void PlayerStatus::clear_symbol() {
  symbol_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PlayerStatus::symbol() const {
  // @@protoc_insertion_point(field_get:fantasybit.PlayerStatus.symbol)
  return _internal_symbol();
}
inline void PlayerStatus::set_symbol(const std::string& value) {
  _internal_set_symbol(value);
  // @@protoc_insertion_point(field_set:fantasybit.PlayerStatus.symbol)
}
inline std::string* PlayerStatus::mutable_symbol() {
  // @@protoc_insertion_point(field_mutable:fantasybit.PlayerStatus.symbol)
  return _internal_mutable_symbol();
}
inline const std::string& PlayerStatus::_internal_symbol() const {
  return symbol_.Get();
}
inline void PlayerStatus::_internal_set_symbol(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  symbol_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void PlayerStatus::set_symbol(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  symbol_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:fantasybit.PlayerStatus.symbol)
}
inline void PlayerStatus::set_symbol(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  symbol_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:fantasybit.PlayerStatus.symbol)
}
inline void PlayerStatus::set_symbol(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  symbol_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:fantasybit.PlayerStatus.symbol)
}
inline std::string* PlayerStatus::_internal_mutable_symbol() {
  _has_bits_[0] |= 0x00000002u;
  return symbol_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* PlayerStatus::release_symbol() {
  // @@protoc_insertion_point(field_release:fantasybit.PlayerStatus.symbol)
  if (!_internal_has_symbol()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return symbol_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PlayerStatus::set_allocated_symbol(std::string* symbol) {
  if (symbol != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  symbol_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), symbol,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:fantasybit.PlayerStatus.symbol)
}

// -------------------------------------------------------------------

// GameStatus

// optional .fantasybit.GameStatus.Status status = 10;
inline bool GameStatus::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GameStatus::has_status() const {
  return _internal_has_status();
}
inline void GameStatus::clear_status() {
  status_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::fantasybit::GameStatus_Status GameStatus::_internal_status() const {
  return static_cast< ::fantasybit::GameStatus_Status >(status_);
}
inline ::fantasybit::GameStatus_Status GameStatus::status() const {
  // @@protoc_insertion_point(field_get:fantasybit.GameStatus.status)
  return _internal_status();
}
inline void GameStatus::_internal_set_status(::fantasybit::GameStatus_Status value) {
  assert(::fantasybit::GameStatus_Status_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  status_ = value;
}
inline void GameStatus::set_status(::fantasybit::GameStatus_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:fantasybit.GameStatus.status)
}

// optional uint32 datetime = 20;
inline bool GameStatus::_internal_has_datetime() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GameStatus::has_datetime() const {
  return _internal_has_datetime();
}
inline void GameStatus::clear_datetime() {
  datetime_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GameStatus::_internal_datetime() const {
  return datetime_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GameStatus::datetime() const {
  // @@protoc_insertion_point(field_get:fantasybit.GameStatus.datetime)
  return _internal_datetime();
}
inline void GameStatus::_internal_set_datetime(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  datetime_ = value;
}
inline void GameStatus::set_datetime(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_datetime(value);
  // @@protoc_insertion_point(field_set:fantasybit.GameStatus.datetime)
}

// -------------------------------------------------------------------

// TeamDepth

// repeated string qb = 10;
inline int TeamDepth::_internal_qb_size() const {
  return qb_.size();
}
inline int TeamDepth::qb_size() const {
  return _internal_qb_size();
}
inline void TeamDepth::clear_qb() {
  qb_.Clear();
}
inline std::string* TeamDepth::add_qb() {
  // @@protoc_insertion_point(field_add_mutable:fantasybit.TeamDepth.qb)
  return _internal_add_qb();
}
inline const std::string& TeamDepth::_internal_qb(int index) const {
  return qb_.Get(index);
}
inline const std::string& TeamDepth::qb(int index) const {
  // @@protoc_insertion_point(field_get:fantasybit.TeamDepth.qb)
  return _internal_qb(index);
}
inline std::string* TeamDepth::mutable_qb(int index) {
  // @@protoc_insertion_point(field_mutable:fantasybit.TeamDepth.qb)
  return qb_.Mutable(index);
}
inline void TeamDepth::set_qb(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:fantasybit.TeamDepth.qb)
  qb_.Mutable(index)->assign(value);
}
inline void TeamDepth::set_qb(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:fantasybit.TeamDepth.qb)
  qb_.Mutable(index)->assign(std::move(value));
}
inline void TeamDepth::set_qb(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  qb_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:fantasybit.TeamDepth.qb)
}
inline void TeamDepth::set_qb(int index, const char* value, size_t size) {
  qb_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fantasybit.TeamDepth.qb)
}
inline std::string* TeamDepth::_internal_add_qb() {
  return qb_.Add();
}
inline void TeamDepth::add_qb(const std::string& value) {
  qb_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:fantasybit.TeamDepth.qb)
}
inline void TeamDepth::add_qb(std::string&& value) {
  qb_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:fantasybit.TeamDepth.qb)
}
inline void TeamDepth::add_qb(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  qb_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:fantasybit.TeamDepth.qb)
}
inline void TeamDepth::add_qb(const char* value, size_t size) {
  qb_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:fantasybit.TeamDepth.qb)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TeamDepth::qb() const {
  // @@protoc_insertion_point(field_list:fantasybit.TeamDepth.qb)
  return qb_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TeamDepth::mutable_qb() {
  // @@protoc_insertion_point(field_mutable_list:fantasybit.TeamDepth.qb)
  return &qb_;
}

// repeated string rb = 20;
inline int TeamDepth::_internal_rb_size() const {
  return rb_.size();
}
inline int TeamDepth::rb_size() const {
  return _internal_rb_size();
}
inline void TeamDepth::clear_rb() {
  rb_.Clear();
}
inline std::string* TeamDepth::add_rb() {
  // @@protoc_insertion_point(field_add_mutable:fantasybit.TeamDepth.rb)
  return _internal_add_rb();
}
inline const std::string& TeamDepth::_internal_rb(int index) const {
  return rb_.Get(index);
}
inline const std::string& TeamDepth::rb(int index) const {
  // @@protoc_insertion_point(field_get:fantasybit.TeamDepth.rb)
  return _internal_rb(index);
}
inline std::string* TeamDepth::mutable_rb(int index) {
  // @@protoc_insertion_point(field_mutable:fantasybit.TeamDepth.rb)
  return rb_.Mutable(index);
}
inline void TeamDepth::set_rb(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:fantasybit.TeamDepth.rb)
  rb_.Mutable(index)->assign(value);
}
inline void TeamDepth::set_rb(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:fantasybit.TeamDepth.rb)
  rb_.Mutable(index)->assign(std::move(value));
}
inline void TeamDepth::set_rb(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  rb_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:fantasybit.TeamDepth.rb)
}
inline void TeamDepth::set_rb(int index, const char* value, size_t size) {
  rb_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fantasybit.TeamDepth.rb)
}
inline std::string* TeamDepth::_internal_add_rb() {
  return rb_.Add();
}
inline void TeamDepth::add_rb(const std::string& value) {
  rb_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:fantasybit.TeamDepth.rb)
}
inline void TeamDepth::add_rb(std::string&& value) {
  rb_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:fantasybit.TeamDepth.rb)
}
inline void TeamDepth::add_rb(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  rb_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:fantasybit.TeamDepth.rb)
}
inline void TeamDepth::add_rb(const char* value, size_t size) {
  rb_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:fantasybit.TeamDepth.rb)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TeamDepth::rb() const {
  // @@protoc_insertion_point(field_list:fantasybit.TeamDepth.rb)
  return rb_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TeamDepth::mutable_rb() {
  // @@protoc_insertion_point(field_mutable_list:fantasybit.TeamDepth.rb)
  return &rb_;
}

// repeated string wr = 30;
inline int TeamDepth::_internal_wr_size() const {
  return wr_.size();
}
inline int TeamDepth::wr_size() const {
  return _internal_wr_size();
}
inline void TeamDepth::clear_wr() {
  wr_.Clear();
}
inline std::string* TeamDepth::add_wr() {
  // @@protoc_insertion_point(field_add_mutable:fantasybit.TeamDepth.wr)
  return _internal_add_wr();
}
inline const std::string& TeamDepth::_internal_wr(int index) const {
  return wr_.Get(index);
}
inline const std::string& TeamDepth::wr(int index) const {
  // @@protoc_insertion_point(field_get:fantasybit.TeamDepth.wr)
  return _internal_wr(index);
}
inline std::string* TeamDepth::mutable_wr(int index) {
  // @@protoc_insertion_point(field_mutable:fantasybit.TeamDepth.wr)
  return wr_.Mutable(index);
}
inline void TeamDepth::set_wr(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:fantasybit.TeamDepth.wr)
  wr_.Mutable(index)->assign(value);
}
inline void TeamDepth::set_wr(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:fantasybit.TeamDepth.wr)
  wr_.Mutable(index)->assign(std::move(value));
}
inline void TeamDepth::set_wr(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  wr_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:fantasybit.TeamDepth.wr)
}
inline void TeamDepth::set_wr(int index, const char* value, size_t size) {
  wr_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fantasybit.TeamDepth.wr)
}
inline std::string* TeamDepth::_internal_add_wr() {
  return wr_.Add();
}
inline void TeamDepth::add_wr(const std::string& value) {
  wr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:fantasybit.TeamDepth.wr)
}
inline void TeamDepth::add_wr(std::string&& value) {
  wr_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:fantasybit.TeamDepth.wr)
}
inline void TeamDepth::add_wr(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  wr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:fantasybit.TeamDepth.wr)
}
inline void TeamDepth::add_wr(const char* value, size_t size) {
  wr_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:fantasybit.TeamDepth.wr)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TeamDepth::wr() const {
  // @@protoc_insertion_point(field_list:fantasybit.TeamDepth.wr)
  return wr_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TeamDepth::mutable_wr() {
  // @@protoc_insertion_point(field_mutable_list:fantasybit.TeamDepth.wr)
  return &wr_;
}

// repeated string te = 40;
inline int TeamDepth::_internal_te_size() const {
  return te_.size();
}
inline int TeamDepth::te_size() const {
  return _internal_te_size();
}
inline void TeamDepth::clear_te() {
  te_.Clear();
}
inline std::string* TeamDepth::add_te() {
  // @@protoc_insertion_point(field_add_mutable:fantasybit.TeamDepth.te)
  return _internal_add_te();
}
inline const std::string& TeamDepth::_internal_te(int index) const {
  return te_.Get(index);
}
inline const std::string& TeamDepth::te(int index) const {
  // @@protoc_insertion_point(field_get:fantasybit.TeamDepth.te)
  return _internal_te(index);
}
inline std::string* TeamDepth::mutable_te(int index) {
  // @@protoc_insertion_point(field_mutable:fantasybit.TeamDepth.te)
  return te_.Mutable(index);
}
inline void TeamDepth::set_te(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:fantasybit.TeamDepth.te)
  te_.Mutable(index)->assign(value);
}
inline void TeamDepth::set_te(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:fantasybit.TeamDepth.te)
  te_.Mutable(index)->assign(std::move(value));
}
inline void TeamDepth::set_te(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  te_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:fantasybit.TeamDepth.te)
}
inline void TeamDepth::set_te(int index, const char* value, size_t size) {
  te_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fantasybit.TeamDepth.te)
}
inline std::string* TeamDepth::_internal_add_te() {
  return te_.Add();
}
inline void TeamDepth::add_te(const std::string& value) {
  te_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:fantasybit.TeamDepth.te)
}
inline void TeamDepth::add_te(std::string&& value) {
  te_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:fantasybit.TeamDepth.te)
}
inline void TeamDepth::add_te(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  te_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:fantasybit.TeamDepth.te)
}
inline void TeamDepth::add_te(const char* value, size_t size) {
  te_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:fantasybit.TeamDepth.te)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TeamDepth::te() const {
  // @@protoc_insertion_point(field_list:fantasybit.TeamDepth.te)
  return te_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TeamDepth::mutable_te() {
  // @@protoc_insertion_point(field_mutable_list:fantasybit.TeamDepth.te)
  return &te_;
}

// repeated string k = 50;
inline int TeamDepth::_internal_k_size() const {
  return k_.size();
}
inline int TeamDepth::k_size() const {
  return _internal_k_size();
}
inline void TeamDepth::clear_k() {
  k_.Clear();
}
inline std::string* TeamDepth::add_k() {
  // @@protoc_insertion_point(field_add_mutable:fantasybit.TeamDepth.k)
  return _internal_add_k();
}
inline const std::string& TeamDepth::_internal_k(int index) const {
  return k_.Get(index);
}
inline const std::string& TeamDepth::k(int index) const {
  // @@protoc_insertion_point(field_get:fantasybit.TeamDepth.k)
  return _internal_k(index);
}
inline std::string* TeamDepth::mutable_k(int index) {
  // @@protoc_insertion_point(field_mutable:fantasybit.TeamDepth.k)
  return k_.Mutable(index);
}
inline void TeamDepth::set_k(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:fantasybit.TeamDepth.k)
  k_.Mutable(index)->assign(value);
}
inline void TeamDepth::set_k(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:fantasybit.TeamDepth.k)
  k_.Mutable(index)->assign(std::move(value));
}
inline void TeamDepth::set_k(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  k_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:fantasybit.TeamDepth.k)
}
inline void TeamDepth::set_k(int index, const char* value, size_t size) {
  k_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fantasybit.TeamDepth.k)
}
inline std::string* TeamDepth::_internal_add_k() {
  return k_.Add();
}
inline void TeamDepth::add_k(const std::string& value) {
  k_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:fantasybit.TeamDepth.k)
}
inline void TeamDepth::add_k(std::string&& value) {
  k_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:fantasybit.TeamDepth.k)
}
inline void TeamDepth::add_k(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  k_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:fantasybit.TeamDepth.k)
}
inline void TeamDepth::add_k(const char* value, size_t size) {
  k_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:fantasybit.TeamDepth.k)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TeamDepth::k() const {
  // @@protoc_insertion_point(field_list:fantasybit.TeamDepth.k)
  return k_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TeamDepth::mutable_k() {
  // @@protoc_insertion_point(field_mutable_list:fantasybit.TeamDepth.k)
  return &k_;
}

// -------------------------------------------------------------------

// GlobalState

// optional .fantasybit.GlobalState.State state = 1;
inline bool GlobalState::_internal_has_state() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GlobalState::has_state() const {
  return _internal_has_state();
}
inline void GlobalState::clear_state() {
  state_ = 10;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::fantasybit::GlobalState_State GlobalState::_internal_state() const {
  return static_cast< ::fantasybit::GlobalState_State >(state_);
}
inline ::fantasybit::GlobalState_State GlobalState::state() const {
  // @@protoc_insertion_point(field_get:fantasybit.GlobalState.state)
  return _internal_state();
}
inline void GlobalState::_internal_set_state(::fantasybit::GlobalState_State value) {
  assert(::fantasybit::GlobalState_State_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  state_ = value;
}
inline void GlobalState::set_state(::fantasybit::GlobalState_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:fantasybit.GlobalState.state)
}

// optional uint32 season = 10;
inline bool GlobalState::_internal_has_season() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GlobalState::has_season() const {
  return _internal_has_season();
}
inline void GlobalState::clear_season() {
  season_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GlobalState::_internal_season() const {
  return season_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GlobalState::season() const {
  // @@protoc_insertion_point(field_get:fantasybit.GlobalState.season)
  return _internal_season();
}
inline void GlobalState::_internal_set_season(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  season_ = value;
}
inline void GlobalState::set_season(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_season(value);
  // @@protoc_insertion_point(field_set:fantasybit.GlobalState.season)
}

// optional uint32 week = 20;
inline bool GlobalState::_internal_has_week() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GlobalState::has_week() const {
  return _internal_has_week();
}
inline void GlobalState::clear_week() {
  week_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GlobalState::_internal_week() const {
  return week_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GlobalState::week() const {
  // @@protoc_insertion_point(field_get:fantasybit.GlobalState.week)
  return _internal_week();
}
inline void GlobalState::_internal_set_week(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  week_ = value;
}
inline void GlobalState::set_week(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_week(value);
  // @@protoc_insertion_point(field_set:fantasybit.GlobalState.week)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace fantasybit

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::fantasybit::PlayerStatus_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fantasybit::PlayerStatus_Status>() {
  return ::fantasybit::PlayerStatus_Status_descriptor();
}
template <> struct is_proto_enum< ::fantasybit::GameStatus_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fantasybit::GameStatus_Status>() {
  return ::fantasybit::GameStatus_Status_descriptor();
}
template <> struct is_proto_enum< ::fantasybit::GlobalState_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fantasybit::GlobalState_State>() {
  return ::fantasybit::GlobalState_State_descriptor();
}
template <> struct is_proto_enum< ::fantasybit::PlayerGameStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fantasybit::PlayerGameStatus>() {
  return ::fantasybit::PlayerGameStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_StatusData_2eproto
