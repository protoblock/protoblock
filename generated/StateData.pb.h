// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: StateData.proto

#ifndef PROTOBUF_StateData_2eproto__INCLUDED
#define PROTOBUF_StateData_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "ProtoData.pb.h"
#include "NameData.pb.h"
#include "StaticData.pb.h"
#include "StatusData.pb.h"
#include "ExData.pb.h"
// @@protoc_insertion_point(includes)

namespace fantasybit {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_StateData_2eproto();
void protobuf_AssignDesc_StateData_2eproto();
void protobuf_ShutdownFile_StateData_2eproto();

class BlockMeta;
class TxMeta;
class TrMeta;
class GameMeta;
class DataMeta;
class LeaderBoardMeta;
class FantasyNameBalMeta;
class FantasyNameState;
class WeekGameStatusMeta;
class InGameProjMeta;
class GameResultsMeta;
class GameStatusMeta;
class TeamProjMeta;
class TeamResultMeta;
class GamePlayerProjMeta;
class ProjMeta;
class PosMeta;
class PlayerResultMeta;
class PlayerGameStats;
class AwardMeta;
class PnlMeta;
class PlayerMarketState;
class LimitBookMeta;
class MarketTicMeta;
class OrderMeta;
class OrderFillMeta;
class GlobalStateMeta;
class PlayerMeta;
class TeamMeta;
class pbstate;
class MerkleTree;

// ===================================================================

class BlockMeta : public ::google::protobuf::Message {
 public:
  BlockMeta();
  virtual ~BlockMeta();

  BlockMeta(const BlockMeta& from);

  inline BlockMeta& operator=(const BlockMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlockMeta& default_instance();

  void Swap(BlockMeta* other);

  // implements Message ----------------------------------------------

  BlockMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlockMeta& from);
  void MergeFrom(const BlockMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 blocknum = 40;
  inline bool has_blocknum() const;
  inline void clear_blocknum();
  static const int kBlocknumFieldNumber = 40;
  inline ::google::protobuf::int32 blocknum() const;
  inline void set_blocknum(::google::protobuf::int32 value);

  // optional bytes trmetaid = 50;
  inline bool has_trmetaid() const;
  inline void clear_trmetaid();
  static const int kTrmetaidFieldNumber = 50;
  inline const ::std::string& trmetaid() const;
  inline void set_trmetaid(const ::std::string& value);
  inline void set_trmetaid(const char* value);
  inline void set_trmetaid(const void* value, size_t size);
  inline ::std::string* mutable_trmetaid();
  inline ::std::string* release_trmetaid();
  inline void set_allocated_trmetaid(::std::string* trmetaid);

  // optional bytes txmetaroot = 10;
  inline bool has_txmetaroot() const;
  inline void clear_txmetaroot();
  static const int kTxmetarootFieldNumber = 10;
  inline const ::std::string& txmetaroot() const;
  inline void set_txmetaroot(const ::std::string& value);
  inline void set_txmetaroot(const char* value);
  inline void set_txmetaroot(const void* value, size_t size);
  inline ::std::string* mutable_txmetaroot();
  inline ::std::string* release_txmetaroot();
  inline void set_allocated_txmetaroot(::std::string* txmetaroot);

  // optional bytes pbstateid = 60;
  inline bool has_pbstateid() const;
  inline void clear_pbstateid();
  static const int kPbstateidFieldNumber = 60;
  inline const ::std::string& pbstateid() const;
  inline void set_pbstateid(const ::std::string& value);
  inline void set_pbstateid(const char* value);
  inline void set_pbstateid(const void* value, size_t size);
  inline ::std::string* mutable_pbstateid();
  inline ::std::string* release_pbstateid();
  inline void set_allocated_pbstateid(::std::string* pbstateid);

  // optional bytes prev = 20;
  inline bool has_prev() const;
  inline void clear_prev();
  static const int kPrevFieldNumber = 20;
  inline const ::std::string& prev() const;
  inline void set_prev(const ::std::string& value);
  inline void set_prev(const char* value);
  inline void set_prev(const void* value, size_t size);
  inline ::std::string* mutable_prev();
  inline ::std::string* release_prev();
  inline void set_allocated_prev(::std::string* prev);

  // optional bytes next = 30;
  inline bool has_next() const;
  inline void clear_next();
  static const int kNextFieldNumber = 30;
  inline const ::std::string& next() const;
  inline void set_next(const ::std::string& value);
  inline void set_next(const char* value);
  inline void set_next(const void* value, size_t size);
  inline ::std::string* mutable_next();
  inline ::std::string* release_next();
  inline void set_allocated_next(::std::string* next);

  // @@protoc_insertion_point(class_scope:fantasybit.BlockMeta)
 private:
  inline void set_has_blocknum();
  inline void clear_has_blocknum();
  inline void set_has_trmetaid();
  inline void clear_has_trmetaid();
  inline void set_has_txmetaroot();
  inline void clear_has_txmetaroot();
  inline void set_has_pbstateid();
  inline void clear_has_pbstateid();
  inline void set_has_prev();
  inline void clear_has_prev();
  inline void set_has_next();
  inline void clear_has_next();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* trmetaid_;
  ::std::string* txmetaroot_;
  ::std::string* pbstateid_;
  ::std::string* prev_;
  ::std::string* next_;
  ::google::protobuf::int32 blocknum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static BlockMeta* default_instance_;
};
// -------------------------------------------------------------------

class TxMeta : public ::google::protobuf::Message {
 public:
  TxMeta();
  virtual ~TxMeta();

  TxMeta(const TxMeta& from);

  inline TxMeta& operator=(const TxMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TxMeta& default_instance();

  void Swap(TxMeta* other);

  // implements Message ----------------------------------------------

  TxMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TxMeta& from);
  void MergeFrom(const TxMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 blocknum = 10;
  inline bool has_blocknum() const;
  inline void clear_blocknum();
  static const int kBlocknumFieldNumber = 10;
  inline ::google::protobuf::int32 blocknum() const;
  inline void set_blocknum(::google::protobuf::int32 value);

  // optional int32 txnum = 20;
  inline bool has_txnum() const;
  inline void clear_txnum();
  static const int kTxnumFieldNumber = 20;
  inline ::google::protobuf::int32 txnum() const;
  inline void set_txnum(::google::protobuf::int32 value);

  // optional .fantasybit.TransType txtype = 40;
  inline bool has_txtype() const;
  inline void clear_txtype();
  static const int kTxtypeFieldNumber = 40;
  inline ::fantasybit::TransType txtype() const;
  inline void set_txtype(::fantasybit::TransType value);

  // optional .fantasybit.Transaction tx = 50;
  inline bool has_tx() const;
  inline void clear_tx();
  static const int kTxFieldNumber = 50;
  inline const ::fantasybit::Transaction& tx() const;
  inline ::fantasybit::Transaction* mutable_tx();
  inline ::fantasybit::Transaction* release_tx();
  inline void set_allocated_tx(::fantasybit::Transaction* tx);

  // optional string fantasy_name = 60;
  inline bool has_fantasy_name() const;
  inline void clear_fantasy_name();
  static const int kFantasyNameFieldNumber = 60;
  inline const ::std::string& fantasy_name() const;
  inline void set_fantasy_name(const ::std::string& value);
  inline void set_fantasy_name(const char* value);
  inline void set_fantasy_name(const char* value, size_t size);
  inline ::std::string* mutable_fantasy_name();
  inline ::std::string* release_fantasy_name();
  inline void set_allocated_fantasy_name(::std::string* fantasy_name);

  // optional bytes id = 70;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 70;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const void* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:fantasybit.TxMeta)
 private:
  inline void set_has_blocknum();
  inline void clear_has_blocknum();
  inline void set_has_txnum();
  inline void clear_has_txnum();
  inline void set_has_txtype();
  inline void clear_has_txtype();
  inline void set_has_tx();
  inline void clear_has_tx();
  inline void set_has_fantasy_name();
  inline void clear_has_fantasy_name();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 blocknum_;
  ::google::protobuf::int32 txnum_;
  ::fantasybit::Transaction* tx_;
  ::std::string* fantasy_name_;
  ::std::string* id_;
  int txtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static TxMeta* default_instance_;
};
// -------------------------------------------------------------------

class TrMeta : public ::google::protobuf::Message {
 public:
  TrMeta();
  virtual ~TrMeta();

  TrMeta(const TrMeta& from);

  inline TrMeta& operator=(const TrMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrMeta& default_instance();

  void Swap(TrMeta* other);

  // implements Message ----------------------------------------------

  TrMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TrMeta& from);
  void MergeFrom(const TrMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 blocknum = 10;
  inline bool has_blocknum() const;
  inline void clear_blocknum();
  static const int kBlocknumFieldNumber = 10;
  inline ::google::protobuf::int32 blocknum() const;
  inline void set_blocknum(::google::protobuf::int32 value);

  // optional .fantasybit.TrType type = 40;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 40;
  inline ::fantasybit::TrType type() const;
  inline void set_type(::fantasybit::TrType value);

  // optional uint32 season = 50;
  inline bool has_season() const;
  inline void clear_season();
  static const int kSeasonFieldNumber = 50;
  inline ::google::protobuf::uint32 season() const;
  inline void set_season(::google::protobuf::uint32 value);

  // optional uint32 week = 60;
  inline bool has_week() const;
  inline void clear_week();
  static const int kWeekFieldNumber = 60;
  inline ::google::protobuf::uint32 week() const;
  inline void set_week(::google::protobuf::uint32 value);

  // optional bytes gamemetaroot = 70;
  inline bool has_gamemetaroot() const;
  inline void clear_gamemetaroot();
  static const int kGamemetarootFieldNumber = 70;
  inline const ::std::string& gamemetaroot() const;
  inline void set_gamemetaroot(const ::std::string& value);
  inline void set_gamemetaroot(const char* value);
  inline void set_gamemetaroot(const void* value, size_t size);
  inline ::std::string* mutable_gamemetaroot();
  inline ::std::string* release_gamemetaroot();
  inline void set_allocated_gamemetaroot(::std::string* gamemetaroot);

  // optional bytes datametaroot = 80;
  inline bool has_datametaroot() const;
  inline void clear_datametaroot();
  static const int kDatametarootFieldNumber = 80;
  inline const ::std::string& datametaroot() const;
  inline void set_datametaroot(const ::std::string& value);
  inline void set_datametaroot(const char* value);
  inline void set_datametaroot(const void* value, size_t size);
  inline ::std::string* mutable_datametaroot();
  inline ::std::string* release_datametaroot();
  inline void set_allocated_datametaroot(::std::string* datametaroot);

  // optional bytes txmetaid = 100;
  inline bool has_txmetaid() const;
  inline void clear_txmetaid();
  static const int kTxmetaidFieldNumber = 100;
  inline const ::std::string& txmetaid() const;
  inline void set_txmetaid(const ::std::string& value);
  inline void set_txmetaid(const char* value);
  inline void set_txmetaid(const void* value, size_t size);
  inline ::std::string* mutable_txmetaid();
  inline ::std::string* release_txmetaid();
  inline void set_allocated_txmetaid(::std::string* txmetaid);

  // @@protoc_insertion_point(class_scope:fantasybit.TrMeta)
 private:
  inline void set_has_blocknum();
  inline void clear_has_blocknum();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_season();
  inline void clear_has_season();
  inline void set_has_week();
  inline void clear_has_week();
  inline void set_has_gamemetaroot();
  inline void clear_has_gamemetaroot();
  inline void set_has_datametaroot();
  inline void clear_has_datametaroot();
  inline void set_has_txmetaid();
  inline void clear_has_txmetaid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 blocknum_;
  int type_;
  ::google::protobuf::uint32 season_;
  ::google::protobuf::uint32 week_;
  ::std::string* gamemetaroot_;
  ::std::string* datametaroot_;
  ::std::string* txmetaid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static TrMeta* default_instance_;
};
// -------------------------------------------------------------------

class GameMeta : public ::google::protobuf::Message {
 public:
  GameMeta();
  virtual ~GameMeta();

  GameMeta(const GameMeta& from);

  inline GameMeta& operator=(const GameMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameMeta& default_instance();

  void Swap(GameMeta* other);

  // implements Message ----------------------------------------------

  GameMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameMeta& from);
  void MergeFrom(const GameMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes txmetaid = 10;
  inline bool has_txmetaid() const;
  inline void clear_txmetaid();
  static const int kTxmetaidFieldNumber = 10;
  inline const ::std::string& txmetaid() const;
  inline void set_txmetaid(const ::std::string& value);
  inline void set_txmetaid(const char* value);
  inline void set_txmetaid(const void* value, size_t size);
  inline ::std::string* mutable_txmetaid();
  inline ::std::string* release_txmetaid();
  inline void set_allocated_txmetaid(::std::string* txmetaid);

  // optional .fantasybit.GameData gamedata = 20;
  inline bool has_gamedata() const;
  inline void clear_gamedata();
  static const int kGamedataFieldNumber = 20;
  inline const ::fantasybit::GameData& gamedata() const;
  inline ::fantasybit::GameData* mutable_gamedata();
  inline ::fantasybit::GameData* release_gamedata();
  inline void set_allocated_gamedata(::fantasybit::GameData* gamedata);

  // @@protoc_insertion_point(class_scope:fantasybit.GameMeta)
 private:
  inline void set_has_txmetaid();
  inline void clear_has_txmetaid();
  inline void set_has_gamedata();
  inline void clear_has_gamedata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* txmetaid_;
  ::fantasybit::GameData* gamedata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static GameMeta* default_instance_;
};
// -------------------------------------------------------------------

class DataMeta : public ::google::protobuf::Message {
 public:
  DataMeta();
  virtual ~DataMeta();

  DataMeta(const DataMeta& from);

  inline DataMeta& operator=(const DataMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataMeta& default_instance();

  void Swap(DataMeta* other);

  // implements Message ----------------------------------------------

  DataMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataMeta& from);
  void MergeFrom(const DataMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes txmetaid = 10;
  inline bool has_txmetaid() const;
  inline void clear_txmetaid();
  static const int kTxmetaidFieldNumber = 10;
  inline const ::std::string& txmetaid() const;
  inline void set_txmetaid(const ::std::string& value);
  inline void set_txmetaid(const char* value);
  inline void set_txmetaid(const void* value, size_t size);
  inline ::std::string* mutable_txmetaid();
  inline ::std::string* release_txmetaid();
  inline void set_allocated_txmetaid(::std::string* txmetaid);

  // optional .fantasybit.Data data = 20;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 20;
  inline const ::fantasybit::Data& data() const;
  inline ::fantasybit::Data* mutable_data();
  inline ::fantasybit::Data* release_data();
  inline void set_allocated_data(::fantasybit::Data* data);

  // @@protoc_insertion_point(class_scope:fantasybit.DataMeta)
 private:
  inline void set_has_txmetaid();
  inline void clear_has_txmetaid();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* txmetaid_;
  ::fantasybit::Data* data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static DataMeta* default_instance_;
};
// -------------------------------------------------------------------

class LeaderBoardMeta : public ::google::protobuf::Message {
 public:
  LeaderBoardMeta();
  virtual ~LeaderBoardMeta();

  LeaderBoardMeta(const LeaderBoardMeta& from);

  inline LeaderBoardMeta& operator=(const LeaderBoardMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LeaderBoardMeta& default_instance();

  void Swap(LeaderBoardMeta* other);

  // implements Message ----------------------------------------------

  LeaderBoardMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LeaderBoardMeta& from);
  void MergeFrom(const LeaderBoardMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 week = 10;
  inline bool has_week() const;
  inline void clear_week();
  static const int kWeekFieldNumber = 10;
  inline ::google::protobuf::uint32 week() const;
  inline void set_week(::google::protobuf::uint32 value);

  // optional bytes fnbalmetaroot = 20;
  inline bool has_fnbalmetaroot() const;
  inline void clear_fnbalmetaroot();
  static const int kFnbalmetarootFieldNumber = 20;
  inline const ::std::string& fnbalmetaroot() const;
  inline void set_fnbalmetaroot(const ::std::string& value);
  inline void set_fnbalmetaroot(const char* value);
  inline void set_fnbalmetaroot(const void* value, size_t size);
  inline ::std::string* mutable_fnbalmetaroot();
  inline ::std::string* release_fnbalmetaroot();
  inline void set_allocated_fnbalmetaroot(::std::string* fnbalmetaroot);

  // optional bytes prev = 30;
  inline bool has_prev() const;
  inline void clear_prev();
  static const int kPrevFieldNumber = 30;
  inline const ::std::string& prev() const;
  inline void set_prev(const ::std::string& value);
  inline void set_prev(const char* value);
  inline void set_prev(const void* value, size_t size);
  inline ::std::string* mutable_prev();
  inline ::std::string* release_prev();
  inline void set_allocated_prev(::std::string* prev);

  // optional bytes next = 40;
  inline bool has_next() const;
  inline void clear_next();
  static const int kNextFieldNumber = 40;
  inline const ::std::string& next() const;
  inline void set_next(const ::std::string& value);
  inline void set_next(const char* value);
  inline void set_next(const void* value, size_t size);
  inline ::std::string* mutable_next();
  inline ::std::string* release_next();
  inline void set_allocated_next(::std::string* next);

  // @@protoc_insertion_point(class_scope:fantasybit.LeaderBoardMeta)
 private:
  inline void set_has_week();
  inline void clear_has_week();
  inline void set_has_fnbalmetaroot();
  inline void clear_has_fnbalmetaroot();
  inline void set_has_prev();
  inline void clear_has_prev();
  inline void set_has_next();
  inline void clear_has_next();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* fnbalmetaroot_;
  ::std::string* prev_;
  ::std::string* next_;
  ::google::protobuf::uint32 week_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static LeaderBoardMeta* default_instance_;
};
// -------------------------------------------------------------------

class FantasyNameBalMeta : public ::google::protobuf::Message {
 public:
  FantasyNameBalMeta();
  virtual ~FantasyNameBalMeta();

  FantasyNameBalMeta(const FantasyNameBalMeta& from);

  inline FantasyNameBalMeta& operator=(const FantasyNameBalMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FantasyNameBalMeta& default_instance();

  void Swap(FantasyNameBalMeta* other);

  // implements Message ----------------------------------------------

  FantasyNameBalMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FantasyNameBalMeta& from);
  void MergeFrom(const FantasyNameBalMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes txmetaid = 10;
  inline bool has_txmetaid() const;
  inline void clear_txmetaid();
  static const int kTxmetaidFieldNumber = 10;
  inline const ::std::string& txmetaid() const;
  inline void set_txmetaid(const ::std::string& value);
  inline void set_txmetaid(const char* value);
  inline void set_txmetaid(const void* value, size_t size);
  inline ::std::string* mutable_txmetaid();
  inline ::std::string* release_txmetaid();
  inline void set_allocated_txmetaid(::std::string* txmetaid);

  // optional bytes trmetaid = 20;
  inline bool has_trmetaid() const;
  inline void clear_trmetaid();
  static const int kTrmetaidFieldNumber = 20;
  inline const ::std::string& trmetaid() const;
  inline void set_trmetaid(const ::std::string& value);
  inline void set_trmetaid(const char* value);
  inline void set_trmetaid(const void* value, size_t size);
  inline ::std::string* mutable_trmetaid();
  inline ::std::string* release_trmetaid();
  inline void set_allocated_trmetaid(::std::string* trmetaid);

  // optional string name = 25;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 25;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string public_key = 30;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 30;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const char* value, size_t size);
  inline ::std::string* mutable_public_key();
  inline ::std::string* release_public_key();
  inline void set_allocated_public_key(::std::string* public_key);

  // optional uint64 bits = 35;
  inline bool has_bits() const;
  inline void clear_bits();
  static const int kBitsFieldNumber = 35;
  inline ::google::protobuf::uint64 bits() const;
  inline void set_bits(::google::protobuf::uint64 value);

  // optional int64 stake = 40;
  inline bool has_stake() const;
  inline void clear_stake();
  static const int kStakeFieldNumber = 40;
  inline ::google::protobuf::int64 stake() const;
  inline void set_stake(::google::protobuf::int64 value);

  // optional bytes awardmetaroot = 50;
  inline bool has_awardmetaroot() const;
  inline void clear_awardmetaroot();
  static const int kAwardmetarootFieldNumber = 50;
  inline const ::std::string& awardmetaroot() const;
  inline void set_awardmetaroot(const ::std::string& value);
  inline void set_awardmetaroot(const char* value);
  inline void set_awardmetaroot(const void* value, size_t size);
  inline ::std::string* mutable_awardmetaroot();
  inline ::std::string* release_awardmetaroot();
  inline void set_allocated_awardmetaroot(::std::string* awardmetaroot);

  // optional bytes pnlmetaroot = 60;
  inline bool has_pnlmetaroot() const;
  inline void clear_pnlmetaroot();
  static const int kPnlmetarootFieldNumber = 60;
  inline const ::std::string& pnlmetaroot() const;
  inline void set_pnlmetaroot(const ::std::string& value);
  inline void set_pnlmetaroot(const char* value);
  inline void set_pnlmetaroot(const void* value, size_t size);
  inline ::std::string* mutable_pnlmetaroot();
  inline ::std::string* release_pnlmetaroot();
  inline void set_allocated_pnlmetaroot(::std::string* pnlmetaroot);

  // optional bytes prev = 70;
  inline bool has_prev() const;
  inline void clear_prev();
  static const int kPrevFieldNumber = 70;
  inline const ::std::string& prev() const;
  inline void set_prev(const ::std::string& value);
  inline void set_prev(const char* value);
  inline void set_prev(const void* value, size_t size);
  inline ::std::string* mutable_prev();
  inline ::std::string* release_prev();
  inline void set_allocated_prev(::std::string* prev);

  // optional bytes next = 80;
  inline bool has_next() const;
  inline void clear_next();
  static const int kNextFieldNumber = 80;
  inline const ::std::string& next() const;
  inline void set_next(const ::std::string& value);
  inline void set_next(const char* value);
  inline void set_next(const void* value, size_t size);
  inline ::std::string* mutable_next();
  inline ::std::string* release_next();
  inline void set_allocated_next(::std::string* next);

  // @@protoc_insertion_point(class_scope:fantasybit.FantasyNameBalMeta)
 private:
  inline void set_has_txmetaid();
  inline void clear_has_txmetaid();
  inline void set_has_trmetaid();
  inline void clear_has_trmetaid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_public_key();
  inline void clear_has_public_key();
  inline void set_has_bits();
  inline void clear_has_bits();
  inline void set_has_stake();
  inline void clear_has_stake();
  inline void set_has_awardmetaroot();
  inline void clear_has_awardmetaroot();
  inline void set_has_pnlmetaroot();
  inline void clear_has_pnlmetaroot();
  inline void set_has_prev();
  inline void clear_has_prev();
  inline void set_has_next();
  inline void clear_has_next();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* txmetaid_;
  ::std::string* trmetaid_;
  ::std::string* name_;
  ::std::string* public_key_;
  ::google::protobuf::uint64 bits_;
  ::google::protobuf::int64 stake_;
  ::std::string* awardmetaroot_;
  ::std::string* pnlmetaroot_;
  ::std::string* prev_;
  ::std::string* next_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static FantasyNameBalMeta* default_instance_;
};
// -------------------------------------------------------------------

class FantasyNameState : public ::google::protobuf::Message {
 public:
  FantasyNameState();
  virtual ~FantasyNameState();

  FantasyNameState(const FantasyNameState& from);

  inline FantasyNameState& operator=(const FantasyNameState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FantasyNameState& default_instance();

  void Swap(FantasyNameState* other);

  // implements Message ----------------------------------------------

  FantasyNameState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FantasyNameState& from);
  void MergeFrom(const FantasyNameState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bytes fantasynamebalmetaid = 10;
  inline bool has_fantasynamebalmetaid() const;
  inline void clear_fantasynamebalmetaid();
  static const int kFantasynamebalmetaidFieldNumber = 10;
  inline const ::std::string& fantasynamebalmetaid() const;
  inline void set_fantasynamebalmetaid(const ::std::string& value);
  inline void set_fantasynamebalmetaid(const char* value);
  inline void set_fantasynamebalmetaid(const void* value, size_t size);
  inline ::std::string* mutable_fantasynamebalmetaid();
  inline ::std::string* release_fantasynamebalmetaid();
  inline void set_allocated_fantasynamebalmetaid(::std::string* fantasynamebalmetaid);

  // optional bytes posmetaroot = 20;
  inline bool has_posmetaroot() const;
  inline void clear_posmetaroot();
  static const int kPosmetarootFieldNumber = 20;
  inline const ::std::string& posmetaroot() const;
  inline void set_posmetaroot(const ::std::string& value);
  inline void set_posmetaroot(const char* value);
  inline void set_posmetaroot(const void* value, size_t size);
  inline ::std::string* mutable_posmetaroot();
  inline ::std::string* release_posmetaroot();
  inline void set_allocated_posmetaroot(::std::string* posmetaroot);

  // optional bytes ordersmetaroot = 30;
  inline bool has_ordersmetaroot() const;
  inline void clear_ordersmetaroot();
  static const int kOrdersmetarootFieldNumber = 30;
  inline const ::std::string& ordersmetaroot() const;
  inline void set_ordersmetaroot(const ::std::string& value);
  inline void set_ordersmetaroot(const char* value);
  inline void set_ordersmetaroot(const void* value, size_t size);
  inline ::std::string* mutable_ordersmetaroot();
  inline ::std::string* release_ordersmetaroot();
  inline void set_allocated_ordersmetaroot(::std::string* ordersmetaroot);

  // optional bytes projmetaroot = 40;
  inline bool has_projmetaroot() const;
  inline void clear_projmetaroot();
  static const int kProjmetarootFieldNumber = 40;
  inline const ::std::string& projmetaroot() const;
  inline void set_projmetaroot(const ::std::string& value);
  inline void set_projmetaroot(const char* value);
  inline void set_projmetaroot(const void* value, size_t size);
  inline ::std::string* mutable_projmetaroot();
  inline ::std::string* release_projmetaroot();
  inline void set_allocated_projmetaroot(::std::string* projmetaroot);

  // optional bytes prev = 70;
  inline bool has_prev() const;
  inline void clear_prev();
  static const int kPrevFieldNumber = 70;
  inline const ::std::string& prev() const;
  inline void set_prev(const ::std::string& value);
  inline void set_prev(const char* value);
  inline void set_prev(const void* value, size_t size);
  inline ::std::string* mutable_prev();
  inline ::std::string* release_prev();
  inline void set_allocated_prev(::std::string* prev);

  // optional bytes next = 80;
  inline bool has_next() const;
  inline void clear_next();
  static const int kNextFieldNumber = 80;
  inline const ::std::string& next() const;
  inline void set_next(const ::std::string& value);
  inline void set_next(const char* value);
  inline void set_next(const void* value, size_t size);
  inline ::std::string* mutable_next();
  inline ::std::string* release_next();
  inline void set_allocated_next(::std::string* next);

  // optional bytes txmetaid = 50;
  inline bool has_txmetaid() const;
  inline void clear_txmetaid();
  static const int kTxmetaidFieldNumber = 50;
  inline const ::std::string& txmetaid() const;
  inline void set_txmetaid(const ::std::string& value);
  inline void set_txmetaid(const char* value);
  inline void set_txmetaid(const void* value, size_t size);
  inline ::std::string* mutable_txmetaid();
  inline ::std::string* release_txmetaid();
  inline void set_allocated_txmetaid(::std::string* txmetaid);

  // @@protoc_insertion_point(class_scope:fantasybit.FantasyNameState)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_fantasynamebalmetaid();
  inline void clear_has_fantasynamebalmetaid();
  inline void set_has_posmetaroot();
  inline void clear_has_posmetaroot();
  inline void set_has_ordersmetaroot();
  inline void clear_has_ordersmetaroot();
  inline void set_has_projmetaroot();
  inline void clear_has_projmetaroot();
  inline void set_has_prev();
  inline void clear_has_prev();
  inline void set_has_next();
  inline void clear_has_next();
  inline void set_has_txmetaid();
  inline void clear_has_txmetaid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* fantasynamebalmetaid_;
  ::std::string* posmetaroot_;
  ::std::string* ordersmetaroot_;
  ::std::string* projmetaroot_;
  ::std::string* prev_;
  ::std::string* next_;
  ::std::string* txmetaid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static FantasyNameState* default_instance_;
};
// -------------------------------------------------------------------

class WeekGameStatusMeta : public ::google::protobuf::Message {
 public:
  WeekGameStatusMeta();
  virtual ~WeekGameStatusMeta();

  WeekGameStatusMeta(const WeekGameStatusMeta& from);

  inline WeekGameStatusMeta& operator=(const WeekGameStatusMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WeekGameStatusMeta& default_instance();

  void Swap(WeekGameStatusMeta* other);

  // implements Message ----------------------------------------------

  WeekGameStatusMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WeekGameStatusMeta& from);
  void MergeFrom(const WeekGameStatusMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 week = 10;
  inline bool has_week() const;
  inline void clear_week();
  static const int kWeekFieldNumber = 10;
  inline ::google::protobuf::uint32 week() const;
  inline void set_week(::google::protobuf::uint32 value);

  // optional bytes gameresultmetaroot = 20;
  inline bool has_gameresultmetaroot() const;
  inline void clear_gameresultmetaroot();
  static const int kGameresultmetarootFieldNumber = 20;
  inline const ::std::string& gameresultmetaroot() const;
  inline void set_gameresultmetaroot(const ::std::string& value);
  inline void set_gameresultmetaroot(const char* value);
  inline void set_gameresultmetaroot(const void* value, size_t size);
  inline ::std::string* mutable_gameresultmetaroot();
  inline ::std::string* release_gameresultmetaroot();
  inline void set_allocated_gameresultmetaroot(::std::string* gameresultmetaroot);

  // optional bytes ingameprojmetaroot = 30;
  inline bool has_ingameprojmetaroot() const;
  inline void clear_ingameprojmetaroot();
  static const int kIngameprojmetarootFieldNumber = 30;
  inline const ::std::string& ingameprojmetaroot() const;
  inline void set_ingameprojmetaroot(const ::std::string& value);
  inline void set_ingameprojmetaroot(const char* value);
  inline void set_ingameprojmetaroot(const void* value, size_t size);
  inline ::std::string* mutable_ingameprojmetaroot();
  inline ::std::string* release_ingameprojmetaroot();
  inline void set_allocated_ingameprojmetaroot(::std::string* ingameprojmetaroot);

  // optional bytes opengamestatusroot = 40;
  inline bool has_opengamestatusroot() const;
  inline void clear_opengamestatusroot();
  static const int kOpengamestatusrootFieldNumber = 40;
  inline const ::std::string& opengamestatusroot() const;
  inline void set_opengamestatusroot(const ::std::string& value);
  inline void set_opengamestatusroot(const char* value);
  inline void set_opengamestatusroot(const void* value, size_t size);
  inline ::std::string* mutable_opengamestatusroot();
  inline ::std::string* release_opengamestatusroot();
  inline void set_allocated_opengamestatusroot(::std::string* opengamestatusroot);

  // optional bytes prev = 50;
  inline bool has_prev() const;
  inline void clear_prev();
  static const int kPrevFieldNumber = 50;
  inline const ::std::string& prev() const;
  inline void set_prev(const ::std::string& value);
  inline void set_prev(const char* value);
  inline void set_prev(const void* value, size_t size);
  inline ::std::string* mutable_prev();
  inline ::std::string* release_prev();
  inline void set_allocated_prev(::std::string* prev);

  // optional bytes next = 60;
  inline bool has_next() const;
  inline void clear_next();
  static const int kNextFieldNumber = 60;
  inline const ::std::string& next() const;
  inline void set_next(const ::std::string& value);
  inline void set_next(const char* value);
  inline void set_next(const void* value, size_t size);
  inline ::std::string* mutable_next();
  inline ::std::string* release_next();
  inline void set_allocated_next(::std::string* next);

  // @@protoc_insertion_point(class_scope:fantasybit.WeekGameStatusMeta)
 private:
  inline void set_has_week();
  inline void clear_has_week();
  inline void set_has_gameresultmetaroot();
  inline void clear_has_gameresultmetaroot();
  inline void set_has_ingameprojmetaroot();
  inline void clear_has_ingameprojmetaroot();
  inline void set_has_opengamestatusroot();
  inline void clear_has_opengamestatusroot();
  inline void set_has_prev();
  inline void clear_has_prev();
  inline void set_has_next();
  inline void clear_has_next();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* gameresultmetaroot_;
  ::std::string* ingameprojmetaroot_;
  ::std::string* opengamestatusroot_;
  ::std::string* prev_;
  ::std::string* next_;
  ::google::protobuf::uint32 week_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static WeekGameStatusMeta* default_instance_;
};
// -------------------------------------------------------------------

class InGameProjMeta : public ::google::protobuf::Message {
 public:
  InGameProjMeta();
  virtual ~InGameProjMeta();

  InGameProjMeta(const InGameProjMeta& from);

  inline InGameProjMeta& operator=(const InGameProjMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InGameProjMeta& default_instance();

  void Swap(InGameProjMeta* other);

  // implements Message ----------------------------------------------

  InGameProjMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InGameProjMeta& from);
  void MergeFrom(const InGameProjMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string gameid = 20;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameidFieldNumber = 20;
  inline const ::std::string& gameid() const;
  inline void set_gameid(const ::std::string& value);
  inline void set_gameid(const char* value);
  inline void set_gameid(const char* value, size_t size);
  inline ::std::string* mutable_gameid();
  inline ::std::string* release_gameid();
  inline void set_allocated_gameid(::std::string* gameid);

  // optional bytes gamestatusmetaid = 40;
  inline bool has_gamestatusmetaid() const;
  inline void clear_gamestatusmetaid();
  static const int kGamestatusmetaidFieldNumber = 40;
  inline const ::std::string& gamestatusmetaid() const;
  inline void set_gamestatusmetaid(const ::std::string& value);
  inline void set_gamestatusmetaid(const char* value);
  inline void set_gamestatusmetaid(const void* value, size_t size);
  inline ::std::string* mutable_gamestatusmetaid();
  inline ::std::string* release_gamestatusmetaid();
  inline void set_allocated_gamestatusmetaid(::std::string* gamestatusmetaid);

  // optional bytes homeprojmeta = 60;
  inline bool has_homeprojmeta() const;
  inline void clear_homeprojmeta();
  static const int kHomeprojmetaFieldNumber = 60;
  inline const ::std::string& homeprojmeta() const;
  inline void set_homeprojmeta(const ::std::string& value);
  inline void set_homeprojmeta(const char* value);
  inline void set_homeprojmeta(const void* value, size_t size);
  inline ::std::string* mutable_homeprojmeta();
  inline ::std::string* release_homeprojmeta();
  inline void set_allocated_homeprojmeta(::std::string* homeprojmeta);

  // optional bytes awayprojmeta = 70;
  inline bool has_awayprojmeta() const;
  inline void clear_awayprojmeta();
  static const int kAwayprojmetaFieldNumber = 70;
  inline const ::std::string& awayprojmeta() const;
  inline void set_awayprojmeta(const ::std::string& value);
  inline void set_awayprojmeta(const char* value);
  inline void set_awayprojmeta(const void* value, size_t size);
  inline ::std::string* mutable_awayprojmeta();
  inline ::std::string* release_awayprojmeta();
  inline void set_allocated_awayprojmeta(::std::string* awayprojmeta);

  // optional bytes gamedatametaid = 50;
  inline bool has_gamedatametaid() const;
  inline void clear_gamedatametaid();
  static const int kGamedatametaidFieldNumber = 50;
  inline const ::std::string& gamedatametaid() const;
  inline void set_gamedatametaid(const ::std::string& value);
  inline void set_gamedatametaid(const char* value);
  inline void set_gamedatametaid(const void* value, size_t size);
  inline ::std::string* mutable_gamedatametaid();
  inline ::std::string* release_gamedatametaid();
  inline void set_allocated_gamedatametaid(::std::string* gamedatametaid);

  // @@protoc_insertion_point(class_scope:fantasybit.InGameProjMeta)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gamestatusmetaid();
  inline void clear_has_gamestatusmetaid();
  inline void set_has_homeprojmeta();
  inline void clear_has_homeprojmeta();
  inline void set_has_awayprojmeta();
  inline void clear_has_awayprojmeta();
  inline void set_has_gamedatametaid();
  inline void clear_has_gamedatametaid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* gameid_;
  ::std::string* gamestatusmetaid_;
  ::std::string* homeprojmeta_;
  ::std::string* awayprojmeta_;
  ::std::string* gamedatametaid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static InGameProjMeta* default_instance_;
};
// -------------------------------------------------------------------

class GameResultsMeta : public ::google::protobuf::Message {
 public:
  GameResultsMeta();
  virtual ~GameResultsMeta();

  GameResultsMeta(const GameResultsMeta& from);

  inline GameResultsMeta& operator=(const GameResultsMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameResultsMeta& default_instance();

  void Swap(GameResultsMeta* other);

  // implements Message ----------------------------------------------

  GameResultsMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameResultsMeta& from);
  void MergeFrom(const GameResultsMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string gameid = 20;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameidFieldNumber = 20;
  inline const ::std::string& gameid() const;
  inline void set_gameid(const ::std::string& value);
  inline void set_gameid(const char* value);
  inline void set_gameid(const char* value, size_t size);
  inline ::std::string* mutable_gameid();
  inline ::std::string* release_gameid();
  inline void set_allocated_gameid(::std::string* gameid);

  // optional bytes gamestatusmetaid = 40;
  inline bool has_gamestatusmetaid() const;
  inline void clear_gamestatusmetaid();
  static const int kGamestatusmetaidFieldNumber = 40;
  inline const ::std::string& gamestatusmetaid() const;
  inline void set_gamestatusmetaid(const ::std::string& value);
  inline void set_gamestatusmetaid(const char* value);
  inline void set_gamestatusmetaid(const void* value, size_t size);
  inline ::std::string* mutable_gamestatusmetaid();
  inline ::std::string* release_gamestatusmetaid();
  inline void set_allocated_gamestatusmetaid(::std::string* gamestatusmetaid);

  // optional bytes homeresultmeta = 60;
  inline bool has_homeresultmeta() const;
  inline void clear_homeresultmeta();
  static const int kHomeresultmetaFieldNumber = 60;
  inline const ::std::string& homeresultmeta() const;
  inline void set_homeresultmeta(const ::std::string& value);
  inline void set_homeresultmeta(const char* value);
  inline void set_homeresultmeta(const void* value, size_t size);
  inline ::std::string* mutable_homeresultmeta();
  inline ::std::string* release_homeresultmeta();
  inline void set_allocated_homeresultmeta(::std::string* homeresultmeta);

  // optional bytes awayresultmeta = 70;
  inline bool has_awayresultmeta() const;
  inline void clear_awayresultmeta();
  static const int kAwayresultmetaFieldNumber = 70;
  inline const ::std::string& awayresultmeta() const;
  inline void set_awayresultmeta(const ::std::string& value);
  inline void set_awayresultmeta(const char* value);
  inline void set_awayresultmeta(const void* value, size_t size);
  inline ::std::string* mutable_awayresultmeta();
  inline ::std::string* release_awayresultmeta();
  inline void set_allocated_awayresultmeta(::std::string* awayresultmeta);

  // optional bytes resultdatametaid = 50;
  inline bool has_resultdatametaid() const;
  inline void clear_resultdatametaid();
  static const int kResultdatametaidFieldNumber = 50;
  inline const ::std::string& resultdatametaid() const;
  inline void set_resultdatametaid(const ::std::string& value);
  inline void set_resultdatametaid(const char* value);
  inline void set_resultdatametaid(const void* value, size_t size);
  inline ::std::string* mutable_resultdatametaid();
  inline ::std::string* release_resultdatametaid();
  inline void set_allocated_resultdatametaid(::std::string* resultdatametaid);

  // @@protoc_insertion_point(class_scope:fantasybit.GameResultsMeta)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gamestatusmetaid();
  inline void clear_has_gamestatusmetaid();
  inline void set_has_homeresultmeta();
  inline void clear_has_homeresultmeta();
  inline void set_has_awayresultmeta();
  inline void clear_has_awayresultmeta();
  inline void set_has_resultdatametaid();
  inline void clear_has_resultdatametaid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* gameid_;
  ::std::string* gamestatusmetaid_;
  ::std::string* homeresultmeta_;
  ::std::string* awayresultmeta_;
  ::std::string* resultdatametaid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static GameResultsMeta* default_instance_;
};
// -------------------------------------------------------------------

class GameStatusMeta : public ::google::protobuf::Message {
 public:
  GameStatusMeta();
  virtual ~GameStatusMeta();

  GameStatusMeta(const GameStatusMeta& from);

  inline GameStatusMeta& operator=(const GameStatusMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameStatusMeta& default_instance();

  void Swap(GameStatusMeta* other);

  // implements Message ----------------------------------------------

  GameStatusMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameStatusMeta& from);
  void MergeFrom(const GameStatusMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional int32 week = 2;
  inline bool has_week() const;
  inline void clear_week();
  static const int kWeekFieldNumber = 2;
  inline ::google::protobuf::int32 week() const;
  inline void set_week(::google::protobuf::int32 value);

  // optional .fantasybit.GameInfo gameinfo = 10;
  inline bool has_gameinfo() const;
  inline void clear_gameinfo();
  static const int kGameinfoFieldNumber = 10;
  inline const ::fantasybit::GameInfo& gameinfo() const;
  inline ::fantasybit::GameInfo* mutable_gameinfo();
  inline ::fantasybit::GameInfo* release_gameinfo();
  inline void set_allocated_gameinfo(::fantasybit::GameInfo* gameinfo);

  // optional .fantasybit.GameStatus gamesatus = 20;
  inline bool has_gamesatus() const;
  inline void clear_gamesatus();
  static const int kGamesatusFieldNumber = 20;
  inline const ::fantasybit::GameStatus& gamesatus() const;
  inline ::fantasybit::GameStatus* mutable_gamesatus();
  inline ::fantasybit::GameStatus* release_gamesatus();
  inline void set_allocated_gamesatus(::fantasybit::GameStatus* gamesatus);

  // optional bytes gamemetaid = 30;
  inline bool has_gamemetaid() const;
  inline void clear_gamemetaid();
  static const int kGamemetaidFieldNumber = 30;
  inline const ::std::string& gamemetaid() const;
  inline void set_gamemetaid(const ::std::string& value);
  inline void set_gamemetaid(const char* value);
  inline void set_gamemetaid(const void* value, size_t size);
  inline ::std::string* mutable_gamemetaid();
  inline ::std::string* release_gamemetaid();
  inline void set_allocated_gamemetaid(::std::string* gamemetaid);

  // optional bytes datametaid = 40;
  inline bool has_datametaid() const;
  inline void clear_datametaid();
  static const int kDatametaidFieldNumber = 40;
  inline const ::std::string& datametaid() const;
  inline void set_datametaid(const ::std::string& value);
  inline void set_datametaid(const char* value);
  inline void set_datametaid(const void* value, size_t size);
  inline ::std::string* mutable_datametaid();
  inline ::std::string* release_datametaid();
  inline void set_allocated_datametaid(::std::string* datametaid);

  // optional bytes prev = 50;
  inline bool has_prev() const;
  inline void clear_prev();
  static const int kPrevFieldNumber = 50;
  inline const ::std::string& prev() const;
  inline void set_prev(const ::std::string& value);
  inline void set_prev(const char* value);
  inline void set_prev(const void* value, size_t size);
  inline ::std::string* mutable_prev();
  inline ::std::string* release_prev();
  inline void set_allocated_prev(::std::string* prev);

  // optional bytes next = 60;
  inline bool has_next() const;
  inline void clear_next();
  static const int kNextFieldNumber = 60;
  inline const ::std::string& next() const;
  inline void set_next(const ::std::string& value);
  inline void set_next(const char* value);
  inline void set_next(const void* value, size_t size);
  inline ::std::string* mutable_next();
  inline ::std::string* release_next();
  inline void set_allocated_next(::std::string* next);

  // @@protoc_insertion_point(class_scope:fantasybit.GameStatusMeta)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_week();
  inline void clear_has_week();
  inline void set_has_gameinfo();
  inline void clear_has_gameinfo();
  inline void set_has_gamesatus();
  inline void clear_has_gamesatus();
  inline void set_has_gamemetaid();
  inline void clear_has_gamemetaid();
  inline void set_has_datametaid();
  inline void clear_has_datametaid();
  inline void set_has_prev();
  inline void clear_has_prev();
  inline void set_has_next();
  inline void clear_has_next();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::fantasybit::GameInfo* gameinfo_;
  ::fantasybit::GameStatus* gamesatus_;
  ::std::string* gamemetaid_;
  ::std::string* datametaid_;
  ::std::string* prev_;
  ::std::string* next_;
  ::google::protobuf::int32 week_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static GameStatusMeta* default_instance_;
};
// -------------------------------------------------------------------

class TeamProjMeta : public ::google::protobuf::Message {
 public:
  TeamProjMeta();
  virtual ~TeamProjMeta();

  TeamProjMeta(const TeamProjMeta& from);

  inline TeamProjMeta& operator=(const TeamProjMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TeamProjMeta& default_instance();

  void Swap(TeamProjMeta* other);

  // implements Message ----------------------------------------------

  TeamProjMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TeamProjMeta& from);
  void MergeFrom(const TeamProjMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string gameid = 20;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameidFieldNumber = 20;
  inline const ::std::string& gameid() const;
  inline void set_gameid(const ::std::string& value);
  inline void set_gameid(const char* value);
  inline void set_gameid(const char* value, size_t size);
  inline ::std::string* mutable_gameid();
  inline ::std::string* release_gameid();
  inline void set_allocated_gameid(::std::string* gameid);

  // optional string team = 30;
  inline bool has_team() const;
  inline void clear_team();
  static const int kTeamFieldNumber = 30;
  inline const ::std::string& team() const;
  inline void set_team(const ::std::string& value);
  inline void set_team(const char* value);
  inline void set_team(const char* value, size_t size);
  inline ::std::string* mutable_team();
  inline ::std::string* release_team();
  inline void set_allocated_team(::std::string* team);

  // optional uint32 kickofftime = 40;
  inline bool has_kickofftime() const;
  inline void clear_kickofftime();
  static const int kKickofftimeFieldNumber = 40;
  inline ::google::protobuf::uint32 kickofftime() const;
  inline void set_kickofftime(::google::protobuf::uint32 value);

  // optional uint32 week = 50;
  inline bool has_week() const;
  inline void clear_week();
  static const int kWeekFieldNumber = 50;
  inline ::google::protobuf::uint32 week() const;
  inline void set_week(::google::protobuf::uint32 value);

  // optional bytes gameplayerprojmetaroot = 60;
  inline bool has_gameplayerprojmetaroot() const;
  inline void clear_gameplayerprojmetaroot();
  static const int kGameplayerprojmetarootFieldNumber = 60;
  inline const ::std::string& gameplayerprojmetaroot() const;
  inline void set_gameplayerprojmetaroot(const ::std::string& value);
  inline void set_gameplayerprojmetaroot(const char* value);
  inline void set_gameplayerprojmetaroot(const void* value, size_t size);
  inline ::std::string* mutable_gameplayerprojmetaroot();
  inline ::std::string* release_gameplayerprojmetaroot();
  inline void set_allocated_gameplayerprojmetaroot(::std::string* gameplayerprojmetaroot);

  // optional bytes gamedatametaid = 70;
  inline bool has_gamedatametaid() const;
  inline void clear_gamedatametaid();
  static const int kGamedatametaidFieldNumber = 70;
  inline const ::std::string& gamedatametaid() const;
  inline void set_gamedatametaid(const ::std::string& value);
  inline void set_gamedatametaid(const char* value);
  inline void set_gamedatametaid(const void* value, size_t size);
  inline ::std::string* mutable_gamedatametaid();
  inline ::std::string* release_gamedatametaid();
  inline void set_allocated_gamedatametaid(::std::string* gamedatametaid);

  // @@protoc_insertion_point(class_scope:fantasybit.TeamProjMeta)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_team();
  inline void clear_has_team();
  inline void set_has_kickofftime();
  inline void clear_has_kickofftime();
  inline void set_has_week();
  inline void clear_has_week();
  inline void set_has_gameplayerprojmetaroot();
  inline void clear_has_gameplayerprojmetaroot();
  inline void set_has_gamedatametaid();
  inline void clear_has_gamedatametaid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* gameid_;
  ::std::string* team_;
  ::google::protobuf::uint32 kickofftime_;
  ::google::protobuf::uint32 week_;
  ::std::string* gameplayerprojmetaroot_;
  ::std::string* gamedatametaid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static TeamProjMeta* default_instance_;
};
// -------------------------------------------------------------------

class TeamResultMeta : public ::google::protobuf::Message {
 public:
  TeamResultMeta();
  virtual ~TeamResultMeta();

  TeamResultMeta(const TeamResultMeta& from);

  inline TeamResultMeta& operator=(const TeamResultMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TeamResultMeta& default_instance();

  void Swap(TeamResultMeta* other);

  // implements Message ----------------------------------------------

  TeamResultMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TeamResultMeta& from);
  void MergeFrom(const TeamResultMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string gameid = 20;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameidFieldNumber = 20;
  inline const ::std::string& gameid() const;
  inline void set_gameid(const ::std::string& value);
  inline void set_gameid(const char* value);
  inline void set_gameid(const char* value, size_t size);
  inline ::std::string* mutable_gameid();
  inline ::std::string* release_gameid();
  inline void set_allocated_gameid(::std::string* gameid);

  // optional string team = 30;
  inline bool has_team() const;
  inline void clear_team();
  static const int kTeamFieldNumber = 30;
  inline const ::std::string& team() const;
  inline void set_team(const ::std::string& value);
  inline void set_team(const char* value);
  inline void set_team(const char* value, size_t size);
  inline ::std::string* mutable_team();
  inline ::std::string* release_team();
  inline void set_allocated_team(::std::string* team);

  // optional uint32 kickofftime = 40;
  inline bool has_kickofftime() const;
  inline void clear_kickofftime();
  static const int kKickofftimeFieldNumber = 40;
  inline ::google::protobuf::uint32 kickofftime() const;
  inline void set_kickofftime(::google::protobuf::uint32 value);

  // optional uint32 week = 50;
  inline bool has_week() const;
  inline void clear_week();
  static const int kWeekFieldNumber = 50;
  inline ::google::protobuf::uint32 week() const;
  inline void set_week(::google::protobuf::uint32 value);

  // optional bytes playerresultmetaroot = 60;
  inline bool has_playerresultmetaroot() const;
  inline void clear_playerresultmetaroot();
  static const int kPlayerresultmetarootFieldNumber = 60;
  inline const ::std::string& playerresultmetaroot() const;
  inline void set_playerresultmetaroot(const ::std::string& value);
  inline void set_playerresultmetaroot(const char* value);
  inline void set_playerresultmetaroot(const void* value, size_t size);
  inline ::std::string* mutable_playerresultmetaroot();
  inline ::std::string* release_playerresultmetaroot();
  inline void set_allocated_playerresultmetaroot(::std::string* playerresultmetaroot);

  // optional bytes resultdatametaid = 70;
  inline bool has_resultdatametaid() const;
  inline void clear_resultdatametaid();
  static const int kResultdatametaidFieldNumber = 70;
  inline const ::std::string& resultdatametaid() const;
  inline void set_resultdatametaid(const ::std::string& value);
  inline void set_resultdatametaid(const char* value);
  inline void set_resultdatametaid(const void* value, size_t size);
  inline ::std::string* mutable_resultdatametaid();
  inline ::std::string* release_resultdatametaid();
  inline void set_allocated_resultdatametaid(::std::string* resultdatametaid);

  // @@protoc_insertion_point(class_scope:fantasybit.TeamResultMeta)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_team();
  inline void clear_has_team();
  inline void set_has_kickofftime();
  inline void clear_has_kickofftime();
  inline void set_has_week();
  inline void clear_has_week();
  inline void set_has_playerresultmetaroot();
  inline void clear_has_playerresultmetaroot();
  inline void set_has_resultdatametaid();
  inline void clear_has_resultdatametaid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* gameid_;
  ::std::string* team_;
  ::google::protobuf::uint32 kickofftime_;
  ::google::protobuf::uint32 week_;
  ::std::string* playerresultmetaroot_;
  ::std::string* resultdatametaid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static TeamResultMeta* default_instance_;
};
// -------------------------------------------------------------------

class GamePlayerProjMeta : public ::google::protobuf::Message {
 public:
  GamePlayerProjMeta();
  virtual ~GamePlayerProjMeta();

  GamePlayerProjMeta(const GamePlayerProjMeta& from);

  inline GamePlayerProjMeta& operator=(const GamePlayerProjMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GamePlayerProjMeta& default_instance();

  void Swap(GamePlayerProjMeta* other);

  // implements Message ----------------------------------------------

  GamePlayerProjMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GamePlayerProjMeta& from);
  void MergeFrom(const GamePlayerProjMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string playerid = 20;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 20;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  inline void set_allocated_playerid(::std::string* playerid);

  // optional bytes gamestatusmetaid = 30;
  inline bool has_gamestatusmetaid() const;
  inline void clear_gamestatusmetaid();
  static const int kGamestatusmetaidFieldNumber = 30;
  inline const ::std::string& gamestatusmetaid() const;
  inline void set_gamestatusmetaid(const ::std::string& value);
  inline void set_gamestatusmetaid(const char* value);
  inline void set_gamestatusmetaid(const void* value, size_t size);
  inline ::std::string* mutable_gamestatusmetaid();
  inline ::std::string* release_gamestatusmetaid();
  inline void set_allocated_gamestatusmetaid(::std::string* gamestatusmetaid);

  // optional bytes projmetaplayerroot = 60;
  inline bool has_projmetaplayerroot() const;
  inline void clear_projmetaplayerroot();
  static const int kProjmetaplayerrootFieldNumber = 60;
  inline const ::std::string& projmetaplayerroot() const;
  inline void set_projmetaplayerroot(const ::std::string& value);
  inline void set_projmetaplayerroot(const char* value);
  inline void set_projmetaplayerroot(const void* value, size_t size);
  inline ::std::string* mutable_projmetaplayerroot();
  inline ::std::string* release_projmetaplayerroot();
  inline void set_allocated_projmetaplayerroot(::std::string* projmetaplayerroot);

  // optional bytes posmetaplayerroot = 70;
  inline bool has_posmetaplayerroot() const;
  inline void clear_posmetaplayerroot();
  static const int kPosmetaplayerrootFieldNumber = 70;
  inline const ::std::string& posmetaplayerroot() const;
  inline void set_posmetaplayerroot(const ::std::string& value);
  inline void set_posmetaplayerroot(const char* value);
  inline void set_posmetaplayerroot(const void* value, size_t size);
  inline ::std::string* mutable_posmetaplayerroot();
  inline ::std::string* release_posmetaplayerroot();
  inline void set_allocated_posmetaplayerroot(::std::string* posmetaplayerroot);

  // optional bytes gamedatametaid = 80;
  inline bool has_gamedatametaid() const;
  inline void clear_gamedatametaid();
  static const int kGamedatametaidFieldNumber = 80;
  inline const ::std::string& gamedatametaid() const;
  inline void set_gamedatametaid(const ::std::string& value);
  inline void set_gamedatametaid(const char* value);
  inline void set_gamedatametaid(const void* value, size_t size);
  inline ::std::string* mutable_gamedatametaid();
  inline ::std::string* release_gamedatametaid();
  inline void set_allocated_gamedatametaid(::std::string* gamedatametaid);

  // @@protoc_insertion_point(class_scope:fantasybit.GamePlayerProjMeta)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_gamestatusmetaid();
  inline void clear_has_gamestatusmetaid();
  inline void set_has_projmetaplayerroot();
  inline void clear_has_projmetaplayerroot();
  inline void set_has_posmetaplayerroot();
  inline void clear_has_posmetaplayerroot();
  inline void set_has_gamedatametaid();
  inline void clear_has_gamedatametaid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* playerid_;
  ::std::string* gamestatusmetaid_;
  ::std::string* projmetaplayerroot_;
  ::std::string* posmetaplayerroot_;
  ::std::string* gamedatametaid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static GamePlayerProjMeta* default_instance_;
};
// -------------------------------------------------------------------

class ProjMeta : public ::google::protobuf::Message {
 public:
  ProjMeta();
  virtual ~ProjMeta();

  ProjMeta(const ProjMeta& from);

  inline ProjMeta& operator=(const ProjMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProjMeta& default_instance();

  void Swap(ProjMeta* other);

  // implements Message ----------------------------------------------

  ProjMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProjMeta& from);
  void MergeFrom(const ProjMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 10;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 10;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 proj = 20;
  inline bool has_proj() const;
  inline void clear_proj();
  static const int kProjFieldNumber = 20;
  inline ::google::protobuf::int32 proj() const;
  inline void set_proj(::google::protobuf::int32 value);

  // optional string playerid = 30;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 30;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  inline void set_allocated_playerid(::std::string* playerid);

  // optional bytes txmetaid = 40;
  inline bool has_txmetaid() const;
  inline void clear_txmetaid();
  static const int kTxmetaidFieldNumber = 40;
  inline const ::std::string& txmetaid() const;
  inline void set_txmetaid(const ::std::string& value);
  inline void set_txmetaid(const char* value);
  inline void set_txmetaid(const void* value, size_t size);
  inline ::std::string* mutable_txmetaid();
  inline ::std::string* release_txmetaid();
  inline void set_allocated_txmetaid(::std::string* txmetaid);

  // optional bytes prev = 50;
  inline bool has_prev() const;
  inline void clear_prev();
  static const int kPrevFieldNumber = 50;
  inline const ::std::string& prev() const;
  inline void set_prev(const ::std::string& value);
  inline void set_prev(const char* value);
  inline void set_prev(const void* value, size_t size);
  inline ::std::string* mutable_prev();
  inline ::std::string* release_prev();
  inline void set_allocated_prev(::std::string* prev);

  // @@protoc_insertion_point(class_scope:fantasybit.ProjMeta)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_proj();
  inline void clear_has_proj();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_txmetaid();
  inline void clear_has_txmetaid();
  inline void set_has_prev();
  inline void clear_has_prev();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* playerid_;
  ::std::string* txmetaid_;
  ::std::string* prev_;
  ::google::protobuf::int32 proj_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static ProjMeta* default_instance_;
};
// -------------------------------------------------------------------

class PosMeta : public ::google::protobuf::Message {
 public:
  PosMeta();
  virtual ~PosMeta();

  PosMeta(const PosMeta& from);

  inline PosMeta& operator=(const PosMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PosMeta& default_instance();

  void Swap(PosMeta* other);

  // implements Message ----------------------------------------------

  PosMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PosMeta& from);
  void MergeFrom(const PosMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 10;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 10;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 qty = 20;
  inline bool has_qty() const;
  inline void clear_qty();
  static const int kQtyFieldNumber = 20;
  inline ::google::protobuf::int32 qty() const;
  inline void set_qty(::google::protobuf::int32 value);

  // optional int32 price = 30;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 30;
  inline ::google::protobuf::int32 price() const;
  inline void set_price(::google::protobuf::int32 value);

  // optional string playerid = 40;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 40;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  inline void set_allocated_playerid(::std::string* playerid);

  // optional bytes txmetaid = 50;
  inline bool has_txmetaid() const;
  inline void clear_txmetaid();
  static const int kTxmetaidFieldNumber = 50;
  inline const ::std::string& txmetaid() const;
  inline void set_txmetaid(const ::std::string& value);
  inline void set_txmetaid(const char* value);
  inline void set_txmetaid(const void* value, size_t size);
  inline ::std::string* mutable_txmetaid();
  inline ::std::string* release_txmetaid();
  inline void set_allocated_txmetaid(::std::string* txmetaid);

  // optional bytes prev = 60;
  inline bool has_prev() const;
  inline void clear_prev();
  static const int kPrevFieldNumber = 60;
  inline const ::std::string& prev() const;
  inline void set_prev(const ::std::string& value);
  inline void set_prev(const char* value);
  inline void set_prev(const void* value, size_t size);
  inline ::std::string* mutable_prev();
  inline ::std::string* release_prev();
  inline void set_allocated_prev(::std::string* prev);

  // @@protoc_insertion_point(class_scope:fantasybit.PosMeta)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_qty();
  inline void clear_has_qty();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_txmetaid();
  inline void clear_has_txmetaid();
  inline void set_has_prev();
  inline void clear_has_prev();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::int32 qty_;
  ::google::protobuf::int32 price_;
  ::std::string* playerid_;
  ::std::string* txmetaid_;
  ::std::string* prev_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static PosMeta* default_instance_;
};
// -------------------------------------------------------------------

class PlayerResultMeta : public ::google::protobuf::Message {
 public:
  PlayerResultMeta();
  virtual ~PlayerResultMeta();

  PlayerResultMeta(const PlayerResultMeta& from);

  inline PlayerResultMeta& operator=(const PlayerResultMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerResultMeta& default_instance();

  void Swap(PlayerResultMeta* other);

  // implements Message ----------------------------------------------

  PlayerResultMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerResultMeta& from);
  void MergeFrom(const PlayerResultMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes playergamestatsid = 10;
  inline bool has_playergamestatsid() const;
  inline void clear_playergamestatsid();
  static const int kPlayergamestatsidFieldNumber = 10;
  inline const ::std::string& playergamestatsid() const;
  inline void set_playergamestatsid(const ::std::string& value);
  inline void set_playergamestatsid(const char* value);
  inline void set_playergamestatsid(const void* value, size_t size);
  inline ::std::string* mutable_playergamestatsid();
  inline ::std::string* release_playergamestatsid();
  inline void set_allocated_playergamestatsid(::std::string* playergamestatsid);

  // optional bytes gamestatusmetaid = 30;
  inline bool has_gamestatusmetaid() const;
  inline void clear_gamestatusmetaid();
  static const int kGamestatusmetaidFieldNumber = 30;
  inline const ::std::string& gamestatusmetaid() const;
  inline void set_gamestatusmetaid(const ::std::string& value);
  inline void set_gamestatusmetaid(const char* value);
  inline void set_gamestatusmetaid(const void* value, size_t size);
  inline ::std::string* mutable_gamestatusmetaid();
  inline ::std::string* release_gamestatusmetaid();
  inline void set_allocated_gamestatusmetaid(::std::string* gamestatusmetaid);

  // optional bytes awardmetaplayerroot = 60;
  inline bool has_awardmetaplayerroot() const;
  inline void clear_awardmetaplayerroot();
  static const int kAwardmetaplayerrootFieldNumber = 60;
  inline const ::std::string& awardmetaplayerroot() const;
  inline void set_awardmetaplayerroot(const ::std::string& value);
  inline void set_awardmetaplayerroot(const char* value);
  inline void set_awardmetaplayerroot(const void* value, size_t size);
  inline ::std::string* mutable_awardmetaplayerroot();
  inline ::std::string* release_awardmetaplayerroot();
  inline void set_allocated_awardmetaplayerroot(::std::string* awardmetaplayerroot);

  // optional bytes pnlmetaplayerroot = 70;
  inline bool has_pnlmetaplayerroot() const;
  inline void clear_pnlmetaplayerroot();
  static const int kPnlmetaplayerrootFieldNumber = 70;
  inline const ::std::string& pnlmetaplayerroot() const;
  inline void set_pnlmetaplayerroot(const ::std::string& value);
  inline void set_pnlmetaplayerroot(const char* value);
  inline void set_pnlmetaplayerroot(const void* value, size_t size);
  inline ::std::string* mutable_pnlmetaplayerroot();
  inline ::std::string* release_pnlmetaplayerroot();
  inline void set_allocated_pnlmetaplayerroot(::std::string* pnlmetaplayerroot);

  // optional bytes resultdatametaid = 80;
  inline bool has_resultdatametaid() const;
  inline void clear_resultdatametaid();
  static const int kResultdatametaidFieldNumber = 80;
  inline const ::std::string& resultdatametaid() const;
  inline void set_resultdatametaid(const ::std::string& value);
  inline void set_resultdatametaid(const char* value);
  inline void set_resultdatametaid(const void* value, size_t size);
  inline ::std::string* mutable_resultdatametaid();
  inline ::std::string* release_resultdatametaid();
  inline void set_allocated_resultdatametaid(::std::string* resultdatametaid);

  // @@protoc_insertion_point(class_scope:fantasybit.PlayerResultMeta)
 private:
  inline void set_has_playergamestatsid();
  inline void clear_has_playergamestatsid();
  inline void set_has_gamestatusmetaid();
  inline void clear_has_gamestatusmetaid();
  inline void set_has_awardmetaplayerroot();
  inline void clear_has_awardmetaplayerroot();
  inline void set_has_pnlmetaplayerroot();
  inline void clear_has_pnlmetaplayerroot();
  inline void set_has_resultdatametaid();
  inline void clear_has_resultdatametaid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* playergamestatsid_;
  ::std::string* gamestatusmetaid_;
  ::std::string* awardmetaplayerroot_;
  ::std::string* pnlmetaplayerroot_;
  ::std::string* resultdatametaid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static PlayerResultMeta* default_instance_;
};
// -------------------------------------------------------------------

class PlayerGameStats : public ::google::protobuf::Message {
 public:
  PlayerGameStats();
  virtual ~PlayerGameStats();

  PlayerGameStats(const PlayerGameStats& from);

  inline PlayerGameStats& operator=(const PlayerGameStats& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerGameStats& default_instance();

  void Swap(PlayerGameStats* other);

  // implements Message ----------------------------------------------

  PlayerGameStats* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerGameStats& from);
  void MergeFrom(const PlayerGameStats& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string playerid = 20;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 20;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  inline void set_allocated_playerid(::std::string* playerid);

  // optional float result = 40;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 40;
  inline float result() const;
  inline void set_result(float value);

  // optional .fantasybit.Stats stats = 50;
  inline bool has_stats() const;
  inline void clear_stats();
  static const int kStatsFieldNumber = 50;
  inline const ::fantasybit::Stats& stats() const;
  inline ::fantasybit::Stats* mutable_stats();
  inline ::fantasybit::Stats* release_stats();
  inline void set_allocated_stats(::fantasybit::Stats* stats);

  // optional string gameid = 60;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameidFieldNumber = 60;
  inline const ::std::string& gameid() const;
  inline void set_gameid(const ::std::string& value);
  inline void set_gameid(const char* value);
  inline void set_gameid(const char* value, size_t size);
  inline ::std::string* mutable_gameid();
  inline ::std::string* release_gameid();
  inline void set_allocated_gameid(::std::string* gameid);

  // @@protoc_insertion_point(class_scope:fantasybit.PlayerGameStats)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_stats();
  inline void clear_has_stats();
  inline void set_has_gameid();
  inline void clear_has_gameid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* playerid_;
  ::fantasybit::Stats* stats_;
  ::std::string* gameid_;
  float result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static PlayerGameStats* default_instance_;
};
// -------------------------------------------------------------------

class AwardMeta : public ::google::protobuf::Message {
 public:
  AwardMeta();
  virtual ~AwardMeta();

  AwardMeta(const AwardMeta& from);

  inline AwardMeta& operator=(const AwardMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AwardMeta& default_instance();

  void Swap(AwardMeta* other);

  // implements Message ----------------------------------------------

  AwardMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AwardMeta& from);
  void MergeFrom(const AwardMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 10;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 10;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 proj = 20;
  inline bool has_proj() const;
  inline void clear_proj();
  static const int kProjFieldNumber = 20;
  inline ::google::protobuf::int32 proj() const;
  inline void set_proj(::google::protobuf::int32 value);

  // optional uint64 award = 30;
  inline bool has_award() const;
  inline void clear_award();
  static const int kAwardFieldNumber = 30;
  inline ::google::protobuf::uint64 award() const;
  inline void set_award(::google::protobuf::uint64 value);

  // optional bytes projmetaid = 40;
  inline bool has_projmetaid() const;
  inline void clear_projmetaid();
  static const int kProjmetaidFieldNumber = 40;
  inline const ::std::string& projmetaid() const;
  inline void set_projmetaid(const ::std::string& value);
  inline void set_projmetaid(const char* value);
  inline void set_projmetaid(const void* value, size_t size);
  inline ::std::string* mutable_projmetaid();
  inline ::std::string* release_projmetaid();
  inline void set_allocated_projmetaid(::std::string* projmetaid);

  // optional bytes playergamestatsid = 50;
  inline bool has_playergamestatsid() const;
  inline void clear_playergamestatsid();
  static const int kPlayergamestatsidFieldNumber = 50;
  inline const ::std::string& playergamestatsid() const;
  inline void set_playergamestatsid(const ::std::string& value);
  inline void set_playergamestatsid(const char* value);
  inline void set_playergamestatsid(const void* value, size_t size);
  inline ::std::string* mutable_playergamestatsid();
  inline ::std::string* release_playergamestatsid();
  inline void set_allocated_playergamestatsid(::std::string* playergamestatsid);

  // @@protoc_insertion_point(class_scope:fantasybit.AwardMeta)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_proj();
  inline void clear_has_proj();
  inline void set_has_award();
  inline void clear_has_award();
  inline void set_has_projmetaid();
  inline void clear_has_projmetaid();
  inline void set_has_playergamestatsid();
  inline void clear_has_playergamestatsid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint64 award_;
  ::std::string* projmetaid_;
  ::std::string* playergamestatsid_;
  ::google::protobuf::int32 proj_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static AwardMeta* default_instance_;
};
// -------------------------------------------------------------------

class PnlMeta : public ::google::protobuf::Message {
 public:
  PnlMeta();
  virtual ~PnlMeta();

  PnlMeta(const PnlMeta& from);

  inline PnlMeta& operator=(const PnlMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PnlMeta& default_instance();

  void Swap(PnlMeta* other);

  // implements Message ----------------------------------------------

  PnlMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PnlMeta& from);
  void MergeFrom(const PnlMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 10;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 10;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 qty = 20;
  inline bool has_qty() const;
  inline void clear_qty();
  static const int kQtyFieldNumber = 20;
  inline ::google::protobuf::int32 qty() const;
  inline void set_qty(::google::protobuf::int32 value);

  // optional int32 price = 30;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 30;
  inline ::google::protobuf::int32 price() const;
  inline void set_price(::google::protobuf::int32 value);

  // optional int64 pnl = 40;
  inline bool has_pnl() const;
  inline void clear_pnl();
  static const int kPnlFieldNumber = 40;
  inline ::google::protobuf::int64 pnl() const;
  inline void set_pnl(::google::protobuf::int64 value);

  // optional bytes posmetaid = 50;
  inline bool has_posmetaid() const;
  inline void clear_posmetaid();
  static const int kPosmetaidFieldNumber = 50;
  inline const ::std::string& posmetaid() const;
  inline void set_posmetaid(const ::std::string& value);
  inline void set_posmetaid(const char* value);
  inline void set_posmetaid(const void* value, size_t size);
  inline ::std::string* mutable_posmetaid();
  inline ::std::string* release_posmetaid();
  inline void set_allocated_posmetaid(::std::string* posmetaid);

  // optional bytes playergamestatsid = 60;
  inline bool has_playergamestatsid() const;
  inline void clear_playergamestatsid();
  static const int kPlayergamestatsidFieldNumber = 60;
  inline const ::std::string& playergamestatsid() const;
  inline void set_playergamestatsid(const ::std::string& value);
  inline void set_playergamestatsid(const char* value);
  inline void set_playergamestatsid(const void* value, size_t size);
  inline ::std::string* mutable_playergamestatsid();
  inline ::std::string* release_playergamestatsid();
  inline void set_allocated_playergamestatsid(::std::string* playergamestatsid);

  // @@protoc_insertion_point(class_scope:fantasybit.PnlMeta)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_qty();
  inline void clear_has_qty();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_pnl();
  inline void clear_has_pnl();
  inline void set_has_posmetaid();
  inline void clear_has_posmetaid();
  inline void set_has_playergamestatsid();
  inline void clear_has_playergamestatsid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::int32 qty_;
  ::google::protobuf::int32 price_;
  ::google::protobuf::int64 pnl_;
  ::std::string* posmetaid_;
  ::std::string* playergamestatsid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static PnlMeta* default_instance_;
};
// -------------------------------------------------------------------

class PlayerMarketState : public ::google::protobuf::Message {
 public:
  PlayerMarketState();
  virtual ~PlayerMarketState();

  PlayerMarketState(const PlayerMarketState& from);

  inline PlayerMarketState& operator=(const PlayerMarketState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerMarketState& default_instance();

  void Swap(PlayerMarketState* other);

  // implements Message ----------------------------------------------

  PlayerMarketState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerMarketState& from);
  void MergeFrom(const PlayerMarketState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes limitbookmetaid = 10;
  inline bool has_limitbookmetaid() const;
  inline void clear_limitbookmetaid();
  static const int kLimitbookmetaidFieldNumber = 10;
  inline const ::std::string& limitbookmetaid() const;
  inline void set_limitbookmetaid(const ::std::string& value);
  inline void set_limitbookmetaid(const char* value);
  inline void set_limitbookmetaid(const void* value, size_t size);
  inline ::std::string* mutable_limitbookmetaid();
  inline ::std::string* release_limitbookmetaid();
  inline void set_allocated_limitbookmetaid(::std::string* limitbookmetaid);

  // optional string playerid = 20;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 20;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  inline void set_allocated_playerid(::std::string* playerid);

  // optional bytes marketticmetaid = 30;
  inline bool has_marketticmetaid() const;
  inline void clear_marketticmetaid();
  static const int kMarketticmetaidFieldNumber = 30;
  inline const ::std::string& marketticmetaid() const;
  inline void set_marketticmetaid(const ::std::string& value);
  inline void set_marketticmetaid(const char* value);
  inline void set_marketticmetaid(const void* value, size_t size);
  inline ::std::string* mutable_marketticmetaid();
  inline ::std::string* release_marketticmetaid();
  inline void set_allocated_marketticmetaid(::std::string* marketticmetaid);

  // optional bool locked = 31;
  inline bool has_locked() const;
  inline void clear_locked();
  static const int kLockedFieldNumber = 31;
  inline bool locked() const;
  inline void set_locked(bool value);

  // optional bytes prev = 40;
  inline bool has_prev() const;
  inline void clear_prev();
  static const int kPrevFieldNumber = 40;
  inline const ::std::string& prev() const;
  inline void set_prev(const ::std::string& value);
  inline void set_prev(const char* value);
  inline void set_prev(const void* value, size_t size);
  inline ::std::string* mutable_prev();
  inline ::std::string* release_prev();
  inline void set_allocated_prev(::std::string* prev);

  // optional bytes next = 50;
  inline bool has_next() const;
  inline void clear_next();
  static const int kNextFieldNumber = 50;
  inline const ::std::string& next() const;
  inline void set_next(const ::std::string& value);
  inline void set_next(const char* value);
  inline void set_next(const void* value, size_t size);
  inline ::std::string* mutable_next();
  inline ::std::string* release_next();
  inline void set_allocated_next(::std::string* next);

  // @@protoc_insertion_point(class_scope:fantasybit.PlayerMarketState)
 private:
  inline void set_has_limitbookmetaid();
  inline void clear_has_limitbookmetaid();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_marketticmetaid();
  inline void clear_has_marketticmetaid();
  inline void set_has_locked();
  inline void clear_has_locked();
  inline void set_has_prev();
  inline void clear_has_prev();
  inline void set_has_next();
  inline void clear_has_next();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* limitbookmetaid_;
  ::std::string* playerid_;
  ::std::string* marketticmetaid_;
  ::std::string* prev_;
  ::std::string* next_;
  bool locked_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static PlayerMarketState* default_instance_;
};
// -------------------------------------------------------------------

class LimitBookMeta : public ::google::protobuf::Message {
 public:
  LimitBookMeta();
  virtual ~LimitBookMeta();

  LimitBookMeta(const LimitBookMeta& from);

  inline LimitBookMeta& operator=(const LimitBookMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LimitBookMeta& default_instance();

  void Swap(LimitBookMeta* other);

  // implements Message ----------------------------------------------

  LimitBookMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LimitBookMeta& from);
  void MergeFrom(const LimitBookMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 bid = 10;
  inline bool has_bid() const;
  inline void clear_bid();
  static const int kBidFieldNumber = 10;
  inline ::google::protobuf::int32 bid() const;
  inline void set_bid(::google::protobuf::int32 value);

  // optional int32 bidsize = 20;
  inline bool has_bidsize() const;
  inline void clear_bidsize();
  static const int kBidsizeFieldNumber = 20;
  inline ::google::protobuf::int32 bidsize() const;
  inline void set_bidsize(::google::protobuf::int32 value);

  // optional int32 asksize = 30;
  inline bool has_asksize() const;
  inline void clear_asksize();
  static const int kAsksizeFieldNumber = 30;
  inline ::google::protobuf::int32 asksize() const;
  inline void set_asksize(::google::protobuf::int32 value);

  // optional int32 ask = 40;
  inline bool has_ask() const;
  inline void clear_ask();
  static const int kAskFieldNumber = 40;
  inline ::google::protobuf::int32 ask() const;
  inline void set_ask(::google::protobuf::int32 value);

  // optional bytes bidordermetaroot = 50;
  inline bool has_bidordermetaroot() const;
  inline void clear_bidordermetaroot();
  static const int kBidordermetarootFieldNumber = 50;
  inline const ::std::string& bidordermetaroot() const;
  inline void set_bidordermetaroot(const ::std::string& value);
  inline void set_bidordermetaroot(const char* value);
  inline void set_bidordermetaroot(const void* value, size_t size);
  inline ::std::string* mutable_bidordermetaroot();
  inline ::std::string* release_bidordermetaroot();
  inline void set_allocated_bidordermetaroot(::std::string* bidordermetaroot);

  // optional bytes askordermetaroot = 60;
  inline bool has_askordermetaroot() const;
  inline void clear_askordermetaroot();
  static const int kAskordermetarootFieldNumber = 60;
  inline const ::std::string& askordermetaroot() const;
  inline void set_askordermetaroot(const ::std::string& value);
  inline void set_askordermetaroot(const char* value);
  inline void set_askordermetaroot(const void* value, size_t size);
  inline ::std::string* mutable_askordermetaroot();
  inline ::std::string* release_askordermetaroot();
  inline void set_allocated_askordermetaroot(::std::string* askordermetaroot);

  // @@protoc_insertion_point(class_scope:fantasybit.LimitBookMeta)
 private:
  inline void set_has_bid();
  inline void clear_has_bid();
  inline void set_has_bidsize();
  inline void clear_has_bidsize();
  inline void set_has_asksize();
  inline void clear_has_asksize();
  inline void set_has_ask();
  inline void clear_has_ask();
  inline void set_has_bidordermetaroot();
  inline void clear_has_bidordermetaroot();
  inline void set_has_askordermetaroot();
  inline void clear_has_askordermetaroot();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 bid_;
  ::google::protobuf::int32 bidsize_;
  ::google::protobuf::int32 asksize_;
  ::google::protobuf::int32 ask_;
  ::std::string* bidordermetaroot_;
  ::std::string* askordermetaroot_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static LimitBookMeta* default_instance_;
};
// -------------------------------------------------------------------

class MarketTicMeta : public ::google::protobuf::Message {
 public:
  MarketTicMeta();
  virtual ~MarketTicMeta();

  MarketTicMeta(const MarketTicMeta& from);

  inline MarketTicMeta& operator=(const MarketTicMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketTicMeta& default_instance();

  void Swap(MarketTicMeta* other);

  // implements Message ----------------------------------------------

  MarketTicMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MarketTicMeta& from);
  void MergeFrom(const MarketTicMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 price = 20;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 20;
  inline ::google::protobuf::int32 price() const;
  inline void set_price(::google::protobuf::int32 value);

  // optional int32 size = 30;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 30;
  inline ::google::protobuf::int32 size() const;
  inline void set_size(::google::protobuf::int32 value);

  // optional bytes orderfillhead = 40;
  inline bool has_orderfillhead() const;
  inline void clear_orderfillhead();
  static const int kOrderfillheadFieldNumber = 40;
  inline const ::std::string& orderfillhead() const;
  inline void set_orderfillhead(const ::std::string& value);
  inline void set_orderfillhead(const char* value);
  inline void set_orderfillhead(const void* value, size_t size);
  inline ::std::string* mutable_orderfillhead();
  inline ::std::string* release_orderfillhead();
  inline void set_allocated_orderfillhead(::std::string* orderfillhead);

  // optional bytes prev = 50;
  inline bool has_prev() const;
  inline void clear_prev();
  static const int kPrevFieldNumber = 50;
  inline const ::std::string& prev() const;
  inline void set_prev(const ::std::string& value);
  inline void set_prev(const char* value);
  inline void set_prev(const void* value, size_t size);
  inline ::std::string* mutable_prev();
  inline ::std::string* release_prev();
  inline void set_allocated_prev(::std::string* prev);

  // @@protoc_insertion_point(class_scope:fantasybit.MarketTicMeta)
 private:
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_orderfillhead();
  inline void clear_has_orderfillhead();
  inline void set_has_prev();
  inline void clear_has_prev();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 price_;
  ::google::protobuf::int32 size_;
  ::std::string* orderfillhead_;
  ::std::string* prev_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static MarketTicMeta* default_instance_;
};
// -------------------------------------------------------------------

class OrderMeta : public ::google::protobuf::Message {
 public:
  OrderMeta();
  virtual ~OrderMeta();

  OrderMeta(const OrderMeta& from);

  inline OrderMeta& operator=(const OrderMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OrderMeta& default_instance();

  void Swap(OrderMeta* other);

  // implements Message ----------------------------------------------

  OrderMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OrderMeta& from);
  void MergeFrom(const OrderMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 refnum = 1;
  inline bool has_refnum() const;
  inline void clear_refnum();
  static const int kRefnumFieldNumber = 1;
  inline ::google::protobuf::int32 refnum() const;
  inline void set_refnum(::google::protobuf::int32 value);

  // optional string fname = 10;
  inline bool has_fname() const;
  inline void clear_fname();
  static const int kFnameFieldNumber = 10;
  inline const ::std::string& fname() const;
  inline void set_fname(const ::std::string& value);
  inline void set_fname(const char* value);
  inline void set_fname(const char* value, size_t size);
  inline ::std::string* mutable_fname();
  inline ::std::string* release_fname();
  inline void set_allocated_fname(::std::string* fname);

  // optional string playerid = 20;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 20;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  inline void set_allocated_playerid(::std::string* playerid);

  // optional bool buyside = 30;
  inline bool has_buyside() const;
  inline void clear_buyside();
  static const int kBuysideFieldNumber = 30;
  inline bool buyside() const;
  inline void set_buyside(bool value);

  // optional int32 size = 40;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 40;
  inline ::google::protobuf::int32 size() const;
  inline void set_size(::google::protobuf::int32 value);

  // optional int32 price = 50;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 50;
  inline ::google::protobuf::int32 price() const;
  inline void set_price(::google::protobuf::int32 value);

  // optional bytes txmetaid = 60;
  inline bool has_txmetaid() const;
  inline void clear_txmetaid();
  static const int kTxmetaidFieldNumber = 60;
  inline const ::std::string& txmetaid() const;
  inline void set_txmetaid(const ::std::string& value);
  inline void set_txmetaid(const char* value);
  inline void set_txmetaid(const void* value, size_t size);
  inline ::std::string* mutable_txmetaid();
  inline ::std::string* release_txmetaid();
  inline void set_allocated_txmetaid(::std::string* txmetaid);

  // optional bytes orderfillmetaid = 70;
  inline bool has_orderfillmetaid() const;
  inline void clear_orderfillmetaid();
  static const int kOrderfillmetaidFieldNumber = 70;
  inline const ::std::string& orderfillmetaid() const;
  inline void set_orderfillmetaid(const ::std::string& value);
  inline void set_orderfillmetaid(const char* value);
  inline void set_orderfillmetaid(const void* value, size_t size);
  inline ::std::string* mutable_orderfillmetaid();
  inline ::std::string* release_orderfillmetaid();
  inline void set_allocated_orderfillmetaid(::std::string* orderfillmetaid);

  // optional int32 timestamp = 75;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 75;
  inline ::google::protobuf::int32 timestamp() const;
  inline void set_timestamp(::google::protobuf::int32 value);

  // optional bytes prev = 80;
  inline bool has_prev() const;
  inline void clear_prev();
  static const int kPrevFieldNumber = 80;
  inline const ::std::string& prev() const;
  inline void set_prev(const ::std::string& value);
  inline void set_prev(const char* value);
  inline void set_prev(const void* value, size_t size);
  inline ::std::string* mutable_prev();
  inline ::std::string* release_prev();
  inline void set_allocated_prev(::std::string* prev);

  // @@protoc_insertion_point(class_scope:fantasybit.OrderMeta)
 private:
  inline void set_has_refnum();
  inline void clear_has_refnum();
  inline void set_has_fname();
  inline void clear_has_fname();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_buyside();
  inline void clear_has_buyside();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_txmetaid();
  inline void clear_has_txmetaid();
  inline void set_has_orderfillmetaid();
  inline void clear_has_orderfillmetaid();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_prev();
  inline void clear_has_prev();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* fname_;
  ::google::protobuf::int32 refnum_;
  bool buyside_;
  ::std::string* playerid_;
  ::google::protobuf::int32 size_;
  ::google::protobuf::int32 price_;
  ::std::string* txmetaid_;
  ::std::string* orderfillmetaid_;
  ::std::string* prev_;
  ::google::protobuf::int32 timestamp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static OrderMeta* default_instance_;
};
// -------------------------------------------------------------------

class OrderFillMeta : public ::google::protobuf::Message {
 public:
  OrderFillMeta();
  virtual ~OrderFillMeta();

  OrderFillMeta(const OrderFillMeta& from);

  inline OrderFillMeta& operator=(const OrderFillMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OrderFillMeta& default_instance();

  void Swap(OrderFillMeta* other);

  // implements Message ----------------------------------------------

  OrderFillMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OrderFillMeta& from);
  void MergeFrom(const OrderFillMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 refnum = 1;
  inline bool has_refnum() const;
  inline void clear_refnum();
  static const int kRefnumFieldNumber = 1;
  inline ::google::protobuf::int32 refnum() const;
  inline void set_refnum(::google::protobuf::int32 value);

  // optional string fname = 10;
  inline bool has_fname() const;
  inline void clear_fname();
  static const int kFnameFieldNumber = 10;
  inline const ::std::string& fname() const;
  inline void set_fname(const ::std::string& value);
  inline void set_fname(const char* value);
  inline void set_fname(const char* value, size_t size);
  inline ::std::string* mutable_fname();
  inline ::std::string* release_fname();
  inline void set_allocated_fname(::std::string* fname);

  // optional string playerid = 15;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 15;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  inline void set_allocated_playerid(::std::string* playerid);

  // optional int32 fillprice = 20;
  inline bool has_fillprice() const;
  inline void clear_fillprice();
  static const int kFillpriceFieldNumber = 20;
  inline ::google::protobuf::int32 fillprice() const;
  inline void set_fillprice(::google::protobuf::int32 value);

  // optional int32 fillsize = 30;
  inline bool has_fillsize() const;
  inline void clear_fillsize();
  static const int kFillsizeFieldNumber = 30;
  inline ::google::protobuf::int32 fillsize() const;
  inline void set_fillsize(::google::protobuf::int32 value);

  // optional bool buyside = 35;
  inline bool has_buyside() const;
  inline void clear_buyside();
  static const int kBuysideFieldNumber = 35;
  inline bool buyside() const;
  inline void set_buyside(bool value);

  // optional int32 timestamp = 40;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 40;
  inline ::google::protobuf::int32 timestamp() const;
  inline void set_timestamp(::google::protobuf::int32 value);

  // optional bytes txmetaid = 60;
  inline bool has_txmetaid() const;
  inline void clear_txmetaid();
  static const int kTxmetaidFieldNumber = 60;
  inline const ::std::string& txmetaid() const;
  inline void set_txmetaid(const ::std::string& value);
  inline void set_txmetaid(const char* value);
  inline void set_txmetaid(const void* value, size_t size);
  inline ::std::string* mutable_txmetaid();
  inline ::std::string* release_txmetaid();
  inline void set_allocated_txmetaid(::std::string* txmetaid);

  // optional bytes prev = 70;
  inline bool has_prev() const;
  inline void clear_prev();
  static const int kPrevFieldNumber = 70;
  inline const ::std::string& prev() const;
  inline void set_prev(const ::std::string& value);
  inline void set_prev(const char* value);
  inline void set_prev(const void* value, size_t size);
  inline ::std::string* mutable_prev();
  inline ::std::string* release_prev();
  inline void set_allocated_prev(::std::string* prev);

  // @@protoc_insertion_point(class_scope:fantasybit.OrderFillMeta)
 private:
  inline void set_has_refnum();
  inline void clear_has_refnum();
  inline void set_has_fname();
  inline void clear_has_fname();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_fillprice();
  inline void clear_has_fillprice();
  inline void set_has_fillsize();
  inline void clear_has_fillsize();
  inline void set_has_buyside();
  inline void clear_has_buyside();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_txmetaid();
  inline void clear_has_txmetaid();
  inline void set_has_prev();
  inline void clear_has_prev();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* fname_;
  ::google::protobuf::int32 refnum_;
  ::google::protobuf::int32 fillprice_;
  ::std::string* playerid_;
  ::google::protobuf::int32 fillsize_;
  bool buyside_;
  ::std::string* txmetaid_;
  ::std::string* prev_;
  ::google::protobuf::int32 timestamp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static OrderFillMeta* default_instance_;
};
// -------------------------------------------------------------------

class GlobalStateMeta : public ::google::protobuf::Message {
 public:
  GlobalStateMeta();
  virtual ~GlobalStateMeta();

  GlobalStateMeta(const GlobalStateMeta& from);

  inline GlobalStateMeta& operator=(const GlobalStateMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GlobalStateMeta& default_instance();

  void Swap(GlobalStateMeta* other);

  // implements Message ----------------------------------------------

  GlobalStateMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GlobalStateMeta& from);
  void MergeFrom(const GlobalStateMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .fantasybit.GlobalState globalstate = 10;
  inline bool has_globalstate() const;
  inline void clear_globalstate();
  static const int kGlobalstateFieldNumber = 10;
  inline const ::fantasybit::GlobalState& globalstate() const;
  inline ::fantasybit::GlobalState* mutable_globalstate();
  inline ::fantasybit::GlobalState* release_globalstate();
  inline void set_allocated_globalstate(::fantasybit::GlobalState* globalstate);

  // optional bytes trmetaid = 20;
  inline bool has_trmetaid() const;
  inline void clear_trmetaid();
  static const int kTrmetaidFieldNumber = 20;
  inline const ::std::string& trmetaid() const;
  inline void set_trmetaid(const ::std::string& value);
  inline void set_trmetaid(const char* value);
  inline void set_trmetaid(const void* value, size_t size);
  inline ::std::string* mutable_trmetaid();
  inline ::std::string* release_trmetaid();
  inline void set_allocated_trmetaid(::std::string* trmetaid);

  // optional bytes prev = 30;
  inline bool has_prev() const;
  inline void clear_prev();
  static const int kPrevFieldNumber = 30;
  inline const ::std::string& prev() const;
  inline void set_prev(const ::std::string& value);
  inline void set_prev(const char* value);
  inline void set_prev(const void* value, size_t size);
  inline ::std::string* mutable_prev();
  inline ::std::string* release_prev();
  inline void set_allocated_prev(::std::string* prev);

  // optional bytes next = 40;
  inline bool has_next() const;
  inline void clear_next();
  static const int kNextFieldNumber = 40;
  inline const ::std::string& next() const;
  inline void set_next(const ::std::string& value);
  inline void set_next(const char* value);
  inline void set_next(const void* value, size_t size);
  inline ::std::string* mutable_next();
  inline ::std::string* release_next();
  inline void set_allocated_next(::std::string* next);

  // @@protoc_insertion_point(class_scope:fantasybit.GlobalStateMeta)
 private:
  inline void set_has_globalstate();
  inline void clear_has_globalstate();
  inline void set_has_trmetaid();
  inline void clear_has_trmetaid();
  inline void set_has_prev();
  inline void clear_has_prev();
  inline void set_has_next();
  inline void clear_has_next();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::fantasybit::GlobalState* globalstate_;
  ::std::string* trmetaid_;
  ::std::string* prev_;
  ::std::string* next_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static GlobalStateMeta* default_instance_;
};
// -------------------------------------------------------------------

class PlayerMeta : public ::google::protobuf::Message {
 public:
  PlayerMeta();
  virtual ~PlayerMeta();

  PlayerMeta(const PlayerMeta& from);

  inline PlayerMeta& operator=(const PlayerMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerMeta& default_instance();

  void Swap(PlayerMeta* other);

  // implements Message ----------------------------------------------

  PlayerMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerMeta& from);
  void MergeFrom(const PlayerMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string playerid = 10;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 10;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  inline void set_allocated_playerid(::std::string* playerid);

  // optional .fantasybit.PlayerBase player_base = 20;
  inline bool has_player_base() const;
  inline void clear_player_base();
  static const int kPlayerBaseFieldNumber = 20;
  inline const ::fantasybit::PlayerBase& player_base() const;
  inline ::fantasybit::PlayerBase* mutable_player_base();
  inline ::fantasybit::PlayerBase* release_player_base();
  inline void set_allocated_player_base(::fantasybit::PlayerBase* player_base);

  // optional .fantasybit.PlayerStatus player_status = 30;
  inline bool has_player_status() const;
  inline void clear_player_status();
  static const int kPlayerStatusFieldNumber = 30;
  inline const ::fantasybit::PlayerStatus& player_status() const;
  inline ::fantasybit::PlayerStatus* mutable_player_status();
  inline ::fantasybit::PlayerStatus* release_player_status();
  inline void set_allocated_player_status(::fantasybit::PlayerStatus* player_status);

  // optional bytes datametaid = 40;
  inline bool has_datametaid() const;
  inline void clear_datametaid();
  static const int kDatametaidFieldNumber = 40;
  inline const ::std::string& datametaid() const;
  inline void set_datametaid(const ::std::string& value);
  inline void set_datametaid(const char* value);
  inline void set_datametaid(const void* value, size_t size);
  inline ::std::string* mutable_datametaid();
  inline ::std::string* release_datametaid();
  inline void set_allocated_datametaid(::std::string* datametaid);

  // optional bytes prev = 50;
  inline bool has_prev() const;
  inline void clear_prev();
  static const int kPrevFieldNumber = 50;
  inline const ::std::string& prev() const;
  inline void set_prev(const ::std::string& value);
  inline void set_prev(const char* value);
  inline void set_prev(const void* value, size_t size);
  inline ::std::string* mutable_prev();
  inline ::std::string* release_prev();
  inline void set_allocated_prev(::std::string* prev);

  // @@protoc_insertion_point(class_scope:fantasybit.PlayerMeta)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_player_base();
  inline void clear_has_player_base();
  inline void set_has_player_status();
  inline void clear_has_player_status();
  inline void set_has_datametaid();
  inline void clear_has_datametaid();
  inline void set_has_prev();
  inline void clear_has_prev();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* playerid_;
  ::fantasybit::PlayerBase* player_base_;
  ::fantasybit::PlayerStatus* player_status_;
  ::std::string* datametaid_;
  ::std::string* prev_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static PlayerMeta* default_instance_;
};
// -------------------------------------------------------------------

class TeamMeta : public ::google::protobuf::Message {
 public:
  TeamMeta();
  virtual ~TeamMeta();

  TeamMeta(const TeamMeta& from);

  inline TeamMeta& operator=(const TeamMeta& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TeamMeta& default_instance();

  void Swap(TeamMeta* other);

  // implements Message ----------------------------------------------

  TeamMeta* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TeamMeta& from);
  void MergeFrom(const TeamMeta& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string teamid = 10;
  inline bool has_teamid() const;
  inline void clear_teamid();
  static const int kTeamidFieldNumber = 10;
  inline const ::std::string& teamid() const;
  inline void set_teamid(const ::std::string& value);
  inline void set_teamid(const char* value);
  inline void set_teamid(const char* value, size_t size);
  inline ::std::string* mutable_teamid();
  inline ::std::string* release_teamid();
  inline void set_allocated_teamid(::std::string* teamid);

  // optional bytes playermetaidroot = 20;
  inline bool has_playermetaidroot() const;
  inline void clear_playermetaidroot();
  static const int kPlayermetaidrootFieldNumber = 20;
  inline const ::std::string& playermetaidroot() const;
  inline void set_playermetaidroot(const ::std::string& value);
  inline void set_playermetaidroot(const char* value);
  inline void set_playermetaidroot(const void* value, size_t size);
  inline ::std::string* mutable_playermetaidroot();
  inline ::std::string* release_playermetaidroot();
  inline void set_allocated_playermetaidroot(::std::string* playermetaidroot);

  // optional bytes prev = 30;
  inline bool has_prev() const;
  inline void clear_prev();
  static const int kPrevFieldNumber = 30;
  inline const ::std::string& prev() const;
  inline void set_prev(const ::std::string& value);
  inline void set_prev(const char* value);
  inline void set_prev(const void* value, size_t size);
  inline ::std::string* mutable_prev();
  inline ::std::string* release_prev();
  inline void set_allocated_prev(::std::string* prev);

  // @@protoc_insertion_point(class_scope:fantasybit.TeamMeta)
 private:
  inline void set_has_teamid();
  inline void clear_has_teamid();
  inline void set_has_playermetaidroot();
  inline void clear_has_playermetaidroot();
  inline void set_has_prev();
  inline void clear_has_prev();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* teamid_;
  ::std::string* playermetaidroot_;
  ::std::string* prev_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static TeamMeta* default_instance_;
};
// -------------------------------------------------------------------

class pbstate : public ::google::protobuf::Message {
 public:
  pbstate();
  virtual ~pbstate();

  pbstate(const pbstate& from);

  inline pbstate& operator=(const pbstate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const pbstate& default_instance();

  void Swap(pbstate* other);

  // implements Message ----------------------------------------------

  pbstate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const pbstate& from);
  void MergeFrom(const pbstate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes schedulestateid = 10;
  inline bool has_schedulestateid() const;
  inline void clear_schedulestateid();
  static const int kSchedulestateidFieldNumber = 10;
  inline const ::std::string& schedulestateid() const;
  inline void set_schedulestateid(const ::std::string& value);
  inline void set_schedulestateid(const char* value);
  inline void set_schedulestateid(const void* value, size_t size);
  inline ::std::string* mutable_schedulestateid();
  inline ::std::string* release_schedulestateid();
  inline void set_allocated_schedulestateid(::std::string* schedulestateid);

  // optional bytes leaderboardstateid = 20;
  inline bool has_leaderboardstateid() const;
  inline void clear_leaderboardstateid();
  static const int kLeaderboardstateidFieldNumber = 20;
  inline const ::std::string& leaderboardstateid() const;
  inline void set_leaderboardstateid(const ::std::string& value);
  inline void set_leaderboardstateid(const char* value);
  inline void set_leaderboardstateid(const void* value, size_t size);
  inline ::std::string* mutable_leaderboardstateid();
  inline ::std::string* release_leaderboardstateid();
  inline void set_allocated_leaderboardstateid(::std::string* leaderboardstateid);

  // optional bytes projstateid = 30;
  inline bool has_projstateid() const;
  inline void clear_projstateid();
  static const int kProjstateidFieldNumber = 30;
  inline const ::std::string& projstateid() const;
  inline void set_projstateid(const ::std::string& value);
  inline void set_projstateid(const char* value);
  inline void set_projstateid(const void* value, size_t size);
  inline ::std::string* mutable_projstateid();
  inline ::std::string* release_projstateid();
  inline void set_allocated_projstateid(::std::string* projstateid);

  // optional bytes posstateid = 35;
  inline bool has_posstateid() const;
  inline void clear_posstateid();
  static const int kPosstateidFieldNumber = 35;
  inline const ::std::string& posstateid() const;
  inline void set_posstateid(const ::std::string& value);
  inline void set_posstateid(const char* value);
  inline void set_posstateid(const void* value, size_t size);
  inline ::std::string* mutable_posstateid();
  inline ::std::string* release_posstateid();
  inline void set_allocated_posstateid(::std::string* posstateid);

  // optional bytes orderstateid = 40;
  inline bool has_orderstateid() const;
  inline void clear_orderstateid();
  static const int kOrderstateidFieldNumber = 40;
  inline const ::std::string& orderstateid() const;
  inline void set_orderstateid(const ::std::string& value);
  inline void set_orderstateid(const char* value);
  inline void set_orderstateid(const void* value, size_t size);
  inline ::std::string* mutable_orderstateid();
  inline ::std::string* release_orderstateid();
  inline void set_allocated_orderstateid(::std::string* orderstateid);

  // optional bytes marketstateid = 50;
  inline bool has_marketstateid() const;
  inline void clear_marketstateid();
  static const int kMarketstateidFieldNumber = 50;
  inline const ::std::string& marketstateid() const;
  inline void set_marketstateid(const ::std::string& value);
  inline void set_marketstateid(const char* value);
  inline void set_marketstateid(const void* value, size_t size);
  inline ::std::string* mutable_marketstateid();
  inline ::std::string* release_marketstateid();
  inline void set_allocated_marketstateid(::std::string* marketstateid);

  // optional bytes globalstateid = 60;
  inline bool has_globalstateid() const;
  inline void clear_globalstateid();
  static const int kGlobalstateidFieldNumber = 60;
  inline const ::std::string& globalstateid() const;
  inline void set_globalstateid(const ::std::string& value);
  inline void set_globalstateid(const char* value);
  inline void set_globalstateid(const void* value, size_t size);
  inline ::std::string* mutable_globalstateid();
  inline ::std::string* release_globalstateid();
  inline void set_allocated_globalstateid(::std::string* globalstateid);

  // optional bytes teamstatemid = 70;
  inline bool has_teamstatemid() const;
  inline void clear_teamstatemid();
  static const int kTeamstatemidFieldNumber = 70;
  inline const ::std::string& teamstatemid() const;
  inline void set_teamstatemid(const ::std::string& value);
  inline void set_teamstatemid(const char* value);
  inline void set_teamstatemid(const void* value, size_t size);
  inline ::std::string* mutable_teamstatemid();
  inline ::std::string* release_teamstatemid();
  inline void set_allocated_teamstatemid(::std::string* teamstatemid);

  // optional bytes fantasynamestateid = 80;
  inline bool has_fantasynamestateid() const;
  inline void clear_fantasynamestateid();
  static const int kFantasynamestateidFieldNumber = 80;
  inline const ::std::string& fantasynamestateid() const;
  inline void set_fantasynamestateid(const ::std::string& value);
  inline void set_fantasynamestateid(const char* value);
  inline void set_fantasynamestateid(const void* value, size_t size);
  inline ::std::string* mutable_fantasynamestateid();
  inline ::std::string* release_fantasynamestateid();
  inline void set_allocated_fantasynamestateid(::std::string* fantasynamestateid);

  // @@protoc_insertion_point(class_scope:fantasybit.pbstate)
 private:
  inline void set_has_schedulestateid();
  inline void clear_has_schedulestateid();
  inline void set_has_leaderboardstateid();
  inline void clear_has_leaderboardstateid();
  inline void set_has_projstateid();
  inline void clear_has_projstateid();
  inline void set_has_posstateid();
  inline void clear_has_posstateid();
  inline void set_has_orderstateid();
  inline void clear_has_orderstateid();
  inline void set_has_marketstateid();
  inline void clear_has_marketstateid();
  inline void set_has_globalstateid();
  inline void clear_has_globalstateid();
  inline void set_has_teamstatemid();
  inline void clear_has_teamstatemid();
  inline void set_has_fantasynamestateid();
  inline void clear_has_fantasynamestateid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* schedulestateid_;
  ::std::string* leaderboardstateid_;
  ::std::string* projstateid_;
  ::std::string* posstateid_;
  ::std::string* orderstateid_;
  ::std::string* marketstateid_;
  ::std::string* globalstateid_;
  ::std::string* teamstatemid_;
  ::std::string* fantasynamestateid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static pbstate* default_instance_;
};
// -------------------------------------------------------------------

class MerkleTree : public ::google::protobuf::Message {
 public:
  MerkleTree();
  virtual ~MerkleTree();

  MerkleTree(const MerkleTree& from);

  inline MerkleTree& operator=(const MerkleTree& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MerkleTree& default_instance();

  void Swap(MerkleTree* other);

  // implements Message ----------------------------------------------

  MerkleTree* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MerkleTree& from);
  void MergeFrom(const MerkleTree& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes root = 10;
  inline bool has_root() const;
  inline void clear_root();
  static const int kRootFieldNumber = 10;
  inline const ::std::string& root() const;
  inline void set_root(const ::std::string& value);
  inline void set_root(const char* value);
  inline void set_root(const void* value, size_t size);
  inline ::std::string* mutable_root();
  inline ::std::string* release_root();
  inline void set_allocated_root(::std::string* root);

  // repeated bytes leaves = 20;
  inline int leaves_size() const;
  inline void clear_leaves();
  static const int kLeavesFieldNumber = 20;
  inline const ::std::string& leaves(int index) const;
  inline ::std::string* mutable_leaves(int index);
  inline void set_leaves(int index, const ::std::string& value);
  inline void set_leaves(int index, const char* value);
  inline void set_leaves(int index, const void* value, size_t size);
  inline ::std::string* add_leaves();
  inline void add_leaves(const ::std::string& value);
  inline void add_leaves(const char* value);
  inline void add_leaves(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& leaves() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_leaves();

  // @@protoc_insertion_point(class_scope:fantasybit.MerkleTree)
 private:
  inline void set_has_root();
  inline void clear_has_root();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* root_;
  ::google::protobuf::RepeatedPtrField< ::std::string> leaves_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_StateData_2eproto();
  friend void protobuf_AssignDesc_StateData_2eproto();
  friend void protobuf_ShutdownFile_StateData_2eproto();

  void InitAsDefaultInstance();
  static MerkleTree* default_instance_;
};
// ===================================================================


// ===================================================================

// BlockMeta

// optional int32 blocknum = 40;
inline bool BlockMeta::has_blocknum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlockMeta::set_has_blocknum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlockMeta::clear_has_blocknum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlockMeta::clear_blocknum() {
  blocknum_ = 0;
  clear_has_blocknum();
}
inline ::google::protobuf::int32 BlockMeta::blocknum() const {
  return blocknum_;
}
inline void BlockMeta::set_blocknum(::google::protobuf::int32 value) {
  set_has_blocknum();
  blocknum_ = value;
}

// optional bytes trmetaid = 50;
inline bool BlockMeta::has_trmetaid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlockMeta::set_has_trmetaid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlockMeta::clear_has_trmetaid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlockMeta::clear_trmetaid() {
  if (trmetaid_ != &::google::protobuf::internal::kEmptyString) {
    trmetaid_->clear();
  }
  clear_has_trmetaid();
}
inline const ::std::string& BlockMeta::trmetaid() const {
  return *trmetaid_;
}
inline void BlockMeta::set_trmetaid(const ::std::string& value) {
  set_has_trmetaid();
  if (trmetaid_ == &::google::protobuf::internal::kEmptyString) {
    trmetaid_ = new ::std::string;
  }
  trmetaid_->assign(value);
}
inline void BlockMeta::set_trmetaid(const char* value) {
  set_has_trmetaid();
  if (trmetaid_ == &::google::protobuf::internal::kEmptyString) {
    trmetaid_ = new ::std::string;
  }
  trmetaid_->assign(value);
}
inline void BlockMeta::set_trmetaid(const void* value, size_t size) {
  set_has_trmetaid();
  if (trmetaid_ == &::google::protobuf::internal::kEmptyString) {
    trmetaid_ = new ::std::string;
  }
  trmetaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BlockMeta::mutable_trmetaid() {
  set_has_trmetaid();
  if (trmetaid_ == &::google::protobuf::internal::kEmptyString) {
    trmetaid_ = new ::std::string;
  }
  return trmetaid_;
}
inline ::std::string* BlockMeta::release_trmetaid() {
  clear_has_trmetaid();
  if (trmetaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = trmetaid_;
    trmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BlockMeta::set_allocated_trmetaid(::std::string* trmetaid) {
  if (trmetaid_ != &::google::protobuf::internal::kEmptyString) {
    delete trmetaid_;
  }
  if (trmetaid) {
    set_has_trmetaid();
    trmetaid_ = trmetaid;
  } else {
    clear_has_trmetaid();
    trmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes txmetaroot = 10;
inline bool BlockMeta::has_txmetaroot() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BlockMeta::set_has_txmetaroot() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BlockMeta::clear_has_txmetaroot() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BlockMeta::clear_txmetaroot() {
  if (txmetaroot_ != &::google::protobuf::internal::kEmptyString) {
    txmetaroot_->clear();
  }
  clear_has_txmetaroot();
}
inline const ::std::string& BlockMeta::txmetaroot() const {
  return *txmetaroot_;
}
inline void BlockMeta::set_txmetaroot(const ::std::string& value) {
  set_has_txmetaroot();
  if (txmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    txmetaroot_ = new ::std::string;
  }
  txmetaroot_->assign(value);
}
inline void BlockMeta::set_txmetaroot(const char* value) {
  set_has_txmetaroot();
  if (txmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    txmetaroot_ = new ::std::string;
  }
  txmetaroot_->assign(value);
}
inline void BlockMeta::set_txmetaroot(const void* value, size_t size) {
  set_has_txmetaroot();
  if (txmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    txmetaroot_ = new ::std::string;
  }
  txmetaroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BlockMeta::mutable_txmetaroot() {
  set_has_txmetaroot();
  if (txmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    txmetaroot_ = new ::std::string;
  }
  return txmetaroot_;
}
inline ::std::string* BlockMeta::release_txmetaroot() {
  clear_has_txmetaroot();
  if (txmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = txmetaroot_;
    txmetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BlockMeta::set_allocated_txmetaroot(::std::string* txmetaroot) {
  if (txmetaroot_ != &::google::protobuf::internal::kEmptyString) {
    delete txmetaroot_;
  }
  if (txmetaroot) {
    set_has_txmetaroot();
    txmetaroot_ = txmetaroot;
  } else {
    clear_has_txmetaroot();
    txmetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes pbstateid = 60;
inline bool BlockMeta::has_pbstateid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BlockMeta::set_has_pbstateid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BlockMeta::clear_has_pbstateid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BlockMeta::clear_pbstateid() {
  if (pbstateid_ != &::google::protobuf::internal::kEmptyString) {
    pbstateid_->clear();
  }
  clear_has_pbstateid();
}
inline const ::std::string& BlockMeta::pbstateid() const {
  return *pbstateid_;
}
inline void BlockMeta::set_pbstateid(const ::std::string& value) {
  set_has_pbstateid();
  if (pbstateid_ == &::google::protobuf::internal::kEmptyString) {
    pbstateid_ = new ::std::string;
  }
  pbstateid_->assign(value);
}
inline void BlockMeta::set_pbstateid(const char* value) {
  set_has_pbstateid();
  if (pbstateid_ == &::google::protobuf::internal::kEmptyString) {
    pbstateid_ = new ::std::string;
  }
  pbstateid_->assign(value);
}
inline void BlockMeta::set_pbstateid(const void* value, size_t size) {
  set_has_pbstateid();
  if (pbstateid_ == &::google::protobuf::internal::kEmptyString) {
    pbstateid_ = new ::std::string;
  }
  pbstateid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BlockMeta::mutable_pbstateid() {
  set_has_pbstateid();
  if (pbstateid_ == &::google::protobuf::internal::kEmptyString) {
    pbstateid_ = new ::std::string;
  }
  return pbstateid_;
}
inline ::std::string* BlockMeta::release_pbstateid() {
  clear_has_pbstateid();
  if (pbstateid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pbstateid_;
    pbstateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BlockMeta::set_allocated_pbstateid(::std::string* pbstateid) {
  if (pbstateid_ != &::google::protobuf::internal::kEmptyString) {
    delete pbstateid_;
  }
  if (pbstateid) {
    set_has_pbstateid();
    pbstateid_ = pbstateid;
  } else {
    clear_has_pbstateid();
    pbstateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes prev = 20;
inline bool BlockMeta::has_prev() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BlockMeta::set_has_prev() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BlockMeta::clear_has_prev() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BlockMeta::clear_prev() {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    prev_->clear();
  }
  clear_has_prev();
}
inline const ::std::string& BlockMeta::prev() const {
  return *prev_;
}
inline void BlockMeta::set_prev(const ::std::string& value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void BlockMeta::set_prev(const char* value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void BlockMeta::set_prev(const void* value, size_t size) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BlockMeta::mutable_prev() {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  return prev_;
}
inline ::std::string* BlockMeta::release_prev() {
  clear_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prev_;
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BlockMeta::set_allocated_prev(::std::string* prev) {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    delete prev_;
  }
  if (prev) {
    set_has_prev();
    prev_ = prev;
  } else {
    clear_has_prev();
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes next = 30;
inline bool BlockMeta::has_next() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BlockMeta::set_has_next() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BlockMeta::clear_has_next() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BlockMeta::clear_next() {
  if (next_ != &::google::protobuf::internal::kEmptyString) {
    next_->clear();
  }
  clear_has_next();
}
inline const ::std::string& BlockMeta::next() const {
  return *next_;
}
inline void BlockMeta::set_next(const ::std::string& value) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(value);
}
inline void BlockMeta::set_next(const char* value) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(value);
}
inline void BlockMeta::set_next(const void* value, size_t size) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BlockMeta::mutable_next() {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  return next_;
}
inline ::std::string* BlockMeta::release_next() {
  clear_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = next_;
    next_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BlockMeta::set_allocated_next(::std::string* next) {
  if (next_ != &::google::protobuf::internal::kEmptyString) {
    delete next_;
  }
  if (next) {
    set_has_next();
    next_ = next;
  } else {
    clear_has_next();
    next_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TxMeta

// optional int32 blocknum = 10;
inline bool TxMeta::has_blocknum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxMeta::set_has_blocknum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TxMeta::clear_has_blocknum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TxMeta::clear_blocknum() {
  blocknum_ = 0;
  clear_has_blocknum();
}
inline ::google::protobuf::int32 TxMeta::blocknum() const {
  return blocknum_;
}
inline void TxMeta::set_blocknum(::google::protobuf::int32 value) {
  set_has_blocknum();
  blocknum_ = value;
}

// optional int32 txnum = 20;
inline bool TxMeta::has_txnum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TxMeta::set_has_txnum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TxMeta::clear_has_txnum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TxMeta::clear_txnum() {
  txnum_ = 0;
  clear_has_txnum();
}
inline ::google::protobuf::int32 TxMeta::txnum() const {
  return txnum_;
}
inline void TxMeta::set_txnum(::google::protobuf::int32 value) {
  set_has_txnum();
  txnum_ = value;
}

// optional .fantasybit.TransType txtype = 40;
inline bool TxMeta::has_txtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TxMeta::set_has_txtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TxMeta::clear_has_txtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TxMeta::clear_txtype() {
  txtype_ = 0;
  clear_has_txtype();
}
inline ::fantasybit::TransType TxMeta::txtype() const {
  return static_cast< ::fantasybit::TransType >(txtype_);
}
inline void TxMeta::set_txtype(::fantasybit::TransType value) {
  assert(::fantasybit::TransType_IsValid(value));
  set_has_txtype();
  txtype_ = value;
}

// optional .fantasybit.Transaction tx = 50;
inline bool TxMeta::has_tx() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TxMeta::set_has_tx() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TxMeta::clear_has_tx() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TxMeta::clear_tx() {
  if (tx_ != NULL) tx_->::fantasybit::Transaction::Clear();
  clear_has_tx();
}
inline const ::fantasybit::Transaction& TxMeta::tx() const {
  return tx_ != NULL ? *tx_ : *default_instance_->tx_;
}
inline ::fantasybit::Transaction* TxMeta::mutable_tx() {
  set_has_tx();
  if (tx_ == NULL) tx_ = new ::fantasybit::Transaction;
  return tx_;
}
inline ::fantasybit::Transaction* TxMeta::release_tx() {
  clear_has_tx();
  ::fantasybit::Transaction* temp = tx_;
  tx_ = NULL;
  return temp;
}
inline void TxMeta::set_allocated_tx(::fantasybit::Transaction* tx) {
  delete tx_;
  tx_ = tx;
  if (tx) {
    set_has_tx();
  } else {
    clear_has_tx();
  }
}

// optional string fantasy_name = 60;
inline bool TxMeta::has_fantasy_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TxMeta::set_has_fantasy_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TxMeta::clear_has_fantasy_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TxMeta::clear_fantasy_name() {
  if (fantasy_name_ != &::google::protobuf::internal::kEmptyString) {
    fantasy_name_->clear();
  }
  clear_has_fantasy_name();
}
inline const ::std::string& TxMeta::fantasy_name() const {
  return *fantasy_name_;
}
inline void TxMeta::set_fantasy_name(const ::std::string& value) {
  set_has_fantasy_name();
  if (fantasy_name_ == &::google::protobuf::internal::kEmptyString) {
    fantasy_name_ = new ::std::string;
  }
  fantasy_name_->assign(value);
}
inline void TxMeta::set_fantasy_name(const char* value) {
  set_has_fantasy_name();
  if (fantasy_name_ == &::google::protobuf::internal::kEmptyString) {
    fantasy_name_ = new ::std::string;
  }
  fantasy_name_->assign(value);
}
inline void TxMeta::set_fantasy_name(const char* value, size_t size) {
  set_has_fantasy_name();
  if (fantasy_name_ == &::google::protobuf::internal::kEmptyString) {
    fantasy_name_ = new ::std::string;
  }
  fantasy_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TxMeta::mutable_fantasy_name() {
  set_has_fantasy_name();
  if (fantasy_name_ == &::google::protobuf::internal::kEmptyString) {
    fantasy_name_ = new ::std::string;
  }
  return fantasy_name_;
}
inline ::std::string* TxMeta::release_fantasy_name() {
  clear_has_fantasy_name();
  if (fantasy_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fantasy_name_;
    fantasy_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TxMeta::set_allocated_fantasy_name(::std::string* fantasy_name) {
  if (fantasy_name_ != &::google::protobuf::internal::kEmptyString) {
    delete fantasy_name_;
  }
  if (fantasy_name) {
    set_has_fantasy_name();
    fantasy_name_ = fantasy_name;
  } else {
    clear_has_fantasy_name();
    fantasy_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes id = 70;
inline bool TxMeta::has_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TxMeta::set_has_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TxMeta::clear_has_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TxMeta::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& TxMeta::id() const {
  return *id_;
}
inline void TxMeta::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void TxMeta::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void TxMeta::set_id(const void* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TxMeta::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* TxMeta::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TxMeta::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TrMeta

// optional int32 blocknum = 10;
inline bool TrMeta::has_blocknum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrMeta::set_has_blocknum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrMeta::clear_has_blocknum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrMeta::clear_blocknum() {
  blocknum_ = 0;
  clear_has_blocknum();
}
inline ::google::protobuf::int32 TrMeta::blocknum() const {
  return blocknum_;
}
inline void TrMeta::set_blocknum(::google::protobuf::int32 value) {
  set_has_blocknum();
  blocknum_ = value;
}

// optional .fantasybit.TrType type = 40;
inline bool TrMeta::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrMeta::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrMeta::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrMeta::clear_type() {
  type_ = 2;
  clear_has_type();
}
inline ::fantasybit::TrType TrMeta::type() const {
  return static_cast< ::fantasybit::TrType >(type_);
}
inline void TrMeta::set_type(::fantasybit::TrType value) {
  assert(::fantasybit::TrType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional uint32 season = 50;
inline bool TrMeta::has_season() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrMeta::set_has_season() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrMeta::clear_has_season() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrMeta::clear_season() {
  season_ = 0u;
  clear_has_season();
}
inline ::google::protobuf::uint32 TrMeta::season() const {
  return season_;
}
inline void TrMeta::set_season(::google::protobuf::uint32 value) {
  set_has_season();
  season_ = value;
}

// optional uint32 week = 60;
inline bool TrMeta::has_week() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrMeta::set_has_week() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrMeta::clear_has_week() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TrMeta::clear_week() {
  week_ = 0u;
  clear_has_week();
}
inline ::google::protobuf::uint32 TrMeta::week() const {
  return week_;
}
inline void TrMeta::set_week(::google::protobuf::uint32 value) {
  set_has_week();
  week_ = value;
}

// optional bytes gamemetaroot = 70;
inline bool TrMeta::has_gamemetaroot() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TrMeta::set_has_gamemetaroot() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TrMeta::clear_has_gamemetaroot() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TrMeta::clear_gamemetaroot() {
  if (gamemetaroot_ != &::google::protobuf::internal::kEmptyString) {
    gamemetaroot_->clear();
  }
  clear_has_gamemetaroot();
}
inline const ::std::string& TrMeta::gamemetaroot() const {
  return *gamemetaroot_;
}
inline void TrMeta::set_gamemetaroot(const ::std::string& value) {
  set_has_gamemetaroot();
  if (gamemetaroot_ == &::google::protobuf::internal::kEmptyString) {
    gamemetaroot_ = new ::std::string;
  }
  gamemetaroot_->assign(value);
}
inline void TrMeta::set_gamemetaroot(const char* value) {
  set_has_gamemetaroot();
  if (gamemetaroot_ == &::google::protobuf::internal::kEmptyString) {
    gamemetaroot_ = new ::std::string;
  }
  gamemetaroot_->assign(value);
}
inline void TrMeta::set_gamemetaroot(const void* value, size_t size) {
  set_has_gamemetaroot();
  if (gamemetaroot_ == &::google::protobuf::internal::kEmptyString) {
    gamemetaroot_ = new ::std::string;
  }
  gamemetaroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrMeta::mutable_gamemetaroot() {
  set_has_gamemetaroot();
  if (gamemetaroot_ == &::google::protobuf::internal::kEmptyString) {
    gamemetaroot_ = new ::std::string;
  }
  return gamemetaroot_;
}
inline ::std::string* TrMeta::release_gamemetaroot() {
  clear_has_gamemetaroot();
  if (gamemetaroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gamemetaroot_;
    gamemetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TrMeta::set_allocated_gamemetaroot(::std::string* gamemetaroot) {
  if (gamemetaroot_ != &::google::protobuf::internal::kEmptyString) {
    delete gamemetaroot_;
  }
  if (gamemetaroot) {
    set_has_gamemetaroot();
    gamemetaroot_ = gamemetaroot;
  } else {
    clear_has_gamemetaroot();
    gamemetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes datametaroot = 80;
inline bool TrMeta::has_datametaroot() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TrMeta::set_has_datametaroot() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TrMeta::clear_has_datametaroot() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TrMeta::clear_datametaroot() {
  if (datametaroot_ != &::google::protobuf::internal::kEmptyString) {
    datametaroot_->clear();
  }
  clear_has_datametaroot();
}
inline const ::std::string& TrMeta::datametaroot() const {
  return *datametaroot_;
}
inline void TrMeta::set_datametaroot(const ::std::string& value) {
  set_has_datametaroot();
  if (datametaroot_ == &::google::protobuf::internal::kEmptyString) {
    datametaroot_ = new ::std::string;
  }
  datametaroot_->assign(value);
}
inline void TrMeta::set_datametaroot(const char* value) {
  set_has_datametaroot();
  if (datametaroot_ == &::google::protobuf::internal::kEmptyString) {
    datametaroot_ = new ::std::string;
  }
  datametaroot_->assign(value);
}
inline void TrMeta::set_datametaroot(const void* value, size_t size) {
  set_has_datametaroot();
  if (datametaroot_ == &::google::protobuf::internal::kEmptyString) {
    datametaroot_ = new ::std::string;
  }
  datametaroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrMeta::mutable_datametaroot() {
  set_has_datametaroot();
  if (datametaroot_ == &::google::protobuf::internal::kEmptyString) {
    datametaroot_ = new ::std::string;
  }
  return datametaroot_;
}
inline ::std::string* TrMeta::release_datametaroot() {
  clear_has_datametaroot();
  if (datametaroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = datametaroot_;
    datametaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TrMeta::set_allocated_datametaroot(::std::string* datametaroot) {
  if (datametaroot_ != &::google::protobuf::internal::kEmptyString) {
    delete datametaroot_;
  }
  if (datametaroot) {
    set_has_datametaroot();
    datametaroot_ = datametaroot;
  } else {
    clear_has_datametaroot();
    datametaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes txmetaid = 100;
inline bool TrMeta::has_txmetaid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TrMeta::set_has_txmetaid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TrMeta::clear_has_txmetaid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TrMeta::clear_txmetaid() {
  if (txmetaid_ != &::google::protobuf::internal::kEmptyString) {
    txmetaid_->clear();
  }
  clear_has_txmetaid();
}
inline const ::std::string& TrMeta::txmetaid() const {
  return *txmetaid_;
}
inline void TrMeta::set_txmetaid(const ::std::string& value) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(value);
}
inline void TrMeta::set_txmetaid(const char* value) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(value);
}
inline void TrMeta::set_txmetaid(const void* value, size_t size) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrMeta::mutable_txmetaid() {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  return txmetaid_;
}
inline ::std::string* TrMeta::release_txmetaid() {
  clear_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = txmetaid_;
    txmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TrMeta::set_allocated_txmetaid(::std::string* txmetaid) {
  if (txmetaid_ != &::google::protobuf::internal::kEmptyString) {
    delete txmetaid_;
  }
  if (txmetaid) {
    set_has_txmetaid();
    txmetaid_ = txmetaid;
  } else {
    clear_has_txmetaid();
    txmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GameMeta

// optional bytes txmetaid = 10;
inline bool GameMeta::has_txmetaid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameMeta::set_has_txmetaid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameMeta::clear_has_txmetaid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameMeta::clear_txmetaid() {
  if (txmetaid_ != &::google::protobuf::internal::kEmptyString) {
    txmetaid_->clear();
  }
  clear_has_txmetaid();
}
inline const ::std::string& GameMeta::txmetaid() const {
  return *txmetaid_;
}
inline void GameMeta::set_txmetaid(const ::std::string& value) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(value);
}
inline void GameMeta::set_txmetaid(const char* value) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(value);
}
inline void GameMeta::set_txmetaid(const void* value, size_t size) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameMeta::mutable_txmetaid() {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  return txmetaid_;
}
inline ::std::string* GameMeta::release_txmetaid() {
  clear_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = txmetaid_;
    txmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameMeta::set_allocated_txmetaid(::std::string* txmetaid) {
  if (txmetaid_ != &::google::protobuf::internal::kEmptyString) {
    delete txmetaid_;
  }
  if (txmetaid) {
    set_has_txmetaid();
    txmetaid_ = txmetaid;
  } else {
    clear_has_txmetaid();
    txmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .fantasybit.GameData gamedata = 20;
inline bool GameMeta::has_gamedata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameMeta::set_has_gamedata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameMeta::clear_has_gamedata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameMeta::clear_gamedata() {
  if (gamedata_ != NULL) gamedata_->::fantasybit::GameData::Clear();
  clear_has_gamedata();
}
inline const ::fantasybit::GameData& GameMeta::gamedata() const {
  return gamedata_ != NULL ? *gamedata_ : *default_instance_->gamedata_;
}
inline ::fantasybit::GameData* GameMeta::mutable_gamedata() {
  set_has_gamedata();
  if (gamedata_ == NULL) gamedata_ = new ::fantasybit::GameData;
  return gamedata_;
}
inline ::fantasybit::GameData* GameMeta::release_gamedata() {
  clear_has_gamedata();
  ::fantasybit::GameData* temp = gamedata_;
  gamedata_ = NULL;
  return temp;
}
inline void GameMeta::set_allocated_gamedata(::fantasybit::GameData* gamedata) {
  delete gamedata_;
  gamedata_ = gamedata;
  if (gamedata) {
    set_has_gamedata();
  } else {
    clear_has_gamedata();
  }
}

// -------------------------------------------------------------------

// DataMeta

// optional bytes txmetaid = 10;
inline bool DataMeta::has_txmetaid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataMeta::set_has_txmetaid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataMeta::clear_has_txmetaid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataMeta::clear_txmetaid() {
  if (txmetaid_ != &::google::protobuf::internal::kEmptyString) {
    txmetaid_->clear();
  }
  clear_has_txmetaid();
}
inline const ::std::string& DataMeta::txmetaid() const {
  return *txmetaid_;
}
inline void DataMeta::set_txmetaid(const ::std::string& value) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(value);
}
inline void DataMeta::set_txmetaid(const char* value) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(value);
}
inline void DataMeta::set_txmetaid(const void* value, size_t size) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataMeta::mutable_txmetaid() {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  return txmetaid_;
}
inline ::std::string* DataMeta::release_txmetaid() {
  clear_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = txmetaid_;
    txmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DataMeta::set_allocated_txmetaid(::std::string* txmetaid) {
  if (txmetaid_ != &::google::protobuf::internal::kEmptyString) {
    delete txmetaid_;
  }
  if (txmetaid) {
    set_has_txmetaid();
    txmetaid_ = txmetaid;
  } else {
    clear_has_txmetaid();
    txmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .fantasybit.Data data = 20;
inline bool DataMeta::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataMeta::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataMeta::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataMeta::clear_data() {
  if (data_ != NULL) data_->::fantasybit::Data::Clear();
  clear_has_data();
}
inline const ::fantasybit::Data& DataMeta::data() const {
  return data_ != NULL ? *data_ : *default_instance_->data_;
}
inline ::fantasybit::Data* DataMeta::mutable_data() {
  set_has_data();
  if (data_ == NULL) data_ = new ::fantasybit::Data;
  return data_;
}
inline ::fantasybit::Data* DataMeta::release_data() {
  clear_has_data();
  ::fantasybit::Data* temp = data_;
  data_ = NULL;
  return temp;
}
inline void DataMeta::set_allocated_data(::fantasybit::Data* data) {
  delete data_;
  data_ = data;
  if (data) {
    set_has_data();
  } else {
    clear_has_data();
  }
}

// -------------------------------------------------------------------

// LeaderBoardMeta

// optional uint32 week = 10;
inline bool LeaderBoardMeta::has_week() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LeaderBoardMeta::set_has_week() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LeaderBoardMeta::clear_has_week() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LeaderBoardMeta::clear_week() {
  week_ = 0u;
  clear_has_week();
}
inline ::google::protobuf::uint32 LeaderBoardMeta::week() const {
  return week_;
}
inline void LeaderBoardMeta::set_week(::google::protobuf::uint32 value) {
  set_has_week();
  week_ = value;
}

// optional bytes fnbalmetaroot = 20;
inline bool LeaderBoardMeta::has_fnbalmetaroot() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LeaderBoardMeta::set_has_fnbalmetaroot() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LeaderBoardMeta::clear_has_fnbalmetaroot() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LeaderBoardMeta::clear_fnbalmetaroot() {
  if (fnbalmetaroot_ != &::google::protobuf::internal::kEmptyString) {
    fnbalmetaroot_->clear();
  }
  clear_has_fnbalmetaroot();
}
inline const ::std::string& LeaderBoardMeta::fnbalmetaroot() const {
  return *fnbalmetaroot_;
}
inline void LeaderBoardMeta::set_fnbalmetaroot(const ::std::string& value) {
  set_has_fnbalmetaroot();
  if (fnbalmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    fnbalmetaroot_ = new ::std::string;
  }
  fnbalmetaroot_->assign(value);
}
inline void LeaderBoardMeta::set_fnbalmetaroot(const char* value) {
  set_has_fnbalmetaroot();
  if (fnbalmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    fnbalmetaroot_ = new ::std::string;
  }
  fnbalmetaroot_->assign(value);
}
inline void LeaderBoardMeta::set_fnbalmetaroot(const void* value, size_t size) {
  set_has_fnbalmetaroot();
  if (fnbalmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    fnbalmetaroot_ = new ::std::string;
  }
  fnbalmetaroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LeaderBoardMeta::mutable_fnbalmetaroot() {
  set_has_fnbalmetaroot();
  if (fnbalmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    fnbalmetaroot_ = new ::std::string;
  }
  return fnbalmetaroot_;
}
inline ::std::string* LeaderBoardMeta::release_fnbalmetaroot() {
  clear_has_fnbalmetaroot();
  if (fnbalmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fnbalmetaroot_;
    fnbalmetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LeaderBoardMeta::set_allocated_fnbalmetaroot(::std::string* fnbalmetaroot) {
  if (fnbalmetaroot_ != &::google::protobuf::internal::kEmptyString) {
    delete fnbalmetaroot_;
  }
  if (fnbalmetaroot) {
    set_has_fnbalmetaroot();
    fnbalmetaroot_ = fnbalmetaroot;
  } else {
    clear_has_fnbalmetaroot();
    fnbalmetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes prev = 30;
inline bool LeaderBoardMeta::has_prev() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LeaderBoardMeta::set_has_prev() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LeaderBoardMeta::clear_has_prev() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LeaderBoardMeta::clear_prev() {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    prev_->clear();
  }
  clear_has_prev();
}
inline const ::std::string& LeaderBoardMeta::prev() const {
  return *prev_;
}
inline void LeaderBoardMeta::set_prev(const ::std::string& value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void LeaderBoardMeta::set_prev(const char* value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void LeaderBoardMeta::set_prev(const void* value, size_t size) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LeaderBoardMeta::mutable_prev() {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  return prev_;
}
inline ::std::string* LeaderBoardMeta::release_prev() {
  clear_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prev_;
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LeaderBoardMeta::set_allocated_prev(::std::string* prev) {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    delete prev_;
  }
  if (prev) {
    set_has_prev();
    prev_ = prev;
  } else {
    clear_has_prev();
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes next = 40;
inline bool LeaderBoardMeta::has_next() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LeaderBoardMeta::set_has_next() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LeaderBoardMeta::clear_has_next() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LeaderBoardMeta::clear_next() {
  if (next_ != &::google::protobuf::internal::kEmptyString) {
    next_->clear();
  }
  clear_has_next();
}
inline const ::std::string& LeaderBoardMeta::next() const {
  return *next_;
}
inline void LeaderBoardMeta::set_next(const ::std::string& value) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(value);
}
inline void LeaderBoardMeta::set_next(const char* value) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(value);
}
inline void LeaderBoardMeta::set_next(const void* value, size_t size) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LeaderBoardMeta::mutable_next() {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  return next_;
}
inline ::std::string* LeaderBoardMeta::release_next() {
  clear_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = next_;
    next_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LeaderBoardMeta::set_allocated_next(::std::string* next) {
  if (next_ != &::google::protobuf::internal::kEmptyString) {
    delete next_;
  }
  if (next) {
    set_has_next();
    next_ = next;
  } else {
    clear_has_next();
    next_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FantasyNameBalMeta

// optional bytes txmetaid = 10;
inline bool FantasyNameBalMeta::has_txmetaid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FantasyNameBalMeta::set_has_txmetaid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FantasyNameBalMeta::clear_has_txmetaid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FantasyNameBalMeta::clear_txmetaid() {
  if (txmetaid_ != &::google::protobuf::internal::kEmptyString) {
    txmetaid_->clear();
  }
  clear_has_txmetaid();
}
inline const ::std::string& FantasyNameBalMeta::txmetaid() const {
  return *txmetaid_;
}
inline void FantasyNameBalMeta::set_txmetaid(const ::std::string& value) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(value);
}
inline void FantasyNameBalMeta::set_txmetaid(const char* value) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(value);
}
inline void FantasyNameBalMeta::set_txmetaid(const void* value, size_t size) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FantasyNameBalMeta::mutable_txmetaid() {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  return txmetaid_;
}
inline ::std::string* FantasyNameBalMeta::release_txmetaid() {
  clear_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = txmetaid_;
    txmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FantasyNameBalMeta::set_allocated_txmetaid(::std::string* txmetaid) {
  if (txmetaid_ != &::google::protobuf::internal::kEmptyString) {
    delete txmetaid_;
  }
  if (txmetaid) {
    set_has_txmetaid();
    txmetaid_ = txmetaid;
  } else {
    clear_has_txmetaid();
    txmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes trmetaid = 20;
inline bool FantasyNameBalMeta::has_trmetaid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FantasyNameBalMeta::set_has_trmetaid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FantasyNameBalMeta::clear_has_trmetaid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FantasyNameBalMeta::clear_trmetaid() {
  if (trmetaid_ != &::google::protobuf::internal::kEmptyString) {
    trmetaid_->clear();
  }
  clear_has_trmetaid();
}
inline const ::std::string& FantasyNameBalMeta::trmetaid() const {
  return *trmetaid_;
}
inline void FantasyNameBalMeta::set_trmetaid(const ::std::string& value) {
  set_has_trmetaid();
  if (trmetaid_ == &::google::protobuf::internal::kEmptyString) {
    trmetaid_ = new ::std::string;
  }
  trmetaid_->assign(value);
}
inline void FantasyNameBalMeta::set_trmetaid(const char* value) {
  set_has_trmetaid();
  if (trmetaid_ == &::google::protobuf::internal::kEmptyString) {
    trmetaid_ = new ::std::string;
  }
  trmetaid_->assign(value);
}
inline void FantasyNameBalMeta::set_trmetaid(const void* value, size_t size) {
  set_has_trmetaid();
  if (trmetaid_ == &::google::protobuf::internal::kEmptyString) {
    trmetaid_ = new ::std::string;
  }
  trmetaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FantasyNameBalMeta::mutable_trmetaid() {
  set_has_trmetaid();
  if (trmetaid_ == &::google::protobuf::internal::kEmptyString) {
    trmetaid_ = new ::std::string;
  }
  return trmetaid_;
}
inline ::std::string* FantasyNameBalMeta::release_trmetaid() {
  clear_has_trmetaid();
  if (trmetaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = trmetaid_;
    trmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FantasyNameBalMeta::set_allocated_trmetaid(::std::string* trmetaid) {
  if (trmetaid_ != &::google::protobuf::internal::kEmptyString) {
    delete trmetaid_;
  }
  if (trmetaid) {
    set_has_trmetaid();
    trmetaid_ = trmetaid;
  } else {
    clear_has_trmetaid();
    trmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 25;
inline bool FantasyNameBalMeta::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FantasyNameBalMeta::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FantasyNameBalMeta::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FantasyNameBalMeta::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& FantasyNameBalMeta::name() const {
  return *name_;
}
inline void FantasyNameBalMeta::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FantasyNameBalMeta::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FantasyNameBalMeta::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FantasyNameBalMeta::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* FantasyNameBalMeta::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FantasyNameBalMeta::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string public_key = 30;
inline bool FantasyNameBalMeta::has_public_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FantasyNameBalMeta::set_has_public_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FantasyNameBalMeta::clear_has_public_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FantasyNameBalMeta::clear_public_key() {
  if (public_key_ != &::google::protobuf::internal::kEmptyString) {
    public_key_->clear();
  }
  clear_has_public_key();
}
inline const ::std::string& FantasyNameBalMeta::public_key() const {
  return *public_key_;
}
inline void FantasyNameBalMeta::set_public_key(const ::std::string& value) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void FantasyNameBalMeta::set_public_key(const char* value) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void FantasyNameBalMeta::set_public_key(const char* value, size_t size) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FantasyNameBalMeta::mutable_public_key() {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}
inline ::std::string* FantasyNameBalMeta::release_public_key() {
  clear_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = public_key_;
    public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FantasyNameBalMeta::set_allocated_public_key(::std::string* public_key) {
  if (public_key_ != &::google::protobuf::internal::kEmptyString) {
    delete public_key_;
  }
  if (public_key) {
    set_has_public_key();
    public_key_ = public_key;
  } else {
    clear_has_public_key();
    public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 bits = 35;
inline bool FantasyNameBalMeta::has_bits() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FantasyNameBalMeta::set_has_bits() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FantasyNameBalMeta::clear_has_bits() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FantasyNameBalMeta::clear_bits() {
  bits_ = GOOGLE_ULONGLONG(0);
  clear_has_bits();
}
inline ::google::protobuf::uint64 FantasyNameBalMeta::bits() const {
  return bits_;
}
inline void FantasyNameBalMeta::set_bits(::google::protobuf::uint64 value) {
  set_has_bits();
  bits_ = value;
}

// optional int64 stake = 40;
inline bool FantasyNameBalMeta::has_stake() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FantasyNameBalMeta::set_has_stake() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FantasyNameBalMeta::clear_has_stake() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FantasyNameBalMeta::clear_stake() {
  stake_ = GOOGLE_LONGLONG(0);
  clear_has_stake();
}
inline ::google::protobuf::int64 FantasyNameBalMeta::stake() const {
  return stake_;
}
inline void FantasyNameBalMeta::set_stake(::google::protobuf::int64 value) {
  set_has_stake();
  stake_ = value;
}

// optional bytes awardmetaroot = 50;
inline bool FantasyNameBalMeta::has_awardmetaroot() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FantasyNameBalMeta::set_has_awardmetaroot() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FantasyNameBalMeta::clear_has_awardmetaroot() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FantasyNameBalMeta::clear_awardmetaroot() {
  if (awardmetaroot_ != &::google::protobuf::internal::kEmptyString) {
    awardmetaroot_->clear();
  }
  clear_has_awardmetaroot();
}
inline const ::std::string& FantasyNameBalMeta::awardmetaroot() const {
  return *awardmetaroot_;
}
inline void FantasyNameBalMeta::set_awardmetaroot(const ::std::string& value) {
  set_has_awardmetaroot();
  if (awardmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    awardmetaroot_ = new ::std::string;
  }
  awardmetaroot_->assign(value);
}
inline void FantasyNameBalMeta::set_awardmetaroot(const char* value) {
  set_has_awardmetaroot();
  if (awardmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    awardmetaroot_ = new ::std::string;
  }
  awardmetaroot_->assign(value);
}
inline void FantasyNameBalMeta::set_awardmetaroot(const void* value, size_t size) {
  set_has_awardmetaroot();
  if (awardmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    awardmetaroot_ = new ::std::string;
  }
  awardmetaroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FantasyNameBalMeta::mutable_awardmetaroot() {
  set_has_awardmetaroot();
  if (awardmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    awardmetaroot_ = new ::std::string;
  }
  return awardmetaroot_;
}
inline ::std::string* FantasyNameBalMeta::release_awardmetaroot() {
  clear_has_awardmetaroot();
  if (awardmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = awardmetaroot_;
    awardmetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FantasyNameBalMeta::set_allocated_awardmetaroot(::std::string* awardmetaroot) {
  if (awardmetaroot_ != &::google::protobuf::internal::kEmptyString) {
    delete awardmetaroot_;
  }
  if (awardmetaroot) {
    set_has_awardmetaroot();
    awardmetaroot_ = awardmetaroot;
  } else {
    clear_has_awardmetaroot();
    awardmetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes pnlmetaroot = 60;
inline bool FantasyNameBalMeta::has_pnlmetaroot() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FantasyNameBalMeta::set_has_pnlmetaroot() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FantasyNameBalMeta::clear_has_pnlmetaroot() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FantasyNameBalMeta::clear_pnlmetaroot() {
  if (pnlmetaroot_ != &::google::protobuf::internal::kEmptyString) {
    pnlmetaroot_->clear();
  }
  clear_has_pnlmetaroot();
}
inline const ::std::string& FantasyNameBalMeta::pnlmetaroot() const {
  return *pnlmetaroot_;
}
inline void FantasyNameBalMeta::set_pnlmetaroot(const ::std::string& value) {
  set_has_pnlmetaroot();
  if (pnlmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    pnlmetaroot_ = new ::std::string;
  }
  pnlmetaroot_->assign(value);
}
inline void FantasyNameBalMeta::set_pnlmetaroot(const char* value) {
  set_has_pnlmetaroot();
  if (pnlmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    pnlmetaroot_ = new ::std::string;
  }
  pnlmetaroot_->assign(value);
}
inline void FantasyNameBalMeta::set_pnlmetaroot(const void* value, size_t size) {
  set_has_pnlmetaroot();
  if (pnlmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    pnlmetaroot_ = new ::std::string;
  }
  pnlmetaroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FantasyNameBalMeta::mutable_pnlmetaroot() {
  set_has_pnlmetaroot();
  if (pnlmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    pnlmetaroot_ = new ::std::string;
  }
  return pnlmetaroot_;
}
inline ::std::string* FantasyNameBalMeta::release_pnlmetaroot() {
  clear_has_pnlmetaroot();
  if (pnlmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pnlmetaroot_;
    pnlmetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FantasyNameBalMeta::set_allocated_pnlmetaroot(::std::string* pnlmetaroot) {
  if (pnlmetaroot_ != &::google::protobuf::internal::kEmptyString) {
    delete pnlmetaroot_;
  }
  if (pnlmetaroot) {
    set_has_pnlmetaroot();
    pnlmetaroot_ = pnlmetaroot;
  } else {
    clear_has_pnlmetaroot();
    pnlmetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes prev = 70;
inline bool FantasyNameBalMeta::has_prev() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void FantasyNameBalMeta::set_has_prev() {
  _has_bits_[0] |= 0x00000100u;
}
inline void FantasyNameBalMeta::clear_has_prev() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void FantasyNameBalMeta::clear_prev() {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    prev_->clear();
  }
  clear_has_prev();
}
inline const ::std::string& FantasyNameBalMeta::prev() const {
  return *prev_;
}
inline void FantasyNameBalMeta::set_prev(const ::std::string& value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void FantasyNameBalMeta::set_prev(const char* value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void FantasyNameBalMeta::set_prev(const void* value, size_t size) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FantasyNameBalMeta::mutable_prev() {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  return prev_;
}
inline ::std::string* FantasyNameBalMeta::release_prev() {
  clear_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prev_;
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FantasyNameBalMeta::set_allocated_prev(::std::string* prev) {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    delete prev_;
  }
  if (prev) {
    set_has_prev();
    prev_ = prev;
  } else {
    clear_has_prev();
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes next = 80;
inline bool FantasyNameBalMeta::has_next() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void FantasyNameBalMeta::set_has_next() {
  _has_bits_[0] |= 0x00000200u;
}
inline void FantasyNameBalMeta::clear_has_next() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void FantasyNameBalMeta::clear_next() {
  if (next_ != &::google::protobuf::internal::kEmptyString) {
    next_->clear();
  }
  clear_has_next();
}
inline const ::std::string& FantasyNameBalMeta::next() const {
  return *next_;
}
inline void FantasyNameBalMeta::set_next(const ::std::string& value) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(value);
}
inline void FantasyNameBalMeta::set_next(const char* value) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(value);
}
inline void FantasyNameBalMeta::set_next(const void* value, size_t size) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FantasyNameBalMeta::mutable_next() {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  return next_;
}
inline ::std::string* FantasyNameBalMeta::release_next() {
  clear_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = next_;
    next_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FantasyNameBalMeta::set_allocated_next(::std::string* next) {
  if (next_ != &::google::protobuf::internal::kEmptyString) {
    delete next_;
  }
  if (next) {
    set_has_next();
    next_ = next;
  } else {
    clear_has_next();
    next_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FantasyNameState

// optional string name = 1;
inline bool FantasyNameState::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FantasyNameState::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FantasyNameState::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FantasyNameState::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& FantasyNameState::name() const {
  return *name_;
}
inline void FantasyNameState::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FantasyNameState::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FantasyNameState::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FantasyNameState::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* FantasyNameState::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FantasyNameState::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes fantasynamebalmetaid = 10;
inline bool FantasyNameState::has_fantasynamebalmetaid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FantasyNameState::set_has_fantasynamebalmetaid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FantasyNameState::clear_has_fantasynamebalmetaid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FantasyNameState::clear_fantasynamebalmetaid() {
  if (fantasynamebalmetaid_ != &::google::protobuf::internal::kEmptyString) {
    fantasynamebalmetaid_->clear();
  }
  clear_has_fantasynamebalmetaid();
}
inline const ::std::string& FantasyNameState::fantasynamebalmetaid() const {
  return *fantasynamebalmetaid_;
}
inline void FantasyNameState::set_fantasynamebalmetaid(const ::std::string& value) {
  set_has_fantasynamebalmetaid();
  if (fantasynamebalmetaid_ == &::google::protobuf::internal::kEmptyString) {
    fantasynamebalmetaid_ = new ::std::string;
  }
  fantasynamebalmetaid_->assign(value);
}
inline void FantasyNameState::set_fantasynamebalmetaid(const char* value) {
  set_has_fantasynamebalmetaid();
  if (fantasynamebalmetaid_ == &::google::protobuf::internal::kEmptyString) {
    fantasynamebalmetaid_ = new ::std::string;
  }
  fantasynamebalmetaid_->assign(value);
}
inline void FantasyNameState::set_fantasynamebalmetaid(const void* value, size_t size) {
  set_has_fantasynamebalmetaid();
  if (fantasynamebalmetaid_ == &::google::protobuf::internal::kEmptyString) {
    fantasynamebalmetaid_ = new ::std::string;
  }
  fantasynamebalmetaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FantasyNameState::mutable_fantasynamebalmetaid() {
  set_has_fantasynamebalmetaid();
  if (fantasynamebalmetaid_ == &::google::protobuf::internal::kEmptyString) {
    fantasynamebalmetaid_ = new ::std::string;
  }
  return fantasynamebalmetaid_;
}
inline ::std::string* FantasyNameState::release_fantasynamebalmetaid() {
  clear_has_fantasynamebalmetaid();
  if (fantasynamebalmetaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fantasynamebalmetaid_;
    fantasynamebalmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FantasyNameState::set_allocated_fantasynamebalmetaid(::std::string* fantasynamebalmetaid) {
  if (fantasynamebalmetaid_ != &::google::protobuf::internal::kEmptyString) {
    delete fantasynamebalmetaid_;
  }
  if (fantasynamebalmetaid) {
    set_has_fantasynamebalmetaid();
    fantasynamebalmetaid_ = fantasynamebalmetaid;
  } else {
    clear_has_fantasynamebalmetaid();
    fantasynamebalmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes posmetaroot = 20;
inline bool FantasyNameState::has_posmetaroot() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FantasyNameState::set_has_posmetaroot() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FantasyNameState::clear_has_posmetaroot() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FantasyNameState::clear_posmetaroot() {
  if (posmetaroot_ != &::google::protobuf::internal::kEmptyString) {
    posmetaroot_->clear();
  }
  clear_has_posmetaroot();
}
inline const ::std::string& FantasyNameState::posmetaroot() const {
  return *posmetaroot_;
}
inline void FantasyNameState::set_posmetaroot(const ::std::string& value) {
  set_has_posmetaroot();
  if (posmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    posmetaroot_ = new ::std::string;
  }
  posmetaroot_->assign(value);
}
inline void FantasyNameState::set_posmetaroot(const char* value) {
  set_has_posmetaroot();
  if (posmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    posmetaroot_ = new ::std::string;
  }
  posmetaroot_->assign(value);
}
inline void FantasyNameState::set_posmetaroot(const void* value, size_t size) {
  set_has_posmetaroot();
  if (posmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    posmetaroot_ = new ::std::string;
  }
  posmetaroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FantasyNameState::mutable_posmetaroot() {
  set_has_posmetaroot();
  if (posmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    posmetaroot_ = new ::std::string;
  }
  return posmetaroot_;
}
inline ::std::string* FantasyNameState::release_posmetaroot() {
  clear_has_posmetaroot();
  if (posmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = posmetaroot_;
    posmetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FantasyNameState::set_allocated_posmetaroot(::std::string* posmetaroot) {
  if (posmetaroot_ != &::google::protobuf::internal::kEmptyString) {
    delete posmetaroot_;
  }
  if (posmetaroot) {
    set_has_posmetaroot();
    posmetaroot_ = posmetaroot;
  } else {
    clear_has_posmetaroot();
    posmetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes ordersmetaroot = 30;
inline bool FantasyNameState::has_ordersmetaroot() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FantasyNameState::set_has_ordersmetaroot() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FantasyNameState::clear_has_ordersmetaroot() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FantasyNameState::clear_ordersmetaroot() {
  if (ordersmetaroot_ != &::google::protobuf::internal::kEmptyString) {
    ordersmetaroot_->clear();
  }
  clear_has_ordersmetaroot();
}
inline const ::std::string& FantasyNameState::ordersmetaroot() const {
  return *ordersmetaroot_;
}
inline void FantasyNameState::set_ordersmetaroot(const ::std::string& value) {
  set_has_ordersmetaroot();
  if (ordersmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    ordersmetaroot_ = new ::std::string;
  }
  ordersmetaroot_->assign(value);
}
inline void FantasyNameState::set_ordersmetaroot(const char* value) {
  set_has_ordersmetaroot();
  if (ordersmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    ordersmetaroot_ = new ::std::string;
  }
  ordersmetaroot_->assign(value);
}
inline void FantasyNameState::set_ordersmetaroot(const void* value, size_t size) {
  set_has_ordersmetaroot();
  if (ordersmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    ordersmetaroot_ = new ::std::string;
  }
  ordersmetaroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FantasyNameState::mutable_ordersmetaroot() {
  set_has_ordersmetaroot();
  if (ordersmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    ordersmetaroot_ = new ::std::string;
  }
  return ordersmetaroot_;
}
inline ::std::string* FantasyNameState::release_ordersmetaroot() {
  clear_has_ordersmetaroot();
  if (ordersmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ordersmetaroot_;
    ordersmetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FantasyNameState::set_allocated_ordersmetaroot(::std::string* ordersmetaroot) {
  if (ordersmetaroot_ != &::google::protobuf::internal::kEmptyString) {
    delete ordersmetaroot_;
  }
  if (ordersmetaroot) {
    set_has_ordersmetaroot();
    ordersmetaroot_ = ordersmetaroot;
  } else {
    clear_has_ordersmetaroot();
    ordersmetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes projmetaroot = 40;
inline bool FantasyNameState::has_projmetaroot() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FantasyNameState::set_has_projmetaroot() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FantasyNameState::clear_has_projmetaroot() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FantasyNameState::clear_projmetaroot() {
  if (projmetaroot_ != &::google::protobuf::internal::kEmptyString) {
    projmetaroot_->clear();
  }
  clear_has_projmetaroot();
}
inline const ::std::string& FantasyNameState::projmetaroot() const {
  return *projmetaroot_;
}
inline void FantasyNameState::set_projmetaroot(const ::std::string& value) {
  set_has_projmetaroot();
  if (projmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    projmetaroot_ = new ::std::string;
  }
  projmetaroot_->assign(value);
}
inline void FantasyNameState::set_projmetaroot(const char* value) {
  set_has_projmetaroot();
  if (projmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    projmetaroot_ = new ::std::string;
  }
  projmetaroot_->assign(value);
}
inline void FantasyNameState::set_projmetaroot(const void* value, size_t size) {
  set_has_projmetaroot();
  if (projmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    projmetaroot_ = new ::std::string;
  }
  projmetaroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FantasyNameState::mutable_projmetaroot() {
  set_has_projmetaroot();
  if (projmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    projmetaroot_ = new ::std::string;
  }
  return projmetaroot_;
}
inline ::std::string* FantasyNameState::release_projmetaroot() {
  clear_has_projmetaroot();
  if (projmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = projmetaroot_;
    projmetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FantasyNameState::set_allocated_projmetaroot(::std::string* projmetaroot) {
  if (projmetaroot_ != &::google::protobuf::internal::kEmptyString) {
    delete projmetaroot_;
  }
  if (projmetaroot) {
    set_has_projmetaroot();
    projmetaroot_ = projmetaroot;
  } else {
    clear_has_projmetaroot();
    projmetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes prev = 70;
inline bool FantasyNameState::has_prev() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FantasyNameState::set_has_prev() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FantasyNameState::clear_has_prev() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FantasyNameState::clear_prev() {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    prev_->clear();
  }
  clear_has_prev();
}
inline const ::std::string& FantasyNameState::prev() const {
  return *prev_;
}
inline void FantasyNameState::set_prev(const ::std::string& value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void FantasyNameState::set_prev(const char* value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void FantasyNameState::set_prev(const void* value, size_t size) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FantasyNameState::mutable_prev() {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  return prev_;
}
inline ::std::string* FantasyNameState::release_prev() {
  clear_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prev_;
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FantasyNameState::set_allocated_prev(::std::string* prev) {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    delete prev_;
  }
  if (prev) {
    set_has_prev();
    prev_ = prev;
  } else {
    clear_has_prev();
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes next = 80;
inline bool FantasyNameState::has_next() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FantasyNameState::set_has_next() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FantasyNameState::clear_has_next() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FantasyNameState::clear_next() {
  if (next_ != &::google::protobuf::internal::kEmptyString) {
    next_->clear();
  }
  clear_has_next();
}
inline const ::std::string& FantasyNameState::next() const {
  return *next_;
}
inline void FantasyNameState::set_next(const ::std::string& value) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(value);
}
inline void FantasyNameState::set_next(const char* value) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(value);
}
inline void FantasyNameState::set_next(const void* value, size_t size) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FantasyNameState::mutable_next() {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  return next_;
}
inline ::std::string* FantasyNameState::release_next() {
  clear_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = next_;
    next_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FantasyNameState::set_allocated_next(::std::string* next) {
  if (next_ != &::google::protobuf::internal::kEmptyString) {
    delete next_;
  }
  if (next) {
    set_has_next();
    next_ = next;
  } else {
    clear_has_next();
    next_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes txmetaid = 50;
inline bool FantasyNameState::has_txmetaid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FantasyNameState::set_has_txmetaid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FantasyNameState::clear_has_txmetaid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FantasyNameState::clear_txmetaid() {
  if (txmetaid_ != &::google::protobuf::internal::kEmptyString) {
    txmetaid_->clear();
  }
  clear_has_txmetaid();
}
inline const ::std::string& FantasyNameState::txmetaid() const {
  return *txmetaid_;
}
inline void FantasyNameState::set_txmetaid(const ::std::string& value) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(value);
}
inline void FantasyNameState::set_txmetaid(const char* value) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(value);
}
inline void FantasyNameState::set_txmetaid(const void* value, size_t size) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FantasyNameState::mutable_txmetaid() {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  return txmetaid_;
}
inline ::std::string* FantasyNameState::release_txmetaid() {
  clear_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = txmetaid_;
    txmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FantasyNameState::set_allocated_txmetaid(::std::string* txmetaid) {
  if (txmetaid_ != &::google::protobuf::internal::kEmptyString) {
    delete txmetaid_;
  }
  if (txmetaid) {
    set_has_txmetaid();
    txmetaid_ = txmetaid;
  } else {
    clear_has_txmetaid();
    txmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// WeekGameStatusMeta

// optional uint32 week = 10;
inline bool WeekGameStatusMeta::has_week() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WeekGameStatusMeta::set_has_week() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WeekGameStatusMeta::clear_has_week() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WeekGameStatusMeta::clear_week() {
  week_ = 0u;
  clear_has_week();
}
inline ::google::protobuf::uint32 WeekGameStatusMeta::week() const {
  return week_;
}
inline void WeekGameStatusMeta::set_week(::google::protobuf::uint32 value) {
  set_has_week();
  week_ = value;
}

// optional bytes gameresultmetaroot = 20;
inline bool WeekGameStatusMeta::has_gameresultmetaroot() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WeekGameStatusMeta::set_has_gameresultmetaroot() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WeekGameStatusMeta::clear_has_gameresultmetaroot() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WeekGameStatusMeta::clear_gameresultmetaroot() {
  if (gameresultmetaroot_ != &::google::protobuf::internal::kEmptyString) {
    gameresultmetaroot_->clear();
  }
  clear_has_gameresultmetaroot();
}
inline const ::std::string& WeekGameStatusMeta::gameresultmetaroot() const {
  return *gameresultmetaroot_;
}
inline void WeekGameStatusMeta::set_gameresultmetaroot(const ::std::string& value) {
  set_has_gameresultmetaroot();
  if (gameresultmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    gameresultmetaroot_ = new ::std::string;
  }
  gameresultmetaroot_->assign(value);
}
inline void WeekGameStatusMeta::set_gameresultmetaroot(const char* value) {
  set_has_gameresultmetaroot();
  if (gameresultmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    gameresultmetaroot_ = new ::std::string;
  }
  gameresultmetaroot_->assign(value);
}
inline void WeekGameStatusMeta::set_gameresultmetaroot(const void* value, size_t size) {
  set_has_gameresultmetaroot();
  if (gameresultmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    gameresultmetaroot_ = new ::std::string;
  }
  gameresultmetaroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WeekGameStatusMeta::mutable_gameresultmetaroot() {
  set_has_gameresultmetaroot();
  if (gameresultmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    gameresultmetaroot_ = new ::std::string;
  }
  return gameresultmetaroot_;
}
inline ::std::string* WeekGameStatusMeta::release_gameresultmetaroot() {
  clear_has_gameresultmetaroot();
  if (gameresultmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gameresultmetaroot_;
    gameresultmetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WeekGameStatusMeta::set_allocated_gameresultmetaroot(::std::string* gameresultmetaroot) {
  if (gameresultmetaroot_ != &::google::protobuf::internal::kEmptyString) {
    delete gameresultmetaroot_;
  }
  if (gameresultmetaroot) {
    set_has_gameresultmetaroot();
    gameresultmetaroot_ = gameresultmetaroot;
  } else {
    clear_has_gameresultmetaroot();
    gameresultmetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes ingameprojmetaroot = 30;
inline bool WeekGameStatusMeta::has_ingameprojmetaroot() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WeekGameStatusMeta::set_has_ingameprojmetaroot() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WeekGameStatusMeta::clear_has_ingameprojmetaroot() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WeekGameStatusMeta::clear_ingameprojmetaroot() {
  if (ingameprojmetaroot_ != &::google::protobuf::internal::kEmptyString) {
    ingameprojmetaroot_->clear();
  }
  clear_has_ingameprojmetaroot();
}
inline const ::std::string& WeekGameStatusMeta::ingameprojmetaroot() const {
  return *ingameprojmetaroot_;
}
inline void WeekGameStatusMeta::set_ingameprojmetaroot(const ::std::string& value) {
  set_has_ingameprojmetaroot();
  if (ingameprojmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    ingameprojmetaroot_ = new ::std::string;
  }
  ingameprojmetaroot_->assign(value);
}
inline void WeekGameStatusMeta::set_ingameprojmetaroot(const char* value) {
  set_has_ingameprojmetaroot();
  if (ingameprojmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    ingameprojmetaroot_ = new ::std::string;
  }
  ingameprojmetaroot_->assign(value);
}
inline void WeekGameStatusMeta::set_ingameprojmetaroot(const void* value, size_t size) {
  set_has_ingameprojmetaroot();
  if (ingameprojmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    ingameprojmetaroot_ = new ::std::string;
  }
  ingameprojmetaroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WeekGameStatusMeta::mutable_ingameprojmetaroot() {
  set_has_ingameprojmetaroot();
  if (ingameprojmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    ingameprojmetaroot_ = new ::std::string;
  }
  return ingameprojmetaroot_;
}
inline ::std::string* WeekGameStatusMeta::release_ingameprojmetaroot() {
  clear_has_ingameprojmetaroot();
  if (ingameprojmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ingameprojmetaroot_;
    ingameprojmetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WeekGameStatusMeta::set_allocated_ingameprojmetaroot(::std::string* ingameprojmetaroot) {
  if (ingameprojmetaroot_ != &::google::protobuf::internal::kEmptyString) {
    delete ingameprojmetaroot_;
  }
  if (ingameprojmetaroot) {
    set_has_ingameprojmetaroot();
    ingameprojmetaroot_ = ingameprojmetaroot;
  } else {
    clear_has_ingameprojmetaroot();
    ingameprojmetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes opengamestatusroot = 40;
inline bool WeekGameStatusMeta::has_opengamestatusroot() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WeekGameStatusMeta::set_has_opengamestatusroot() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WeekGameStatusMeta::clear_has_opengamestatusroot() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WeekGameStatusMeta::clear_opengamestatusroot() {
  if (opengamestatusroot_ != &::google::protobuf::internal::kEmptyString) {
    opengamestatusroot_->clear();
  }
  clear_has_opengamestatusroot();
}
inline const ::std::string& WeekGameStatusMeta::opengamestatusroot() const {
  return *opengamestatusroot_;
}
inline void WeekGameStatusMeta::set_opengamestatusroot(const ::std::string& value) {
  set_has_opengamestatusroot();
  if (opengamestatusroot_ == &::google::protobuf::internal::kEmptyString) {
    opengamestatusroot_ = new ::std::string;
  }
  opengamestatusroot_->assign(value);
}
inline void WeekGameStatusMeta::set_opengamestatusroot(const char* value) {
  set_has_opengamestatusroot();
  if (opengamestatusroot_ == &::google::protobuf::internal::kEmptyString) {
    opengamestatusroot_ = new ::std::string;
  }
  opengamestatusroot_->assign(value);
}
inline void WeekGameStatusMeta::set_opengamestatusroot(const void* value, size_t size) {
  set_has_opengamestatusroot();
  if (opengamestatusroot_ == &::google::protobuf::internal::kEmptyString) {
    opengamestatusroot_ = new ::std::string;
  }
  opengamestatusroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WeekGameStatusMeta::mutable_opengamestatusroot() {
  set_has_opengamestatusroot();
  if (opengamestatusroot_ == &::google::protobuf::internal::kEmptyString) {
    opengamestatusroot_ = new ::std::string;
  }
  return opengamestatusroot_;
}
inline ::std::string* WeekGameStatusMeta::release_opengamestatusroot() {
  clear_has_opengamestatusroot();
  if (opengamestatusroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = opengamestatusroot_;
    opengamestatusroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WeekGameStatusMeta::set_allocated_opengamestatusroot(::std::string* opengamestatusroot) {
  if (opengamestatusroot_ != &::google::protobuf::internal::kEmptyString) {
    delete opengamestatusroot_;
  }
  if (opengamestatusroot) {
    set_has_opengamestatusroot();
    opengamestatusroot_ = opengamestatusroot;
  } else {
    clear_has_opengamestatusroot();
    opengamestatusroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes prev = 50;
inline bool WeekGameStatusMeta::has_prev() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WeekGameStatusMeta::set_has_prev() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WeekGameStatusMeta::clear_has_prev() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WeekGameStatusMeta::clear_prev() {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    prev_->clear();
  }
  clear_has_prev();
}
inline const ::std::string& WeekGameStatusMeta::prev() const {
  return *prev_;
}
inline void WeekGameStatusMeta::set_prev(const ::std::string& value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void WeekGameStatusMeta::set_prev(const char* value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void WeekGameStatusMeta::set_prev(const void* value, size_t size) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WeekGameStatusMeta::mutable_prev() {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  return prev_;
}
inline ::std::string* WeekGameStatusMeta::release_prev() {
  clear_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prev_;
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WeekGameStatusMeta::set_allocated_prev(::std::string* prev) {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    delete prev_;
  }
  if (prev) {
    set_has_prev();
    prev_ = prev;
  } else {
    clear_has_prev();
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes next = 60;
inline bool WeekGameStatusMeta::has_next() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void WeekGameStatusMeta::set_has_next() {
  _has_bits_[0] |= 0x00000020u;
}
inline void WeekGameStatusMeta::clear_has_next() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void WeekGameStatusMeta::clear_next() {
  if (next_ != &::google::protobuf::internal::kEmptyString) {
    next_->clear();
  }
  clear_has_next();
}
inline const ::std::string& WeekGameStatusMeta::next() const {
  return *next_;
}
inline void WeekGameStatusMeta::set_next(const ::std::string& value) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(value);
}
inline void WeekGameStatusMeta::set_next(const char* value) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(value);
}
inline void WeekGameStatusMeta::set_next(const void* value, size_t size) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WeekGameStatusMeta::mutable_next() {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  return next_;
}
inline ::std::string* WeekGameStatusMeta::release_next() {
  clear_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = next_;
    next_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WeekGameStatusMeta::set_allocated_next(::std::string* next) {
  if (next_ != &::google::protobuf::internal::kEmptyString) {
    delete next_;
  }
  if (next) {
    set_has_next();
    next_ = next;
  } else {
    clear_has_next();
    next_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// InGameProjMeta

// optional string gameid = 20;
inline bool InGameProjMeta::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InGameProjMeta::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InGameProjMeta::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InGameProjMeta::clear_gameid() {
  if (gameid_ != &::google::protobuf::internal::kEmptyString) {
    gameid_->clear();
  }
  clear_has_gameid();
}
inline const ::std::string& InGameProjMeta::gameid() const {
  return *gameid_;
}
inline void InGameProjMeta::set_gameid(const ::std::string& value) {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  gameid_->assign(value);
}
inline void InGameProjMeta::set_gameid(const char* value) {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  gameid_->assign(value);
}
inline void InGameProjMeta::set_gameid(const char* value, size_t size) {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  gameid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InGameProjMeta::mutable_gameid() {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  return gameid_;
}
inline ::std::string* InGameProjMeta::release_gameid() {
  clear_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gameid_;
    gameid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InGameProjMeta::set_allocated_gameid(::std::string* gameid) {
  if (gameid_ != &::google::protobuf::internal::kEmptyString) {
    delete gameid_;
  }
  if (gameid) {
    set_has_gameid();
    gameid_ = gameid;
  } else {
    clear_has_gameid();
    gameid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes gamestatusmetaid = 40;
inline bool InGameProjMeta::has_gamestatusmetaid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InGameProjMeta::set_has_gamestatusmetaid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InGameProjMeta::clear_has_gamestatusmetaid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InGameProjMeta::clear_gamestatusmetaid() {
  if (gamestatusmetaid_ != &::google::protobuf::internal::kEmptyString) {
    gamestatusmetaid_->clear();
  }
  clear_has_gamestatusmetaid();
}
inline const ::std::string& InGameProjMeta::gamestatusmetaid() const {
  return *gamestatusmetaid_;
}
inline void InGameProjMeta::set_gamestatusmetaid(const ::std::string& value) {
  set_has_gamestatusmetaid();
  if (gamestatusmetaid_ == &::google::protobuf::internal::kEmptyString) {
    gamestatusmetaid_ = new ::std::string;
  }
  gamestatusmetaid_->assign(value);
}
inline void InGameProjMeta::set_gamestatusmetaid(const char* value) {
  set_has_gamestatusmetaid();
  if (gamestatusmetaid_ == &::google::protobuf::internal::kEmptyString) {
    gamestatusmetaid_ = new ::std::string;
  }
  gamestatusmetaid_->assign(value);
}
inline void InGameProjMeta::set_gamestatusmetaid(const void* value, size_t size) {
  set_has_gamestatusmetaid();
  if (gamestatusmetaid_ == &::google::protobuf::internal::kEmptyString) {
    gamestatusmetaid_ = new ::std::string;
  }
  gamestatusmetaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InGameProjMeta::mutable_gamestatusmetaid() {
  set_has_gamestatusmetaid();
  if (gamestatusmetaid_ == &::google::protobuf::internal::kEmptyString) {
    gamestatusmetaid_ = new ::std::string;
  }
  return gamestatusmetaid_;
}
inline ::std::string* InGameProjMeta::release_gamestatusmetaid() {
  clear_has_gamestatusmetaid();
  if (gamestatusmetaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gamestatusmetaid_;
    gamestatusmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InGameProjMeta::set_allocated_gamestatusmetaid(::std::string* gamestatusmetaid) {
  if (gamestatusmetaid_ != &::google::protobuf::internal::kEmptyString) {
    delete gamestatusmetaid_;
  }
  if (gamestatusmetaid) {
    set_has_gamestatusmetaid();
    gamestatusmetaid_ = gamestatusmetaid;
  } else {
    clear_has_gamestatusmetaid();
    gamestatusmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes homeprojmeta = 60;
inline bool InGameProjMeta::has_homeprojmeta() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InGameProjMeta::set_has_homeprojmeta() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InGameProjMeta::clear_has_homeprojmeta() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InGameProjMeta::clear_homeprojmeta() {
  if (homeprojmeta_ != &::google::protobuf::internal::kEmptyString) {
    homeprojmeta_->clear();
  }
  clear_has_homeprojmeta();
}
inline const ::std::string& InGameProjMeta::homeprojmeta() const {
  return *homeprojmeta_;
}
inline void InGameProjMeta::set_homeprojmeta(const ::std::string& value) {
  set_has_homeprojmeta();
  if (homeprojmeta_ == &::google::protobuf::internal::kEmptyString) {
    homeprojmeta_ = new ::std::string;
  }
  homeprojmeta_->assign(value);
}
inline void InGameProjMeta::set_homeprojmeta(const char* value) {
  set_has_homeprojmeta();
  if (homeprojmeta_ == &::google::protobuf::internal::kEmptyString) {
    homeprojmeta_ = new ::std::string;
  }
  homeprojmeta_->assign(value);
}
inline void InGameProjMeta::set_homeprojmeta(const void* value, size_t size) {
  set_has_homeprojmeta();
  if (homeprojmeta_ == &::google::protobuf::internal::kEmptyString) {
    homeprojmeta_ = new ::std::string;
  }
  homeprojmeta_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InGameProjMeta::mutable_homeprojmeta() {
  set_has_homeprojmeta();
  if (homeprojmeta_ == &::google::protobuf::internal::kEmptyString) {
    homeprojmeta_ = new ::std::string;
  }
  return homeprojmeta_;
}
inline ::std::string* InGameProjMeta::release_homeprojmeta() {
  clear_has_homeprojmeta();
  if (homeprojmeta_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = homeprojmeta_;
    homeprojmeta_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InGameProjMeta::set_allocated_homeprojmeta(::std::string* homeprojmeta) {
  if (homeprojmeta_ != &::google::protobuf::internal::kEmptyString) {
    delete homeprojmeta_;
  }
  if (homeprojmeta) {
    set_has_homeprojmeta();
    homeprojmeta_ = homeprojmeta;
  } else {
    clear_has_homeprojmeta();
    homeprojmeta_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes awayprojmeta = 70;
inline bool InGameProjMeta::has_awayprojmeta() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InGameProjMeta::set_has_awayprojmeta() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InGameProjMeta::clear_has_awayprojmeta() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InGameProjMeta::clear_awayprojmeta() {
  if (awayprojmeta_ != &::google::protobuf::internal::kEmptyString) {
    awayprojmeta_->clear();
  }
  clear_has_awayprojmeta();
}
inline const ::std::string& InGameProjMeta::awayprojmeta() const {
  return *awayprojmeta_;
}
inline void InGameProjMeta::set_awayprojmeta(const ::std::string& value) {
  set_has_awayprojmeta();
  if (awayprojmeta_ == &::google::protobuf::internal::kEmptyString) {
    awayprojmeta_ = new ::std::string;
  }
  awayprojmeta_->assign(value);
}
inline void InGameProjMeta::set_awayprojmeta(const char* value) {
  set_has_awayprojmeta();
  if (awayprojmeta_ == &::google::protobuf::internal::kEmptyString) {
    awayprojmeta_ = new ::std::string;
  }
  awayprojmeta_->assign(value);
}
inline void InGameProjMeta::set_awayprojmeta(const void* value, size_t size) {
  set_has_awayprojmeta();
  if (awayprojmeta_ == &::google::protobuf::internal::kEmptyString) {
    awayprojmeta_ = new ::std::string;
  }
  awayprojmeta_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InGameProjMeta::mutable_awayprojmeta() {
  set_has_awayprojmeta();
  if (awayprojmeta_ == &::google::protobuf::internal::kEmptyString) {
    awayprojmeta_ = new ::std::string;
  }
  return awayprojmeta_;
}
inline ::std::string* InGameProjMeta::release_awayprojmeta() {
  clear_has_awayprojmeta();
  if (awayprojmeta_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = awayprojmeta_;
    awayprojmeta_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InGameProjMeta::set_allocated_awayprojmeta(::std::string* awayprojmeta) {
  if (awayprojmeta_ != &::google::protobuf::internal::kEmptyString) {
    delete awayprojmeta_;
  }
  if (awayprojmeta) {
    set_has_awayprojmeta();
    awayprojmeta_ = awayprojmeta;
  } else {
    clear_has_awayprojmeta();
    awayprojmeta_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes gamedatametaid = 50;
inline bool InGameProjMeta::has_gamedatametaid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InGameProjMeta::set_has_gamedatametaid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InGameProjMeta::clear_has_gamedatametaid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InGameProjMeta::clear_gamedatametaid() {
  if (gamedatametaid_ != &::google::protobuf::internal::kEmptyString) {
    gamedatametaid_->clear();
  }
  clear_has_gamedatametaid();
}
inline const ::std::string& InGameProjMeta::gamedatametaid() const {
  return *gamedatametaid_;
}
inline void InGameProjMeta::set_gamedatametaid(const ::std::string& value) {
  set_has_gamedatametaid();
  if (gamedatametaid_ == &::google::protobuf::internal::kEmptyString) {
    gamedatametaid_ = new ::std::string;
  }
  gamedatametaid_->assign(value);
}
inline void InGameProjMeta::set_gamedatametaid(const char* value) {
  set_has_gamedatametaid();
  if (gamedatametaid_ == &::google::protobuf::internal::kEmptyString) {
    gamedatametaid_ = new ::std::string;
  }
  gamedatametaid_->assign(value);
}
inline void InGameProjMeta::set_gamedatametaid(const void* value, size_t size) {
  set_has_gamedatametaid();
  if (gamedatametaid_ == &::google::protobuf::internal::kEmptyString) {
    gamedatametaid_ = new ::std::string;
  }
  gamedatametaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InGameProjMeta::mutable_gamedatametaid() {
  set_has_gamedatametaid();
  if (gamedatametaid_ == &::google::protobuf::internal::kEmptyString) {
    gamedatametaid_ = new ::std::string;
  }
  return gamedatametaid_;
}
inline ::std::string* InGameProjMeta::release_gamedatametaid() {
  clear_has_gamedatametaid();
  if (gamedatametaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gamedatametaid_;
    gamedatametaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InGameProjMeta::set_allocated_gamedatametaid(::std::string* gamedatametaid) {
  if (gamedatametaid_ != &::google::protobuf::internal::kEmptyString) {
    delete gamedatametaid_;
  }
  if (gamedatametaid) {
    set_has_gamedatametaid();
    gamedatametaid_ = gamedatametaid;
  } else {
    clear_has_gamedatametaid();
    gamedatametaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GameResultsMeta

// optional string gameid = 20;
inline bool GameResultsMeta::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameResultsMeta::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameResultsMeta::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameResultsMeta::clear_gameid() {
  if (gameid_ != &::google::protobuf::internal::kEmptyString) {
    gameid_->clear();
  }
  clear_has_gameid();
}
inline const ::std::string& GameResultsMeta::gameid() const {
  return *gameid_;
}
inline void GameResultsMeta::set_gameid(const ::std::string& value) {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  gameid_->assign(value);
}
inline void GameResultsMeta::set_gameid(const char* value) {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  gameid_->assign(value);
}
inline void GameResultsMeta::set_gameid(const char* value, size_t size) {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  gameid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameResultsMeta::mutable_gameid() {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  return gameid_;
}
inline ::std::string* GameResultsMeta::release_gameid() {
  clear_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gameid_;
    gameid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameResultsMeta::set_allocated_gameid(::std::string* gameid) {
  if (gameid_ != &::google::protobuf::internal::kEmptyString) {
    delete gameid_;
  }
  if (gameid) {
    set_has_gameid();
    gameid_ = gameid;
  } else {
    clear_has_gameid();
    gameid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes gamestatusmetaid = 40;
inline bool GameResultsMeta::has_gamestatusmetaid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameResultsMeta::set_has_gamestatusmetaid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameResultsMeta::clear_has_gamestatusmetaid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameResultsMeta::clear_gamestatusmetaid() {
  if (gamestatusmetaid_ != &::google::protobuf::internal::kEmptyString) {
    gamestatusmetaid_->clear();
  }
  clear_has_gamestatusmetaid();
}
inline const ::std::string& GameResultsMeta::gamestatusmetaid() const {
  return *gamestatusmetaid_;
}
inline void GameResultsMeta::set_gamestatusmetaid(const ::std::string& value) {
  set_has_gamestatusmetaid();
  if (gamestatusmetaid_ == &::google::protobuf::internal::kEmptyString) {
    gamestatusmetaid_ = new ::std::string;
  }
  gamestatusmetaid_->assign(value);
}
inline void GameResultsMeta::set_gamestatusmetaid(const char* value) {
  set_has_gamestatusmetaid();
  if (gamestatusmetaid_ == &::google::protobuf::internal::kEmptyString) {
    gamestatusmetaid_ = new ::std::string;
  }
  gamestatusmetaid_->assign(value);
}
inline void GameResultsMeta::set_gamestatusmetaid(const void* value, size_t size) {
  set_has_gamestatusmetaid();
  if (gamestatusmetaid_ == &::google::protobuf::internal::kEmptyString) {
    gamestatusmetaid_ = new ::std::string;
  }
  gamestatusmetaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameResultsMeta::mutable_gamestatusmetaid() {
  set_has_gamestatusmetaid();
  if (gamestatusmetaid_ == &::google::protobuf::internal::kEmptyString) {
    gamestatusmetaid_ = new ::std::string;
  }
  return gamestatusmetaid_;
}
inline ::std::string* GameResultsMeta::release_gamestatusmetaid() {
  clear_has_gamestatusmetaid();
  if (gamestatusmetaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gamestatusmetaid_;
    gamestatusmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameResultsMeta::set_allocated_gamestatusmetaid(::std::string* gamestatusmetaid) {
  if (gamestatusmetaid_ != &::google::protobuf::internal::kEmptyString) {
    delete gamestatusmetaid_;
  }
  if (gamestatusmetaid) {
    set_has_gamestatusmetaid();
    gamestatusmetaid_ = gamestatusmetaid;
  } else {
    clear_has_gamestatusmetaid();
    gamestatusmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes homeresultmeta = 60;
inline bool GameResultsMeta::has_homeresultmeta() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameResultsMeta::set_has_homeresultmeta() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameResultsMeta::clear_has_homeresultmeta() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameResultsMeta::clear_homeresultmeta() {
  if (homeresultmeta_ != &::google::protobuf::internal::kEmptyString) {
    homeresultmeta_->clear();
  }
  clear_has_homeresultmeta();
}
inline const ::std::string& GameResultsMeta::homeresultmeta() const {
  return *homeresultmeta_;
}
inline void GameResultsMeta::set_homeresultmeta(const ::std::string& value) {
  set_has_homeresultmeta();
  if (homeresultmeta_ == &::google::protobuf::internal::kEmptyString) {
    homeresultmeta_ = new ::std::string;
  }
  homeresultmeta_->assign(value);
}
inline void GameResultsMeta::set_homeresultmeta(const char* value) {
  set_has_homeresultmeta();
  if (homeresultmeta_ == &::google::protobuf::internal::kEmptyString) {
    homeresultmeta_ = new ::std::string;
  }
  homeresultmeta_->assign(value);
}
inline void GameResultsMeta::set_homeresultmeta(const void* value, size_t size) {
  set_has_homeresultmeta();
  if (homeresultmeta_ == &::google::protobuf::internal::kEmptyString) {
    homeresultmeta_ = new ::std::string;
  }
  homeresultmeta_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameResultsMeta::mutable_homeresultmeta() {
  set_has_homeresultmeta();
  if (homeresultmeta_ == &::google::protobuf::internal::kEmptyString) {
    homeresultmeta_ = new ::std::string;
  }
  return homeresultmeta_;
}
inline ::std::string* GameResultsMeta::release_homeresultmeta() {
  clear_has_homeresultmeta();
  if (homeresultmeta_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = homeresultmeta_;
    homeresultmeta_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameResultsMeta::set_allocated_homeresultmeta(::std::string* homeresultmeta) {
  if (homeresultmeta_ != &::google::protobuf::internal::kEmptyString) {
    delete homeresultmeta_;
  }
  if (homeresultmeta) {
    set_has_homeresultmeta();
    homeresultmeta_ = homeresultmeta;
  } else {
    clear_has_homeresultmeta();
    homeresultmeta_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes awayresultmeta = 70;
inline bool GameResultsMeta::has_awayresultmeta() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameResultsMeta::set_has_awayresultmeta() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameResultsMeta::clear_has_awayresultmeta() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameResultsMeta::clear_awayresultmeta() {
  if (awayresultmeta_ != &::google::protobuf::internal::kEmptyString) {
    awayresultmeta_->clear();
  }
  clear_has_awayresultmeta();
}
inline const ::std::string& GameResultsMeta::awayresultmeta() const {
  return *awayresultmeta_;
}
inline void GameResultsMeta::set_awayresultmeta(const ::std::string& value) {
  set_has_awayresultmeta();
  if (awayresultmeta_ == &::google::protobuf::internal::kEmptyString) {
    awayresultmeta_ = new ::std::string;
  }
  awayresultmeta_->assign(value);
}
inline void GameResultsMeta::set_awayresultmeta(const char* value) {
  set_has_awayresultmeta();
  if (awayresultmeta_ == &::google::protobuf::internal::kEmptyString) {
    awayresultmeta_ = new ::std::string;
  }
  awayresultmeta_->assign(value);
}
inline void GameResultsMeta::set_awayresultmeta(const void* value, size_t size) {
  set_has_awayresultmeta();
  if (awayresultmeta_ == &::google::protobuf::internal::kEmptyString) {
    awayresultmeta_ = new ::std::string;
  }
  awayresultmeta_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameResultsMeta::mutable_awayresultmeta() {
  set_has_awayresultmeta();
  if (awayresultmeta_ == &::google::protobuf::internal::kEmptyString) {
    awayresultmeta_ = new ::std::string;
  }
  return awayresultmeta_;
}
inline ::std::string* GameResultsMeta::release_awayresultmeta() {
  clear_has_awayresultmeta();
  if (awayresultmeta_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = awayresultmeta_;
    awayresultmeta_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameResultsMeta::set_allocated_awayresultmeta(::std::string* awayresultmeta) {
  if (awayresultmeta_ != &::google::protobuf::internal::kEmptyString) {
    delete awayresultmeta_;
  }
  if (awayresultmeta) {
    set_has_awayresultmeta();
    awayresultmeta_ = awayresultmeta;
  } else {
    clear_has_awayresultmeta();
    awayresultmeta_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes resultdatametaid = 50;
inline bool GameResultsMeta::has_resultdatametaid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameResultsMeta::set_has_resultdatametaid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameResultsMeta::clear_has_resultdatametaid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameResultsMeta::clear_resultdatametaid() {
  if (resultdatametaid_ != &::google::protobuf::internal::kEmptyString) {
    resultdatametaid_->clear();
  }
  clear_has_resultdatametaid();
}
inline const ::std::string& GameResultsMeta::resultdatametaid() const {
  return *resultdatametaid_;
}
inline void GameResultsMeta::set_resultdatametaid(const ::std::string& value) {
  set_has_resultdatametaid();
  if (resultdatametaid_ == &::google::protobuf::internal::kEmptyString) {
    resultdatametaid_ = new ::std::string;
  }
  resultdatametaid_->assign(value);
}
inline void GameResultsMeta::set_resultdatametaid(const char* value) {
  set_has_resultdatametaid();
  if (resultdatametaid_ == &::google::protobuf::internal::kEmptyString) {
    resultdatametaid_ = new ::std::string;
  }
  resultdatametaid_->assign(value);
}
inline void GameResultsMeta::set_resultdatametaid(const void* value, size_t size) {
  set_has_resultdatametaid();
  if (resultdatametaid_ == &::google::protobuf::internal::kEmptyString) {
    resultdatametaid_ = new ::std::string;
  }
  resultdatametaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameResultsMeta::mutable_resultdatametaid() {
  set_has_resultdatametaid();
  if (resultdatametaid_ == &::google::protobuf::internal::kEmptyString) {
    resultdatametaid_ = new ::std::string;
  }
  return resultdatametaid_;
}
inline ::std::string* GameResultsMeta::release_resultdatametaid() {
  clear_has_resultdatametaid();
  if (resultdatametaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resultdatametaid_;
    resultdatametaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameResultsMeta::set_allocated_resultdatametaid(::std::string* resultdatametaid) {
  if (resultdatametaid_ != &::google::protobuf::internal::kEmptyString) {
    delete resultdatametaid_;
  }
  if (resultdatametaid) {
    set_has_resultdatametaid();
    resultdatametaid_ = resultdatametaid;
  } else {
    clear_has_resultdatametaid();
    resultdatametaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GameStatusMeta

// optional string id = 1;
inline bool GameStatusMeta::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameStatusMeta::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameStatusMeta::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameStatusMeta::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& GameStatusMeta::id() const {
  return *id_;
}
inline void GameStatusMeta::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void GameStatusMeta::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void GameStatusMeta::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameStatusMeta::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* GameStatusMeta::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameStatusMeta::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 week = 2;
inline bool GameStatusMeta::has_week() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameStatusMeta::set_has_week() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameStatusMeta::clear_has_week() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameStatusMeta::clear_week() {
  week_ = 0;
  clear_has_week();
}
inline ::google::protobuf::int32 GameStatusMeta::week() const {
  return week_;
}
inline void GameStatusMeta::set_week(::google::protobuf::int32 value) {
  set_has_week();
  week_ = value;
}

// optional .fantasybit.GameInfo gameinfo = 10;
inline bool GameStatusMeta::has_gameinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameStatusMeta::set_has_gameinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameStatusMeta::clear_has_gameinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameStatusMeta::clear_gameinfo() {
  if (gameinfo_ != NULL) gameinfo_->::fantasybit::GameInfo::Clear();
  clear_has_gameinfo();
}
inline const ::fantasybit::GameInfo& GameStatusMeta::gameinfo() const {
  return gameinfo_ != NULL ? *gameinfo_ : *default_instance_->gameinfo_;
}
inline ::fantasybit::GameInfo* GameStatusMeta::mutable_gameinfo() {
  set_has_gameinfo();
  if (gameinfo_ == NULL) gameinfo_ = new ::fantasybit::GameInfo;
  return gameinfo_;
}
inline ::fantasybit::GameInfo* GameStatusMeta::release_gameinfo() {
  clear_has_gameinfo();
  ::fantasybit::GameInfo* temp = gameinfo_;
  gameinfo_ = NULL;
  return temp;
}
inline void GameStatusMeta::set_allocated_gameinfo(::fantasybit::GameInfo* gameinfo) {
  delete gameinfo_;
  gameinfo_ = gameinfo;
  if (gameinfo) {
    set_has_gameinfo();
  } else {
    clear_has_gameinfo();
  }
}

// optional .fantasybit.GameStatus gamesatus = 20;
inline bool GameStatusMeta::has_gamesatus() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameStatusMeta::set_has_gamesatus() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameStatusMeta::clear_has_gamesatus() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameStatusMeta::clear_gamesatus() {
  if (gamesatus_ != NULL) gamesatus_->::fantasybit::GameStatus::Clear();
  clear_has_gamesatus();
}
inline const ::fantasybit::GameStatus& GameStatusMeta::gamesatus() const {
  return gamesatus_ != NULL ? *gamesatus_ : *default_instance_->gamesatus_;
}
inline ::fantasybit::GameStatus* GameStatusMeta::mutable_gamesatus() {
  set_has_gamesatus();
  if (gamesatus_ == NULL) gamesatus_ = new ::fantasybit::GameStatus;
  return gamesatus_;
}
inline ::fantasybit::GameStatus* GameStatusMeta::release_gamesatus() {
  clear_has_gamesatus();
  ::fantasybit::GameStatus* temp = gamesatus_;
  gamesatus_ = NULL;
  return temp;
}
inline void GameStatusMeta::set_allocated_gamesatus(::fantasybit::GameStatus* gamesatus) {
  delete gamesatus_;
  gamesatus_ = gamesatus;
  if (gamesatus) {
    set_has_gamesatus();
  } else {
    clear_has_gamesatus();
  }
}

// optional bytes gamemetaid = 30;
inline bool GameStatusMeta::has_gamemetaid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameStatusMeta::set_has_gamemetaid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameStatusMeta::clear_has_gamemetaid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameStatusMeta::clear_gamemetaid() {
  if (gamemetaid_ != &::google::protobuf::internal::kEmptyString) {
    gamemetaid_->clear();
  }
  clear_has_gamemetaid();
}
inline const ::std::string& GameStatusMeta::gamemetaid() const {
  return *gamemetaid_;
}
inline void GameStatusMeta::set_gamemetaid(const ::std::string& value) {
  set_has_gamemetaid();
  if (gamemetaid_ == &::google::protobuf::internal::kEmptyString) {
    gamemetaid_ = new ::std::string;
  }
  gamemetaid_->assign(value);
}
inline void GameStatusMeta::set_gamemetaid(const char* value) {
  set_has_gamemetaid();
  if (gamemetaid_ == &::google::protobuf::internal::kEmptyString) {
    gamemetaid_ = new ::std::string;
  }
  gamemetaid_->assign(value);
}
inline void GameStatusMeta::set_gamemetaid(const void* value, size_t size) {
  set_has_gamemetaid();
  if (gamemetaid_ == &::google::protobuf::internal::kEmptyString) {
    gamemetaid_ = new ::std::string;
  }
  gamemetaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameStatusMeta::mutable_gamemetaid() {
  set_has_gamemetaid();
  if (gamemetaid_ == &::google::protobuf::internal::kEmptyString) {
    gamemetaid_ = new ::std::string;
  }
  return gamemetaid_;
}
inline ::std::string* GameStatusMeta::release_gamemetaid() {
  clear_has_gamemetaid();
  if (gamemetaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gamemetaid_;
    gamemetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameStatusMeta::set_allocated_gamemetaid(::std::string* gamemetaid) {
  if (gamemetaid_ != &::google::protobuf::internal::kEmptyString) {
    delete gamemetaid_;
  }
  if (gamemetaid) {
    set_has_gamemetaid();
    gamemetaid_ = gamemetaid;
  } else {
    clear_has_gamemetaid();
    gamemetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes datametaid = 40;
inline bool GameStatusMeta::has_datametaid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GameStatusMeta::set_has_datametaid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GameStatusMeta::clear_has_datametaid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GameStatusMeta::clear_datametaid() {
  if (datametaid_ != &::google::protobuf::internal::kEmptyString) {
    datametaid_->clear();
  }
  clear_has_datametaid();
}
inline const ::std::string& GameStatusMeta::datametaid() const {
  return *datametaid_;
}
inline void GameStatusMeta::set_datametaid(const ::std::string& value) {
  set_has_datametaid();
  if (datametaid_ == &::google::protobuf::internal::kEmptyString) {
    datametaid_ = new ::std::string;
  }
  datametaid_->assign(value);
}
inline void GameStatusMeta::set_datametaid(const char* value) {
  set_has_datametaid();
  if (datametaid_ == &::google::protobuf::internal::kEmptyString) {
    datametaid_ = new ::std::string;
  }
  datametaid_->assign(value);
}
inline void GameStatusMeta::set_datametaid(const void* value, size_t size) {
  set_has_datametaid();
  if (datametaid_ == &::google::protobuf::internal::kEmptyString) {
    datametaid_ = new ::std::string;
  }
  datametaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameStatusMeta::mutable_datametaid() {
  set_has_datametaid();
  if (datametaid_ == &::google::protobuf::internal::kEmptyString) {
    datametaid_ = new ::std::string;
  }
  return datametaid_;
}
inline ::std::string* GameStatusMeta::release_datametaid() {
  clear_has_datametaid();
  if (datametaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = datametaid_;
    datametaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameStatusMeta::set_allocated_datametaid(::std::string* datametaid) {
  if (datametaid_ != &::google::protobuf::internal::kEmptyString) {
    delete datametaid_;
  }
  if (datametaid) {
    set_has_datametaid();
    datametaid_ = datametaid;
  } else {
    clear_has_datametaid();
    datametaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes prev = 50;
inline bool GameStatusMeta::has_prev() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GameStatusMeta::set_has_prev() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GameStatusMeta::clear_has_prev() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GameStatusMeta::clear_prev() {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    prev_->clear();
  }
  clear_has_prev();
}
inline const ::std::string& GameStatusMeta::prev() const {
  return *prev_;
}
inline void GameStatusMeta::set_prev(const ::std::string& value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void GameStatusMeta::set_prev(const char* value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void GameStatusMeta::set_prev(const void* value, size_t size) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameStatusMeta::mutable_prev() {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  return prev_;
}
inline ::std::string* GameStatusMeta::release_prev() {
  clear_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prev_;
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameStatusMeta::set_allocated_prev(::std::string* prev) {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    delete prev_;
  }
  if (prev) {
    set_has_prev();
    prev_ = prev;
  } else {
    clear_has_prev();
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes next = 60;
inline bool GameStatusMeta::has_next() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GameStatusMeta::set_has_next() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GameStatusMeta::clear_has_next() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GameStatusMeta::clear_next() {
  if (next_ != &::google::protobuf::internal::kEmptyString) {
    next_->clear();
  }
  clear_has_next();
}
inline const ::std::string& GameStatusMeta::next() const {
  return *next_;
}
inline void GameStatusMeta::set_next(const ::std::string& value) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(value);
}
inline void GameStatusMeta::set_next(const char* value) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(value);
}
inline void GameStatusMeta::set_next(const void* value, size_t size) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameStatusMeta::mutable_next() {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  return next_;
}
inline ::std::string* GameStatusMeta::release_next() {
  clear_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = next_;
    next_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameStatusMeta::set_allocated_next(::std::string* next) {
  if (next_ != &::google::protobuf::internal::kEmptyString) {
    delete next_;
  }
  if (next) {
    set_has_next();
    next_ = next;
  } else {
    clear_has_next();
    next_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TeamProjMeta

// optional string gameid = 20;
inline bool TeamProjMeta::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TeamProjMeta::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TeamProjMeta::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TeamProjMeta::clear_gameid() {
  if (gameid_ != &::google::protobuf::internal::kEmptyString) {
    gameid_->clear();
  }
  clear_has_gameid();
}
inline const ::std::string& TeamProjMeta::gameid() const {
  return *gameid_;
}
inline void TeamProjMeta::set_gameid(const ::std::string& value) {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  gameid_->assign(value);
}
inline void TeamProjMeta::set_gameid(const char* value) {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  gameid_->assign(value);
}
inline void TeamProjMeta::set_gameid(const char* value, size_t size) {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  gameid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TeamProjMeta::mutable_gameid() {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  return gameid_;
}
inline ::std::string* TeamProjMeta::release_gameid() {
  clear_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gameid_;
    gameid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TeamProjMeta::set_allocated_gameid(::std::string* gameid) {
  if (gameid_ != &::google::protobuf::internal::kEmptyString) {
    delete gameid_;
  }
  if (gameid) {
    set_has_gameid();
    gameid_ = gameid;
  } else {
    clear_has_gameid();
    gameid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string team = 30;
inline bool TeamProjMeta::has_team() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TeamProjMeta::set_has_team() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TeamProjMeta::clear_has_team() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TeamProjMeta::clear_team() {
  if (team_ != &::google::protobuf::internal::kEmptyString) {
    team_->clear();
  }
  clear_has_team();
}
inline const ::std::string& TeamProjMeta::team() const {
  return *team_;
}
inline void TeamProjMeta::set_team(const ::std::string& value) {
  set_has_team();
  if (team_ == &::google::protobuf::internal::kEmptyString) {
    team_ = new ::std::string;
  }
  team_->assign(value);
}
inline void TeamProjMeta::set_team(const char* value) {
  set_has_team();
  if (team_ == &::google::protobuf::internal::kEmptyString) {
    team_ = new ::std::string;
  }
  team_->assign(value);
}
inline void TeamProjMeta::set_team(const char* value, size_t size) {
  set_has_team();
  if (team_ == &::google::protobuf::internal::kEmptyString) {
    team_ = new ::std::string;
  }
  team_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TeamProjMeta::mutable_team() {
  set_has_team();
  if (team_ == &::google::protobuf::internal::kEmptyString) {
    team_ = new ::std::string;
  }
  return team_;
}
inline ::std::string* TeamProjMeta::release_team() {
  clear_has_team();
  if (team_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = team_;
    team_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TeamProjMeta::set_allocated_team(::std::string* team) {
  if (team_ != &::google::protobuf::internal::kEmptyString) {
    delete team_;
  }
  if (team) {
    set_has_team();
    team_ = team;
  } else {
    clear_has_team();
    team_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 kickofftime = 40;
inline bool TeamProjMeta::has_kickofftime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TeamProjMeta::set_has_kickofftime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TeamProjMeta::clear_has_kickofftime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TeamProjMeta::clear_kickofftime() {
  kickofftime_ = 0u;
  clear_has_kickofftime();
}
inline ::google::protobuf::uint32 TeamProjMeta::kickofftime() const {
  return kickofftime_;
}
inline void TeamProjMeta::set_kickofftime(::google::protobuf::uint32 value) {
  set_has_kickofftime();
  kickofftime_ = value;
}

// optional uint32 week = 50;
inline bool TeamProjMeta::has_week() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TeamProjMeta::set_has_week() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TeamProjMeta::clear_has_week() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TeamProjMeta::clear_week() {
  week_ = 0u;
  clear_has_week();
}
inline ::google::protobuf::uint32 TeamProjMeta::week() const {
  return week_;
}
inline void TeamProjMeta::set_week(::google::protobuf::uint32 value) {
  set_has_week();
  week_ = value;
}

// optional bytes gameplayerprojmetaroot = 60;
inline bool TeamProjMeta::has_gameplayerprojmetaroot() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TeamProjMeta::set_has_gameplayerprojmetaroot() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TeamProjMeta::clear_has_gameplayerprojmetaroot() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TeamProjMeta::clear_gameplayerprojmetaroot() {
  if (gameplayerprojmetaroot_ != &::google::protobuf::internal::kEmptyString) {
    gameplayerprojmetaroot_->clear();
  }
  clear_has_gameplayerprojmetaroot();
}
inline const ::std::string& TeamProjMeta::gameplayerprojmetaroot() const {
  return *gameplayerprojmetaroot_;
}
inline void TeamProjMeta::set_gameplayerprojmetaroot(const ::std::string& value) {
  set_has_gameplayerprojmetaroot();
  if (gameplayerprojmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    gameplayerprojmetaroot_ = new ::std::string;
  }
  gameplayerprojmetaroot_->assign(value);
}
inline void TeamProjMeta::set_gameplayerprojmetaroot(const char* value) {
  set_has_gameplayerprojmetaroot();
  if (gameplayerprojmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    gameplayerprojmetaroot_ = new ::std::string;
  }
  gameplayerprojmetaroot_->assign(value);
}
inline void TeamProjMeta::set_gameplayerprojmetaroot(const void* value, size_t size) {
  set_has_gameplayerprojmetaroot();
  if (gameplayerprojmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    gameplayerprojmetaroot_ = new ::std::string;
  }
  gameplayerprojmetaroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TeamProjMeta::mutable_gameplayerprojmetaroot() {
  set_has_gameplayerprojmetaroot();
  if (gameplayerprojmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    gameplayerprojmetaroot_ = new ::std::string;
  }
  return gameplayerprojmetaroot_;
}
inline ::std::string* TeamProjMeta::release_gameplayerprojmetaroot() {
  clear_has_gameplayerprojmetaroot();
  if (gameplayerprojmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gameplayerprojmetaroot_;
    gameplayerprojmetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TeamProjMeta::set_allocated_gameplayerprojmetaroot(::std::string* gameplayerprojmetaroot) {
  if (gameplayerprojmetaroot_ != &::google::protobuf::internal::kEmptyString) {
    delete gameplayerprojmetaroot_;
  }
  if (gameplayerprojmetaroot) {
    set_has_gameplayerprojmetaroot();
    gameplayerprojmetaroot_ = gameplayerprojmetaroot;
  } else {
    clear_has_gameplayerprojmetaroot();
    gameplayerprojmetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes gamedatametaid = 70;
inline bool TeamProjMeta::has_gamedatametaid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TeamProjMeta::set_has_gamedatametaid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TeamProjMeta::clear_has_gamedatametaid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TeamProjMeta::clear_gamedatametaid() {
  if (gamedatametaid_ != &::google::protobuf::internal::kEmptyString) {
    gamedatametaid_->clear();
  }
  clear_has_gamedatametaid();
}
inline const ::std::string& TeamProjMeta::gamedatametaid() const {
  return *gamedatametaid_;
}
inline void TeamProjMeta::set_gamedatametaid(const ::std::string& value) {
  set_has_gamedatametaid();
  if (gamedatametaid_ == &::google::protobuf::internal::kEmptyString) {
    gamedatametaid_ = new ::std::string;
  }
  gamedatametaid_->assign(value);
}
inline void TeamProjMeta::set_gamedatametaid(const char* value) {
  set_has_gamedatametaid();
  if (gamedatametaid_ == &::google::protobuf::internal::kEmptyString) {
    gamedatametaid_ = new ::std::string;
  }
  gamedatametaid_->assign(value);
}
inline void TeamProjMeta::set_gamedatametaid(const void* value, size_t size) {
  set_has_gamedatametaid();
  if (gamedatametaid_ == &::google::protobuf::internal::kEmptyString) {
    gamedatametaid_ = new ::std::string;
  }
  gamedatametaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TeamProjMeta::mutable_gamedatametaid() {
  set_has_gamedatametaid();
  if (gamedatametaid_ == &::google::protobuf::internal::kEmptyString) {
    gamedatametaid_ = new ::std::string;
  }
  return gamedatametaid_;
}
inline ::std::string* TeamProjMeta::release_gamedatametaid() {
  clear_has_gamedatametaid();
  if (gamedatametaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gamedatametaid_;
    gamedatametaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TeamProjMeta::set_allocated_gamedatametaid(::std::string* gamedatametaid) {
  if (gamedatametaid_ != &::google::protobuf::internal::kEmptyString) {
    delete gamedatametaid_;
  }
  if (gamedatametaid) {
    set_has_gamedatametaid();
    gamedatametaid_ = gamedatametaid;
  } else {
    clear_has_gamedatametaid();
    gamedatametaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TeamResultMeta

// optional string gameid = 20;
inline bool TeamResultMeta::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TeamResultMeta::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TeamResultMeta::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TeamResultMeta::clear_gameid() {
  if (gameid_ != &::google::protobuf::internal::kEmptyString) {
    gameid_->clear();
  }
  clear_has_gameid();
}
inline const ::std::string& TeamResultMeta::gameid() const {
  return *gameid_;
}
inline void TeamResultMeta::set_gameid(const ::std::string& value) {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  gameid_->assign(value);
}
inline void TeamResultMeta::set_gameid(const char* value) {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  gameid_->assign(value);
}
inline void TeamResultMeta::set_gameid(const char* value, size_t size) {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  gameid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TeamResultMeta::mutable_gameid() {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  return gameid_;
}
inline ::std::string* TeamResultMeta::release_gameid() {
  clear_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gameid_;
    gameid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TeamResultMeta::set_allocated_gameid(::std::string* gameid) {
  if (gameid_ != &::google::protobuf::internal::kEmptyString) {
    delete gameid_;
  }
  if (gameid) {
    set_has_gameid();
    gameid_ = gameid;
  } else {
    clear_has_gameid();
    gameid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string team = 30;
inline bool TeamResultMeta::has_team() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TeamResultMeta::set_has_team() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TeamResultMeta::clear_has_team() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TeamResultMeta::clear_team() {
  if (team_ != &::google::protobuf::internal::kEmptyString) {
    team_->clear();
  }
  clear_has_team();
}
inline const ::std::string& TeamResultMeta::team() const {
  return *team_;
}
inline void TeamResultMeta::set_team(const ::std::string& value) {
  set_has_team();
  if (team_ == &::google::protobuf::internal::kEmptyString) {
    team_ = new ::std::string;
  }
  team_->assign(value);
}
inline void TeamResultMeta::set_team(const char* value) {
  set_has_team();
  if (team_ == &::google::protobuf::internal::kEmptyString) {
    team_ = new ::std::string;
  }
  team_->assign(value);
}
inline void TeamResultMeta::set_team(const char* value, size_t size) {
  set_has_team();
  if (team_ == &::google::protobuf::internal::kEmptyString) {
    team_ = new ::std::string;
  }
  team_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TeamResultMeta::mutable_team() {
  set_has_team();
  if (team_ == &::google::protobuf::internal::kEmptyString) {
    team_ = new ::std::string;
  }
  return team_;
}
inline ::std::string* TeamResultMeta::release_team() {
  clear_has_team();
  if (team_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = team_;
    team_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TeamResultMeta::set_allocated_team(::std::string* team) {
  if (team_ != &::google::protobuf::internal::kEmptyString) {
    delete team_;
  }
  if (team) {
    set_has_team();
    team_ = team;
  } else {
    clear_has_team();
    team_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 kickofftime = 40;
inline bool TeamResultMeta::has_kickofftime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TeamResultMeta::set_has_kickofftime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TeamResultMeta::clear_has_kickofftime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TeamResultMeta::clear_kickofftime() {
  kickofftime_ = 0u;
  clear_has_kickofftime();
}
inline ::google::protobuf::uint32 TeamResultMeta::kickofftime() const {
  return kickofftime_;
}
inline void TeamResultMeta::set_kickofftime(::google::protobuf::uint32 value) {
  set_has_kickofftime();
  kickofftime_ = value;
}

// optional uint32 week = 50;
inline bool TeamResultMeta::has_week() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TeamResultMeta::set_has_week() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TeamResultMeta::clear_has_week() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TeamResultMeta::clear_week() {
  week_ = 0u;
  clear_has_week();
}
inline ::google::protobuf::uint32 TeamResultMeta::week() const {
  return week_;
}
inline void TeamResultMeta::set_week(::google::protobuf::uint32 value) {
  set_has_week();
  week_ = value;
}

// optional bytes playerresultmetaroot = 60;
inline bool TeamResultMeta::has_playerresultmetaroot() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TeamResultMeta::set_has_playerresultmetaroot() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TeamResultMeta::clear_has_playerresultmetaroot() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TeamResultMeta::clear_playerresultmetaroot() {
  if (playerresultmetaroot_ != &::google::protobuf::internal::kEmptyString) {
    playerresultmetaroot_->clear();
  }
  clear_has_playerresultmetaroot();
}
inline const ::std::string& TeamResultMeta::playerresultmetaroot() const {
  return *playerresultmetaroot_;
}
inline void TeamResultMeta::set_playerresultmetaroot(const ::std::string& value) {
  set_has_playerresultmetaroot();
  if (playerresultmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    playerresultmetaroot_ = new ::std::string;
  }
  playerresultmetaroot_->assign(value);
}
inline void TeamResultMeta::set_playerresultmetaroot(const char* value) {
  set_has_playerresultmetaroot();
  if (playerresultmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    playerresultmetaroot_ = new ::std::string;
  }
  playerresultmetaroot_->assign(value);
}
inline void TeamResultMeta::set_playerresultmetaroot(const void* value, size_t size) {
  set_has_playerresultmetaroot();
  if (playerresultmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    playerresultmetaroot_ = new ::std::string;
  }
  playerresultmetaroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TeamResultMeta::mutable_playerresultmetaroot() {
  set_has_playerresultmetaroot();
  if (playerresultmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    playerresultmetaroot_ = new ::std::string;
  }
  return playerresultmetaroot_;
}
inline ::std::string* TeamResultMeta::release_playerresultmetaroot() {
  clear_has_playerresultmetaroot();
  if (playerresultmetaroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerresultmetaroot_;
    playerresultmetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TeamResultMeta::set_allocated_playerresultmetaroot(::std::string* playerresultmetaroot) {
  if (playerresultmetaroot_ != &::google::protobuf::internal::kEmptyString) {
    delete playerresultmetaroot_;
  }
  if (playerresultmetaroot) {
    set_has_playerresultmetaroot();
    playerresultmetaroot_ = playerresultmetaroot;
  } else {
    clear_has_playerresultmetaroot();
    playerresultmetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes resultdatametaid = 70;
inline bool TeamResultMeta::has_resultdatametaid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TeamResultMeta::set_has_resultdatametaid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TeamResultMeta::clear_has_resultdatametaid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TeamResultMeta::clear_resultdatametaid() {
  if (resultdatametaid_ != &::google::protobuf::internal::kEmptyString) {
    resultdatametaid_->clear();
  }
  clear_has_resultdatametaid();
}
inline const ::std::string& TeamResultMeta::resultdatametaid() const {
  return *resultdatametaid_;
}
inline void TeamResultMeta::set_resultdatametaid(const ::std::string& value) {
  set_has_resultdatametaid();
  if (resultdatametaid_ == &::google::protobuf::internal::kEmptyString) {
    resultdatametaid_ = new ::std::string;
  }
  resultdatametaid_->assign(value);
}
inline void TeamResultMeta::set_resultdatametaid(const char* value) {
  set_has_resultdatametaid();
  if (resultdatametaid_ == &::google::protobuf::internal::kEmptyString) {
    resultdatametaid_ = new ::std::string;
  }
  resultdatametaid_->assign(value);
}
inline void TeamResultMeta::set_resultdatametaid(const void* value, size_t size) {
  set_has_resultdatametaid();
  if (resultdatametaid_ == &::google::protobuf::internal::kEmptyString) {
    resultdatametaid_ = new ::std::string;
  }
  resultdatametaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TeamResultMeta::mutable_resultdatametaid() {
  set_has_resultdatametaid();
  if (resultdatametaid_ == &::google::protobuf::internal::kEmptyString) {
    resultdatametaid_ = new ::std::string;
  }
  return resultdatametaid_;
}
inline ::std::string* TeamResultMeta::release_resultdatametaid() {
  clear_has_resultdatametaid();
  if (resultdatametaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resultdatametaid_;
    resultdatametaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TeamResultMeta::set_allocated_resultdatametaid(::std::string* resultdatametaid) {
  if (resultdatametaid_ != &::google::protobuf::internal::kEmptyString) {
    delete resultdatametaid_;
  }
  if (resultdatametaid) {
    set_has_resultdatametaid();
    resultdatametaid_ = resultdatametaid;
  } else {
    clear_has_resultdatametaid();
    resultdatametaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GamePlayerProjMeta

// optional string playerid = 20;
inline bool GamePlayerProjMeta::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GamePlayerProjMeta::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GamePlayerProjMeta::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GamePlayerProjMeta::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& GamePlayerProjMeta::playerid() const {
  return *playerid_;
}
inline void GamePlayerProjMeta::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void GamePlayerProjMeta::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void GamePlayerProjMeta::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GamePlayerProjMeta::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* GamePlayerProjMeta::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GamePlayerProjMeta::set_allocated_playerid(::std::string* playerid) {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    delete playerid_;
  }
  if (playerid) {
    set_has_playerid();
    playerid_ = playerid;
  } else {
    clear_has_playerid();
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes gamestatusmetaid = 30;
inline bool GamePlayerProjMeta::has_gamestatusmetaid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GamePlayerProjMeta::set_has_gamestatusmetaid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GamePlayerProjMeta::clear_has_gamestatusmetaid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GamePlayerProjMeta::clear_gamestatusmetaid() {
  if (gamestatusmetaid_ != &::google::protobuf::internal::kEmptyString) {
    gamestatusmetaid_->clear();
  }
  clear_has_gamestatusmetaid();
}
inline const ::std::string& GamePlayerProjMeta::gamestatusmetaid() const {
  return *gamestatusmetaid_;
}
inline void GamePlayerProjMeta::set_gamestatusmetaid(const ::std::string& value) {
  set_has_gamestatusmetaid();
  if (gamestatusmetaid_ == &::google::protobuf::internal::kEmptyString) {
    gamestatusmetaid_ = new ::std::string;
  }
  gamestatusmetaid_->assign(value);
}
inline void GamePlayerProjMeta::set_gamestatusmetaid(const char* value) {
  set_has_gamestatusmetaid();
  if (gamestatusmetaid_ == &::google::protobuf::internal::kEmptyString) {
    gamestatusmetaid_ = new ::std::string;
  }
  gamestatusmetaid_->assign(value);
}
inline void GamePlayerProjMeta::set_gamestatusmetaid(const void* value, size_t size) {
  set_has_gamestatusmetaid();
  if (gamestatusmetaid_ == &::google::protobuf::internal::kEmptyString) {
    gamestatusmetaid_ = new ::std::string;
  }
  gamestatusmetaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GamePlayerProjMeta::mutable_gamestatusmetaid() {
  set_has_gamestatusmetaid();
  if (gamestatusmetaid_ == &::google::protobuf::internal::kEmptyString) {
    gamestatusmetaid_ = new ::std::string;
  }
  return gamestatusmetaid_;
}
inline ::std::string* GamePlayerProjMeta::release_gamestatusmetaid() {
  clear_has_gamestatusmetaid();
  if (gamestatusmetaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gamestatusmetaid_;
    gamestatusmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GamePlayerProjMeta::set_allocated_gamestatusmetaid(::std::string* gamestatusmetaid) {
  if (gamestatusmetaid_ != &::google::protobuf::internal::kEmptyString) {
    delete gamestatusmetaid_;
  }
  if (gamestatusmetaid) {
    set_has_gamestatusmetaid();
    gamestatusmetaid_ = gamestatusmetaid;
  } else {
    clear_has_gamestatusmetaid();
    gamestatusmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes projmetaplayerroot = 60;
inline bool GamePlayerProjMeta::has_projmetaplayerroot() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GamePlayerProjMeta::set_has_projmetaplayerroot() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GamePlayerProjMeta::clear_has_projmetaplayerroot() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GamePlayerProjMeta::clear_projmetaplayerroot() {
  if (projmetaplayerroot_ != &::google::protobuf::internal::kEmptyString) {
    projmetaplayerroot_->clear();
  }
  clear_has_projmetaplayerroot();
}
inline const ::std::string& GamePlayerProjMeta::projmetaplayerroot() const {
  return *projmetaplayerroot_;
}
inline void GamePlayerProjMeta::set_projmetaplayerroot(const ::std::string& value) {
  set_has_projmetaplayerroot();
  if (projmetaplayerroot_ == &::google::protobuf::internal::kEmptyString) {
    projmetaplayerroot_ = new ::std::string;
  }
  projmetaplayerroot_->assign(value);
}
inline void GamePlayerProjMeta::set_projmetaplayerroot(const char* value) {
  set_has_projmetaplayerroot();
  if (projmetaplayerroot_ == &::google::protobuf::internal::kEmptyString) {
    projmetaplayerroot_ = new ::std::string;
  }
  projmetaplayerroot_->assign(value);
}
inline void GamePlayerProjMeta::set_projmetaplayerroot(const void* value, size_t size) {
  set_has_projmetaplayerroot();
  if (projmetaplayerroot_ == &::google::protobuf::internal::kEmptyString) {
    projmetaplayerroot_ = new ::std::string;
  }
  projmetaplayerroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GamePlayerProjMeta::mutable_projmetaplayerroot() {
  set_has_projmetaplayerroot();
  if (projmetaplayerroot_ == &::google::protobuf::internal::kEmptyString) {
    projmetaplayerroot_ = new ::std::string;
  }
  return projmetaplayerroot_;
}
inline ::std::string* GamePlayerProjMeta::release_projmetaplayerroot() {
  clear_has_projmetaplayerroot();
  if (projmetaplayerroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = projmetaplayerroot_;
    projmetaplayerroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GamePlayerProjMeta::set_allocated_projmetaplayerroot(::std::string* projmetaplayerroot) {
  if (projmetaplayerroot_ != &::google::protobuf::internal::kEmptyString) {
    delete projmetaplayerroot_;
  }
  if (projmetaplayerroot) {
    set_has_projmetaplayerroot();
    projmetaplayerroot_ = projmetaplayerroot;
  } else {
    clear_has_projmetaplayerroot();
    projmetaplayerroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes posmetaplayerroot = 70;
inline bool GamePlayerProjMeta::has_posmetaplayerroot() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GamePlayerProjMeta::set_has_posmetaplayerroot() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GamePlayerProjMeta::clear_has_posmetaplayerroot() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GamePlayerProjMeta::clear_posmetaplayerroot() {
  if (posmetaplayerroot_ != &::google::protobuf::internal::kEmptyString) {
    posmetaplayerroot_->clear();
  }
  clear_has_posmetaplayerroot();
}
inline const ::std::string& GamePlayerProjMeta::posmetaplayerroot() const {
  return *posmetaplayerroot_;
}
inline void GamePlayerProjMeta::set_posmetaplayerroot(const ::std::string& value) {
  set_has_posmetaplayerroot();
  if (posmetaplayerroot_ == &::google::protobuf::internal::kEmptyString) {
    posmetaplayerroot_ = new ::std::string;
  }
  posmetaplayerroot_->assign(value);
}
inline void GamePlayerProjMeta::set_posmetaplayerroot(const char* value) {
  set_has_posmetaplayerroot();
  if (posmetaplayerroot_ == &::google::protobuf::internal::kEmptyString) {
    posmetaplayerroot_ = new ::std::string;
  }
  posmetaplayerroot_->assign(value);
}
inline void GamePlayerProjMeta::set_posmetaplayerroot(const void* value, size_t size) {
  set_has_posmetaplayerroot();
  if (posmetaplayerroot_ == &::google::protobuf::internal::kEmptyString) {
    posmetaplayerroot_ = new ::std::string;
  }
  posmetaplayerroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GamePlayerProjMeta::mutable_posmetaplayerroot() {
  set_has_posmetaplayerroot();
  if (posmetaplayerroot_ == &::google::protobuf::internal::kEmptyString) {
    posmetaplayerroot_ = new ::std::string;
  }
  return posmetaplayerroot_;
}
inline ::std::string* GamePlayerProjMeta::release_posmetaplayerroot() {
  clear_has_posmetaplayerroot();
  if (posmetaplayerroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = posmetaplayerroot_;
    posmetaplayerroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GamePlayerProjMeta::set_allocated_posmetaplayerroot(::std::string* posmetaplayerroot) {
  if (posmetaplayerroot_ != &::google::protobuf::internal::kEmptyString) {
    delete posmetaplayerroot_;
  }
  if (posmetaplayerroot) {
    set_has_posmetaplayerroot();
    posmetaplayerroot_ = posmetaplayerroot;
  } else {
    clear_has_posmetaplayerroot();
    posmetaplayerroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes gamedatametaid = 80;
inline bool GamePlayerProjMeta::has_gamedatametaid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GamePlayerProjMeta::set_has_gamedatametaid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GamePlayerProjMeta::clear_has_gamedatametaid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GamePlayerProjMeta::clear_gamedatametaid() {
  if (gamedatametaid_ != &::google::protobuf::internal::kEmptyString) {
    gamedatametaid_->clear();
  }
  clear_has_gamedatametaid();
}
inline const ::std::string& GamePlayerProjMeta::gamedatametaid() const {
  return *gamedatametaid_;
}
inline void GamePlayerProjMeta::set_gamedatametaid(const ::std::string& value) {
  set_has_gamedatametaid();
  if (gamedatametaid_ == &::google::protobuf::internal::kEmptyString) {
    gamedatametaid_ = new ::std::string;
  }
  gamedatametaid_->assign(value);
}
inline void GamePlayerProjMeta::set_gamedatametaid(const char* value) {
  set_has_gamedatametaid();
  if (gamedatametaid_ == &::google::protobuf::internal::kEmptyString) {
    gamedatametaid_ = new ::std::string;
  }
  gamedatametaid_->assign(value);
}
inline void GamePlayerProjMeta::set_gamedatametaid(const void* value, size_t size) {
  set_has_gamedatametaid();
  if (gamedatametaid_ == &::google::protobuf::internal::kEmptyString) {
    gamedatametaid_ = new ::std::string;
  }
  gamedatametaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GamePlayerProjMeta::mutable_gamedatametaid() {
  set_has_gamedatametaid();
  if (gamedatametaid_ == &::google::protobuf::internal::kEmptyString) {
    gamedatametaid_ = new ::std::string;
  }
  return gamedatametaid_;
}
inline ::std::string* GamePlayerProjMeta::release_gamedatametaid() {
  clear_has_gamedatametaid();
  if (gamedatametaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gamedatametaid_;
    gamedatametaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GamePlayerProjMeta::set_allocated_gamedatametaid(::std::string* gamedatametaid) {
  if (gamedatametaid_ != &::google::protobuf::internal::kEmptyString) {
    delete gamedatametaid_;
  }
  if (gamedatametaid) {
    set_has_gamedatametaid();
    gamedatametaid_ = gamedatametaid;
  } else {
    clear_has_gamedatametaid();
    gamedatametaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ProjMeta

// optional string name = 10;
inline bool ProjMeta::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProjMeta::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProjMeta::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProjMeta::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ProjMeta::name() const {
  return *name_;
}
inline void ProjMeta::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ProjMeta::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ProjMeta::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProjMeta::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ProjMeta::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProjMeta::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 proj = 20;
inline bool ProjMeta::has_proj() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProjMeta::set_has_proj() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProjMeta::clear_has_proj() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProjMeta::clear_proj() {
  proj_ = 0;
  clear_has_proj();
}
inline ::google::protobuf::int32 ProjMeta::proj() const {
  return proj_;
}
inline void ProjMeta::set_proj(::google::protobuf::int32 value) {
  set_has_proj();
  proj_ = value;
}

// optional string playerid = 30;
inline bool ProjMeta::has_playerid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProjMeta::set_has_playerid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProjMeta::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProjMeta::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& ProjMeta::playerid() const {
  return *playerid_;
}
inline void ProjMeta::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void ProjMeta::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void ProjMeta::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProjMeta::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* ProjMeta::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProjMeta::set_allocated_playerid(::std::string* playerid) {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    delete playerid_;
  }
  if (playerid) {
    set_has_playerid();
    playerid_ = playerid;
  } else {
    clear_has_playerid();
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes txmetaid = 40;
inline bool ProjMeta::has_txmetaid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProjMeta::set_has_txmetaid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProjMeta::clear_has_txmetaid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProjMeta::clear_txmetaid() {
  if (txmetaid_ != &::google::protobuf::internal::kEmptyString) {
    txmetaid_->clear();
  }
  clear_has_txmetaid();
}
inline const ::std::string& ProjMeta::txmetaid() const {
  return *txmetaid_;
}
inline void ProjMeta::set_txmetaid(const ::std::string& value) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(value);
}
inline void ProjMeta::set_txmetaid(const char* value) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(value);
}
inline void ProjMeta::set_txmetaid(const void* value, size_t size) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProjMeta::mutable_txmetaid() {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  return txmetaid_;
}
inline ::std::string* ProjMeta::release_txmetaid() {
  clear_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = txmetaid_;
    txmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProjMeta::set_allocated_txmetaid(::std::string* txmetaid) {
  if (txmetaid_ != &::google::protobuf::internal::kEmptyString) {
    delete txmetaid_;
  }
  if (txmetaid) {
    set_has_txmetaid();
    txmetaid_ = txmetaid;
  } else {
    clear_has_txmetaid();
    txmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes prev = 50;
inline bool ProjMeta::has_prev() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProjMeta::set_has_prev() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProjMeta::clear_has_prev() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProjMeta::clear_prev() {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    prev_->clear();
  }
  clear_has_prev();
}
inline const ::std::string& ProjMeta::prev() const {
  return *prev_;
}
inline void ProjMeta::set_prev(const ::std::string& value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void ProjMeta::set_prev(const char* value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void ProjMeta::set_prev(const void* value, size_t size) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProjMeta::mutable_prev() {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  return prev_;
}
inline ::std::string* ProjMeta::release_prev() {
  clear_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prev_;
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProjMeta::set_allocated_prev(::std::string* prev) {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    delete prev_;
  }
  if (prev) {
    set_has_prev();
    prev_ = prev;
  } else {
    clear_has_prev();
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PosMeta

// optional string name = 10;
inline bool PosMeta::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PosMeta::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PosMeta::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PosMeta::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PosMeta::name() const {
  return *name_;
}
inline void PosMeta::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PosMeta::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PosMeta::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PosMeta::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* PosMeta::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PosMeta::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 qty = 20;
inline bool PosMeta::has_qty() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PosMeta::set_has_qty() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PosMeta::clear_has_qty() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PosMeta::clear_qty() {
  qty_ = 0;
  clear_has_qty();
}
inline ::google::protobuf::int32 PosMeta::qty() const {
  return qty_;
}
inline void PosMeta::set_qty(::google::protobuf::int32 value) {
  set_has_qty();
  qty_ = value;
}

// optional int32 price = 30;
inline bool PosMeta::has_price() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PosMeta::set_has_price() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PosMeta::clear_has_price() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PosMeta::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 PosMeta::price() const {
  return price_;
}
inline void PosMeta::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
}

// optional string playerid = 40;
inline bool PosMeta::has_playerid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PosMeta::set_has_playerid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PosMeta::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PosMeta::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& PosMeta::playerid() const {
  return *playerid_;
}
inline void PosMeta::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void PosMeta::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void PosMeta::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PosMeta::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* PosMeta::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PosMeta::set_allocated_playerid(::std::string* playerid) {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    delete playerid_;
  }
  if (playerid) {
    set_has_playerid();
    playerid_ = playerid;
  } else {
    clear_has_playerid();
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes txmetaid = 50;
inline bool PosMeta::has_txmetaid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PosMeta::set_has_txmetaid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PosMeta::clear_has_txmetaid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PosMeta::clear_txmetaid() {
  if (txmetaid_ != &::google::protobuf::internal::kEmptyString) {
    txmetaid_->clear();
  }
  clear_has_txmetaid();
}
inline const ::std::string& PosMeta::txmetaid() const {
  return *txmetaid_;
}
inline void PosMeta::set_txmetaid(const ::std::string& value) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(value);
}
inline void PosMeta::set_txmetaid(const char* value) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(value);
}
inline void PosMeta::set_txmetaid(const void* value, size_t size) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PosMeta::mutable_txmetaid() {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  return txmetaid_;
}
inline ::std::string* PosMeta::release_txmetaid() {
  clear_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = txmetaid_;
    txmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PosMeta::set_allocated_txmetaid(::std::string* txmetaid) {
  if (txmetaid_ != &::google::protobuf::internal::kEmptyString) {
    delete txmetaid_;
  }
  if (txmetaid) {
    set_has_txmetaid();
    txmetaid_ = txmetaid;
  } else {
    clear_has_txmetaid();
    txmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes prev = 60;
inline bool PosMeta::has_prev() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PosMeta::set_has_prev() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PosMeta::clear_has_prev() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PosMeta::clear_prev() {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    prev_->clear();
  }
  clear_has_prev();
}
inline const ::std::string& PosMeta::prev() const {
  return *prev_;
}
inline void PosMeta::set_prev(const ::std::string& value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void PosMeta::set_prev(const char* value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void PosMeta::set_prev(const void* value, size_t size) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PosMeta::mutable_prev() {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  return prev_;
}
inline ::std::string* PosMeta::release_prev() {
  clear_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prev_;
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PosMeta::set_allocated_prev(::std::string* prev) {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    delete prev_;
  }
  if (prev) {
    set_has_prev();
    prev_ = prev;
  } else {
    clear_has_prev();
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PlayerResultMeta

// optional bytes playergamestatsid = 10;
inline bool PlayerResultMeta::has_playergamestatsid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerResultMeta::set_has_playergamestatsid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerResultMeta::clear_has_playergamestatsid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerResultMeta::clear_playergamestatsid() {
  if (playergamestatsid_ != &::google::protobuf::internal::kEmptyString) {
    playergamestatsid_->clear();
  }
  clear_has_playergamestatsid();
}
inline const ::std::string& PlayerResultMeta::playergamestatsid() const {
  return *playergamestatsid_;
}
inline void PlayerResultMeta::set_playergamestatsid(const ::std::string& value) {
  set_has_playergamestatsid();
  if (playergamestatsid_ == &::google::protobuf::internal::kEmptyString) {
    playergamestatsid_ = new ::std::string;
  }
  playergamestatsid_->assign(value);
}
inline void PlayerResultMeta::set_playergamestatsid(const char* value) {
  set_has_playergamestatsid();
  if (playergamestatsid_ == &::google::protobuf::internal::kEmptyString) {
    playergamestatsid_ = new ::std::string;
  }
  playergamestatsid_->assign(value);
}
inline void PlayerResultMeta::set_playergamestatsid(const void* value, size_t size) {
  set_has_playergamestatsid();
  if (playergamestatsid_ == &::google::protobuf::internal::kEmptyString) {
    playergamestatsid_ = new ::std::string;
  }
  playergamestatsid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerResultMeta::mutable_playergamestatsid() {
  set_has_playergamestatsid();
  if (playergamestatsid_ == &::google::protobuf::internal::kEmptyString) {
    playergamestatsid_ = new ::std::string;
  }
  return playergamestatsid_;
}
inline ::std::string* PlayerResultMeta::release_playergamestatsid() {
  clear_has_playergamestatsid();
  if (playergamestatsid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playergamestatsid_;
    playergamestatsid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerResultMeta::set_allocated_playergamestatsid(::std::string* playergamestatsid) {
  if (playergamestatsid_ != &::google::protobuf::internal::kEmptyString) {
    delete playergamestatsid_;
  }
  if (playergamestatsid) {
    set_has_playergamestatsid();
    playergamestatsid_ = playergamestatsid;
  } else {
    clear_has_playergamestatsid();
    playergamestatsid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes gamestatusmetaid = 30;
inline bool PlayerResultMeta::has_gamestatusmetaid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerResultMeta::set_has_gamestatusmetaid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerResultMeta::clear_has_gamestatusmetaid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerResultMeta::clear_gamestatusmetaid() {
  if (gamestatusmetaid_ != &::google::protobuf::internal::kEmptyString) {
    gamestatusmetaid_->clear();
  }
  clear_has_gamestatusmetaid();
}
inline const ::std::string& PlayerResultMeta::gamestatusmetaid() const {
  return *gamestatusmetaid_;
}
inline void PlayerResultMeta::set_gamestatusmetaid(const ::std::string& value) {
  set_has_gamestatusmetaid();
  if (gamestatusmetaid_ == &::google::protobuf::internal::kEmptyString) {
    gamestatusmetaid_ = new ::std::string;
  }
  gamestatusmetaid_->assign(value);
}
inline void PlayerResultMeta::set_gamestatusmetaid(const char* value) {
  set_has_gamestatusmetaid();
  if (gamestatusmetaid_ == &::google::protobuf::internal::kEmptyString) {
    gamestatusmetaid_ = new ::std::string;
  }
  gamestatusmetaid_->assign(value);
}
inline void PlayerResultMeta::set_gamestatusmetaid(const void* value, size_t size) {
  set_has_gamestatusmetaid();
  if (gamestatusmetaid_ == &::google::protobuf::internal::kEmptyString) {
    gamestatusmetaid_ = new ::std::string;
  }
  gamestatusmetaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerResultMeta::mutable_gamestatusmetaid() {
  set_has_gamestatusmetaid();
  if (gamestatusmetaid_ == &::google::protobuf::internal::kEmptyString) {
    gamestatusmetaid_ = new ::std::string;
  }
  return gamestatusmetaid_;
}
inline ::std::string* PlayerResultMeta::release_gamestatusmetaid() {
  clear_has_gamestatusmetaid();
  if (gamestatusmetaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gamestatusmetaid_;
    gamestatusmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerResultMeta::set_allocated_gamestatusmetaid(::std::string* gamestatusmetaid) {
  if (gamestatusmetaid_ != &::google::protobuf::internal::kEmptyString) {
    delete gamestatusmetaid_;
  }
  if (gamestatusmetaid) {
    set_has_gamestatusmetaid();
    gamestatusmetaid_ = gamestatusmetaid;
  } else {
    clear_has_gamestatusmetaid();
    gamestatusmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes awardmetaplayerroot = 60;
inline bool PlayerResultMeta::has_awardmetaplayerroot() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerResultMeta::set_has_awardmetaplayerroot() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerResultMeta::clear_has_awardmetaplayerroot() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerResultMeta::clear_awardmetaplayerroot() {
  if (awardmetaplayerroot_ != &::google::protobuf::internal::kEmptyString) {
    awardmetaplayerroot_->clear();
  }
  clear_has_awardmetaplayerroot();
}
inline const ::std::string& PlayerResultMeta::awardmetaplayerroot() const {
  return *awardmetaplayerroot_;
}
inline void PlayerResultMeta::set_awardmetaplayerroot(const ::std::string& value) {
  set_has_awardmetaplayerroot();
  if (awardmetaplayerroot_ == &::google::protobuf::internal::kEmptyString) {
    awardmetaplayerroot_ = new ::std::string;
  }
  awardmetaplayerroot_->assign(value);
}
inline void PlayerResultMeta::set_awardmetaplayerroot(const char* value) {
  set_has_awardmetaplayerroot();
  if (awardmetaplayerroot_ == &::google::protobuf::internal::kEmptyString) {
    awardmetaplayerroot_ = new ::std::string;
  }
  awardmetaplayerroot_->assign(value);
}
inline void PlayerResultMeta::set_awardmetaplayerroot(const void* value, size_t size) {
  set_has_awardmetaplayerroot();
  if (awardmetaplayerroot_ == &::google::protobuf::internal::kEmptyString) {
    awardmetaplayerroot_ = new ::std::string;
  }
  awardmetaplayerroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerResultMeta::mutable_awardmetaplayerroot() {
  set_has_awardmetaplayerroot();
  if (awardmetaplayerroot_ == &::google::protobuf::internal::kEmptyString) {
    awardmetaplayerroot_ = new ::std::string;
  }
  return awardmetaplayerroot_;
}
inline ::std::string* PlayerResultMeta::release_awardmetaplayerroot() {
  clear_has_awardmetaplayerroot();
  if (awardmetaplayerroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = awardmetaplayerroot_;
    awardmetaplayerroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerResultMeta::set_allocated_awardmetaplayerroot(::std::string* awardmetaplayerroot) {
  if (awardmetaplayerroot_ != &::google::protobuf::internal::kEmptyString) {
    delete awardmetaplayerroot_;
  }
  if (awardmetaplayerroot) {
    set_has_awardmetaplayerroot();
    awardmetaplayerroot_ = awardmetaplayerroot;
  } else {
    clear_has_awardmetaplayerroot();
    awardmetaplayerroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes pnlmetaplayerroot = 70;
inline bool PlayerResultMeta::has_pnlmetaplayerroot() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerResultMeta::set_has_pnlmetaplayerroot() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerResultMeta::clear_has_pnlmetaplayerroot() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerResultMeta::clear_pnlmetaplayerroot() {
  if (pnlmetaplayerroot_ != &::google::protobuf::internal::kEmptyString) {
    pnlmetaplayerroot_->clear();
  }
  clear_has_pnlmetaplayerroot();
}
inline const ::std::string& PlayerResultMeta::pnlmetaplayerroot() const {
  return *pnlmetaplayerroot_;
}
inline void PlayerResultMeta::set_pnlmetaplayerroot(const ::std::string& value) {
  set_has_pnlmetaplayerroot();
  if (pnlmetaplayerroot_ == &::google::protobuf::internal::kEmptyString) {
    pnlmetaplayerroot_ = new ::std::string;
  }
  pnlmetaplayerroot_->assign(value);
}
inline void PlayerResultMeta::set_pnlmetaplayerroot(const char* value) {
  set_has_pnlmetaplayerroot();
  if (pnlmetaplayerroot_ == &::google::protobuf::internal::kEmptyString) {
    pnlmetaplayerroot_ = new ::std::string;
  }
  pnlmetaplayerroot_->assign(value);
}
inline void PlayerResultMeta::set_pnlmetaplayerroot(const void* value, size_t size) {
  set_has_pnlmetaplayerroot();
  if (pnlmetaplayerroot_ == &::google::protobuf::internal::kEmptyString) {
    pnlmetaplayerroot_ = new ::std::string;
  }
  pnlmetaplayerroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerResultMeta::mutable_pnlmetaplayerroot() {
  set_has_pnlmetaplayerroot();
  if (pnlmetaplayerroot_ == &::google::protobuf::internal::kEmptyString) {
    pnlmetaplayerroot_ = new ::std::string;
  }
  return pnlmetaplayerroot_;
}
inline ::std::string* PlayerResultMeta::release_pnlmetaplayerroot() {
  clear_has_pnlmetaplayerroot();
  if (pnlmetaplayerroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pnlmetaplayerroot_;
    pnlmetaplayerroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerResultMeta::set_allocated_pnlmetaplayerroot(::std::string* pnlmetaplayerroot) {
  if (pnlmetaplayerroot_ != &::google::protobuf::internal::kEmptyString) {
    delete pnlmetaplayerroot_;
  }
  if (pnlmetaplayerroot) {
    set_has_pnlmetaplayerroot();
    pnlmetaplayerroot_ = pnlmetaplayerroot;
  } else {
    clear_has_pnlmetaplayerroot();
    pnlmetaplayerroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes resultdatametaid = 80;
inline bool PlayerResultMeta::has_resultdatametaid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayerResultMeta::set_has_resultdatametaid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayerResultMeta::clear_has_resultdatametaid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayerResultMeta::clear_resultdatametaid() {
  if (resultdatametaid_ != &::google::protobuf::internal::kEmptyString) {
    resultdatametaid_->clear();
  }
  clear_has_resultdatametaid();
}
inline const ::std::string& PlayerResultMeta::resultdatametaid() const {
  return *resultdatametaid_;
}
inline void PlayerResultMeta::set_resultdatametaid(const ::std::string& value) {
  set_has_resultdatametaid();
  if (resultdatametaid_ == &::google::protobuf::internal::kEmptyString) {
    resultdatametaid_ = new ::std::string;
  }
  resultdatametaid_->assign(value);
}
inline void PlayerResultMeta::set_resultdatametaid(const char* value) {
  set_has_resultdatametaid();
  if (resultdatametaid_ == &::google::protobuf::internal::kEmptyString) {
    resultdatametaid_ = new ::std::string;
  }
  resultdatametaid_->assign(value);
}
inline void PlayerResultMeta::set_resultdatametaid(const void* value, size_t size) {
  set_has_resultdatametaid();
  if (resultdatametaid_ == &::google::protobuf::internal::kEmptyString) {
    resultdatametaid_ = new ::std::string;
  }
  resultdatametaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerResultMeta::mutable_resultdatametaid() {
  set_has_resultdatametaid();
  if (resultdatametaid_ == &::google::protobuf::internal::kEmptyString) {
    resultdatametaid_ = new ::std::string;
  }
  return resultdatametaid_;
}
inline ::std::string* PlayerResultMeta::release_resultdatametaid() {
  clear_has_resultdatametaid();
  if (resultdatametaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resultdatametaid_;
    resultdatametaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerResultMeta::set_allocated_resultdatametaid(::std::string* resultdatametaid) {
  if (resultdatametaid_ != &::google::protobuf::internal::kEmptyString) {
    delete resultdatametaid_;
  }
  if (resultdatametaid) {
    set_has_resultdatametaid();
    resultdatametaid_ = resultdatametaid;
  } else {
    clear_has_resultdatametaid();
    resultdatametaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PlayerGameStats

// optional string playerid = 20;
inline bool PlayerGameStats::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerGameStats::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerGameStats::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerGameStats::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& PlayerGameStats::playerid() const {
  return *playerid_;
}
inline void PlayerGameStats::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void PlayerGameStats::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void PlayerGameStats::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerGameStats::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* PlayerGameStats::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerGameStats::set_allocated_playerid(::std::string* playerid) {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    delete playerid_;
  }
  if (playerid) {
    set_has_playerid();
    playerid_ = playerid;
  } else {
    clear_has_playerid();
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float result = 40;
inline bool PlayerGameStats::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerGameStats::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerGameStats::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerGameStats::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline float PlayerGameStats::result() const {
  return result_;
}
inline void PlayerGameStats::set_result(float value) {
  set_has_result();
  result_ = value;
}

// optional .fantasybit.Stats stats = 50;
inline bool PlayerGameStats::has_stats() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerGameStats::set_has_stats() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerGameStats::clear_has_stats() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerGameStats::clear_stats() {
  if (stats_ != NULL) stats_->::fantasybit::Stats::Clear();
  clear_has_stats();
}
inline const ::fantasybit::Stats& PlayerGameStats::stats() const {
  return stats_ != NULL ? *stats_ : *default_instance_->stats_;
}
inline ::fantasybit::Stats* PlayerGameStats::mutable_stats() {
  set_has_stats();
  if (stats_ == NULL) stats_ = new ::fantasybit::Stats;
  return stats_;
}
inline ::fantasybit::Stats* PlayerGameStats::release_stats() {
  clear_has_stats();
  ::fantasybit::Stats* temp = stats_;
  stats_ = NULL;
  return temp;
}
inline void PlayerGameStats::set_allocated_stats(::fantasybit::Stats* stats) {
  delete stats_;
  stats_ = stats;
  if (stats) {
    set_has_stats();
  } else {
    clear_has_stats();
  }
}

// optional string gameid = 60;
inline bool PlayerGameStats::has_gameid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerGameStats::set_has_gameid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerGameStats::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerGameStats::clear_gameid() {
  if (gameid_ != &::google::protobuf::internal::kEmptyString) {
    gameid_->clear();
  }
  clear_has_gameid();
}
inline const ::std::string& PlayerGameStats::gameid() const {
  return *gameid_;
}
inline void PlayerGameStats::set_gameid(const ::std::string& value) {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  gameid_->assign(value);
}
inline void PlayerGameStats::set_gameid(const char* value) {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  gameid_->assign(value);
}
inline void PlayerGameStats::set_gameid(const char* value, size_t size) {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  gameid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerGameStats::mutable_gameid() {
  set_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    gameid_ = new ::std::string;
  }
  return gameid_;
}
inline ::std::string* PlayerGameStats::release_gameid() {
  clear_has_gameid();
  if (gameid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gameid_;
    gameid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerGameStats::set_allocated_gameid(::std::string* gameid) {
  if (gameid_ != &::google::protobuf::internal::kEmptyString) {
    delete gameid_;
  }
  if (gameid) {
    set_has_gameid();
    gameid_ = gameid;
  } else {
    clear_has_gameid();
    gameid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AwardMeta

// optional string name = 10;
inline bool AwardMeta::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AwardMeta::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AwardMeta::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AwardMeta::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AwardMeta::name() const {
  return *name_;
}
inline void AwardMeta::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AwardMeta::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AwardMeta::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AwardMeta::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* AwardMeta::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AwardMeta::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 proj = 20;
inline bool AwardMeta::has_proj() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AwardMeta::set_has_proj() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AwardMeta::clear_has_proj() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AwardMeta::clear_proj() {
  proj_ = 0;
  clear_has_proj();
}
inline ::google::protobuf::int32 AwardMeta::proj() const {
  return proj_;
}
inline void AwardMeta::set_proj(::google::protobuf::int32 value) {
  set_has_proj();
  proj_ = value;
}

// optional uint64 award = 30;
inline bool AwardMeta::has_award() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AwardMeta::set_has_award() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AwardMeta::clear_has_award() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AwardMeta::clear_award() {
  award_ = GOOGLE_ULONGLONG(0);
  clear_has_award();
}
inline ::google::protobuf::uint64 AwardMeta::award() const {
  return award_;
}
inline void AwardMeta::set_award(::google::protobuf::uint64 value) {
  set_has_award();
  award_ = value;
}

// optional bytes projmetaid = 40;
inline bool AwardMeta::has_projmetaid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AwardMeta::set_has_projmetaid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AwardMeta::clear_has_projmetaid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AwardMeta::clear_projmetaid() {
  if (projmetaid_ != &::google::protobuf::internal::kEmptyString) {
    projmetaid_->clear();
  }
  clear_has_projmetaid();
}
inline const ::std::string& AwardMeta::projmetaid() const {
  return *projmetaid_;
}
inline void AwardMeta::set_projmetaid(const ::std::string& value) {
  set_has_projmetaid();
  if (projmetaid_ == &::google::protobuf::internal::kEmptyString) {
    projmetaid_ = new ::std::string;
  }
  projmetaid_->assign(value);
}
inline void AwardMeta::set_projmetaid(const char* value) {
  set_has_projmetaid();
  if (projmetaid_ == &::google::protobuf::internal::kEmptyString) {
    projmetaid_ = new ::std::string;
  }
  projmetaid_->assign(value);
}
inline void AwardMeta::set_projmetaid(const void* value, size_t size) {
  set_has_projmetaid();
  if (projmetaid_ == &::google::protobuf::internal::kEmptyString) {
    projmetaid_ = new ::std::string;
  }
  projmetaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AwardMeta::mutable_projmetaid() {
  set_has_projmetaid();
  if (projmetaid_ == &::google::protobuf::internal::kEmptyString) {
    projmetaid_ = new ::std::string;
  }
  return projmetaid_;
}
inline ::std::string* AwardMeta::release_projmetaid() {
  clear_has_projmetaid();
  if (projmetaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = projmetaid_;
    projmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AwardMeta::set_allocated_projmetaid(::std::string* projmetaid) {
  if (projmetaid_ != &::google::protobuf::internal::kEmptyString) {
    delete projmetaid_;
  }
  if (projmetaid) {
    set_has_projmetaid();
    projmetaid_ = projmetaid;
  } else {
    clear_has_projmetaid();
    projmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes playergamestatsid = 50;
inline bool AwardMeta::has_playergamestatsid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AwardMeta::set_has_playergamestatsid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AwardMeta::clear_has_playergamestatsid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AwardMeta::clear_playergamestatsid() {
  if (playergamestatsid_ != &::google::protobuf::internal::kEmptyString) {
    playergamestatsid_->clear();
  }
  clear_has_playergamestatsid();
}
inline const ::std::string& AwardMeta::playergamestatsid() const {
  return *playergamestatsid_;
}
inline void AwardMeta::set_playergamestatsid(const ::std::string& value) {
  set_has_playergamestatsid();
  if (playergamestatsid_ == &::google::protobuf::internal::kEmptyString) {
    playergamestatsid_ = new ::std::string;
  }
  playergamestatsid_->assign(value);
}
inline void AwardMeta::set_playergamestatsid(const char* value) {
  set_has_playergamestatsid();
  if (playergamestatsid_ == &::google::protobuf::internal::kEmptyString) {
    playergamestatsid_ = new ::std::string;
  }
  playergamestatsid_->assign(value);
}
inline void AwardMeta::set_playergamestatsid(const void* value, size_t size) {
  set_has_playergamestatsid();
  if (playergamestatsid_ == &::google::protobuf::internal::kEmptyString) {
    playergamestatsid_ = new ::std::string;
  }
  playergamestatsid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AwardMeta::mutable_playergamestatsid() {
  set_has_playergamestatsid();
  if (playergamestatsid_ == &::google::protobuf::internal::kEmptyString) {
    playergamestatsid_ = new ::std::string;
  }
  return playergamestatsid_;
}
inline ::std::string* AwardMeta::release_playergamestatsid() {
  clear_has_playergamestatsid();
  if (playergamestatsid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playergamestatsid_;
    playergamestatsid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AwardMeta::set_allocated_playergamestatsid(::std::string* playergamestatsid) {
  if (playergamestatsid_ != &::google::protobuf::internal::kEmptyString) {
    delete playergamestatsid_;
  }
  if (playergamestatsid) {
    set_has_playergamestatsid();
    playergamestatsid_ = playergamestatsid;
  } else {
    clear_has_playergamestatsid();
    playergamestatsid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PnlMeta

// optional string name = 10;
inline bool PnlMeta::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PnlMeta::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PnlMeta::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PnlMeta::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PnlMeta::name() const {
  return *name_;
}
inline void PnlMeta::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PnlMeta::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PnlMeta::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PnlMeta::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* PnlMeta::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PnlMeta::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 qty = 20;
inline bool PnlMeta::has_qty() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PnlMeta::set_has_qty() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PnlMeta::clear_has_qty() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PnlMeta::clear_qty() {
  qty_ = 0;
  clear_has_qty();
}
inline ::google::protobuf::int32 PnlMeta::qty() const {
  return qty_;
}
inline void PnlMeta::set_qty(::google::protobuf::int32 value) {
  set_has_qty();
  qty_ = value;
}

// optional int32 price = 30;
inline bool PnlMeta::has_price() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PnlMeta::set_has_price() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PnlMeta::clear_has_price() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PnlMeta::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 PnlMeta::price() const {
  return price_;
}
inline void PnlMeta::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
}

// optional int64 pnl = 40;
inline bool PnlMeta::has_pnl() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PnlMeta::set_has_pnl() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PnlMeta::clear_has_pnl() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PnlMeta::clear_pnl() {
  pnl_ = GOOGLE_LONGLONG(0);
  clear_has_pnl();
}
inline ::google::protobuf::int64 PnlMeta::pnl() const {
  return pnl_;
}
inline void PnlMeta::set_pnl(::google::protobuf::int64 value) {
  set_has_pnl();
  pnl_ = value;
}

// optional bytes posmetaid = 50;
inline bool PnlMeta::has_posmetaid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PnlMeta::set_has_posmetaid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PnlMeta::clear_has_posmetaid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PnlMeta::clear_posmetaid() {
  if (posmetaid_ != &::google::protobuf::internal::kEmptyString) {
    posmetaid_->clear();
  }
  clear_has_posmetaid();
}
inline const ::std::string& PnlMeta::posmetaid() const {
  return *posmetaid_;
}
inline void PnlMeta::set_posmetaid(const ::std::string& value) {
  set_has_posmetaid();
  if (posmetaid_ == &::google::protobuf::internal::kEmptyString) {
    posmetaid_ = new ::std::string;
  }
  posmetaid_->assign(value);
}
inline void PnlMeta::set_posmetaid(const char* value) {
  set_has_posmetaid();
  if (posmetaid_ == &::google::protobuf::internal::kEmptyString) {
    posmetaid_ = new ::std::string;
  }
  posmetaid_->assign(value);
}
inline void PnlMeta::set_posmetaid(const void* value, size_t size) {
  set_has_posmetaid();
  if (posmetaid_ == &::google::protobuf::internal::kEmptyString) {
    posmetaid_ = new ::std::string;
  }
  posmetaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PnlMeta::mutable_posmetaid() {
  set_has_posmetaid();
  if (posmetaid_ == &::google::protobuf::internal::kEmptyString) {
    posmetaid_ = new ::std::string;
  }
  return posmetaid_;
}
inline ::std::string* PnlMeta::release_posmetaid() {
  clear_has_posmetaid();
  if (posmetaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = posmetaid_;
    posmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PnlMeta::set_allocated_posmetaid(::std::string* posmetaid) {
  if (posmetaid_ != &::google::protobuf::internal::kEmptyString) {
    delete posmetaid_;
  }
  if (posmetaid) {
    set_has_posmetaid();
    posmetaid_ = posmetaid;
  } else {
    clear_has_posmetaid();
    posmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes playergamestatsid = 60;
inline bool PnlMeta::has_playergamestatsid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PnlMeta::set_has_playergamestatsid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PnlMeta::clear_has_playergamestatsid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PnlMeta::clear_playergamestatsid() {
  if (playergamestatsid_ != &::google::protobuf::internal::kEmptyString) {
    playergamestatsid_->clear();
  }
  clear_has_playergamestatsid();
}
inline const ::std::string& PnlMeta::playergamestatsid() const {
  return *playergamestatsid_;
}
inline void PnlMeta::set_playergamestatsid(const ::std::string& value) {
  set_has_playergamestatsid();
  if (playergamestatsid_ == &::google::protobuf::internal::kEmptyString) {
    playergamestatsid_ = new ::std::string;
  }
  playergamestatsid_->assign(value);
}
inline void PnlMeta::set_playergamestatsid(const char* value) {
  set_has_playergamestatsid();
  if (playergamestatsid_ == &::google::protobuf::internal::kEmptyString) {
    playergamestatsid_ = new ::std::string;
  }
  playergamestatsid_->assign(value);
}
inline void PnlMeta::set_playergamestatsid(const void* value, size_t size) {
  set_has_playergamestatsid();
  if (playergamestatsid_ == &::google::protobuf::internal::kEmptyString) {
    playergamestatsid_ = new ::std::string;
  }
  playergamestatsid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PnlMeta::mutable_playergamestatsid() {
  set_has_playergamestatsid();
  if (playergamestatsid_ == &::google::protobuf::internal::kEmptyString) {
    playergamestatsid_ = new ::std::string;
  }
  return playergamestatsid_;
}
inline ::std::string* PnlMeta::release_playergamestatsid() {
  clear_has_playergamestatsid();
  if (playergamestatsid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playergamestatsid_;
    playergamestatsid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PnlMeta::set_allocated_playergamestatsid(::std::string* playergamestatsid) {
  if (playergamestatsid_ != &::google::protobuf::internal::kEmptyString) {
    delete playergamestatsid_;
  }
  if (playergamestatsid) {
    set_has_playergamestatsid();
    playergamestatsid_ = playergamestatsid;
  } else {
    clear_has_playergamestatsid();
    playergamestatsid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PlayerMarketState

// optional bytes limitbookmetaid = 10;
inline bool PlayerMarketState::has_limitbookmetaid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerMarketState::set_has_limitbookmetaid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerMarketState::clear_has_limitbookmetaid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerMarketState::clear_limitbookmetaid() {
  if (limitbookmetaid_ != &::google::protobuf::internal::kEmptyString) {
    limitbookmetaid_->clear();
  }
  clear_has_limitbookmetaid();
}
inline const ::std::string& PlayerMarketState::limitbookmetaid() const {
  return *limitbookmetaid_;
}
inline void PlayerMarketState::set_limitbookmetaid(const ::std::string& value) {
  set_has_limitbookmetaid();
  if (limitbookmetaid_ == &::google::protobuf::internal::kEmptyString) {
    limitbookmetaid_ = new ::std::string;
  }
  limitbookmetaid_->assign(value);
}
inline void PlayerMarketState::set_limitbookmetaid(const char* value) {
  set_has_limitbookmetaid();
  if (limitbookmetaid_ == &::google::protobuf::internal::kEmptyString) {
    limitbookmetaid_ = new ::std::string;
  }
  limitbookmetaid_->assign(value);
}
inline void PlayerMarketState::set_limitbookmetaid(const void* value, size_t size) {
  set_has_limitbookmetaid();
  if (limitbookmetaid_ == &::google::protobuf::internal::kEmptyString) {
    limitbookmetaid_ = new ::std::string;
  }
  limitbookmetaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerMarketState::mutable_limitbookmetaid() {
  set_has_limitbookmetaid();
  if (limitbookmetaid_ == &::google::protobuf::internal::kEmptyString) {
    limitbookmetaid_ = new ::std::string;
  }
  return limitbookmetaid_;
}
inline ::std::string* PlayerMarketState::release_limitbookmetaid() {
  clear_has_limitbookmetaid();
  if (limitbookmetaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = limitbookmetaid_;
    limitbookmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerMarketState::set_allocated_limitbookmetaid(::std::string* limitbookmetaid) {
  if (limitbookmetaid_ != &::google::protobuf::internal::kEmptyString) {
    delete limitbookmetaid_;
  }
  if (limitbookmetaid) {
    set_has_limitbookmetaid();
    limitbookmetaid_ = limitbookmetaid;
  } else {
    clear_has_limitbookmetaid();
    limitbookmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string playerid = 20;
inline bool PlayerMarketState::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerMarketState::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerMarketState::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerMarketState::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& PlayerMarketState::playerid() const {
  return *playerid_;
}
inline void PlayerMarketState::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void PlayerMarketState::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void PlayerMarketState::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerMarketState::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* PlayerMarketState::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerMarketState::set_allocated_playerid(::std::string* playerid) {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    delete playerid_;
  }
  if (playerid) {
    set_has_playerid();
    playerid_ = playerid;
  } else {
    clear_has_playerid();
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes marketticmetaid = 30;
inline bool PlayerMarketState::has_marketticmetaid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerMarketState::set_has_marketticmetaid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerMarketState::clear_has_marketticmetaid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerMarketState::clear_marketticmetaid() {
  if (marketticmetaid_ != &::google::protobuf::internal::kEmptyString) {
    marketticmetaid_->clear();
  }
  clear_has_marketticmetaid();
}
inline const ::std::string& PlayerMarketState::marketticmetaid() const {
  return *marketticmetaid_;
}
inline void PlayerMarketState::set_marketticmetaid(const ::std::string& value) {
  set_has_marketticmetaid();
  if (marketticmetaid_ == &::google::protobuf::internal::kEmptyString) {
    marketticmetaid_ = new ::std::string;
  }
  marketticmetaid_->assign(value);
}
inline void PlayerMarketState::set_marketticmetaid(const char* value) {
  set_has_marketticmetaid();
  if (marketticmetaid_ == &::google::protobuf::internal::kEmptyString) {
    marketticmetaid_ = new ::std::string;
  }
  marketticmetaid_->assign(value);
}
inline void PlayerMarketState::set_marketticmetaid(const void* value, size_t size) {
  set_has_marketticmetaid();
  if (marketticmetaid_ == &::google::protobuf::internal::kEmptyString) {
    marketticmetaid_ = new ::std::string;
  }
  marketticmetaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerMarketState::mutable_marketticmetaid() {
  set_has_marketticmetaid();
  if (marketticmetaid_ == &::google::protobuf::internal::kEmptyString) {
    marketticmetaid_ = new ::std::string;
  }
  return marketticmetaid_;
}
inline ::std::string* PlayerMarketState::release_marketticmetaid() {
  clear_has_marketticmetaid();
  if (marketticmetaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = marketticmetaid_;
    marketticmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerMarketState::set_allocated_marketticmetaid(::std::string* marketticmetaid) {
  if (marketticmetaid_ != &::google::protobuf::internal::kEmptyString) {
    delete marketticmetaid_;
  }
  if (marketticmetaid) {
    set_has_marketticmetaid();
    marketticmetaid_ = marketticmetaid;
  } else {
    clear_has_marketticmetaid();
    marketticmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool locked = 31;
inline bool PlayerMarketState::has_locked() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerMarketState::set_has_locked() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerMarketState::clear_has_locked() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerMarketState::clear_locked() {
  locked_ = false;
  clear_has_locked();
}
inline bool PlayerMarketState::locked() const {
  return locked_;
}
inline void PlayerMarketState::set_locked(bool value) {
  set_has_locked();
  locked_ = value;
}

// optional bytes prev = 40;
inline bool PlayerMarketState::has_prev() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayerMarketState::set_has_prev() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayerMarketState::clear_has_prev() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayerMarketState::clear_prev() {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    prev_->clear();
  }
  clear_has_prev();
}
inline const ::std::string& PlayerMarketState::prev() const {
  return *prev_;
}
inline void PlayerMarketState::set_prev(const ::std::string& value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void PlayerMarketState::set_prev(const char* value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void PlayerMarketState::set_prev(const void* value, size_t size) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerMarketState::mutable_prev() {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  return prev_;
}
inline ::std::string* PlayerMarketState::release_prev() {
  clear_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prev_;
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerMarketState::set_allocated_prev(::std::string* prev) {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    delete prev_;
  }
  if (prev) {
    set_has_prev();
    prev_ = prev;
  } else {
    clear_has_prev();
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes next = 50;
inline bool PlayerMarketState::has_next() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PlayerMarketState::set_has_next() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PlayerMarketState::clear_has_next() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PlayerMarketState::clear_next() {
  if (next_ != &::google::protobuf::internal::kEmptyString) {
    next_->clear();
  }
  clear_has_next();
}
inline const ::std::string& PlayerMarketState::next() const {
  return *next_;
}
inline void PlayerMarketState::set_next(const ::std::string& value) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(value);
}
inline void PlayerMarketState::set_next(const char* value) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(value);
}
inline void PlayerMarketState::set_next(const void* value, size_t size) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerMarketState::mutable_next() {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  return next_;
}
inline ::std::string* PlayerMarketState::release_next() {
  clear_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = next_;
    next_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerMarketState::set_allocated_next(::std::string* next) {
  if (next_ != &::google::protobuf::internal::kEmptyString) {
    delete next_;
  }
  if (next) {
    set_has_next();
    next_ = next;
  } else {
    clear_has_next();
    next_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LimitBookMeta

// optional int32 bid = 10;
inline bool LimitBookMeta::has_bid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LimitBookMeta::set_has_bid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LimitBookMeta::clear_has_bid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LimitBookMeta::clear_bid() {
  bid_ = 0;
  clear_has_bid();
}
inline ::google::protobuf::int32 LimitBookMeta::bid() const {
  return bid_;
}
inline void LimitBookMeta::set_bid(::google::protobuf::int32 value) {
  set_has_bid();
  bid_ = value;
}

// optional int32 bidsize = 20;
inline bool LimitBookMeta::has_bidsize() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LimitBookMeta::set_has_bidsize() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LimitBookMeta::clear_has_bidsize() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LimitBookMeta::clear_bidsize() {
  bidsize_ = 0;
  clear_has_bidsize();
}
inline ::google::protobuf::int32 LimitBookMeta::bidsize() const {
  return bidsize_;
}
inline void LimitBookMeta::set_bidsize(::google::protobuf::int32 value) {
  set_has_bidsize();
  bidsize_ = value;
}

// optional int32 asksize = 30;
inline bool LimitBookMeta::has_asksize() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LimitBookMeta::set_has_asksize() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LimitBookMeta::clear_has_asksize() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LimitBookMeta::clear_asksize() {
  asksize_ = 0;
  clear_has_asksize();
}
inline ::google::protobuf::int32 LimitBookMeta::asksize() const {
  return asksize_;
}
inline void LimitBookMeta::set_asksize(::google::protobuf::int32 value) {
  set_has_asksize();
  asksize_ = value;
}

// optional int32 ask = 40;
inline bool LimitBookMeta::has_ask() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LimitBookMeta::set_has_ask() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LimitBookMeta::clear_has_ask() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LimitBookMeta::clear_ask() {
  ask_ = 0;
  clear_has_ask();
}
inline ::google::protobuf::int32 LimitBookMeta::ask() const {
  return ask_;
}
inline void LimitBookMeta::set_ask(::google::protobuf::int32 value) {
  set_has_ask();
  ask_ = value;
}

// optional bytes bidordermetaroot = 50;
inline bool LimitBookMeta::has_bidordermetaroot() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LimitBookMeta::set_has_bidordermetaroot() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LimitBookMeta::clear_has_bidordermetaroot() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LimitBookMeta::clear_bidordermetaroot() {
  if (bidordermetaroot_ != &::google::protobuf::internal::kEmptyString) {
    bidordermetaroot_->clear();
  }
  clear_has_bidordermetaroot();
}
inline const ::std::string& LimitBookMeta::bidordermetaroot() const {
  return *bidordermetaroot_;
}
inline void LimitBookMeta::set_bidordermetaroot(const ::std::string& value) {
  set_has_bidordermetaroot();
  if (bidordermetaroot_ == &::google::protobuf::internal::kEmptyString) {
    bidordermetaroot_ = new ::std::string;
  }
  bidordermetaroot_->assign(value);
}
inline void LimitBookMeta::set_bidordermetaroot(const char* value) {
  set_has_bidordermetaroot();
  if (bidordermetaroot_ == &::google::protobuf::internal::kEmptyString) {
    bidordermetaroot_ = new ::std::string;
  }
  bidordermetaroot_->assign(value);
}
inline void LimitBookMeta::set_bidordermetaroot(const void* value, size_t size) {
  set_has_bidordermetaroot();
  if (bidordermetaroot_ == &::google::protobuf::internal::kEmptyString) {
    bidordermetaroot_ = new ::std::string;
  }
  bidordermetaroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LimitBookMeta::mutable_bidordermetaroot() {
  set_has_bidordermetaroot();
  if (bidordermetaroot_ == &::google::protobuf::internal::kEmptyString) {
    bidordermetaroot_ = new ::std::string;
  }
  return bidordermetaroot_;
}
inline ::std::string* LimitBookMeta::release_bidordermetaroot() {
  clear_has_bidordermetaroot();
  if (bidordermetaroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bidordermetaroot_;
    bidordermetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LimitBookMeta::set_allocated_bidordermetaroot(::std::string* bidordermetaroot) {
  if (bidordermetaroot_ != &::google::protobuf::internal::kEmptyString) {
    delete bidordermetaroot_;
  }
  if (bidordermetaroot) {
    set_has_bidordermetaroot();
    bidordermetaroot_ = bidordermetaroot;
  } else {
    clear_has_bidordermetaroot();
    bidordermetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes askordermetaroot = 60;
inline bool LimitBookMeta::has_askordermetaroot() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LimitBookMeta::set_has_askordermetaroot() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LimitBookMeta::clear_has_askordermetaroot() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LimitBookMeta::clear_askordermetaroot() {
  if (askordermetaroot_ != &::google::protobuf::internal::kEmptyString) {
    askordermetaroot_->clear();
  }
  clear_has_askordermetaroot();
}
inline const ::std::string& LimitBookMeta::askordermetaroot() const {
  return *askordermetaroot_;
}
inline void LimitBookMeta::set_askordermetaroot(const ::std::string& value) {
  set_has_askordermetaroot();
  if (askordermetaroot_ == &::google::protobuf::internal::kEmptyString) {
    askordermetaroot_ = new ::std::string;
  }
  askordermetaroot_->assign(value);
}
inline void LimitBookMeta::set_askordermetaroot(const char* value) {
  set_has_askordermetaroot();
  if (askordermetaroot_ == &::google::protobuf::internal::kEmptyString) {
    askordermetaroot_ = new ::std::string;
  }
  askordermetaroot_->assign(value);
}
inline void LimitBookMeta::set_askordermetaroot(const void* value, size_t size) {
  set_has_askordermetaroot();
  if (askordermetaroot_ == &::google::protobuf::internal::kEmptyString) {
    askordermetaroot_ = new ::std::string;
  }
  askordermetaroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LimitBookMeta::mutable_askordermetaroot() {
  set_has_askordermetaroot();
  if (askordermetaroot_ == &::google::protobuf::internal::kEmptyString) {
    askordermetaroot_ = new ::std::string;
  }
  return askordermetaroot_;
}
inline ::std::string* LimitBookMeta::release_askordermetaroot() {
  clear_has_askordermetaroot();
  if (askordermetaroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = askordermetaroot_;
    askordermetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LimitBookMeta::set_allocated_askordermetaroot(::std::string* askordermetaroot) {
  if (askordermetaroot_ != &::google::protobuf::internal::kEmptyString) {
    delete askordermetaroot_;
  }
  if (askordermetaroot) {
    set_has_askordermetaroot();
    askordermetaroot_ = askordermetaroot;
  } else {
    clear_has_askordermetaroot();
    askordermetaroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MarketTicMeta

// optional int32 price = 20;
inline bool MarketTicMeta::has_price() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketTicMeta::set_has_price() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketTicMeta::clear_has_price() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketTicMeta::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 MarketTicMeta::price() const {
  return price_;
}
inline void MarketTicMeta::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
}

// optional int32 size = 30;
inline bool MarketTicMeta::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketTicMeta::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketTicMeta::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketTicMeta::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::google::protobuf::int32 MarketTicMeta::size() const {
  return size_;
}
inline void MarketTicMeta::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
}

// optional bytes orderfillhead = 40;
inline bool MarketTicMeta::has_orderfillhead() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketTicMeta::set_has_orderfillhead() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketTicMeta::clear_has_orderfillhead() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketTicMeta::clear_orderfillhead() {
  if (orderfillhead_ != &::google::protobuf::internal::kEmptyString) {
    orderfillhead_->clear();
  }
  clear_has_orderfillhead();
}
inline const ::std::string& MarketTicMeta::orderfillhead() const {
  return *orderfillhead_;
}
inline void MarketTicMeta::set_orderfillhead(const ::std::string& value) {
  set_has_orderfillhead();
  if (orderfillhead_ == &::google::protobuf::internal::kEmptyString) {
    orderfillhead_ = new ::std::string;
  }
  orderfillhead_->assign(value);
}
inline void MarketTicMeta::set_orderfillhead(const char* value) {
  set_has_orderfillhead();
  if (orderfillhead_ == &::google::protobuf::internal::kEmptyString) {
    orderfillhead_ = new ::std::string;
  }
  orderfillhead_->assign(value);
}
inline void MarketTicMeta::set_orderfillhead(const void* value, size_t size) {
  set_has_orderfillhead();
  if (orderfillhead_ == &::google::protobuf::internal::kEmptyString) {
    orderfillhead_ = new ::std::string;
  }
  orderfillhead_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MarketTicMeta::mutable_orderfillhead() {
  set_has_orderfillhead();
  if (orderfillhead_ == &::google::protobuf::internal::kEmptyString) {
    orderfillhead_ = new ::std::string;
  }
  return orderfillhead_;
}
inline ::std::string* MarketTicMeta::release_orderfillhead() {
  clear_has_orderfillhead();
  if (orderfillhead_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = orderfillhead_;
    orderfillhead_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MarketTicMeta::set_allocated_orderfillhead(::std::string* orderfillhead) {
  if (orderfillhead_ != &::google::protobuf::internal::kEmptyString) {
    delete orderfillhead_;
  }
  if (orderfillhead) {
    set_has_orderfillhead();
    orderfillhead_ = orderfillhead;
  } else {
    clear_has_orderfillhead();
    orderfillhead_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes prev = 50;
inline bool MarketTicMeta::has_prev() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MarketTicMeta::set_has_prev() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MarketTicMeta::clear_has_prev() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MarketTicMeta::clear_prev() {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    prev_->clear();
  }
  clear_has_prev();
}
inline const ::std::string& MarketTicMeta::prev() const {
  return *prev_;
}
inline void MarketTicMeta::set_prev(const ::std::string& value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void MarketTicMeta::set_prev(const char* value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void MarketTicMeta::set_prev(const void* value, size_t size) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MarketTicMeta::mutable_prev() {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  return prev_;
}
inline ::std::string* MarketTicMeta::release_prev() {
  clear_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prev_;
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MarketTicMeta::set_allocated_prev(::std::string* prev) {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    delete prev_;
  }
  if (prev) {
    set_has_prev();
    prev_ = prev;
  } else {
    clear_has_prev();
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// OrderMeta

// optional int32 refnum = 1;
inline bool OrderMeta::has_refnum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OrderMeta::set_has_refnum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OrderMeta::clear_has_refnum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OrderMeta::clear_refnum() {
  refnum_ = 0;
  clear_has_refnum();
}
inline ::google::protobuf::int32 OrderMeta::refnum() const {
  return refnum_;
}
inline void OrderMeta::set_refnum(::google::protobuf::int32 value) {
  set_has_refnum();
  refnum_ = value;
}

// optional string fname = 10;
inline bool OrderMeta::has_fname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OrderMeta::set_has_fname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OrderMeta::clear_has_fname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OrderMeta::clear_fname() {
  if (fname_ != &::google::protobuf::internal::kEmptyString) {
    fname_->clear();
  }
  clear_has_fname();
}
inline const ::std::string& OrderMeta::fname() const {
  return *fname_;
}
inline void OrderMeta::set_fname(const ::std::string& value) {
  set_has_fname();
  if (fname_ == &::google::protobuf::internal::kEmptyString) {
    fname_ = new ::std::string;
  }
  fname_->assign(value);
}
inline void OrderMeta::set_fname(const char* value) {
  set_has_fname();
  if (fname_ == &::google::protobuf::internal::kEmptyString) {
    fname_ = new ::std::string;
  }
  fname_->assign(value);
}
inline void OrderMeta::set_fname(const char* value, size_t size) {
  set_has_fname();
  if (fname_ == &::google::protobuf::internal::kEmptyString) {
    fname_ = new ::std::string;
  }
  fname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderMeta::mutable_fname() {
  set_has_fname();
  if (fname_ == &::google::protobuf::internal::kEmptyString) {
    fname_ = new ::std::string;
  }
  return fname_;
}
inline ::std::string* OrderMeta::release_fname() {
  clear_has_fname();
  if (fname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fname_;
    fname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderMeta::set_allocated_fname(::std::string* fname) {
  if (fname_ != &::google::protobuf::internal::kEmptyString) {
    delete fname_;
  }
  if (fname) {
    set_has_fname();
    fname_ = fname;
  } else {
    clear_has_fname();
    fname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string playerid = 20;
inline bool OrderMeta::has_playerid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OrderMeta::set_has_playerid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OrderMeta::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OrderMeta::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& OrderMeta::playerid() const {
  return *playerid_;
}
inline void OrderMeta::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void OrderMeta::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void OrderMeta::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderMeta::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* OrderMeta::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderMeta::set_allocated_playerid(::std::string* playerid) {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    delete playerid_;
  }
  if (playerid) {
    set_has_playerid();
    playerid_ = playerid;
  } else {
    clear_has_playerid();
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool buyside = 30;
inline bool OrderMeta::has_buyside() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OrderMeta::set_has_buyside() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OrderMeta::clear_has_buyside() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OrderMeta::clear_buyside() {
  buyside_ = false;
  clear_has_buyside();
}
inline bool OrderMeta::buyside() const {
  return buyside_;
}
inline void OrderMeta::set_buyside(bool value) {
  set_has_buyside();
  buyside_ = value;
}

// optional int32 size = 40;
inline bool OrderMeta::has_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OrderMeta::set_has_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OrderMeta::clear_has_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OrderMeta::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::google::protobuf::int32 OrderMeta::size() const {
  return size_;
}
inline void OrderMeta::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
}

// optional int32 price = 50;
inline bool OrderMeta::has_price() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OrderMeta::set_has_price() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OrderMeta::clear_has_price() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OrderMeta::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 OrderMeta::price() const {
  return price_;
}
inline void OrderMeta::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
}

// optional bytes txmetaid = 60;
inline bool OrderMeta::has_txmetaid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OrderMeta::set_has_txmetaid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OrderMeta::clear_has_txmetaid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OrderMeta::clear_txmetaid() {
  if (txmetaid_ != &::google::protobuf::internal::kEmptyString) {
    txmetaid_->clear();
  }
  clear_has_txmetaid();
}
inline const ::std::string& OrderMeta::txmetaid() const {
  return *txmetaid_;
}
inline void OrderMeta::set_txmetaid(const ::std::string& value) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(value);
}
inline void OrderMeta::set_txmetaid(const char* value) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(value);
}
inline void OrderMeta::set_txmetaid(const void* value, size_t size) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderMeta::mutable_txmetaid() {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  return txmetaid_;
}
inline ::std::string* OrderMeta::release_txmetaid() {
  clear_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = txmetaid_;
    txmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderMeta::set_allocated_txmetaid(::std::string* txmetaid) {
  if (txmetaid_ != &::google::protobuf::internal::kEmptyString) {
    delete txmetaid_;
  }
  if (txmetaid) {
    set_has_txmetaid();
    txmetaid_ = txmetaid;
  } else {
    clear_has_txmetaid();
    txmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes orderfillmetaid = 70;
inline bool OrderMeta::has_orderfillmetaid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void OrderMeta::set_has_orderfillmetaid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void OrderMeta::clear_has_orderfillmetaid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void OrderMeta::clear_orderfillmetaid() {
  if (orderfillmetaid_ != &::google::protobuf::internal::kEmptyString) {
    orderfillmetaid_->clear();
  }
  clear_has_orderfillmetaid();
}
inline const ::std::string& OrderMeta::orderfillmetaid() const {
  return *orderfillmetaid_;
}
inline void OrderMeta::set_orderfillmetaid(const ::std::string& value) {
  set_has_orderfillmetaid();
  if (orderfillmetaid_ == &::google::protobuf::internal::kEmptyString) {
    orderfillmetaid_ = new ::std::string;
  }
  orderfillmetaid_->assign(value);
}
inline void OrderMeta::set_orderfillmetaid(const char* value) {
  set_has_orderfillmetaid();
  if (orderfillmetaid_ == &::google::protobuf::internal::kEmptyString) {
    orderfillmetaid_ = new ::std::string;
  }
  orderfillmetaid_->assign(value);
}
inline void OrderMeta::set_orderfillmetaid(const void* value, size_t size) {
  set_has_orderfillmetaid();
  if (orderfillmetaid_ == &::google::protobuf::internal::kEmptyString) {
    orderfillmetaid_ = new ::std::string;
  }
  orderfillmetaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderMeta::mutable_orderfillmetaid() {
  set_has_orderfillmetaid();
  if (orderfillmetaid_ == &::google::protobuf::internal::kEmptyString) {
    orderfillmetaid_ = new ::std::string;
  }
  return orderfillmetaid_;
}
inline ::std::string* OrderMeta::release_orderfillmetaid() {
  clear_has_orderfillmetaid();
  if (orderfillmetaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = orderfillmetaid_;
    orderfillmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderMeta::set_allocated_orderfillmetaid(::std::string* orderfillmetaid) {
  if (orderfillmetaid_ != &::google::protobuf::internal::kEmptyString) {
    delete orderfillmetaid_;
  }
  if (orderfillmetaid) {
    set_has_orderfillmetaid();
    orderfillmetaid_ = orderfillmetaid;
  } else {
    clear_has_orderfillmetaid();
    orderfillmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 timestamp = 75;
inline bool OrderMeta::has_timestamp() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void OrderMeta::set_has_timestamp() {
  _has_bits_[0] |= 0x00000100u;
}
inline void OrderMeta::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void OrderMeta::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline ::google::protobuf::int32 OrderMeta::timestamp() const {
  return timestamp_;
}
inline void OrderMeta::set_timestamp(::google::protobuf::int32 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional bytes prev = 80;
inline bool OrderMeta::has_prev() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void OrderMeta::set_has_prev() {
  _has_bits_[0] |= 0x00000200u;
}
inline void OrderMeta::clear_has_prev() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void OrderMeta::clear_prev() {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    prev_->clear();
  }
  clear_has_prev();
}
inline const ::std::string& OrderMeta::prev() const {
  return *prev_;
}
inline void OrderMeta::set_prev(const ::std::string& value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void OrderMeta::set_prev(const char* value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void OrderMeta::set_prev(const void* value, size_t size) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderMeta::mutable_prev() {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  return prev_;
}
inline ::std::string* OrderMeta::release_prev() {
  clear_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prev_;
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderMeta::set_allocated_prev(::std::string* prev) {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    delete prev_;
  }
  if (prev) {
    set_has_prev();
    prev_ = prev;
  } else {
    clear_has_prev();
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// OrderFillMeta

// optional int32 refnum = 1;
inline bool OrderFillMeta::has_refnum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OrderFillMeta::set_has_refnum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OrderFillMeta::clear_has_refnum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OrderFillMeta::clear_refnum() {
  refnum_ = 0;
  clear_has_refnum();
}
inline ::google::protobuf::int32 OrderFillMeta::refnum() const {
  return refnum_;
}
inline void OrderFillMeta::set_refnum(::google::protobuf::int32 value) {
  set_has_refnum();
  refnum_ = value;
}

// optional string fname = 10;
inline bool OrderFillMeta::has_fname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OrderFillMeta::set_has_fname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OrderFillMeta::clear_has_fname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OrderFillMeta::clear_fname() {
  if (fname_ != &::google::protobuf::internal::kEmptyString) {
    fname_->clear();
  }
  clear_has_fname();
}
inline const ::std::string& OrderFillMeta::fname() const {
  return *fname_;
}
inline void OrderFillMeta::set_fname(const ::std::string& value) {
  set_has_fname();
  if (fname_ == &::google::protobuf::internal::kEmptyString) {
    fname_ = new ::std::string;
  }
  fname_->assign(value);
}
inline void OrderFillMeta::set_fname(const char* value) {
  set_has_fname();
  if (fname_ == &::google::protobuf::internal::kEmptyString) {
    fname_ = new ::std::string;
  }
  fname_->assign(value);
}
inline void OrderFillMeta::set_fname(const char* value, size_t size) {
  set_has_fname();
  if (fname_ == &::google::protobuf::internal::kEmptyString) {
    fname_ = new ::std::string;
  }
  fname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderFillMeta::mutable_fname() {
  set_has_fname();
  if (fname_ == &::google::protobuf::internal::kEmptyString) {
    fname_ = new ::std::string;
  }
  return fname_;
}
inline ::std::string* OrderFillMeta::release_fname() {
  clear_has_fname();
  if (fname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fname_;
    fname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderFillMeta::set_allocated_fname(::std::string* fname) {
  if (fname_ != &::google::protobuf::internal::kEmptyString) {
    delete fname_;
  }
  if (fname) {
    set_has_fname();
    fname_ = fname;
  } else {
    clear_has_fname();
    fname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string playerid = 15;
inline bool OrderFillMeta::has_playerid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OrderFillMeta::set_has_playerid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OrderFillMeta::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OrderFillMeta::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& OrderFillMeta::playerid() const {
  return *playerid_;
}
inline void OrderFillMeta::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void OrderFillMeta::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void OrderFillMeta::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderFillMeta::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* OrderFillMeta::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderFillMeta::set_allocated_playerid(::std::string* playerid) {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    delete playerid_;
  }
  if (playerid) {
    set_has_playerid();
    playerid_ = playerid;
  } else {
    clear_has_playerid();
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 fillprice = 20;
inline bool OrderFillMeta::has_fillprice() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OrderFillMeta::set_has_fillprice() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OrderFillMeta::clear_has_fillprice() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OrderFillMeta::clear_fillprice() {
  fillprice_ = 0;
  clear_has_fillprice();
}
inline ::google::protobuf::int32 OrderFillMeta::fillprice() const {
  return fillprice_;
}
inline void OrderFillMeta::set_fillprice(::google::protobuf::int32 value) {
  set_has_fillprice();
  fillprice_ = value;
}

// optional int32 fillsize = 30;
inline bool OrderFillMeta::has_fillsize() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OrderFillMeta::set_has_fillsize() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OrderFillMeta::clear_has_fillsize() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OrderFillMeta::clear_fillsize() {
  fillsize_ = 0;
  clear_has_fillsize();
}
inline ::google::protobuf::int32 OrderFillMeta::fillsize() const {
  return fillsize_;
}
inline void OrderFillMeta::set_fillsize(::google::protobuf::int32 value) {
  set_has_fillsize();
  fillsize_ = value;
}

// optional bool buyside = 35;
inline bool OrderFillMeta::has_buyside() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OrderFillMeta::set_has_buyside() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OrderFillMeta::clear_has_buyside() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OrderFillMeta::clear_buyside() {
  buyside_ = false;
  clear_has_buyside();
}
inline bool OrderFillMeta::buyside() const {
  return buyside_;
}
inline void OrderFillMeta::set_buyside(bool value) {
  set_has_buyside();
  buyside_ = value;
}

// optional int32 timestamp = 40;
inline bool OrderFillMeta::has_timestamp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OrderFillMeta::set_has_timestamp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OrderFillMeta::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OrderFillMeta::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline ::google::protobuf::int32 OrderFillMeta::timestamp() const {
  return timestamp_;
}
inline void OrderFillMeta::set_timestamp(::google::protobuf::int32 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional bytes txmetaid = 60;
inline bool OrderFillMeta::has_txmetaid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void OrderFillMeta::set_has_txmetaid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void OrderFillMeta::clear_has_txmetaid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void OrderFillMeta::clear_txmetaid() {
  if (txmetaid_ != &::google::protobuf::internal::kEmptyString) {
    txmetaid_->clear();
  }
  clear_has_txmetaid();
}
inline const ::std::string& OrderFillMeta::txmetaid() const {
  return *txmetaid_;
}
inline void OrderFillMeta::set_txmetaid(const ::std::string& value) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(value);
}
inline void OrderFillMeta::set_txmetaid(const char* value) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(value);
}
inline void OrderFillMeta::set_txmetaid(const void* value, size_t size) {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  txmetaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderFillMeta::mutable_txmetaid() {
  set_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    txmetaid_ = new ::std::string;
  }
  return txmetaid_;
}
inline ::std::string* OrderFillMeta::release_txmetaid() {
  clear_has_txmetaid();
  if (txmetaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = txmetaid_;
    txmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderFillMeta::set_allocated_txmetaid(::std::string* txmetaid) {
  if (txmetaid_ != &::google::protobuf::internal::kEmptyString) {
    delete txmetaid_;
  }
  if (txmetaid) {
    set_has_txmetaid();
    txmetaid_ = txmetaid;
  } else {
    clear_has_txmetaid();
    txmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes prev = 70;
inline bool OrderFillMeta::has_prev() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void OrderFillMeta::set_has_prev() {
  _has_bits_[0] |= 0x00000100u;
}
inline void OrderFillMeta::clear_has_prev() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void OrderFillMeta::clear_prev() {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    prev_->clear();
  }
  clear_has_prev();
}
inline const ::std::string& OrderFillMeta::prev() const {
  return *prev_;
}
inline void OrderFillMeta::set_prev(const ::std::string& value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void OrderFillMeta::set_prev(const char* value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void OrderFillMeta::set_prev(const void* value, size_t size) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderFillMeta::mutable_prev() {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  return prev_;
}
inline ::std::string* OrderFillMeta::release_prev() {
  clear_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prev_;
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderFillMeta::set_allocated_prev(::std::string* prev) {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    delete prev_;
  }
  if (prev) {
    set_has_prev();
    prev_ = prev;
  } else {
    clear_has_prev();
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GlobalStateMeta

// optional .fantasybit.GlobalState globalstate = 10;
inline bool GlobalStateMeta::has_globalstate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GlobalStateMeta::set_has_globalstate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GlobalStateMeta::clear_has_globalstate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GlobalStateMeta::clear_globalstate() {
  if (globalstate_ != NULL) globalstate_->::fantasybit::GlobalState::Clear();
  clear_has_globalstate();
}
inline const ::fantasybit::GlobalState& GlobalStateMeta::globalstate() const {
  return globalstate_ != NULL ? *globalstate_ : *default_instance_->globalstate_;
}
inline ::fantasybit::GlobalState* GlobalStateMeta::mutable_globalstate() {
  set_has_globalstate();
  if (globalstate_ == NULL) globalstate_ = new ::fantasybit::GlobalState;
  return globalstate_;
}
inline ::fantasybit::GlobalState* GlobalStateMeta::release_globalstate() {
  clear_has_globalstate();
  ::fantasybit::GlobalState* temp = globalstate_;
  globalstate_ = NULL;
  return temp;
}
inline void GlobalStateMeta::set_allocated_globalstate(::fantasybit::GlobalState* globalstate) {
  delete globalstate_;
  globalstate_ = globalstate;
  if (globalstate) {
    set_has_globalstate();
  } else {
    clear_has_globalstate();
  }
}

// optional bytes trmetaid = 20;
inline bool GlobalStateMeta::has_trmetaid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GlobalStateMeta::set_has_trmetaid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GlobalStateMeta::clear_has_trmetaid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GlobalStateMeta::clear_trmetaid() {
  if (trmetaid_ != &::google::protobuf::internal::kEmptyString) {
    trmetaid_->clear();
  }
  clear_has_trmetaid();
}
inline const ::std::string& GlobalStateMeta::trmetaid() const {
  return *trmetaid_;
}
inline void GlobalStateMeta::set_trmetaid(const ::std::string& value) {
  set_has_trmetaid();
  if (trmetaid_ == &::google::protobuf::internal::kEmptyString) {
    trmetaid_ = new ::std::string;
  }
  trmetaid_->assign(value);
}
inline void GlobalStateMeta::set_trmetaid(const char* value) {
  set_has_trmetaid();
  if (trmetaid_ == &::google::protobuf::internal::kEmptyString) {
    trmetaid_ = new ::std::string;
  }
  trmetaid_->assign(value);
}
inline void GlobalStateMeta::set_trmetaid(const void* value, size_t size) {
  set_has_trmetaid();
  if (trmetaid_ == &::google::protobuf::internal::kEmptyString) {
    trmetaid_ = new ::std::string;
  }
  trmetaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GlobalStateMeta::mutable_trmetaid() {
  set_has_trmetaid();
  if (trmetaid_ == &::google::protobuf::internal::kEmptyString) {
    trmetaid_ = new ::std::string;
  }
  return trmetaid_;
}
inline ::std::string* GlobalStateMeta::release_trmetaid() {
  clear_has_trmetaid();
  if (trmetaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = trmetaid_;
    trmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GlobalStateMeta::set_allocated_trmetaid(::std::string* trmetaid) {
  if (trmetaid_ != &::google::protobuf::internal::kEmptyString) {
    delete trmetaid_;
  }
  if (trmetaid) {
    set_has_trmetaid();
    trmetaid_ = trmetaid;
  } else {
    clear_has_trmetaid();
    trmetaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes prev = 30;
inline bool GlobalStateMeta::has_prev() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GlobalStateMeta::set_has_prev() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GlobalStateMeta::clear_has_prev() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GlobalStateMeta::clear_prev() {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    prev_->clear();
  }
  clear_has_prev();
}
inline const ::std::string& GlobalStateMeta::prev() const {
  return *prev_;
}
inline void GlobalStateMeta::set_prev(const ::std::string& value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void GlobalStateMeta::set_prev(const char* value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void GlobalStateMeta::set_prev(const void* value, size_t size) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GlobalStateMeta::mutable_prev() {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  return prev_;
}
inline ::std::string* GlobalStateMeta::release_prev() {
  clear_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prev_;
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GlobalStateMeta::set_allocated_prev(::std::string* prev) {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    delete prev_;
  }
  if (prev) {
    set_has_prev();
    prev_ = prev;
  } else {
    clear_has_prev();
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes next = 40;
inline bool GlobalStateMeta::has_next() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GlobalStateMeta::set_has_next() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GlobalStateMeta::clear_has_next() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GlobalStateMeta::clear_next() {
  if (next_ != &::google::protobuf::internal::kEmptyString) {
    next_->clear();
  }
  clear_has_next();
}
inline const ::std::string& GlobalStateMeta::next() const {
  return *next_;
}
inline void GlobalStateMeta::set_next(const ::std::string& value) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(value);
}
inline void GlobalStateMeta::set_next(const char* value) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(value);
}
inline void GlobalStateMeta::set_next(const void* value, size_t size) {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  next_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GlobalStateMeta::mutable_next() {
  set_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    next_ = new ::std::string;
  }
  return next_;
}
inline ::std::string* GlobalStateMeta::release_next() {
  clear_has_next();
  if (next_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = next_;
    next_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GlobalStateMeta::set_allocated_next(::std::string* next) {
  if (next_ != &::google::protobuf::internal::kEmptyString) {
    delete next_;
  }
  if (next) {
    set_has_next();
    next_ = next;
  } else {
    clear_has_next();
    next_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PlayerMeta

// optional string playerid = 10;
inline bool PlayerMeta::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerMeta::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerMeta::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerMeta::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& PlayerMeta::playerid() const {
  return *playerid_;
}
inline void PlayerMeta::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void PlayerMeta::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void PlayerMeta::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerMeta::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* PlayerMeta::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerMeta::set_allocated_playerid(::std::string* playerid) {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    delete playerid_;
  }
  if (playerid) {
    set_has_playerid();
    playerid_ = playerid;
  } else {
    clear_has_playerid();
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .fantasybit.PlayerBase player_base = 20;
inline bool PlayerMeta::has_player_base() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerMeta::set_has_player_base() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerMeta::clear_has_player_base() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerMeta::clear_player_base() {
  if (player_base_ != NULL) player_base_->::fantasybit::PlayerBase::Clear();
  clear_has_player_base();
}
inline const ::fantasybit::PlayerBase& PlayerMeta::player_base() const {
  return player_base_ != NULL ? *player_base_ : *default_instance_->player_base_;
}
inline ::fantasybit::PlayerBase* PlayerMeta::mutable_player_base() {
  set_has_player_base();
  if (player_base_ == NULL) player_base_ = new ::fantasybit::PlayerBase;
  return player_base_;
}
inline ::fantasybit::PlayerBase* PlayerMeta::release_player_base() {
  clear_has_player_base();
  ::fantasybit::PlayerBase* temp = player_base_;
  player_base_ = NULL;
  return temp;
}
inline void PlayerMeta::set_allocated_player_base(::fantasybit::PlayerBase* player_base) {
  delete player_base_;
  player_base_ = player_base;
  if (player_base) {
    set_has_player_base();
  } else {
    clear_has_player_base();
  }
}

// optional .fantasybit.PlayerStatus player_status = 30;
inline bool PlayerMeta::has_player_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerMeta::set_has_player_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerMeta::clear_has_player_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerMeta::clear_player_status() {
  if (player_status_ != NULL) player_status_->::fantasybit::PlayerStatus::Clear();
  clear_has_player_status();
}
inline const ::fantasybit::PlayerStatus& PlayerMeta::player_status() const {
  return player_status_ != NULL ? *player_status_ : *default_instance_->player_status_;
}
inline ::fantasybit::PlayerStatus* PlayerMeta::mutable_player_status() {
  set_has_player_status();
  if (player_status_ == NULL) player_status_ = new ::fantasybit::PlayerStatus;
  return player_status_;
}
inline ::fantasybit::PlayerStatus* PlayerMeta::release_player_status() {
  clear_has_player_status();
  ::fantasybit::PlayerStatus* temp = player_status_;
  player_status_ = NULL;
  return temp;
}
inline void PlayerMeta::set_allocated_player_status(::fantasybit::PlayerStatus* player_status) {
  delete player_status_;
  player_status_ = player_status;
  if (player_status) {
    set_has_player_status();
  } else {
    clear_has_player_status();
  }
}

// optional bytes datametaid = 40;
inline bool PlayerMeta::has_datametaid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerMeta::set_has_datametaid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerMeta::clear_has_datametaid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerMeta::clear_datametaid() {
  if (datametaid_ != &::google::protobuf::internal::kEmptyString) {
    datametaid_->clear();
  }
  clear_has_datametaid();
}
inline const ::std::string& PlayerMeta::datametaid() const {
  return *datametaid_;
}
inline void PlayerMeta::set_datametaid(const ::std::string& value) {
  set_has_datametaid();
  if (datametaid_ == &::google::protobuf::internal::kEmptyString) {
    datametaid_ = new ::std::string;
  }
  datametaid_->assign(value);
}
inline void PlayerMeta::set_datametaid(const char* value) {
  set_has_datametaid();
  if (datametaid_ == &::google::protobuf::internal::kEmptyString) {
    datametaid_ = new ::std::string;
  }
  datametaid_->assign(value);
}
inline void PlayerMeta::set_datametaid(const void* value, size_t size) {
  set_has_datametaid();
  if (datametaid_ == &::google::protobuf::internal::kEmptyString) {
    datametaid_ = new ::std::string;
  }
  datametaid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerMeta::mutable_datametaid() {
  set_has_datametaid();
  if (datametaid_ == &::google::protobuf::internal::kEmptyString) {
    datametaid_ = new ::std::string;
  }
  return datametaid_;
}
inline ::std::string* PlayerMeta::release_datametaid() {
  clear_has_datametaid();
  if (datametaid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = datametaid_;
    datametaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerMeta::set_allocated_datametaid(::std::string* datametaid) {
  if (datametaid_ != &::google::protobuf::internal::kEmptyString) {
    delete datametaid_;
  }
  if (datametaid) {
    set_has_datametaid();
    datametaid_ = datametaid;
  } else {
    clear_has_datametaid();
    datametaid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes prev = 50;
inline bool PlayerMeta::has_prev() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayerMeta::set_has_prev() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayerMeta::clear_has_prev() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayerMeta::clear_prev() {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    prev_->clear();
  }
  clear_has_prev();
}
inline const ::std::string& PlayerMeta::prev() const {
  return *prev_;
}
inline void PlayerMeta::set_prev(const ::std::string& value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void PlayerMeta::set_prev(const char* value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void PlayerMeta::set_prev(const void* value, size_t size) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerMeta::mutable_prev() {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  return prev_;
}
inline ::std::string* PlayerMeta::release_prev() {
  clear_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prev_;
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerMeta::set_allocated_prev(::std::string* prev) {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    delete prev_;
  }
  if (prev) {
    set_has_prev();
    prev_ = prev;
  } else {
    clear_has_prev();
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TeamMeta

// optional string teamid = 10;
inline bool TeamMeta::has_teamid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TeamMeta::set_has_teamid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TeamMeta::clear_has_teamid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TeamMeta::clear_teamid() {
  if (teamid_ != &::google::protobuf::internal::kEmptyString) {
    teamid_->clear();
  }
  clear_has_teamid();
}
inline const ::std::string& TeamMeta::teamid() const {
  return *teamid_;
}
inline void TeamMeta::set_teamid(const ::std::string& value) {
  set_has_teamid();
  if (teamid_ == &::google::protobuf::internal::kEmptyString) {
    teamid_ = new ::std::string;
  }
  teamid_->assign(value);
}
inline void TeamMeta::set_teamid(const char* value) {
  set_has_teamid();
  if (teamid_ == &::google::protobuf::internal::kEmptyString) {
    teamid_ = new ::std::string;
  }
  teamid_->assign(value);
}
inline void TeamMeta::set_teamid(const char* value, size_t size) {
  set_has_teamid();
  if (teamid_ == &::google::protobuf::internal::kEmptyString) {
    teamid_ = new ::std::string;
  }
  teamid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TeamMeta::mutable_teamid() {
  set_has_teamid();
  if (teamid_ == &::google::protobuf::internal::kEmptyString) {
    teamid_ = new ::std::string;
  }
  return teamid_;
}
inline ::std::string* TeamMeta::release_teamid() {
  clear_has_teamid();
  if (teamid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = teamid_;
    teamid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TeamMeta::set_allocated_teamid(::std::string* teamid) {
  if (teamid_ != &::google::protobuf::internal::kEmptyString) {
    delete teamid_;
  }
  if (teamid) {
    set_has_teamid();
    teamid_ = teamid;
  } else {
    clear_has_teamid();
    teamid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes playermetaidroot = 20;
inline bool TeamMeta::has_playermetaidroot() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TeamMeta::set_has_playermetaidroot() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TeamMeta::clear_has_playermetaidroot() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TeamMeta::clear_playermetaidroot() {
  if (playermetaidroot_ != &::google::protobuf::internal::kEmptyString) {
    playermetaidroot_->clear();
  }
  clear_has_playermetaidroot();
}
inline const ::std::string& TeamMeta::playermetaidroot() const {
  return *playermetaidroot_;
}
inline void TeamMeta::set_playermetaidroot(const ::std::string& value) {
  set_has_playermetaidroot();
  if (playermetaidroot_ == &::google::protobuf::internal::kEmptyString) {
    playermetaidroot_ = new ::std::string;
  }
  playermetaidroot_->assign(value);
}
inline void TeamMeta::set_playermetaidroot(const char* value) {
  set_has_playermetaidroot();
  if (playermetaidroot_ == &::google::protobuf::internal::kEmptyString) {
    playermetaidroot_ = new ::std::string;
  }
  playermetaidroot_->assign(value);
}
inline void TeamMeta::set_playermetaidroot(const void* value, size_t size) {
  set_has_playermetaidroot();
  if (playermetaidroot_ == &::google::protobuf::internal::kEmptyString) {
    playermetaidroot_ = new ::std::string;
  }
  playermetaidroot_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TeamMeta::mutable_playermetaidroot() {
  set_has_playermetaidroot();
  if (playermetaidroot_ == &::google::protobuf::internal::kEmptyString) {
    playermetaidroot_ = new ::std::string;
  }
  return playermetaidroot_;
}
inline ::std::string* TeamMeta::release_playermetaidroot() {
  clear_has_playermetaidroot();
  if (playermetaidroot_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playermetaidroot_;
    playermetaidroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TeamMeta::set_allocated_playermetaidroot(::std::string* playermetaidroot) {
  if (playermetaidroot_ != &::google::protobuf::internal::kEmptyString) {
    delete playermetaidroot_;
  }
  if (playermetaidroot) {
    set_has_playermetaidroot();
    playermetaidroot_ = playermetaidroot;
  } else {
    clear_has_playermetaidroot();
    playermetaidroot_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes prev = 30;
inline bool TeamMeta::has_prev() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TeamMeta::set_has_prev() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TeamMeta::clear_has_prev() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TeamMeta::clear_prev() {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    prev_->clear();
  }
  clear_has_prev();
}
inline const ::std::string& TeamMeta::prev() const {
  return *prev_;
}
inline void TeamMeta::set_prev(const ::std::string& value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void TeamMeta::set_prev(const char* value) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(value);
}
inline void TeamMeta::set_prev(const void* value, size_t size) {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  prev_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TeamMeta::mutable_prev() {
  set_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    prev_ = new ::std::string;
  }
  return prev_;
}
inline ::std::string* TeamMeta::release_prev() {
  clear_has_prev();
  if (prev_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prev_;
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TeamMeta::set_allocated_prev(::std::string* prev) {
  if (prev_ != &::google::protobuf::internal::kEmptyString) {
    delete prev_;
  }
  if (prev) {
    set_has_prev();
    prev_ = prev;
  } else {
    clear_has_prev();
    prev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// pbstate

// optional bytes schedulestateid = 10;
inline bool pbstate::has_schedulestateid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void pbstate::set_has_schedulestateid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void pbstate::clear_has_schedulestateid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void pbstate::clear_schedulestateid() {
  if (schedulestateid_ != &::google::protobuf::internal::kEmptyString) {
    schedulestateid_->clear();
  }
  clear_has_schedulestateid();
}
inline const ::std::string& pbstate::schedulestateid() const {
  return *schedulestateid_;
}
inline void pbstate::set_schedulestateid(const ::std::string& value) {
  set_has_schedulestateid();
  if (schedulestateid_ == &::google::protobuf::internal::kEmptyString) {
    schedulestateid_ = new ::std::string;
  }
  schedulestateid_->assign(value);
}
inline void pbstate::set_schedulestateid(const char* value) {
  set_has_schedulestateid();
  if (schedulestateid_ == &::google::protobuf::internal::kEmptyString) {
    schedulestateid_ = new ::std::string;
  }
  schedulestateid_->assign(value);
}
inline void pbstate::set_schedulestateid(const void* value, size_t size) {
  set_has_schedulestateid();
  if (schedulestateid_ == &::google::protobuf::internal::kEmptyString) {
    schedulestateid_ = new ::std::string;
  }
  schedulestateid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbstate::mutable_schedulestateid() {
  set_has_schedulestateid();
  if (schedulestateid_ == &::google::protobuf::internal::kEmptyString) {
    schedulestateid_ = new ::std::string;
  }
  return schedulestateid_;
}
inline ::std::string* pbstate::release_schedulestateid() {
  clear_has_schedulestateid();
  if (schedulestateid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = schedulestateid_;
    schedulestateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbstate::set_allocated_schedulestateid(::std::string* schedulestateid) {
  if (schedulestateid_ != &::google::protobuf::internal::kEmptyString) {
    delete schedulestateid_;
  }
  if (schedulestateid) {
    set_has_schedulestateid();
    schedulestateid_ = schedulestateid;
  } else {
    clear_has_schedulestateid();
    schedulestateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes leaderboardstateid = 20;
inline bool pbstate::has_leaderboardstateid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void pbstate::set_has_leaderboardstateid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void pbstate::clear_has_leaderboardstateid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void pbstate::clear_leaderboardstateid() {
  if (leaderboardstateid_ != &::google::protobuf::internal::kEmptyString) {
    leaderboardstateid_->clear();
  }
  clear_has_leaderboardstateid();
}
inline const ::std::string& pbstate::leaderboardstateid() const {
  return *leaderboardstateid_;
}
inline void pbstate::set_leaderboardstateid(const ::std::string& value) {
  set_has_leaderboardstateid();
  if (leaderboardstateid_ == &::google::protobuf::internal::kEmptyString) {
    leaderboardstateid_ = new ::std::string;
  }
  leaderboardstateid_->assign(value);
}
inline void pbstate::set_leaderboardstateid(const char* value) {
  set_has_leaderboardstateid();
  if (leaderboardstateid_ == &::google::protobuf::internal::kEmptyString) {
    leaderboardstateid_ = new ::std::string;
  }
  leaderboardstateid_->assign(value);
}
inline void pbstate::set_leaderboardstateid(const void* value, size_t size) {
  set_has_leaderboardstateid();
  if (leaderboardstateid_ == &::google::protobuf::internal::kEmptyString) {
    leaderboardstateid_ = new ::std::string;
  }
  leaderboardstateid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbstate::mutable_leaderboardstateid() {
  set_has_leaderboardstateid();
  if (leaderboardstateid_ == &::google::protobuf::internal::kEmptyString) {
    leaderboardstateid_ = new ::std::string;
  }
  return leaderboardstateid_;
}
inline ::std::string* pbstate::release_leaderboardstateid() {
  clear_has_leaderboardstateid();
  if (leaderboardstateid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leaderboardstateid_;
    leaderboardstateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbstate::set_allocated_leaderboardstateid(::std::string* leaderboardstateid) {
  if (leaderboardstateid_ != &::google::protobuf::internal::kEmptyString) {
    delete leaderboardstateid_;
  }
  if (leaderboardstateid) {
    set_has_leaderboardstateid();
    leaderboardstateid_ = leaderboardstateid;
  } else {
    clear_has_leaderboardstateid();
    leaderboardstateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes projstateid = 30;
inline bool pbstate::has_projstateid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void pbstate::set_has_projstateid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void pbstate::clear_has_projstateid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void pbstate::clear_projstateid() {
  if (projstateid_ != &::google::protobuf::internal::kEmptyString) {
    projstateid_->clear();
  }
  clear_has_projstateid();
}
inline const ::std::string& pbstate::projstateid() const {
  return *projstateid_;
}
inline void pbstate::set_projstateid(const ::std::string& value) {
  set_has_projstateid();
  if (projstateid_ == &::google::protobuf::internal::kEmptyString) {
    projstateid_ = new ::std::string;
  }
  projstateid_->assign(value);
}
inline void pbstate::set_projstateid(const char* value) {
  set_has_projstateid();
  if (projstateid_ == &::google::protobuf::internal::kEmptyString) {
    projstateid_ = new ::std::string;
  }
  projstateid_->assign(value);
}
inline void pbstate::set_projstateid(const void* value, size_t size) {
  set_has_projstateid();
  if (projstateid_ == &::google::protobuf::internal::kEmptyString) {
    projstateid_ = new ::std::string;
  }
  projstateid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbstate::mutable_projstateid() {
  set_has_projstateid();
  if (projstateid_ == &::google::protobuf::internal::kEmptyString) {
    projstateid_ = new ::std::string;
  }
  return projstateid_;
}
inline ::std::string* pbstate::release_projstateid() {
  clear_has_projstateid();
  if (projstateid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = projstateid_;
    projstateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbstate::set_allocated_projstateid(::std::string* projstateid) {
  if (projstateid_ != &::google::protobuf::internal::kEmptyString) {
    delete projstateid_;
  }
  if (projstateid) {
    set_has_projstateid();
    projstateid_ = projstateid;
  } else {
    clear_has_projstateid();
    projstateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes posstateid = 35;
inline bool pbstate::has_posstateid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void pbstate::set_has_posstateid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void pbstate::clear_has_posstateid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void pbstate::clear_posstateid() {
  if (posstateid_ != &::google::protobuf::internal::kEmptyString) {
    posstateid_->clear();
  }
  clear_has_posstateid();
}
inline const ::std::string& pbstate::posstateid() const {
  return *posstateid_;
}
inline void pbstate::set_posstateid(const ::std::string& value) {
  set_has_posstateid();
  if (posstateid_ == &::google::protobuf::internal::kEmptyString) {
    posstateid_ = new ::std::string;
  }
  posstateid_->assign(value);
}
inline void pbstate::set_posstateid(const char* value) {
  set_has_posstateid();
  if (posstateid_ == &::google::protobuf::internal::kEmptyString) {
    posstateid_ = new ::std::string;
  }
  posstateid_->assign(value);
}
inline void pbstate::set_posstateid(const void* value, size_t size) {
  set_has_posstateid();
  if (posstateid_ == &::google::protobuf::internal::kEmptyString) {
    posstateid_ = new ::std::string;
  }
  posstateid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbstate::mutable_posstateid() {
  set_has_posstateid();
  if (posstateid_ == &::google::protobuf::internal::kEmptyString) {
    posstateid_ = new ::std::string;
  }
  return posstateid_;
}
inline ::std::string* pbstate::release_posstateid() {
  clear_has_posstateid();
  if (posstateid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = posstateid_;
    posstateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbstate::set_allocated_posstateid(::std::string* posstateid) {
  if (posstateid_ != &::google::protobuf::internal::kEmptyString) {
    delete posstateid_;
  }
  if (posstateid) {
    set_has_posstateid();
    posstateid_ = posstateid;
  } else {
    clear_has_posstateid();
    posstateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes orderstateid = 40;
inline bool pbstate::has_orderstateid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void pbstate::set_has_orderstateid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void pbstate::clear_has_orderstateid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void pbstate::clear_orderstateid() {
  if (orderstateid_ != &::google::protobuf::internal::kEmptyString) {
    orderstateid_->clear();
  }
  clear_has_orderstateid();
}
inline const ::std::string& pbstate::orderstateid() const {
  return *orderstateid_;
}
inline void pbstate::set_orderstateid(const ::std::string& value) {
  set_has_orderstateid();
  if (orderstateid_ == &::google::protobuf::internal::kEmptyString) {
    orderstateid_ = new ::std::string;
  }
  orderstateid_->assign(value);
}
inline void pbstate::set_orderstateid(const char* value) {
  set_has_orderstateid();
  if (orderstateid_ == &::google::protobuf::internal::kEmptyString) {
    orderstateid_ = new ::std::string;
  }
  orderstateid_->assign(value);
}
inline void pbstate::set_orderstateid(const void* value, size_t size) {
  set_has_orderstateid();
  if (orderstateid_ == &::google::protobuf::internal::kEmptyString) {
    orderstateid_ = new ::std::string;
  }
  orderstateid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbstate::mutable_orderstateid() {
  set_has_orderstateid();
  if (orderstateid_ == &::google::protobuf::internal::kEmptyString) {
    orderstateid_ = new ::std::string;
  }
  return orderstateid_;
}
inline ::std::string* pbstate::release_orderstateid() {
  clear_has_orderstateid();
  if (orderstateid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = orderstateid_;
    orderstateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbstate::set_allocated_orderstateid(::std::string* orderstateid) {
  if (orderstateid_ != &::google::protobuf::internal::kEmptyString) {
    delete orderstateid_;
  }
  if (orderstateid) {
    set_has_orderstateid();
    orderstateid_ = orderstateid;
  } else {
    clear_has_orderstateid();
    orderstateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes marketstateid = 50;
inline bool pbstate::has_marketstateid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void pbstate::set_has_marketstateid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void pbstate::clear_has_marketstateid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void pbstate::clear_marketstateid() {
  if (marketstateid_ != &::google::protobuf::internal::kEmptyString) {
    marketstateid_->clear();
  }
  clear_has_marketstateid();
}
inline const ::std::string& pbstate::marketstateid() const {
  return *marketstateid_;
}
inline void pbstate::set_marketstateid(const ::std::string& value) {
  set_has_marketstateid();
  if (marketstateid_ == &::google::protobuf::internal::kEmptyString) {
    marketstateid_ = new ::std::string;
  }
  marketstateid_->assign(value);
}
inline void pbstate::set_marketstateid(const char* value) {
  set_has_marketstateid();
  if (marketstateid_ == &::google::protobuf::internal::kEmptyString) {
    marketstateid_ = new ::std::string;
  }
  marketstateid_->assign(value);
}
inline void pbstate::set_marketstateid(const void* value, size_t size) {
  set_has_marketstateid();
  if (marketstateid_ == &::google::protobuf::internal::kEmptyString) {
    marketstateid_ = new ::std::string;
  }
  marketstateid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbstate::mutable_marketstateid() {
  set_has_marketstateid();
  if (marketstateid_ == &::google::protobuf::internal::kEmptyString) {
    marketstateid_ = new ::std::string;
  }
  return marketstateid_;
}
inline ::std::string* pbstate::release_marketstateid() {
  clear_has_marketstateid();
  if (marketstateid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = marketstateid_;
    marketstateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbstate::set_allocated_marketstateid(::std::string* marketstateid) {
  if (marketstateid_ != &::google::protobuf::internal::kEmptyString) {
    delete marketstateid_;
  }
  if (marketstateid) {
    set_has_marketstateid();
    marketstateid_ = marketstateid;
  } else {
    clear_has_marketstateid();
    marketstateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes globalstateid = 60;
inline bool pbstate::has_globalstateid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void pbstate::set_has_globalstateid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void pbstate::clear_has_globalstateid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void pbstate::clear_globalstateid() {
  if (globalstateid_ != &::google::protobuf::internal::kEmptyString) {
    globalstateid_->clear();
  }
  clear_has_globalstateid();
}
inline const ::std::string& pbstate::globalstateid() const {
  return *globalstateid_;
}
inline void pbstate::set_globalstateid(const ::std::string& value) {
  set_has_globalstateid();
  if (globalstateid_ == &::google::protobuf::internal::kEmptyString) {
    globalstateid_ = new ::std::string;
  }
  globalstateid_->assign(value);
}
inline void pbstate::set_globalstateid(const char* value) {
  set_has_globalstateid();
  if (globalstateid_ == &::google::protobuf::internal::kEmptyString) {
    globalstateid_ = new ::std::string;
  }
  globalstateid_->assign(value);
}
inline void pbstate::set_globalstateid(const void* value, size_t size) {
  set_has_globalstateid();
  if (globalstateid_ == &::google::protobuf::internal::kEmptyString) {
    globalstateid_ = new ::std::string;
  }
  globalstateid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbstate::mutable_globalstateid() {
  set_has_globalstateid();
  if (globalstateid_ == &::google::protobuf::internal::kEmptyString) {
    globalstateid_ = new ::std::string;
  }
  return globalstateid_;
}
inline ::std::string* pbstate::release_globalstateid() {
  clear_has_globalstateid();
  if (globalstateid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = globalstateid_;
    globalstateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbstate::set_allocated_globalstateid(::std::string* globalstateid) {
  if (globalstateid_ != &::google::protobuf::internal::kEmptyString) {
    delete globalstateid_;
  }
  if (globalstateid) {
    set_has_globalstateid();
    globalstateid_ = globalstateid;
  } else {
    clear_has_globalstateid();
    globalstateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes teamstatemid = 70;
inline bool pbstate::has_teamstatemid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void pbstate::set_has_teamstatemid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void pbstate::clear_has_teamstatemid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void pbstate::clear_teamstatemid() {
  if (teamstatemid_ != &::google::protobuf::internal::kEmptyString) {
    teamstatemid_->clear();
  }
  clear_has_teamstatemid();
}
inline const ::std::string& pbstate::teamstatemid() const {
  return *teamstatemid_;
}
inline void pbstate::set_teamstatemid(const ::std::string& value) {
  set_has_teamstatemid();
  if (teamstatemid_ == &::google::protobuf::internal::kEmptyString) {
    teamstatemid_ = new ::std::string;
  }
  teamstatemid_->assign(value);
}
inline void pbstate::set_teamstatemid(const char* value) {
  set_has_teamstatemid();
  if (teamstatemid_ == &::google::protobuf::internal::kEmptyString) {
    teamstatemid_ = new ::std::string;
  }
  teamstatemid_->assign(value);
}
inline void pbstate::set_teamstatemid(const void* value, size_t size) {
  set_has_teamstatemid();
  if (teamstatemid_ == &::google::protobuf::internal::kEmptyString) {
    teamstatemid_ = new ::std::string;
  }
  teamstatemid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbstate::mutable_teamstatemid() {
  set_has_teamstatemid();
  if (teamstatemid_ == &::google::protobuf::internal::kEmptyString) {
    teamstatemid_ = new ::std::string;
  }
  return teamstatemid_;
}
inline ::std::string* pbstate::release_teamstatemid() {
  clear_has_teamstatemid();
  if (teamstatemid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = teamstatemid_;
    teamstatemid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbstate::set_allocated_teamstatemid(::std::string* teamstatemid) {
  if (teamstatemid_ != &::google::protobuf::internal::kEmptyString) {
    delete teamstatemid_;
  }
  if (teamstatemid) {
    set_has_teamstatemid();
    teamstatemid_ = teamstatemid;
  } else {
    clear_has_teamstatemid();
    teamstatemid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes fantasynamestateid = 80;
inline bool pbstate::has_fantasynamestateid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void pbstate::set_has_fantasynamestateid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void pbstate::clear_has_fantasynamestateid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void pbstate::clear_fantasynamestateid() {
  if (fantasynamestateid_ != &::google::protobuf::internal::kEmptyString) {
    fantasynamestateid_->clear();
  }
  clear_has_fantasynamestateid();
}
inline const ::std::string& pbstate::fantasynamestateid() const {
  return *fantasynamestateid_;
}
inline void pbstate::set_fantasynamestateid(const ::std::string& value) {
  set_has_fantasynamestateid();
  if (fantasynamestateid_ == &::google::protobuf::internal::kEmptyString) {
    fantasynamestateid_ = new ::std::string;
  }
  fantasynamestateid_->assign(value);
}
inline void pbstate::set_fantasynamestateid(const char* value) {
  set_has_fantasynamestateid();
  if (fantasynamestateid_ == &::google::protobuf::internal::kEmptyString) {
    fantasynamestateid_ = new ::std::string;
  }
  fantasynamestateid_->assign(value);
}
inline void pbstate::set_fantasynamestateid(const void* value, size_t size) {
  set_has_fantasynamestateid();
  if (fantasynamestateid_ == &::google::protobuf::internal::kEmptyString) {
    fantasynamestateid_ = new ::std::string;
  }
  fantasynamestateid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* pbstate::mutable_fantasynamestateid() {
  set_has_fantasynamestateid();
  if (fantasynamestateid_ == &::google::protobuf::internal::kEmptyString) {
    fantasynamestateid_ = new ::std::string;
  }
  return fantasynamestateid_;
}
inline ::std::string* pbstate::release_fantasynamestateid() {
  clear_has_fantasynamestateid();
  if (fantasynamestateid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fantasynamestateid_;
    fantasynamestateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void pbstate::set_allocated_fantasynamestateid(::std::string* fantasynamestateid) {
  if (fantasynamestateid_ != &::google::protobuf::internal::kEmptyString) {
    delete fantasynamestateid_;
  }
  if (fantasynamestateid) {
    set_has_fantasynamestateid();
    fantasynamestateid_ = fantasynamestateid;
  } else {
    clear_has_fantasynamestateid();
    fantasynamestateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MerkleTree

// optional bytes root = 10;
inline bool MerkleTree::has_root() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MerkleTree::set_has_root() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MerkleTree::clear_has_root() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MerkleTree::clear_root() {
  if (root_ != &::google::protobuf::internal::kEmptyString) {
    root_->clear();
  }
  clear_has_root();
}
inline const ::std::string& MerkleTree::root() const {
  return *root_;
}
inline void MerkleTree::set_root(const ::std::string& value) {
  set_has_root();
  if (root_ == &::google::protobuf::internal::kEmptyString) {
    root_ = new ::std::string;
  }
  root_->assign(value);
}
inline void MerkleTree::set_root(const char* value) {
  set_has_root();
  if (root_ == &::google::protobuf::internal::kEmptyString) {
    root_ = new ::std::string;
  }
  root_->assign(value);
}
inline void MerkleTree::set_root(const void* value, size_t size) {
  set_has_root();
  if (root_ == &::google::protobuf::internal::kEmptyString) {
    root_ = new ::std::string;
  }
  root_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MerkleTree::mutable_root() {
  set_has_root();
  if (root_ == &::google::protobuf::internal::kEmptyString) {
    root_ = new ::std::string;
  }
  return root_;
}
inline ::std::string* MerkleTree::release_root() {
  clear_has_root();
  if (root_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = root_;
    root_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MerkleTree::set_allocated_root(::std::string* root) {
  if (root_ != &::google::protobuf::internal::kEmptyString) {
    delete root_;
  }
  if (root) {
    set_has_root();
    root_ = root;
  } else {
    clear_has_root();
    root_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated bytes leaves = 20;
inline int MerkleTree::leaves_size() const {
  return leaves_.size();
}
inline void MerkleTree::clear_leaves() {
  leaves_.Clear();
}
inline const ::std::string& MerkleTree::leaves(int index) const {
  return leaves_.Get(index);
}
inline ::std::string* MerkleTree::mutable_leaves(int index) {
  return leaves_.Mutable(index);
}
inline void MerkleTree::set_leaves(int index, const ::std::string& value) {
  leaves_.Mutable(index)->assign(value);
}
inline void MerkleTree::set_leaves(int index, const char* value) {
  leaves_.Mutable(index)->assign(value);
}
inline void MerkleTree::set_leaves(int index, const void* value, size_t size) {
  leaves_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MerkleTree::add_leaves() {
  return leaves_.Add();
}
inline void MerkleTree::add_leaves(const ::std::string& value) {
  leaves_.Add()->assign(value);
}
inline void MerkleTree::add_leaves(const char* value) {
  leaves_.Add()->assign(value);
}
inline void MerkleTree::add_leaves(const void* value, size_t size) {
  leaves_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MerkleTree::leaves() const {
  return leaves_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MerkleTree::mutable_leaves() {
  return &leaves_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace fantasybit

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_StateData_2eproto__INCLUDED
